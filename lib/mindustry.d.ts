declare type Class<T> = new (...args: any[]) => T;
declare namespace Packages {
  declare abstract class long {}
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare class Object {
        protected finalize(): void;
        public wait(
          _arg0: Packages.long,
          _arg1: number,
        ): void;
        public wait(): void;
        public wait(_arg0: Packages.long): void;
        public equals(_arg0: any): boolean;
        public toString(): string;
        public hashCode(): number;
        public getClass(): Packages.java.lang.Class<any>;
        protected clone(): any;
        public notify(): void;
        public notifyAll(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace io {
      declare abstract class Serializable {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare namespace annotation {
        declare abstract class Annotation {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare namespace reflect {
        declare abstract class AnnotatedElement {
          public isAnnotationPresent(
            _arg0:
              | Class<any>
              | Packages.java.lang.Class<any>,
          ): boolean;
          public getAnnotation<
            T extends
              Packages.java.lang.annotation.Annotation,
          >(
            _arg0: Class<T> | Packages.java.lang.Class<T>,
          ): T | null;
          public getAnnotationsByType<
            T extends
              Packages.java.lang.annotation.Annotation,
          >(
            _arg0: Class<T> | Packages.java.lang.Class<T>,
          ): T[] | null;
          public getAnnotations():
            | Packages.java.lang.annotation.Annotation[]
            | null;
          public getDeclaredAnnotation<
            T extends
              Packages.java.lang.annotation.Annotation,
          >(
            _arg0: Class<T> | Packages.java.lang.Class<T>,
          ): T | null;
          public getDeclaredAnnotationsByType<
            T extends
              Packages.java.lang.annotation.Annotation,
          >(
            _arg0: Class<T> | Packages.java.lang.Class<T>,
          ): T[] | null;
          public getDeclaredAnnotations():
            | Packages.java.lang.annotation.Annotation[]
            | null;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare namespace reflect {
        declare abstract class TypeVariable<
          D extends
            Packages.java.lang.reflect.GenericDeclaration,
        > {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare namespace reflect {
        declare abstract class GenericDeclaration
          implements
            Packages.java.lang.reflect.AnnotatedElement
        {
          public getTypeParameters():
            | Packages.java.lang.reflect.TypeVariable<any>[]
            | null;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare namespace reflect {
        declare abstract class Type {
          public getTypeName(): string;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare namespace invoke {
        declare abstract class TypeDescriptor {
          public static OfMethod = class<
            F extends
              Packages.java.lang.invoke.TypeDescriptor.OfField<F>,
            M extends
              Packages.java.lang.invoke.TypeDescriptor.OfMethod<
                F,
                M
              >,
          > {};
          public static OfField = class<
            F extends
              Packages.java.lang.invoke.TypeDescriptor.OfField<F>,
          > implements
              Packages.java.lang.invoke.TypeDescriptor
          {
            public isArray(): boolean;
            public isPrimitive(): boolean;
            public componentType(): F | null;
            public arrayType(): F | null;
          };
          public descriptorString(): string;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare class Optional<T> {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare namespace constant {
        declare abstract class ConstantDesc {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare namespace constant {
        declare abstract class Constable {
          public describeConstable(): Packages.java.util.Optional<any>;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare namespace reflect {
        declare class Constructor<T> {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare class Module {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace security {
      declare class ProtectionDomain {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare namespace ref {
        declare class SoftReference<T> {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace sun {
    declare namespace reflect {
      declare namespace generics {
        declare namespace repository {
          declare class ClassRepository {}
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace io {
      declare class ObjectStreamField {}
    }
  }
}
declare namespace Packages {
  declare namespace jdk {
    declare namespace internal {
      declare namespace reflect {
        declare class ReflectionFactory {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare abstract class Map<K, V> {}
    }
  }
}
declare namespace Packages {
  declare namespace sun {
    declare namespace reflect {
      declare namespace annotation {
        declare class AnnotationType {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare class SecurityManager {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare abstract class ClassLoader {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare namespace constant {
        declare abstract class ClassDesc {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace sun {
    declare namespace reflect {
      declare namespace generics {
        declare namespace factory {
          declare abstract class GenericsFactory {}
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare namespace reflect {
        declare class Method {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare namespace reflect {
        declare class Field {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare namespace reflect {
        declare class RecordComponent {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace io {
      declare abstract class InputStream {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace net {
      declare class URL {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare namespace reflect {
        declare abstract class Executable {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare abstract class Collection<E> {}
    }
  }
}
declare namespace Packages {
  declare namespace jdk {
    declare namespace internal {
      declare namespace reflect {
        declare class ConstantPool {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare class Package {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare abstract class List<E> {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare namespace reflect {
        declare abstract class AnnotatedType {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare class Class<T>
        extends java.lang.Object
        implements
          Packages.java.lang.reflect.AnnotatedElement,
          Packages.java.lang.constant.Constable,
          Packages.java.lang.reflect.GenericDeclaration,
          Packages.java.lang.invoke.TypeDescriptor.OfField<
            Packages.java.lang.Class<any>
          >,
          Packages.java.io.Serializable,
          Packages.java.lang.reflect.Type
      {
        private static ReflectionData = class<T> {};
        private static EnclosingMethodInfo = class {};
        private static Atomic = class {};
        private static AnnotationData = class {};
        private static ANNOTATION: number;
        private static ENUM: number;
        private static SYNTHETIC: number;
        private cachedConstructor: Packages.java.lang.reflect.Constructor<T>;
        private name: string;
        private module: Packages.java.lang.Module;
        private packageName: string;
        private static allPermDomain: Packages.java.security.ProtectionDomain;
        private classRedefinedCount: number;
        private genericInfo: Packages.sun.reflect.generics.repository.ClassRepository;
        private static EMPTY_CLASS_ARRAY: Packages.java.lang.Class<any>[];
        private static serialVersionUID: Packages.long;
        private static serialPersistentFields: Packages.java.io.ObjectStreamField[];
        private static reflectionFactory: Packages.jdk.internal.reflect.ReflectionFactory;
        private enumConstants: T[];
        private annotationType: Packages.sun.reflect.annotation.AnnotationType;
        classValueMap: Packages.java.lang.ClassValue.ClassValueMap;
        public getName(): string;
        private checkPackageAccess(
          _arg0: Packages.java.lang.SecurityManager,
          _arg1: Packages.java.lang.ClassLoader,
          _arg2: boolean,
        ): void;
        public static forName(
          _arg0: string,
          _arg1: boolean,
          _arg2: Packages.java.lang.ClassLoader,
        ): Packages.java.lang.Class<any>;
        public static forName(
          _arg0: string,
        ): Packages.java.lang.Class<any>;
        public static forName(
          _arg0: Packages.java.lang.Module,
          _arg1: string,
        ): Packages.java.lang.Class<any>;
        private static forName0(
          _arg0: string,
          _arg1: boolean,
          _arg2: Packages.java.lang.ClassLoader,
          _arg3: Class<any> | Packages.java.lang.Class<any>,
        ): Packages.java.lang.Class<any>;
        public toString(): string;
        public getModule(): Packages.java.lang.Module;
        public getProtectionDomain(): Packages.java.security.ProtectionDomain;
        public isAssignableFrom(
          _arg0: Class<any> | Packages.java.lang.Class<any>,
        ): boolean;
        public isInstance(_arg0: any): boolean;
        public getModifiers(): number;
        public isInterface(): boolean;
        public isArray(): boolean;
        public isPrimitive(): boolean;
        public isHidden(): boolean;
        public getSuperclass(): Packages.java.lang.Class<any>;
        public cast(_arg0: any): T | null;
        public componentType(): Packages.java.lang.invoke.TypeDescriptor.OfField<any>;
        public componentType(): Packages.java.lang.Class<any>;
        getClassLoader0(): Packages.java.lang.ClassLoader;
        public describeConstable(): Packages.java.util.Optional<Packages.java.lang.constant.ClassDesc>;
        public getComponentType(): Packages.java.lang.Class<any>;
        public isAnnotation(): boolean;
        public isEnum(): boolean;
        public isRecord(): boolean;
        public getTypeParameters():
          | Packages.java.lang.reflect.TypeVariable<
              Packages.java.lang.Class<T>
            >[]
          | null;
        public getClassLoader(): Packages.java.lang.ClassLoader;
        private checkMemberAccess(
          _arg0: Packages.java.lang.SecurityManager,
          _arg1: number,
          _arg2: Class<any> | Packages.java.lang.Class<any>,
          _arg3: boolean,
        ): void;
        private static getReflectionFactory(): Packages.jdk.internal.reflect.ReflectionFactory;
        private getConstructor0(
          _arg0: Packages.java.lang.Class<any>[],
          _arg1: number,
        ): Packages.java.lang.reflect.Constructor<T>;
        public newInstance(): T | null;
        private initClassName(): string;
        private getGenericInfo(): Packages.sun.reflect.generics.repository.ClassRepository;
        private elementType(): Packages.java.lang.Class<any>;
        public getInterfaces():
          | Packages.java.lang.Class<any>[]
          | null;
        private getInterfaces(
          _arg0: boolean,
        ): Packages.java.lang.Class<any>[] | null;
        private reflectionData(): Packages.java.lang.Class.ReflectionData<T>;
        private getInterfaces0():
          | Packages.java.lang.Class<any>[]
          | null;
        private getEnclosingMethodInfo(): Packages.java.lang.Class.EnclosingMethodInfo;
        private getFactory(): Packages.sun.reflect.generics.factory.GenericsFactory;
        private static toClass(
          _arg0: Packages.java.lang.reflect.Type,
        ): Packages.java.lang.Class<any>;
        public getEnclosingClass(): Packages.java.lang.Class<any>;
        private privateGetDeclaredMethods(
          _arg0: boolean,
        ): Packages.java.lang.reflect.Method[] | null;
        private static arrayContentsEq(
          _arg0: any[],
          _arg1: any[],
        ): boolean;
        private getEnclosingMethod0(): any[] | null;
        private privateGetDeclaredConstructors(
          _arg0: boolean,
        ):
          | Packages.java.lang.reflect.Constructor<T>[]
          | null;
        private getDeclaringClass0(): Packages.java.lang.Class<any>;
        private getSimpleName0(): string;
        public getSimpleName(): string;
        private getSimpleBinaryName(): string;
        private getCanonicalName0(): string;
        public getCanonicalName(): string;
        private isLocalOrAnonymousClass(): boolean;
        private getSimpleBinaryName0(): string;
        private isTopLevelClass(): boolean;
        private hasEnclosingMethodInfo(): boolean;
        private privateGetPublicFields():
          | Packages.java.lang.reflect.Field[]
          | null;
        private static copyFields(
          _arg0: Packages.java.lang.reflect.Field[],
        ): Packages.java.lang.reflect.Field[] | null;
        private privateGetPublicMethods():
          | Packages.java.lang.reflect.Method[]
          | null;
        private static copyMethods(
          _arg0: Packages.java.lang.reflect.Method[],
        ): Packages.java.lang.reflect.Method[] | null;
        private static copyConstructors<U>(
          _arg0: Packages.java.lang.reflect.Constructor<U>[],
        ):
          | Packages.java.lang.reflect.Constructor<U>[]
          | null;
        private getField0(
          _arg0: string,
        ): Packages.java.lang.reflect.Field;
        private getMethod0(
          _arg0: string,
          _arg1: Packages.java.lang.Class<any>[],
        ): Packages.java.lang.reflect.Method;
        private methodToString(
          _arg0: string,
          _arg1: Packages.java.lang.Class<any>[],
        ): string;
        private getDeclaredClasses0():
          | Packages.java.lang.Class<any>[]
          | null;
        private privateGetDeclaredFields(
          _arg0: boolean,
        ): Packages.java.lang.reflect.Field[] | null;
        private getRecordComponents0():
          | Packages.java.lang.reflect.RecordComponent[]
          | null;
        private static searchFields(
          _arg0: Packages.java.lang.reflect.Field[],
          _arg1: string,
        ): Packages.java.lang.reflect.Field;
        private static searchMethods(
          _arg0: Packages.java.lang.reflect.Method[],
          _arg1: string,
          _arg2: Packages.java.lang.Class<any>[],
        ): Packages.java.lang.reflect.Method;
        private resolveName(_arg0: string): string;
        private isOpenToCaller(
          _arg0: string,
          _arg1: Class<any> | Packages.java.lang.Class<any>,
        ): boolean;
        public getResourceAsStream(
          _arg0: string,
        ): Packages.java.io.InputStream;
        public getResource(
          _arg0: string,
        ): Packages.java.net.URL;
        protectionDomain(): Packages.java.security.ProtectionDomain;
        private getProtectionDomain0(): Packages.java.security.ProtectionDomain;
        public getPackageName(): string;
        private newReflectionData(
          _arg0: Packages.java.lang.ref.SoftReference<
            Packages.java.lang.Class.ReflectionData<T>
          >,
          _arg1: number,
        ): Packages.java.lang.Class.ReflectionData<T>;
        private getGenericSignature0(): string;
        static getExecutableTypeAnnotationBytes(
          _arg0: Packages.java.lang.reflect.Executable,
        ): string[] | null;
        private getDeclaredFields0(
          _arg0: boolean,
        ): Packages.java.lang.reflect.Field[] | null;
        private static addAll(
          _arg0: Packages.java.util.Collection<Packages.java.lang.reflect.Field>,
          _arg1: Packages.java.lang.reflect.Field[],
        ): void;
        private getDeclaredConstructors0(
          _arg0: boolean,
        ):
          | Packages.java.lang.reflect.Constructor<T>[]
          | null;
        private getDeclaredMethods0(
          _arg0: boolean,
        ): Packages.java.lang.reflect.Method[] | null;
        private getMethodsRecursive(
          _arg0: string,
          _arg1: Packages.java.lang.Class<any>[],
          _arg2: boolean,
        ): Packages.java.lang.PublicMethods.MethodList;
        private static desiredAssertionStatus0(
          _arg0: Class<any> | Packages.java.lang.Class<any>,
        ): boolean;
        public desiredAssertionStatus(): boolean;
        private isRecord0(): boolean;
        getEnumConstantsShared(): T[] | null;
        public getMethod(
          _arg0: string,
          ..._arg1: Packages.java.lang.Class<any>[]
        ): Packages.java.lang.reflect.Method;
        enumConstantDirectory(): Packages.java.util.Map<
          string,
          T
        >;
        private cannotCastMsg(_arg0: any): string;
        private annotationData(): Packages.java.lang.Class.AnnotationData;
        public isAnnotationPresent(
          _arg0: Class<any> | Packages.java.lang.Class<any>,
        ): boolean;
        private createAnnotationData(
          _arg0: number,
        ): Packages.java.lang.Class.AnnotationData;
        getRawAnnotations(): string[] | null;
        getConstantPool(): Packages.jdk.internal.reflect.ConstantPool;
        casAnnotationType(
          _arg0: Packages.sun.reflect.annotation.AnnotationType,
          _arg1: Packages.sun.reflect.annotation.AnnotationType,
        ): boolean;
        getRawTypeAnnotations(): string[] | null;
        private getNestHost0(): Packages.java.lang.Class<any>;
        public getNestHost(): Packages.java.lang.Class<any>;
        private getNestMembers0():
          | Packages.java.lang.Class<any>[]
          | null;
        public descriptorString(): string;
        private getPermittedSubclasses0():
          | Packages.java.lang.Class<any>[]
          | null;
        private static checkPackageAccessForPermittedSubclasses(
          _arg0: Packages.java.lang.SecurityManager,
          _arg1: Packages.java.lang.ClassLoader,
          _arg2: Packages.java.lang.Class<any>[],
        ): void;
        public getPermittedSubclasses():
          | Packages.java.lang.Class<any>[]
          | null;
        public arrayType(): Packages.java.lang.invoke.TypeDescriptor.OfField<any>;
        public arrayType(): Packages.java.lang.Class<any>;
        private isDirectSubType(
          _arg0: Class<any> | Packages.java.lang.Class<any>,
        ): boolean;
        private static registerNatives(): void;
        public toGenericString(): string;
        static typeVarBounds(
          _arg0: Packages.java.lang.reflect.TypeVariable<any>,
        ): string;
        public isSynthetic(): boolean;
        getClassData(): any;
        public getGenericSuperclass(): Packages.java.lang.reflect.Type;
        public getPackage(): Packages.java.lang.Package;
        public getGenericInterfaces():
          | Packages.java.lang.reflect.Type[]
          | null;
        public getSigners(): any[] | null;
        setSigners(_arg0: any[]): void;
        public getEnclosingMethod(): Packages.java.lang.reflect.Method;
        public getEnclosingConstructor(): Packages.java.lang.reflect.Constructor<any>;
        public getDeclaringClass(): Packages.java.lang.Class<any>;
        public getTypeName(): string;
        public isAnonymousClass(): boolean;
        public isLocalClass(): boolean;
        public isMemberClass(): boolean;
        public getClasses():
          | Packages.java.lang.Class<any>[]
          | null;
        public getFields():
          | Packages.java.lang.reflect.Field[]
          | null;
        public getMethods():
          | Packages.java.lang.reflect.Method[]
          | null;
        public getConstructors():
          | Packages.java.lang.reflect.Constructor<any>[]
          | null;
        public getField(
          _arg0: string,
        ): Packages.java.lang.reflect.Field;
        public getConstructor(
          ..._arg0: Packages.java.lang.Class<any>[]
        ): Packages.java.lang.reflect.Constructor<T>;
        public getDeclaredClasses():
          | Packages.java.lang.Class<any>[]
          | null;
        public getDeclaredFields():
          | Packages.java.lang.reflect.Field[]
          | null;
        public getRecordComponents():
          | Packages.java.lang.reflect.RecordComponent[]
          | null;
        public getDeclaredMethods():
          | Packages.java.lang.reflect.Method[]
          | null;
        public getDeclaredConstructors():
          | Packages.java.lang.reflect.Constructor<any>[]
          | null;
        public getDeclaredField(
          _arg0: string,
        ): Packages.java.lang.reflect.Field;
        public getDeclaredMethod(
          _arg0: string,
          ..._arg1: Packages.java.lang.Class<any>[]
        ): Packages.java.lang.reflect.Method;
        getDeclaredPublicMethods(
          _arg0: string,
          ..._arg1: Packages.java.lang.Class<any>[]
        ): Packages.java.util.List<Packages.java.lang.reflect.Method>;
        public getDeclaredConstructor(
          ..._arg0: Packages.java.lang.Class<any>[]
        ): Packages.java.lang.reflect.Constructor<T>;
        static getPrimitiveClass(
          _arg0: string,
        ): Packages.java.lang.Class<any>;
        public getEnumConstants(): T[] | null;
        public asSubclass<U>(
          _arg0: Class<U> | Packages.java.lang.Class<U>,
        ): Packages.java.lang.Class<any>;
        public getAnnotation<
          A extends
            Packages.java.lang.annotation.Annotation,
        >(
          _arg0: Class<A> | Packages.java.lang.Class<A>,
        ): A | null;
        public getAnnotationsByType<
          A extends
            Packages.java.lang.annotation.Annotation,
        >(
          _arg0: Class<A> | Packages.java.lang.Class<A>,
        ): A[] | null;
        public getAnnotations():
          | Packages.java.lang.annotation.Annotation[]
          | null;
        public getDeclaredAnnotation<
          A extends
            Packages.java.lang.annotation.Annotation,
        >(
          _arg0: Class<A> | Packages.java.lang.Class<A>,
        ): A | null;
        public getDeclaredAnnotationsByType<
          A extends
            Packages.java.lang.annotation.Annotation,
        >(
          _arg0: Class<A> | Packages.java.lang.Class<A>,
        ): A[] | null;
        public getDeclaredAnnotations():
          | Packages.java.lang.annotation.Annotation[]
          | null;
        getAnnotationType(): Packages.sun.reflect.annotation.AnnotationType;
        getDeclaredAnnotationMap(): Packages.java.util.Map<
          Packages.java.lang.Class<any>,
          Packages.java.lang.annotation.Annotation
        >;
        public getAnnotatedSuperclass(): Packages.java.lang.reflect.AnnotatedType;
        public getAnnotatedInterfaces():
          | Packages.java.lang.reflect.AnnotatedType[]
          | null;
        public isNestmateOf(
          _arg0: Class<any> | Packages.java.lang.Class<any>,
        ): boolean;
        public getNestMembers():
          | Packages.java.lang.Class<any>[]
          | null;
        public isSealed(): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare abstract class Disposable {
        public dispose(): void;
        public isDisposed(): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare abstract class Enum<
        E extends Packages.java.lang.Enum<E>,
      > {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare abstract class Comparable<T> {
        public compareTo(_arg0: T): number;
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace io {
      declare class ObjectInputStream {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare abstract class Enum<
          E extends Packages.java.lang.Enum<E>,
        >
        extends java.lang.Object
        implements
          Packages.java.lang.constant.Constable,
          Packages.java.lang.Comparable<E>,
          Packages.java.io.Serializable
      {
        public static EnumDesc = class<
          E extends Packages.java.lang.Enum<E>,
        > {};
        public name(): string;
        protected finalize(): void;
        public equals(_arg0: any): boolean;
        public toString(): string;
        public hashCode(): number;
        protected clone(): any;
        public compareTo(_arg0: any): number;
        public compareTo(_arg0: E): number;
        public static valueOf<
          T extends Packages.java.lang.Enum<T>,
        >(
          _arg0: Class<T> | Packages.java.lang.Class<T>,
          _arg1: string,
        ): T | null;
        public describeConstable(): Packages.java.util.Optional<
          Packages.java.lang.Enum.EnumDesc<E>
        >;
        public getDeclaringClass(): Packages.java.lang.Class<E>;
        private readObject(
          _arg0: Packages.java.io.ObjectInputStream,
        ): void;
        public ordinal(): number;
        private readObjectNoData(): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare abstract class Runnable {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare abstract class Iterator<E> {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare abstract class Spliterator<T> {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare namespace _function {
        declare abstract class Consumer<T> {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare abstract class Iterable<T> {
        public iterator(): Packages.java.util.Iterator<T>;
        public spliterator(): Packages.java.util.Spliterator<T>;
        public forEach(
          _arg0: Packages.java.util._function.Consumer<any>,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class Cons<T> {
        public get(_t: T): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare abstract class Eachable<T> {
        public each(
          _cons: Packages.arc.func.Cons<any>,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare abstract class Iterator<E> {
        public remove(): void;
        public forEachRemaining(
          _arg0: Packages.java.util._function.Consumer<any>,
        ): void;
        public hasNext(): boolean;
        public next(): E | null;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class Boolf<T> {
        public get(_t: T): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class Func<P, R> {
        public get(_param: P): R | null;
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare abstract class Comparator<T> {}
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class Floatf<T> {
        public get(_t: T): number;
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare class ArrayList<E> {}
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class Intf<T> {
        public get(_t: T): number;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class Func2<P1, P2, R> {
        public get(_param1: P1, _param2: P2): R | null;
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare namespace stream {
        declare abstract class IntStream {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare namespace stream {
        declare abstract class LongStream {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare namespace stream {
        declare abstract class DoubleStream {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare namespace random {
        declare abstract class RandomGenerator {
          public static ArbitrarilyJumpableGenerator = class {};
          public static LeapableGenerator = class {};
          public static JumpableGenerator = class {};
          public static SplittableGenerator = class {};
          public static StreamableGenerator = class {};
          public static getDefault(): Packages.java.util.random.RandomGenerator;
          public static of(
            _arg0: string,
          ): Packages.java.util.random.RandomGenerator;
          public nextDouble(_arg0: number): number;
          public nextDouble(): number;
          public nextDouble(
            _arg0: number,
            _arg1: number,
          ): number;
          public nextInt(_arg0: number): number;
          public nextInt(
            _arg0: number,
            _arg1: number,
          ): number;
          public nextInt(): number;
          public nextBytes(_arg0: string[]): void;
          public ints(
            _arg0: number,
            _arg1: number,
          ): Packages.java.util.stream.IntStream;
          public ints(): Packages.java.util.stream.IntStream;
          public ints(
            _arg0: Packages.long,
          ): Packages.java.util.stream.IntStream;
          public ints(
            _arg0: Packages.long,
            _arg1: number,
            _arg2: number,
          ): Packages.java.util.stream.IntStream;
          public longs(
            _arg0: Packages.long,
            _arg1: Packages.long,
            _arg2: Packages.long,
          ): Packages.java.util.stream.LongStream;
          public longs(
            _arg0: Packages.long,
            _arg1: Packages.long,
          ): Packages.java.util.stream.LongStream;
          public longs(): Packages.java.util.stream.LongStream;
          public longs(
            _arg0: Packages.long,
          ): Packages.java.util.stream.LongStream;
          public doubles(): Packages.java.util.stream.DoubleStream;
          public doubles(
            _arg0: Packages.long,
            _arg1: number,
            _arg2: number,
          ): Packages.java.util.stream.DoubleStream;
          public doubles(
            _arg0: number,
            _arg1: number,
          ): Packages.java.util.stream.DoubleStream;
          public doubles(
            _arg0: Packages.long,
          ): Packages.java.util.stream.DoubleStream;
          public nextLong(
            _arg0: Packages.long,
            _arg1: Packages.long,
          ): Packages.long;
          public nextLong(): Packages.long;
          public nextLong(
            _arg0: Packages.long,
          ): Packages.long;
          public nextBoolean(): boolean;
          public nextFloat(): number;
          public nextFloat(_arg0: number): number;
          public nextFloat(
            _arg0: number,
            _arg1: number,
          ): number;
          public nextGaussian(
            _arg0: number,
            _arg1: number,
          ): number;
          public nextGaussian(): number;
          public isDeprecated(): boolean;
          public nextExponential(): number;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare namespace concurrent {
        declare namespace atomic {
          declare class AtomicLong {}
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace jdk {
    declare namespace internal {
      declare namespace misc {
        declare class Unsafe {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace io {
      declare class ObjectOutputStream {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare class Random
        extends java.lang.Object
        implements
          Packages.java.util.random.RandomGenerator,
          Packages.java.io.Serializable
      {
        static serialVersionUID: Packages.long;
        private seed: Packages.java.util.concurrent.atomic.AtomicLong;
        private static multiplier: Packages.long;
        private static addend: Packages.long;
        private static mask: Packages.long;
        private static DOUBLE_UNIT: number;
        private nextNextGaussian: number;
        private haveNextNextGaussian: boolean;
        private static serialPersistentFields: Packages.java.io.ObjectStreamField[];
        private static unsafe: Packages.jdk.internal.misc.Unsafe;
        private static seedOffset: Packages.long;
        protected next(_arg0: number): number;
        private readObject(
          _arg0: Packages.java.io.ObjectInputStream,
        ): void;
        private writeObject(
          _arg0: Packages.java.io.ObjectOutputStream,
        ): void;
        public nextDouble(): number;
        public nextInt(): number;
        public nextInt(_arg0: number): number;
        public nextBytes(_arg0: string[]): void;
        private static seedUniquifier(): Packages.long;
        private static initialScramble(
          _arg0: Packages.long,
        ): Packages.long;
        public setSeed(_arg0: Packages.long): void;
        private resetSeed(_arg0: Packages.long): void;
        public ints(
          _arg0: Packages.long,
        ): Packages.java.util.stream.IntStream;
        public ints(): Packages.java.util.stream.IntStream;
        public ints(
          _arg0: Packages.long,
          _arg1: number,
          _arg2: number,
        ): Packages.java.util.stream.IntStream;
        public ints(
          _arg0: number,
          _arg1: number,
        ): Packages.java.util.stream.IntStream;
        public longs(
          _arg0: Packages.long,
        ): Packages.java.util.stream.LongStream;
        public longs(
          _arg0: Packages.long,
          _arg1: Packages.long,
        ): Packages.java.util.stream.LongStream;
        public longs(
          _arg0: Packages.long,
          _arg1: Packages.long,
          _arg2: Packages.long,
        ): Packages.java.util.stream.LongStream;
        public longs(): Packages.java.util.stream.LongStream;
        public doubles(
          _arg0: Packages.long,
        ): Packages.java.util.stream.DoubleStream;
        public doubles(
          _arg0: Packages.long,
          _arg1: number,
          _arg2: number,
        ): Packages.java.util.stream.DoubleStream;
        public doubles(
          _arg0: number,
          _arg1: number,
        ): Packages.java.util.stream.DoubleStream;
        public doubles(): Packages.java.util.stream.DoubleStream;
        public nextLong(): Packages.long;
        public nextBoolean(): boolean;
        public nextFloat(): number;
        public nextGaussian(): number;
        public constructor();
        public constructor(_arg0: Packages.long);
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare class Rand extends Packages.java.util.Random {
        private static NORM_DOUBLE: number;
        private static NORM_FLOAT: number;
        public seed0: Packages.long;
        public seed1: Packages.long;
        protected next(_bits: number): number;
        public getState(_seed: number): Packages.long;
        public nextDouble(): number;
        public random(_min: number, _max: number): number;
        public random(_min: number, _max: number): number;
        public random(_max: number): number;
        public random(_max: number): number;
        public range(_amount: number): number;
        public range(_amount: number): number;
        public nextInt(_n: number): number;
        public nextInt(): number;
        public nextBytes(_bytes: string[]): void;
        public setSeed(_seed: Packages.long): void;
        public nextLong(_n: Packages.long): Packages.long;
        public nextLong(): Packages.long;
        public nextBoolean(): boolean;
        public nextFloat(): number;
        public setState(
          _seed0: Packages.long,
          _seed1: Packages.long,
        ): void;
        private static murmurHash3(
          _x: Packages.long,
        ): Packages.long;
        public chance(_chance: number): boolean;
        public constructor(
          _seed0: Packages.long,
          _seed1: Packages.long,
        );
        public constructor(_seed: Packages.long);
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class Prov<T> {
        public get(): T | null;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class Cons2<T, N> {
        public get(_t: T, _n: N): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare class RuntimeException {}
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class ObjectMap<K, V>
        extends java.lang.Object
        implements
          Packages.java.lang.Iterable<
            Packages.arc.struct.ObjectMap.Entry<K, V>
          >
      {
        public static Entries = class<K, V> extends Packages
          .arc.struct.ObjectMap.MapIterator<
          K,
          V,
          Packages.arc.struct.ObjectMap.Entry<K, V>
        > {
          entry: Packages.arc.struct.ObjectMap.Entry<K, V>;
          public remove(): void;
          public iterator(): Packages.java.util.Iterator<any>;
          public iterator(): Packages.arc.struct.ObjectMap.Entries<
            K,
            V
          >;
          public hasNext(): boolean;
          public next(): any;
          public next(): Packages.arc.struct.ObjectMap.Entry<
            K,
            V
          >;
          public reset(): void;
          public constructor(
            _map: Packages.arc.struct.ObjectMap<K, V>,
          );
        };
        public static Entry = class<K, V> extends java.lang
          .Object {
          public key: K;
          public value: V;
          public toString(): string;
          public constructor();
        };
        public static Values = class<V> extends Packages.arc
          .struct.ObjectMap.MapIterator<any, V, V> {
          public remove(): void;
          public iterator(): Packages.arc.struct.ObjectMap.Values<V>;
          public iterator(): Packages.java.util.Iterator<any>;
          public hasNext(): boolean;
          public next(): V | null;
          public reset(): void;
          public toSeq(
            _array: Packages.arc.struct.Seq<V>,
          ): Packages.arc.struct.Seq<V>;
          public toSeq(): Packages.arc.struct.Seq<V>;
          public constructor(
            _map: Packages.arc.struct.ObjectMap<any, V>,
          );
        };
        public static Keys = class<K> extends Packages.arc
          .struct.ObjectMap.MapIterator<K, any, K> {
          public remove(): void;
          public iterator(): Packages.arc.struct.ObjectMap.Keys<K>;
          public iterator(): Packages.java.util.Iterator<any>;
          public hasNext(): boolean;
          public next(): K | null;
          public reset(): void;
          public toSeq(
            _array: Packages.arc.struct.Seq<K>,
          ): Packages.arc.struct.Seq<K>;
          public toSeq(): Packages.arc.struct.Seq<K>;
          public constructor(
            _map: Packages.arc.struct.ObjectMap<K, any>,
          );
        };
        private static MapIterator = class<K, V, I>
          extends java.lang.Object
          implements
            Packages.java.lang.Iterable<I>,
            Packages.java.util.Iterator<I>
        {
          map: Packages.arc.struct.ObjectMap<K, V>;
          public hasNext: boolean;
          nextIndex: number;
          currentIndex: number;
          valid: boolean;
          public remove(): void;
          public reset(): void;
          findNextIndex(): void;
          public constructor(
            _map: Packages.arc.struct.ObjectMap<K, V>,
          );
        };
        private static PRIME1: number;
        private static PRIME2: number;
        private static PRIME3: number;
        public size: number;
        keyTable: K[];
        valueTable: V[];
        capacity: number;
        stashSize: number;
        private loadFactor: number;
        private hashShift: number;
        private mask: number;
        private threshold: number;
        private stashCapacity: number;
        private pushIterations: number;
        entries1: Packages.arc.struct.ObjectMap.Entries<anyany>;
        entries2: Packages.arc.struct.ObjectMap.Entries<anyany>;
        values1: Packages.arc.struct.ObjectMap.Values<any>;
        values2: Packages.arc.struct.ObjectMap.Values<any>;
        keys1: Packages.arc.struct.ObjectMap.Keys<any>;
        keys2: Packages.arc.struct.ObjectMap.Keys<any>;
        public remove(_key: K): V | null;
        public get(
          _key: K,
          _supplier: Packages.arc.func.Prov<V>,
        ): V | null;
        public get(_key: K): V | null;
        public get(_key: K, _defaultValue: V): V | null;
        public put(_key: K, _value: V): V | null;
        public equals(_obj: any): boolean;
        public toString(_separator: string): string;
        public toString(): string;
        public toString(
          _separator: string,
          _braces: boolean,
        ): string;
        public values(): Packages.arc.struct.ObjectMap.Values<V>;
        public hashCode(): number;
        public clear(): void;
        public clear(_maximumCapacity: number): void;
        public isEmpty(): boolean;
        public iterator(): Packages.java.util.Iterator<any>;
        public iterator(): Packages.arc.struct.ObjectMap.Entries<
          K,
          V
        >;
        public static of<K, V>(
          ..._values: any[]
        ): Packages.arc.struct.ObjectMap<K, V>;
        public merge(
          _map: Packages.arc.struct.ObjectMap<any, any>,
        ): Packages.arc.struct.ObjectMap<K, V>;
        public putAll(
          _map: Packages.arc.struct.ObjectMap<any, any>,
        ): void;
        public putAll(..._values: any[]): void;
        public containsKey(_key: K): boolean;
        public keys(): Packages.arc.struct.ObjectMap.Keys<K>;
        public containsValue(
          _value: any,
          _identity: boolean,
        ): boolean;
        public entries(): Packages.arc.struct.ObjectMap.Entries<
          K,
          V
        >;
        public copy(): Packages.arc.struct.ObjectMap<K, V>;
        public ensureCapacity(
          _additionalCapacity: number,
        ): void;
        public each(
          _cons: Packages.arc.func.Cons2<K, V>,
        ): void;
        private resize(_newSize: number): void;
        private push(
          _insertKey: K,
          _insertValue: V,
          _index1: number,
          _key1: K,
          _index2: number,
          _key2: K,
          _index3: number,
          _key3: K,
        ): void;
        public shrink(_maximumCapacity: number): void;
        private hash2(_h: number): number;
        private hash3(_h: number): number;
        private putStash(_key: K, _value: V): void;
        private putResize(_key: K, _value: V): void;
        private getStash(
          _key: K,
          _defaultValue: V,
        ): V | null;
        removeStash(_key: K): V | null;
        removeStashIndex(_index: number): void;
        private containsKeyStash(_key: K): boolean;
        public getThrow(
          _key: K,
          _error: Packages.arc.func.Prov<any>,
        ): V | null;
        public getNull(_key: K): V | null;
        public findKey(
          _value: any,
          _identity: boolean,
        ): K | null;
        public constructor(
          _map: Packages.arc.struct.ObjectMap<any, any>,
        );
        public constructor(_initialCapacity: number);
        public constructor();
        public constructor(
          _initialCapacity: number,
          _loadFactor: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class ObjectSet<T>
        extends java.lang.Object
        implements
          Packages.java.lang.Iterable<T>,
          Packages.arc.util.Eachable<T>
      {
        public ObjectSetIterator = class
          extends java.lang.Object
          implements
            Packages.java.lang.Iterable<T>,
            Packages.java.util.Iterator<T>
        {
          public hasNext: boolean;
          nextIndex: number;
          currentIndex: number;
          done: boolean;
          this$0: Packages.arc.struct.ObjectSet<any>;
          public remove(): void;
          public iterator(): Packages.arc.struct.ObjectSet.ObjectSetIterator;
          public iterator(): Packages.java.util.Iterator<any>;
          public hasNext(): boolean;
          public next(): T | null;
          public reset(): void;
          public toSeq(
            _array: Packages.arc.struct.Seq<T>,
          ): Packages.arc.struct.Seq<T>;
          public toSeq(): Packages.arc.struct.Seq<T>;
          private findNextIndex(): void;
          public constructor(
            _this$0: Packages.arc.struct.ObjectSet<any>,
          );
        };
        private static PRIME1: number;
        private static PRIME2: number;
        private static PRIME3: number;
        public size: number;
        keyTable: T[];
        capacity: number;
        stashSize: number;
        private loadFactor: number;
        private hashShift: number;
        private mask: number;
        private threshold: number;
        private stashCapacity: number;
        private pushIterations: number;
        private iterator1?: Packages.arc.struct.ObjectSet.ObjectSetIterator;
        private iterator2?: Packages.arc.struct.ObjectSet.ObjectSetIterator;
        public add(_key: T): boolean;
        public remove(_key: T): boolean;
        public get(_key: T): T | null;
        public equals(_obj: any): boolean;
        public toString(): string;
        public toString(_separator: string): string;
        public hashCode(): number;
        public clear(_maximumCapacity: number): void;
        public clear(): void;
        public isEmpty(): boolean;
        public iterator(): Packages.arc.struct.ObjectSet.ObjectSetIterator;
        public iterator(): Packages.java.util.Iterator<any>;
        public contains(_key: T): boolean;
        public addAll(
          _array: T[],
          _offset: number,
          _length: number,
        ): void;
        public addAll(
          _set: Packages.arc.struct.ObjectSet<T>,
        ): void;
        public addAll(..._array: T[]): void;
        public addAll(
          _array: Packages.arc.struct.Seq<any>,
          _offset: number,
          _length: number,
        ): void;
        public addAll(
          _array: Packages.arc.struct.Seq<any>,
        ): void;
        public first(): T | null;
        public ensureCapacity(
          _additionalCapacity: number,
        ): void;
        public removeAll(_array: T[]): void;
        public removeAll(
          _array: T[],
          _offset: number,
          _length: number,
        ): void;
        public removeAll(
          _array: Packages.arc.struct.Seq<any>,
        ): void;
        public each(
          _cons: Packages.arc.func.Cons<any>,
        ): void;
        private resize(_newSize: number): void;
        private push(
          _insertKey: T,
          _index1: number,
          _key1: T,
          _index2: number,
          _key2: T,
          _index3: number,
          _key3: T,
        ): void;
        public static with<T>(
          _array: Packages.arc.struct.Seq<T>,
        ): Packages.arc.struct.ObjectSet<T>;
        public static with<T>(
          ..._array: T[]
        ): Packages.arc.struct.ObjectSet<T>;
        public select(
          _predicate: Packages.arc.func.Boolf<T>,
        ): Packages.arc.struct.ObjectSet<T>;
        public shrink(_maximumCapacity: number): void;
        public toSeq(): Packages.arc.struct.Seq<T>;
        private addStash(_key: T): void;
        private addResize(_key: T): void;
        private getKeyStash(_key: T): T | null;
        private hash2(_h: number): number;
        private hash3(_h: number): number;
        removeStash(_key: T): boolean;
        removeStashIndex(_index: number): void;
        public constructor(
          _set: Packages.arc.struct.ObjectSet<any>,
        );
        public constructor(
          _initialCapacity: number,
          _loadFactor: number,
        );
        public constructor(_initialCapacity: number);
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class Intc {
        public get(_i: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class IntSeq extends java.lang.Object {
        public items: number[];
        public size: number;
        public ordered: boolean;
        public add(_value: number): void;
        public add(
          _value1: number,
          _value2: number,
          _value3: number,
          _value4: number,
        ): void;
        public add(_value1: number, _value2: number): void;
        public add(
          _value1: number,
          _value2: number,
          _value3: number,
        ): void;
        public get(_index: number): number;
        public equals(_object: any): boolean;
        public toString(): string;
        public toString(_separator: string): string;
        public hashCode(): number;
        public indexOf(_value: number): number;
        public insert(_index: number, _value: number): void;
        public clear(): void;
        public lastIndexOf(_value: number): number;
        public isEmpty(): boolean;
        public toArray(): number[] | null;
        public count(_value: number): number;
        public contains(_value: number): boolean;
        public addAll(
          _array: Packages.arc.struct.IntSeq,
          _offset: number,
          _length: number,
        ): void;
        public addAll(..._array: number[]): void;
        public addAll(
          _array: number[],
          _offset: number,
          _length: number,
        ): void;
        public addAll(
          _array: Packages.arc.struct.IntSeq,
        ): void;
        public first(): number;
        public set(_index: number, _value: number): void;
        public mode(): number;
        public ensureCapacity(
          _additionalCapacity: number,
        ): number[] | null;
        public reverse(): void;
        public peek(): number;
        public sum(): number;
        public sort(): void;
        public removeRange(
          _start: number,
          _end: number,
        ): void;
        public removeAll(
          _array: Packages.arc.struct.IntSeq,
        ): boolean;
        public each(
          _iterator: Packages.arc.func.Intc,
        ): void;
        protected resize(_newSize: number): number[] | null;
        public incr(_index: number, _value: number): void;
        public random(): number;
        public swap(_first: number, _second: number): void;
        public static range(
          _min: number,
          _max: number,
        ): Packages.arc.struct.IntSeq;
        public shuffle(): void;
        public shuffle(_rand: Packages.arc.math.Rand): void;
        public pop(): number;
        public static with(
          ..._array: number[]
        ): Packages.arc.struct.IntSeq;
        public setSize(_newSize: number): number[] | null;
        public mul(_index: number, _value: number): void;
        public truncate(_newSize: number): void;
        public addUnique(_value: number): boolean;
        public shrink(): number[] | null;
        public removeIndex(_index: number): number;
        public removeValue(_value: number): boolean;
        public constructor(
          _ordered: boolean,
          _array: number[],
          _startIndex: number,
          _count: number,
        );
        public constructor(
          _array: Packages.arc.struct.IntSeq,
        );
        public constructor(
          _ordered: boolean,
          _capacity: number,
        );
        public constructor(_array: number[]);
        public constructor();
        public constructor(_capacity: number);
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare abstract class Interp {
        public static Pow = class
          extends java.lang.Object
          implements Packages.arc.math.Interp
        {
          power: number;
          public apply(_a: number): number;
          public constructor(_power: number);
          public constructor(_power: number);
        };
        public static PowIn = class extends Packages.arc
          .math.Interp.Pow {
          public apply(_a: number): number;
          public constructor(_power: number);
          public constructor(_power: number);
        };
        public static PowOut = class extends Packages.arc
          .math.Interp.Pow {
          public apply(_a: number): number;
          public constructor(_power: number);
          public constructor(_power: number);
        };
        public static Exp = class
          extends java.lang.Object
          implements Packages.arc.math.Interp
        {
          value: number;
          power: number;
          min: number;
          scale: number;
          public apply(_a: number): number;
          public constructor(
            _value: number,
            _power: number,
          );
        };
        public static ExpIn = class extends Packages.arc
          .math.Interp.Exp {
          public apply(_a: number): number;
          public constructor(
            _value: number,
            _power: number,
          );
        };
        public static ExpOut = class extends Packages.arc
          .math.Interp.Exp {
          public apply(_a: number): number;
          public constructor(
            _value: number,
            _power: number,
          );
        };
        public static Elastic = class
          extends java.lang.Object
          implements Packages.arc.math.Interp
        {
          value: number;
          power: number;
          scale: number;
          bounces: number;
          public apply(_a: number): number;
          public constructor(
            _value: number,
            _power: number,
            _bounces: number,
            _scale: number,
          );
        };
        public static ElasticIn = class extends Packages.arc
          .math.Interp.Elastic {
          public apply(_a: number): number;
          public constructor(
            _value: number,
            _power: number,
            _bounces: number,
            _scale: number,
          );
        };
        public static ElasticOut = class extends Packages
          .arc.math.Interp.Elastic {
          public apply(_a: number): number;
          public constructor(
            _value: number,
            _power: number,
            _bounces: number,
            _scale: number,
          );
        };
        public static Swing = class
          extends java.lang.Object
          implements Packages.arc.math.Interp
        {
          private scale: number;
          public apply(_a: number): number;
          public constructor(_scale: number);
        };
        public static SwingIn = class
          extends java.lang.Object
          implements Packages.arc.math.Interp
        {
          private scale: number;
          public apply(_a: number): number;
          public constructor(_scale: number);
        };
        public static SwingOut = class
          extends java.lang.Object
          implements Packages.arc.math.Interp
        {
          private scale: number;
          public apply(_a: number): number;
          public constructor(_scale: number);
        };
        public static Bounce = class extends Packages.arc
          .math.Interp.BounceOut {
          public apply(_a: number): number;
          private out(_a: number): number;
          public constructor(
            _widths: number[],
            _heights: number[],
          );
          public constructor(_bounces: number);
        };
        public static BounceIn = class extends Packages.arc
          .math.Interp.BounceOut {
          public apply(_a: number): number;
          public constructor(
            _widths: number[],
            _heights: number[],
          );
          public constructor(_bounces: number);
        };
        public static BounceOut = class
          extends java.lang.Object
          implements Packages.arc.math.Interp
        {
          widths: number[];
          heights: number[];
          public apply(_a: number): number;
          public constructor(
            _widths: number[],
            _heights: number[],
          );
          public constructor(_bounces: number);
        };
        public static linear: Packages.arc.math.Interp;
        public static reverse: Packages.arc.math.Interp;
        public static smooth: Packages.arc.math.Interp;
        public static smooth2: Packages.arc.math.Interp;
        public static one: Packages.arc.math.Interp;
        public static zero: Packages.arc.math.Interp;
        public static slope: Packages.arc.math.Interp;
        public static smoother: Packages.arc.math.Interp;
        public static fade: Packages.arc.math.Interp;
        public static pow2: Packages.arc.math.Interp.Pow;
        public static pow2In: Packages.arc.math.Interp.PowIn;
        public static slowFast: Packages.arc.math.Interp.PowIn;
        public static pow2Out: Packages.arc.math.Interp.PowOut;
        public static fastSlow: Packages.arc.math.Interp.PowOut;
        public static pow2InInverse: Packages.arc.math.Interp;
        public static pow2OutInverse: Packages.arc.math.Interp;
        public static pow3: Packages.arc.math.Interp.Pow;
        public static pow3In: Packages.arc.math.Interp.PowIn;
        public static pow3Out: Packages.arc.math.Interp.PowOut;
        public static pow3InInverse: Packages.arc.math.Interp;
        public static pow3OutInverse: Packages.arc.math.Interp;
        public static pow4: Packages.arc.math.Interp.Pow;
        public static pow4In: Packages.arc.math.Interp.PowIn;
        public static pow4Out: Packages.arc.math.Interp.PowOut;
        public static pow5: Packages.arc.math.Interp.Pow;
        public static pow5In: Packages.arc.math.Interp.PowIn;
        public static pow10In: Packages.arc.math.Interp.PowIn;
        public static pow10Out: Packages.arc.math.Interp.PowOut;
        public static pow5Out: Packages.arc.math.Interp.PowOut;
        public static sine: Packages.arc.math.Interp;
        public static sineIn: Packages.arc.math.Interp;
        public static sineOut: Packages.arc.math.Interp;
        public static exp10: Packages.arc.math.Interp.Exp;
        public static exp10In: Packages.arc.math.Interp.ExpIn;
        public static exp10Out: Packages.arc.math.Interp.ExpOut;
        public static exp5: Packages.arc.math.Interp.Exp;
        public static exp5In: Packages.arc.math.Interp.ExpIn;
        public static exp5Out: Packages.arc.math.Interp.ExpOut;
        public static circle: Packages.arc.math.Interp;
        public static circleIn: Packages.arc.math.Interp;
        public static circleOut: Packages.arc.math.Interp;
        public static elastic: Packages.arc.math.Interp.Elastic;
        public static elasticIn: Packages.arc.math.Interp.ElasticIn;
        public static elasticOut: Packages.arc.math.Interp.ElasticOut;
        public static swing: Packages.arc.math.Interp.Swing;
        public static swingIn: Packages.arc.math.Interp.SwingIn;
        public static swingOut: Packages.arc.math.Interp.SwingOut;
        public static bounce: Packages.arc.math.Interp.Bounce;
        public static bounceIn: Packages.arc.math.Interp.BounceIn;
        public static bounceOut: Packages.arc.math.Interp.BounceOut;
        public apply(_a: number): number;
        public apply(
          _start: number,
          _end: number,
          _a: number,
        ): number;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare abstract class Vector<
          T extends Packages.arc.math.geom.Vector<T>,
        > {
          public add(_v: T): T | null;
          public dst(_v: T): number;
          public len(): number;
          public limit(_limit: number): T | null;
          public dot(_v: T): number;
          public scl(_scalar: number): T | null;
          public scl(_v: T): T | null;
          public set(_v: T): T | null;
          public setLength(_len: number): T | null;
          public len2(): number;
          public sub(_v: T): T | null;
          public plus(_other: T): T | null;
          public isZero(_margin: number): boolean;
          public isZero(): boolean;
          public mulAdd(_v: T, _scalar: number): T | null;
          public mulAdd(_v: T, _mulVec: T): T | null;
          public minus(_other: T): T | null;
          public div(_other: T): T | null;
          public clamp(
            _min: number,
            _max: number,
          ): T | null;
          public limit2(_limit2: number): T | null;
          public setLength2(_len2: number): T | null;
          public setZero(): T | null;
          public setToRandomDirection(): T | null;
          public lerp(_target: T, _alpha: number): T | null;
          public epsilonEquals(
            _other: T,
            _epsilon: number,
          ): boolean;
          public isUnit(): boolean;
          public isUnit(_margin: number): boolean;
          public isOnLine(
            _other: T,
            _epsilon: number,
          ): boolean;
          public isOnLine(_other: T): boolean;
          public hasOppositeDirection(_other: T): boolean;
          public hasSameDirection(_other: T): boolean;
          public isPerpendicular(_other: T): boolean;
          public isPerpendicular(
            _other: T,
            _epsilon: number,
          ): boolean;
          public isCollinearOpposite(_other: T): boolean;
          public isCollinearOpposite(
            _other: T,
            _epsilon: number,
          ): boolean;
          public isCollinear(
            _other: T,
            _epsilon: number,
          ): boolean;
          public isCollinear(_other: T): boolean;
          public interpolate(
            _target: T,
            _alpha: number,
            _interpolator: Packages.arc.math.Interp,
          ): T | null;
          public dst2(_v: T): number;
          public nor(): T | null;
          public cpy(): T | null;
          public unaryMinus(): T | null;
          public times(_other: T): T | null;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare abstract class Vector<
          T extends Packages.arc.math.geom.Vector<T>,
        > {
          public add(_v: T): T | null;
          public dst(_v: T): number;
          public len(): number;
          public limit(_limit: number): T | null;
          public dot(_v: T): number;
          public scl(_scalar: number): T | null;
          public scl(_v: T): T | null;
          public set(_v: T): T | null;
          public setLength(_len: number): T | null;
          public len2(): number;
          public sub(_v: T): T | null;
          public plus(_other: T): T | null;
          public isZero(_margin: number): boolean;
          public isZero(): boolean;
          public mulAdd(_v: T, _scalar: number): T | null;
          public mulAdd(_v: T, _mulVec: T): T | null;
          public minus(_other: T): T | null;
          public div(_other: T): T | null;
          public clamp(
            _min: number,
            _max: number,
          ): T | null;
          public limit2(_limit2: number): T | null;
          public setLength2(_len2: number): T | null;
          public setZero(): T | null;
          public setToRandomDirection(): T | null;
          public lerp(_target: T, _alpha: number): T | null;
          public epsilonEquals(
            _other: T,
            _epsilon: number,
          ): boolean;
          public isUnit(): boolean;
          public isUnit(_margin: number): boolean;
          public isOnLine(
            _other: T,
            _epsilon: number,
          ): boolean;
          public isOnLine(_other: T): boolean;
          public hasOppositeDirection(_other: T): boolean;
          public hasSameDirection(_other: T): boolean;
          public isPerpendicular(_other: T): boolean;
          public isPerpendicular(
            _other: T,
            _epsilon: number,
          ): boolean;
          public isCollinearOpposite(_other: T): boolean;
          public isCollinearOpposite(
            _other: T,
            _epsilon: number,
          ): boolean;
          public isCollinear(
            _other: T,
            _epsilon: number,
          ): boolean;
          public isCollinear(_other: T): boolean;
          public interpolate(
            _target: T,
            _alpha: number,
            _interpolator: Packages.arc.math.Interp,
          ): T | null;
          public dst2(_v: T): number;
          public nor(): T | null;
          public cpy(): T | null;
          public unaryMinus(): T | null;
          public times(_other: T): T | null;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare abstract class Position {
          public dst(
            _other: Packages.arc.math.geom.Position,
          ): number;
          public dst(_x: number, _y: number): number;
          public getX(): number;
          public getY(): number;
          public dst2(_x: number, _y: number): number;
          public dst2(
            _other: Packages.arc.math.geom.Position,
          ): number;
          public within(
            _other: Packages.arc.math.geom.Position,
            _dst: number,
          ): boolean;
          public within(
            _x: number,
            _y: number,
            _dst: number,
          ): boolean;
          public angleTo(
            _other: Packages.arc.math.geom.Position,
          ): number;
          public angleTo(_x: number, _y: number): number;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare class Affine2 extends java.lang.Object {
        public m00: number;
        public m01: number;
        public m02: number;
        public m10: number;
        public m11: number;
        public m12: number;
        public toString(): string;
        public scale(
          _scaleX: number,
          _scaleY: number,
        ): Packages.arc.math.Affine2;
        public scale(
          _scale: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.Affine2;
        public set(
          _other: Packages.arc.math.Affine2,
        ): Packages.arc.math.Affine2;
        public set(
          _matrix: Packages.arc.math.Mat,
        ): Packages.arc.math.Affine2;
        public inv(): Packages.arc.math.Affine2;
        public rotate(
          _degrees: number,
        ): Packages.arc.math.Affine2;
        public mul(
          _other: Packages.arc.math.Affine2,
        ): Packages.arc.math.Affine2;
        public rotateRad(
          _radians: number,
        ): Packages.arc.math.Affine2;
        public setToShearing(
          _shear: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.Affine2;
        public setToShearing(
          _shearX: number,
          _shearY: number,
        ): Packages.arc.math.Affine2;
        public setToRotationRad(
          _radians: number,
        ): Packages.arc.math.Affine2;
        public det(): number;
        public setToTranslation(
          _x: number,
          _y: number,
        ): Packages.arc.math.Affine2;
        public setToTranslation(
          _trn: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.Affine2;
        public setToScaling(
          _scale: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.Affine2;
        public setToScaling(
          _scaleX: number,
          _scaleY: number,
        ): Packages.arc.math.Affine2;
        public translate(
          _x: number,
          _y: number,
        ): Packages.arc.math.Affine2;
        public translate(
          _trn: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.Affine2;
        public getTranslation(
          _position: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.geom.Vec2;
        public setToTrnRotScl(
          _x: number,
          _y: number,
          _degrees: number,
          _scaleX: number,
          _scaleY: number,
        ): Packages.arc.math.Affine2;
        public setToTrnRotScl(
          _trn: Packages.arc.math.geom.Vec2,
          _degrees: number,
          _scale: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.Affine2;
        public setToTrnRotRadScl(
          _x: number,
          _y: number,
          _radians: number,
          _scaleX: number,
          _scaleY: number,
        ): Packages.arc.math.Affine2;
        public setToTrnRotRadScl(
          _trn: Packages.arc.math.geom.Vec2,
          _radians: number,
          _scale: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.Affine2;
        public setToTrnScl(
          _trn: Packages.arc.math.geom.Vec2,
          _scale: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.Affine2;
        public setToTrnScl(
          _x: number,
          _y: number,
          _scaleX: number,
          _scaleY: number,
        ): Packages.arc.math.Affine2;
        public preTranslate(
          _trn: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.Affine2;
        public preTranslate(
          _x: number,
          _y: number,
        ): Packages.arc.math.Affine2;
        public preScale(
          _scaleX: number,
          _scaleY: number,
        ): Packages.arc.math.Affine2;
        public preScale(
          _scale: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.Affine2;
        public shear(
          _shearX: number,
          _shearY: number,
        ): Packages.arc.math.Affine2;
        public shear(
          _shear: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.Affine2;
        public preShear(
          _shear: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.Affine2;
        public preShear(
          _shearX: number,
          _shearY: number,
        ): Packages.arc.math.Affine2;
        public setToProduct(
          _l: Packages.arc.math.Affine2,
          _r: Packages.arc.math.Affine2,
        ): Packages.arc.math.Affine2;
        public setToRotation(
          _degrees: number,
        ): Packages.arc.math.Affine2;
        public setToRotation(
          _cos: number,
          _sin: number,
        ): Packages.arc.math.Affine2;
        public idt(): Packages.arc.math.Affine2;
        public preMul(
          _other: Packages.arc.math.Affine2,
        ): Packages.arc.math.Affine2;
        public preRotate(
          _degrees: number,
        ): Packages.arc.math.Affine2;
        public preRotateRad(
          _radians: number,
        ): Packages.arc.math.Affine2;
        public isTranslation(): boolean;
        public isIdt(): boolean;
        public applyTo(
          _point: Packages.arc.math.geom.Vec2,
        ): void;
        public constructor();
        public constructor(
          _other: Packages.arc.math.Affine2,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare class Mat extends java.lang.Object {
        public static M00: number;
        public static M01: number;
        public static M02: number;
        public static M10: number;
        public static M11: number;
        public static M12: number;
        public static M20: number;
        public static M21: number;
        public static M22: number;
        public val: number[];
        private tmp: number[];
        public toString(): string;
        public scale(
          _scale: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.Mat;
        public scale(
          _scaleX: number,
          _scaleY: number,
        ): Packages.arc.math.Mat;
        public scl(
          _scale: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.Mat;
        public scl(
          _scale: Packages.arc.math.geom.Vec3,
        ): Packages.arc.math.Mat;
        public scl(_scale: number): Packages.arc.math.Mat;
        public set(
          _mat: Packages.arc.math.Mat,
        ): Packages.arc.math.Mat;
        public set(
          _values: number[],
        ): Packages.arc.math.Mat;
        public set(
          _affine: Packages.arc.math.Affine2,
        ): Packages.arc.math.Mat;
        public inv(): Packages.arc.math.Mat;
        public rotate(
          _degrees: number,
        ): Packages.arc.math.Mat;
        private static mul(
          _mata: number[],
          _matb: number[],
        ): void;
        public mul(
          _m: Packages.arc.math.Mat,
        ): Packages.arc.math.Mat;
        public rotateRad(
          _radians: number,
        ): Packages.arc.math.Mat;
        public setToRotationRad(
          _radians: number,
        ): Packages.arc.math.Mat;
        public det(): number;
        public setOrtho(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
        ): Packages.arc.math.Mat;
        public mulLeft(
          _m: Packages.arc.math.Mat,
        ): Packages.arc.math.Mat;
        public setToTranslation(
          _x: number,
          _y: number,
        ): Packages.arc.math.Mat;
        public setToTranslation(
          _translation: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.Mat;
        public setToScaling(
          _scaleX: number,
          _scaleY: number,
        ): Packages.arc.math.Mat;
        public setToScaling(
          _scale: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.Mat;
        public trn(
          _x: number,
          _y: number,
        ): Packages.arc.math.Mat;
        public trn(
          _vector: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.Mat;
        public trn(
          _vector: Packages.arc.math.geom.Vec3,
        ): Packages.arc.math.Mat;
        public translate(
          _translation: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.Mat;
        public translate(
          _x: number,
          _y: number,
        ): Packages.arc.math.Mat;
        public getValues(): number[] | null;
        public getTranslation(
          _position: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.geom.Vec2;
        public getScale(
          _scale: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.geom.Vec2;
        public getRotation(): number;
        public getRotationRad(): number;
        public transpose(): Packages.arc.math.Mat;
        public setToRotation(
          _axis: Packages.arc.math.geom.Vec3,
          _cos: number,
          _sin: number,
        ): Packages.arc.math.Mat;
        public setToRotation(
          _degrees: number,
        ): Packages.arc.math.Mat;
        public setToRotation(
          _axis: Packages.arc.math.geom.Vec3,
          _degrees: number,
        ): Packages.arc.math.Mat;
        public idt(): Packages.arc.math.Mat;
        public constructor(_values: number[]);
        public constructor(_matrix: Packages.arc.math.Mat);
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class Vec3
          extends java.lang.Object
          implements
            Packages.arc.math.geom
              .Vector<Packages.arc.math.geom.Vec3>
        {
          public static X: Packages.arc.math.geom.Vec3;
          public static Y: Packages.arc.math.geom.Vec3;
          public static Z: Packages.arc.math.geom.Vec3;
          public static Zero: Packages.arc.math.geom.Vec3;
          private static tmpMat: Packages.arc.math.Mat;
          public x: number;
          public y: number;
          public z: number;
          public add(
            _vector: Packages.arc.math.geom.Vector<any>,
          ): Packages.arc.math.geom.Vector<any>;
          public add(
            _vector: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public add(
            _values: number,
          ): Packages.arc.math.geom.Vec3;
          public add(
            _vector: Packages.arc.math.geom.Vec3,
            _scale: number,
          ): Packages.arc.math.geom.Vec3;
          public add(
            _x: number,
            _y: number,
            _z: number,
          ): Packages.arc.math.geom.Vec3;
          public equals(_obj: any): boolean;
          public toString(): string;
          public hashCode(): number;
          public dst(
            _vector: Packages.arc.math.geom.Vector<any>,
          ): number;
          public dst(
            _x: number,
            _y: number,
            _z: number,
          ): number;
          public static dst(
            _x1: number,
            _y1: number,
            _z1: number,
            _x2: number,
            _y2: number,
            _z2: number,
          ): number;
          public dst(
            _vector: Packages.arc.math.geom.Vec3,
          ): number;
          public len(): number;
          public static len(
            _x: number,
            _y: number,
            _z: number,
          ): number;
          public limit(
            _limit: number,
          ): Packages.arc.math.geom.Vector<any>;
          public limit(
            _limit: number,
          ): Packages.arc.math.geom.Vec3;
          public dot(
            _vector: Packages.arc.math.geom.Vec3,
          ): number;
          public dot(
            _x: number,
            _y: number,
            _z: number,
          ): number;
          public static dot(
            _x1: number,
            _y1: number,
            _z1: number,
            _x2: number,
            _y2: number,
            _z2: number,
          ): number;
          public dot(
            _vector: Packages.arc.math.geom.Vector<any>,
          ): number;
          public scl(
            _scalar: number,
          ): Packages.arc.math.geom.Vec3;
          public scl(
            _other: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public scl(
            _vx: number,
            _vy: number,
            _vz: number,
          ): Packages.arc.math.geom.Vec3;
          public scl(
            _scalar: number,
          ): Packages.arc.math.geom.Vector<any>;
          public scl(
            _other: Packages.arc.math.geom.Vector<any>,
          ): Packages.arc.math.geom.Vector<any>;
          public set(
            _vector: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public set(
            _values: number[],
          ): Packages.arc.math.geom.Vec3;
          public set(
            _x: number,
            _y: number,
            _z: number,
          ): Packages.arc.math.geom.Vec3;
          public set(
            _vector: Packages.arc.math.geom.Vector<any>,
          ): Packages.arc.math.geom.Vector<any>;
          public set(
            _vector: Packages.arc.math.geom.Vec2,
            _z: number,
          ): Packages.arc.math.geom.Vec3;
          public set(
            _values: number[],
            _offset: number,
          ): Packages.arc.math.geom.Vec3;
          public setLength(
            _len: number,
          ): Packages.arc.math.geom.Vector<any>;
          public setLength(
            _len: number,
          ): Packages.arc.math.geom.Vec3;
          public static len2(
            _x: number,
            _y: number,
            _z: number,
          ): number;
          public len2(): number;
          public rotate(
            _axis: Packages.arc.math.geom.Vec3,
            _degrees: number,
          ): Packages.arc.math.geom.Vec3;
          public sub(
            _x: number,
            _y: number,
            _z: number,
          ): Packages.arc.math.geom.Vec3;
          public sub(
            _value: number,
          ): Packages.arc.math.geom.Vec3;
          public sub(
            _vector: Packages.arc.math.geom.Vec3,
            _scale: number,
          ): Packages.arc.math.geom.Vec3;
          public sub(
            _a_vec: Packages.arc.math.geom.Vector<any>,
          ): Packages.arc.math.geom.Vector<any>;
          public sub(
            _a_vec: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public isZero(_margin: number): boolean;
          public isZero(): boolean;
          public mulAdd(
            _vec: Packages.arc.math.geom.Vector<any>,
            _mulVec: Packages.arc.math.geom.Vector<any>,
          ): Packages.arc.math.geom.Vector<any>;
          public mulAdd(
            _vec: Packages.arc.math.geom.Vector<any>,
            _scalar: number,
          ): Packages.arc.math.geom.Vector<any>;
          public mulAdd(
            _vec: Packages.arc.math.geom.Vec3,
            _mulVec: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public mulAdd(
            _vec: Packages.arc.math.geom.Vec3,
            _scalar: number,
          ): Packages.arc.math.geom.Vec3;
          public div(
            _other: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public div(
            _other: Packages.arc.math.geom.Vector<any>,
          ): Packages.arc.math.geom.Vector<any>;
          public mul(
            _matrix: Packages.arc.math.Mat,
          ): Packages.arc.math.geom.Vec3;
          public clamp(
            _min: number,
            _max: number,
          ): Packages.arc.math.geom.Vector<any>;
          public clamp(
            _min: number,
            _max: number,
          ): Packages.arc.math.geom.Vec3;
          public setFromSpherical(
            _azimuthalAngle: number,
            _polarAngle: number,
          ): Packages.arc.math.geom.Vec3;
          public limit2(
            _limit2: number,
          ): Packages.arc.math.geom.Vec3;
          public limit2(
            _limit2: number,
          ): Packages.arc.math.geom.Vector<any>;
          public setLength2(
            _len2: number,
          ): Packages.arc.math.geom.Vector<any>;
          public setLength2(
            _len2: number,
          ): Packages.arc.math.geom.Vec3;
          public setZero(): Packages.arc.math.geom.Vector<any>;
          public setZero(): Packages.arc.math.geom.Vec3;
          public crs(
            _vector: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public crs(
            _x: number,
            _y: number,
            _z: number,
          ): Packages.arc.math.geom.Vec3;
          public setToRandomDirection(): Packages.arc.math.geom.Vec3;
          public setToRandomDirection(
            _rand: Packages.arc.math.Rand,
          ): Packages.arc.math.geom.Vec3;
          public setToRandomDirection(): Packages.arc.math.geom.Vector<any>;
          public angle(
            _vector: Packages.arc.math.geom.Vec3,
          ): number;
          public lerp(
            _target: Packages.arc.math.geom.Vector<any>,
            _alpha: number,
          ): Packages.arc.math.geom.Vector<any>;
          public lerp(
            _target: Packages.arc.math.geom.Vec3,
            _alpha: number,
          ): Packages.arc.math.geom.Vec3;
          public epsilonEquals(
            _other: Packages.arc.math.geom.Vector<any>,
            _epsilon: number,
          ): boolean;
          public epsilonEquals(
            _other: Packages.arc.math.geom.Vec3,
            _epsilon: number,
          ): boolean;
          public epsilonEquals(
            _other: Packages.arc.math.geom.Vec3,
          ): boolean;
          public epsilonEquals(
            _x: number,
            _y: number,
            _z: number,
          ): boolean;
          public epsilonEquals(
            _x: number,
            _y: number,
            _z: number,
            _epsilon: number,
          ): boolean;
          public isUnit(): boolean;
          public isUnit(_margin: number): boolean;
          public isOnLine(
            _other: Packages.arc.math.geom.Vector<any>,
          ): boolean;
          public isOnLine(
            _other: Packages.arc.math.geom.Vector<any>,
            _epsilon: number,
          ): boolean;
          public isOnLine(
            _other: Packages.arc.math.geom.Vec3,
          ): boolean;
          public isOnLine(
            _other: Packages.arc.math.geom.Vec3,
            _epsilon: number,
          ): boolean;
          public hasOppositeDirection(
            _vector: Packages.arc.math.geom.Vec3,
          ): boolean;
          public hasOppositeDirection(
            _vector: Packages.arc.math.geom.Vector<any>,
          ): boolean;
          public hasSameDirection(
            _vector: Packages.arc.math.geom.Vector<any>,
          ): boolean;
          public hasSameDirection(
            _vector: Packages.arc.math.geom.Vec3,
          ): boolean;
          public isPerpendicular(
            _vector: Packages.arc.math.geom.Vector<any>,
            _epsilon: number,
          ): boolean;
          public isPerpendicular(
            _vector: Packages.arc.math.geom.Vec3,
          ): boolean;
          public isPerpendicular(
            _vector: Packages.arc.math.geom.Vector<any>,
          ): boolean;
          public isPerpendicular(
            _vector: Packages.arc.math.geom.Vec3,
            _epsilon: number,
          ): boolean;
          public isCollinearOpposite(
            _other: Packages.arc.math.geom.Vec3,
            _epsilon: number,
          ): boolean;
          public isCollinearOpposite(
            _other: Packages.arc.math.geom.Vec3,
          ): boolean;
          public isCollinearOpposite(
            _other: Packages.arc.math.geom.Vector<any>,
            _epsilon: number,
          ): boolean;
          public isCollinearOpposite(
            _other: Packages.arc.math.geom.Vector<any>,
          ): boolean;
          public isCollinear(
            _other: Packages.arc.math.geom.Vec3,
          ): boolean;
          public isCollinear(
            _other: Packages.arc.math.geom.Vec3,
            _epsilon: number,
          ): boolean;
          public isCollinear(
            _other: Packages.arc.math.geom.Vector<any>,
          ): boolean;
          public isCollinear(
            _other: Packages.arc.math.geom.Vector<any>,
            _epsilon: number,
          ): boolean;
          public interpolate(
            _target: Packages.arc.math.geom.Vec3,
            _alpha: number,
            _interpolator: Packages.arc.math.Interp,
          ): Packages.arc.math.geom.Vec3;
          public interpolate(
            _target: Packages.arc.math.geom.Vector<any>,
            _alpha: number,
            _interpolator: Packages.arc.math.Interp,
          ): Packages.arc.math.geom.Vector<any>;
          public dst2(
            _point: Packages.arc.math.geom.Vec3,
          ): number;
          public dst2(
            _x: number,
            _y: number,
            _z: number,
          ): number;
          public static dst2(
            _x1: number,
            _y1: number,
            _z1: number,
            _x2: number,
            _y2: number,
            _z2: number,
          ): number;
          public dst2(
            _point: Packages.arc.math.geom.Vector<any>,
          ): number;
          public nor(): Packages.arc.math.geom.Vec3;
          public nor(): Packages.arc.math.geom.Vector<any>;
          public cpy(): Packages.arc.math.geom.Vec3;
          public cpy(): Packages.arc.math.geom.Vector<any>;
          public cpy(
            _dest: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public fromString(
            _v: string,
          ): Packages.arc.math.geom.Vec3;
          public angleRad(
            _vector: Packages.arc.math.geom.Vec3,
          ): number;
          public within(
            _v: Packages.arc.math.geom.Vec3,
            _dst: number,
          ): boolean;
          public idt(
            _vector: Packages.arc.math.geom.Vec3,
          ): boolean;
          public mul4x3(
            _matrix: number[],
          ): Packages.arc.math.geom.Vec3;
          public traMul(
            _matrix: Packages.arc.math.Mat,
          ): Packages.arc.math.geom.Vec3;
          public slerp(
            _target: Packages.arc.math.geom.Vec3,
            _alpha: number,
          ): Packages.arc.math.geom.Vec3;
          public constructor(
            _vector: Packages.arc.math.geom.Vec2,
            _z: number,
          );
          public constructor(_values: number[]);
          public constructor(
            _vector: Packages.arc.math.geom.Vec3,
          );
          public constructor();
          public constructor(
            _x: number,
            _y: number,
            _z: number,
          );
          public constructor(
            _x: number,
            _y: number,
            _z: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class Vec2
          extends java.lang.Object
          implements
            Packages.arc.math.geom
              .Vector<Packages.arc.math.geom.Vec2>,
            Packages.arc.math.geom.Position
        {
          public static X: Packages.arc.math.geom.Vec2;
          public static Y: Packages.arc.math.geom.Vec2;
          public static ZERO: Packages.arc.math.geom.Vec2;
          public x: number;
          public y: number;
          public add(
            _x: number,
            _y: number,
          ): Packages.arc.math.geom.Vec2;
          public add(
            _vec: Packages.arc.math.geom.Vec2,
            _scl: number,
          ): Packages.arc.math.geom.Vec2;
          public add(
            _pos: Packages.arc.math.geom.Position,
          ): Packages.arc.math.geom.Vec2;
          public add(
            _v: Packages.arc.math.geom.Vector<any>,
          ): Packages.arc.math.geom.Vector<any>;
          public add(
            _v: Packages.arc.math.geom.Vec2,
          ): Packages.arc.math.geom.Vec2;
          public equals(_obj: any): boolean;
          public toString(): string;
          public hashCode(): number;
          public dst(_x: number, _y: number): number;
          public dst(
            _v: Packages.arc.math.geom.Vector<any>,
          ): number;
          public dst(
            _v: Packages.arc.math.geom.Vec2,
          ): number;
          public len(): number;
          public limit(
            _limit: number,
          ): Packages.arc.math.geom.Vec2;
          public limit(
            _limit: number,
          ): Packages.arc.math.geom.Vector<any>;
          public dot(_ox: number, _oy: number): number;
          public dot(
            _v: Packages.arc.math.geom.Vec2,
          ): number;
          public dot(
            _v: Packages.arc.math.geom.Vector<any>,
          ): number;
          public scl(
            _x: number,
            _y: number,
          ): Packages.arc.math.geom.Vec2;
          public scl(
            _v: Packages.arc.math.geom.Vector<any>,
          ): Packages.arc.math.geom.Vector<any>;
          public scl(
            _scalar: number,
          ): Packages.arc.math.geom.Vector<any>;
          public scl(
            _v: Packages.arc.math.geom.Vec2,
          ): Packages.arc.math.geom.Vec2;
          public scl(
            _scalar: number,
          ): Packages.arc.math.geom.Vec2;
          public set(
            _v: Packages.arc.math.geom.Vector<any>,
          ): Packages.arc.math.geom.Vector<any>;
          public set(
            _x: number,
            _y: number,
          ): Packages.arc.math.geom.Vec2;
          public set(
            _v: Packages.arc.math.geom.Position,
          ): Packages.arc.math.geom.Vec2;
          public set(
            _v: Packages.arc.math.geom.Vec2,
          ): Packages.arc.math.geom.Vec2;
          public set(
            _other: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec2;
          public setLength(
            _len: number,
          ): Packages.arc.math.geom.Vec2;
          public setLength(
            _len: number,
          ): Packages.arc.math.geom.Vector<any>;
          public isNaN(): boolean;
          public inv(): Packages.arc.math.geom.Vec2;
          public isInfinite(): boolean;
          public len2(): number;
          public rnd(
            _length: number,
          ): Packages.arc.math.geom.Vec2;
          public rotate(
            _degrees: number,
          ): Packages.arc.math.geom.Vec2;
          public sub(
            _v: Packages.arc.math.geom.Vec2,
          ): Packages.arc.math.geom.Vec2;
          public sub(
            _v: Packages.arc.math.geom.Position,
          ): Packages.arc.math.geom.Vec2;
          public sub(
            _v: Packages.arc.math.geom.Vector<any>,
          ): Packages.arc.math.geom.Vector<any>;
          public sub(
            _v: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec2;
          public sub(
            _x: number,
            _y: number,
          ): Packages.arc.math.geom.Vec2;
          public isZero(_margin: number): boolean;
          public isZero(): boolean;
          public mulAdd(
            _vec: Packages.arc.math.geom.Vec2,
            _scalar: number,
          ): Packages.arc.math.geom.Vec2;
          public mulAdd(
            _vec: Packages.arc.math.geom.Vector<any>,
            _scalar: number,
          ): Packages.arc.math.geom.Vector<any>;
          public mulAdd(
            _vec: Packages.arc.math.geom.Vector<any>,
            _mulVec: Packages.arc.math.geom.Vector<any>,
          ): Packages.arc.math.geom.Vector<any>;
          public mulAdd(
            _vec: Packages.arc.math.geom.Vec2,
            _mulVec: Packages.arc.math.geom.Vec2,
          ): Packages.arc.math.geom.Vec2;
          public div(
            _other: Packages.arc.math.geom.Vector<any>,
          ): Packages.arc.math.geom.Vector<any>;
          public div(
            _other: Packages.arc.math.geom.Vec2,
          ): Packages.arc.math.geom.Vec2;
          public mul(
            _mat: Packages.arc.math.Mat,
          ): Packages.arc.math.geom.Vec2;
          public rotateRad(
            _radians: number,
          ): Packages.arc.math.geom.Vec2;
          public clamp(
            _minx: number,
            _miny: number,
            _maxx: number,
            _maxy: number,
          ): Packages.arc.math.geom.Vec2;
          public clamp(
            _min: number,
            _max: number,
          ): Packages.arc.math.geom.Vec2;
          public clamp(
            _min: number,
            _max: number,
          ): Packages.arc.math.geom.Vector<any>;
          public rotateRadExact(
            _radians: number,
          ): Packages.arc.math.geom.Vec2;
          public getX(): number;
          public getY(): number;
          public limit2(
            _limit2: number,
          ): Packages.arc.math.geom.Vector<any>;
          public limit2(
            _limit2: number,
          ): Packages.arc.math.geom.Vec2;
          public setLength2(
            _len2: number,
          ): Packages.arc.math.geom.Vec2;
          public setLength2(
            _len2: number,
          ): Packages.arc.math.geom.Vector<any>;
          public setZero(): Packages.arc.math.geom.Vector<any>;
          public setZero(): Packages.arc.math.geom.Vec2;
          public crs(_x: number, _y: number): number;
          public crs(
            _v: Packages.arc.math.geom.Vec2,
          ): number;
          public setToRandomDirection(
            _rand: Packages.arc.math.Rand,
          ): Packages.arc.math.geom.Vec2;
          public setToRandomDirection(): Packages.arc.math.geom.Vec2;
          public setToRandomDirection(): Packages.arc.math.geom.Vector<any>;
          public setAngleRad(
            _radians: number,
          ): Packages.arc.math.geom.Vec2;
          public angle(
            _reference: Packages.arc.math.geom.Vec2,
          ): number;
          public angle(): number;
          public setAngle(
            _degrees: number,
          ): Packages.arc.math.geom.Vec2;
          public approach(
            _target: Packages.arc.math.geom.Vec2,
            _alpha: number,
          ): Packages.arc.math.geom.Vec2;
          public lerp(
            _target: Packages.arc.math.geom.Vector<any>,
            _alpha: number,
          ): Packages.arc.math.geom.Vector<any>;
          public lerp(
            _tx: number,
            _ty: number,
            _alpha: number,
          ): Packages.arc.math.geom.Vec2;
          public lerp(
            _target: Packages.arc.math.geom.Vec2,
            _alpha: number,
          ): Packages.arc.math.geom.Vec2;
          public lerp(
            _target: Packages.arc.math.geom.Position,
            _alpha: number,
          ): Packages.arc.math.geom.Vec2;
          public epsilonEquals(
            _other: Packages.arc.math.geom.Vector<any>,
            _epsilon: number,
          ): boolean;
          public epsilonEquals(
            _x: number,
            _y: number,
            _epsilon: number,
          ): boolean;
          public epsilonEquals(
            _other: Packages.arc.math.geom.Vec2,
          ): boolean;
          public epsilonEquals(
            _x: number,
            _y: number,
          ): boolean;
          public epsilonEquals(
            _other: Packages.arc.math.geom.Vec2,
            _epsilon: number,
          ): boolean;
          public isUnit(): boolean;
          public isUnit(_margin: number): boolean;
          public isOnLine(
            _other: Packages.arc.math.geom.Vec2,
            _epsilon: number,
          ): boolean;
          public isOnLine(
            _other: Packages.arc.math.geom.Vector<any>,
          ): boolean;
          public isOnLine(
            _other: Packages.arc.math.geom.Vector<any>,
            _epsilon: number,
          ): boolean;
          public isOnLine(
            _other: Packages.arc.math.geom.Vec2,
          ): boolean;
          public hasOppositeDirection(
            _vector: Packages.arc.math.geom.Vector<any>,
          ): boolean;
          public hasOppositeDirection(
            _vector: Packages.arc.math.geom.Vec2,
          ): boolean;
          public hasSameDirection(
            _vector: Packages.arc.math.geom.Vec2,
          ): boolean;
          public hasSameDirection(
            _vector: Packages.arc.math.geom.Vector<any>,
          ): boolean;
          public isPerpendicular(
            _vector: Packages.arc.math.geom.Vector<any>,
            _epsilon: number,
          ): boolean;
          public isPerpendicular(
            _vector: Packages.arc.math.geom.Vector<any>,
          ): boolean;
          public isPerpendicular(
            _vector: Packages.arc.math.geom.Vec2,
          ): boolean;
          public isPerpendicular(
            _vector: Packages.arc.math.geom.Vec2,
            _epsilon: number,
          ): boolean;
          public isCollinearOpposite(
            _other: Packages.arc.math.geom.Vector<any>,
            _epsilon: number,
          ): boolean;
          public isCollinearOpposite(
            _other: Packages.arc.math.geom.Vec2,
          ): boolean;
          public isCollinearOpposite(
            _other: Packages.arc.math.geom.Vector<any>,
          ): boolean;
          public isCollinearOpposite(
            _other: Packages.arc.math.geom.Vec2,
            _epsilon: number,
          ): boolean;
          public isCollinear(
            _other: Packages.arc.math.geom.Vec2,
            _epsilon: number,
          ): boolean;
          public isCollinear(
            _other: Packages.arc.math.geom.Vec2,
          ): boolean;
          public isCollinear(
            _other: Packages.arc.math.geom.Vector<any>,
          ): boolean;
          public isCollinear(
            _other: Packages.arc.math.geom.Vector<any>,
            _epsilon: number,
          ): boolean;
          public interpolate(
            _target: Packages.arc.math.geom.Vec2,
            _alpha: number,
            _interpolation: Packages.arc.math.Interp,
          ): Packages.arc.math.geom.Vec2;
          public interpolate(
            _target: Packages.arc.math.geom.Vector<any>,
            _alpha: number,
            _interpolation: Packages.arc.math.Interp,
          ): Packages.arc.math.geom.Vector<any>;
          public dst2(_x: number, _y: number): number;
          public dst2(
            _v: Packages.arc.math.geom.Vec2,
          ): number;
          public dst2(
            _v: Packages.arc.math.geom.Vector<any>,
          ): number;
          public nor(): Packages.arc.math.geom.Vector<any>;
          public nor(): Packages.arc.math.geom.Vec2;
          public cpy(): Packages.arc.math.geom.Vec2;
          public cpy(): Packages.arc.math.geom.Vector<any>;
          public trns(
            _angle: number,
            _amount: number,
          ): Packages.arc.math.geom.Vec2;
          public trns(
            _angle: number,
            _x: number,
            _y: number,
          ): Packages.arc.math.geom.Vec2;
          public trnsExact(
            _angle: number,
            _amount: number,
          ): Packages.arc.math.geom.Vec2;
          public snap(): Packages.arc.math.geom.Vec2;
          public clampLength(
            _min: number,
            _max: number,
          ): Packages.arc.math.geom.Vec2;
          public tryFromString(
            _v: string,
          ): Packages.arc.math.geom.Vec2;
          public fromString(
            _v: string,
          ): Packages.arc.math.geom.Vec2;
          public angleRad(
            _reference: Packages.arc.math.geom.Vec2,
          ): number;
          public angleRad(): number;
          public rotateTo(
            _angle: number,
            _speed: number,
          ): Packages.arc.math.geom.Vec2;
          public rotateAround(
            _reference: Packages.arc.math.geom.Vec2,
            _degrees: number,
          ): Packages.arc.math.geom.Vec2;
          public rotateAroundRad(
            _reference: Packages.arc.math.geom.Vec2,
            _radians: number,
          ): Packages.arc.math.geom.Vec2;
          public rotate90(
            _dir: number,
          ): Packages.arc.math.geom.Vec2;
          public approachDelta(
            _target: Packages.arc.math.geom.Vec2,
            _alpha: number,
          ): Packages.arc.math.geom.Vec2;
          public lerpPast(
            _target: Packages.arc.math.geom.Vec2,
            _alpha: number,
          ): Packages.arc.math.geom.Vec2;
          public lerpDelta(
            _target: Packages.arc.math.geom.Position,
            _alpha: number,
          ): Packages.arc.math.geom.Vec2;
          public lerpDelta(
            _tx: number,
            _ty: number,
            _alpha: number,
          ): Packages.arc.math.geom.Vec2;
          public constructor(
            _v: Packages.arc.math.geom.Vec2,
          );
          public constructor(_x: number, _y: number);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class FloatSeq extends java.lang.Object {
        public items: number[];
        public size: number;
        public ordered: boolean;
        public add(_value1: number, _value2: number): void;
        public add(_value: number): void;
        public add(
          _value1: number,
          _value2: number,
          _value3: number,
        ): void;
        public add(
          _value1: number,
          _value2: number,
          _value3: number,
          _value4: number,
        ): void;
        public get(_index: number): number;
        public equals(
          _object: any,
          _epsilon: number,
        ): boolean;
        public equals(_object: any): boolean;
        public toString(_separator: string): string;
        public toString(): string;
        public hashCode(): number;
        public indexOf(_value: number): number;
        public insert(_index: number, _value: number): void;
        public clear(): void;
        public lastIndexOf(_value: number): number;
        public isEmpty(): boolean;
        public toArray(): number[] | null;
        public contains(_value: number): boolean;
        public addAll(
          _array: Packages.arc.struct.FloatSeq,
        ): void;
        public addAll(
          _array: Packages.arc.struct.FloatSeq,
          _offset: number,
          _length: number,
        ): void;
        public addAll(
          _array: number[],
          _offset: number,
          _length: number,
        ): void;
        public addAll(..._array: number[]): void;
        public first(): number;
        public set(_index: number, _value: number): void;
        public ensureCapacity(
          _additionalCapacity: number,
        ): number[] | null;
        public reverse(): void;
        public peek(): number;
        public sum(): number;
        public sort(): void;
        public removeRange(
          _start: number,
          _end: number,
        ): void;
        public removeAll(
          _array: Packages.arc.struct.FloatSeq,
        ): boolean;
        protected resize(_newSize: number): number[] | null;
        public incr(_index: number, _value: number): void;
        public random(): number;
        public swap(_first: number, _second: number): void;
        public shuffle(): void;
        public pop(): number;
        public static with(
          ..._array: number[]
        ): Packages.arc.struct.FloatSeq;
        public setSize(_newSize: number): number[] | null;
        public mul(_index: number, _value: number): void;
        public truncate(_newSize: number): void;
        public shrink(): number[] | null;
        public toVec2Array(): Packages.arc.struct.Seq<Packages.arc.math.geom.Vec2>;
        public removeIndex(_index: number): number;
        public removeValue(_value: number): boolean;
        public constructor(
          _ordered: boolean,
          _array: number[],
          _startIndex: number,
          _count: number,
        );
        public constructor(_array: number[]);
        public constructor(
          _array: Packages.arc.struct.FloatSeq,
        );
        public constructor();
        public constructor(_capacity: number);
        public constructor(
          _ordered: boolean,
          _capacity: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class Seq<T>
        extends java.lang.Object
        implements
          Packages.java.lang.Iterable<T>,
          Packages.arc.util.Eachable<T>
      {
        public static SeqIterable = class<T>
          extends java.lang.Object
          implements Packages.java.lang.Iterable<T>
        {
          private SeqIterator = class
            extends java.lang.Object
            implements Packages.java.util.Iterator<T>
          {
            index: number;
            done: boolean;
            this$0: Packages.arc.struct.Seq.SeqIterable<any>;
            public remove(): void;
            public hasNext(): boolean;
            public next(): T | null;
          };
          array: Packages.arc.struct.Seq<T>;
          allowRemove: boolean;
          private iterator1: Packages.arc.struct.Seq.SeqIterable.SeqIterator;
          private iterator2: Packages.arc.struct.Seq.SeqIterable.SeqIterator;
          public iterator(): Packages.java.util.Iterator<T>;
          public constructor(
            _array: Packages.arc.struct.Seq<T>,
          );
          public constructor(
            _array: Packages.arc.struct.Seq<T>,
            _allowRemove: boolean,
          );
        };
        public static iteratorsAllocated: number;
        public items: T[];
        public size: number;
        public ordered: boolean;
        private iterable?: Packages.arc.struct.Seq.SeqIterable<T>;
        public add(
          _value1: T,
          _value2: T,
        ): Packages.arc.struct.Seq<T>;
        public add(
          _value1: T,
          _value2: T,
          _value3: T,
        ): Packages.arc.struct.Seq<T>;
        public add(_array: T[]): Packages.arc.struct.Seq<T>;
        public add(_value: T): Packages.arc.struct.Seq<T>;
        public add(
          _value1: T,
          _value2: T,
          _value3: T,
          _value4: T,
        ): Packages.arc.struct.Seq<T>;
        public add(
          _array: Packages.arc.struct.Seq<any>,
        ): Packages.arc.struct.Seq<T>;
        public remove(
          _value: T,
          _identity: boolean,
        ): boolean;
        public remove(
          _value: Packages.arc.func.Boolf<T>,
        ): boolean;
        public remove(_value: T): boolean;
        public remove(_index: number): T | null;
        public get(_index: number): T | null;
        public equals(_object: any): boolean;
        public toString(
          _separator: string,
          _stringifier: Packages.arc.func.Func<T, string>,
        ): string;
        public toString(): string;
        public toString(_separator: string): string;
        public hashCode(): number;
        public min(
          _func: Packages.java.util.Comparator<T>,
        ): T | null;
        public min(
          _func: Packages.arc.func.Floatf<T>,
        ): T | null;
        public min(
          _filter: Packages.arc.func.Boolf<T>,
          _func: Packages.arc.func.Floatf<T>,
        ): T | null;
        public min(
          _filter: Packages.arc.func.Boolf<T>,
          _func: Packages.java.util.Comparator<T>,
        ): T | null;
        public max(
          _func: Packages.arc.func.Floatf<T>,
        ): T | null;
        public max(
          _func: Packages.java.util.Comparator<T>,
        ): T | null;
        public indexOf(
          _value: T,
          _identity: boolean,
        ): number;
        public indexOf(_value: T): number;
        public indexOf(
          _value: Packages.arc.func.Boolf<T>,
        ): number;
        public insert(_index: number, _value: T): void;
        public clear(): Packages.arc.struct.Seq<T>;
        public lastIndexOf(
          _value: T,
          _identity: boolean,
        ): number;
        public isEmpty(): boolean;
        public replace(_from: T, _to: T): boolean;
        public replace(
          _mapper: Packages.arc.func.Func<T, T>,
        ): void;
        public toArray<V>(
          _type: Class | Packages.java.lang.Class<any>,
        ): V[] | null;
        public toArray(): T[] | null;
        public iterator(): Packages.java.util.Iterator<T>;
        public map<R>(
          _mapper: Packages.arc.func.Func<T, R>,
        ): Packages.arc.struct.Seq<R>;
        public count(
          _predicate: Packages.arc.func.Boolf<T>,
        ): number;
        public contains(
          _value: T,
          _identity: boolean,
        ): boolean;
        public contains(_value: T): boolean;
        public contains(
          _predicate: Packages.arc.func.Boolf<T>,
        ): boolean;
        public list(): Packages.java.util.ArrayList<T>;
        public addAll(
          _array: Packages.arc.struct.Seq<any>,
          _start: number,
          _count: number,
        ): Packages.arc.struct.Seq<T>;
        public addAll(
          ..._array: T[]
        ): Packages.arc.struct.Seq<T>;
        public addAll(
          _array: Packages.arc.struct.Seq<any>,
        ): Packages.arc.struct.Seq<T>;
        public addAll(
          _items: Packages.java.lang.Iterable<any>,
        ): Packages.arc.struct.Seq<T>;
        public addAll(
          _array: T[],
          _start: number,
          _count: number,
        ): Packages.arc.struct.Seq<T>;
        public first(): T | null;
        public find(
          _predicate: Packages.arc.func.Boolf<T>,
        ): T | null;
        public set(_array: T[]): void;
        public set(
          _array: Packages.arc.struct.Seq<any>,
        ): void;
        public set(_index: number, _value: T): void;
        public flatMap<R>(
          _mapper: Packages.arc.func.Func<
            T,
            Packages.java.lang.Iterable<R>
          >,
        ): Packages.arc.struct.Seq<R>;
        public copy(): Packages.arc.struct.Seq<T>;
        public ensureCapacity(
          _additionalCapacity: number,
        ): T[] | null;
        public reverse(): Packages.arc.struct.Seq<T>;
        public peek(): T | null;
        public as<R>(): Packages.arc.struct.Seq<R>;
        public sum(
          _summer: Packages.arc.func.Intf<T>,
        ): number;
        public reduce<R>(
          _initial: R,
          _reducer: Packages.arc.func.Func2<T, R, R>,
        ): R | null;
        public sort(): Packages.arc.struct.Seq<T>;
        public sort(
          _comparator: Packages.java.util.Comparator<any>,
        ): Packages.arc.struct.Seq<T>;
        public sort(
          _comparator: Packages.arc.func.Floatf<any>,
        ): Packages.arc.struct.Seq<T>;
        public removeRange(
          _start: number,
          _end: number,
        ): void;
        public removeAll(
          _array: Packages.arc.struct.Seq<any>,
          _identity: boolean,
        ): boolean;
        public removeAll(
          _array: Packages.arc.struct.Seq<any>,
        ): boolean;
        public removeAll(
          _pred: Packages.arc.func.Boolf<T>,
        ): Packages.arc.struct.Seq<T>;
        public retainAll(
          _predicate: Packages.arc.func.Boolf<T>,
        ): Packages.arc.struct.Seq<T>;
        public containsAll(
          _seq: Packages.arc.struct.Seq<T>,
        ): boolean;
        public containsAll(
          _seq: Packages.arc.struct.Seq<T>,
          _identity: boolean,
        ): boolean;
        public each<E extends T>(
          _pred: Packages.arc.func.Boolf<any>,
          _consumer: Packages.arc.func.Cons<E>,
        ): void;
        public each(
          _consumer: Packages.arc.func.Cons<any>,
        ): void;
        protected resize(_newSize: number): T[] | null;
        public distinct(): Packages.arc.struct.Seq<T>;
        public allMatch(
          _predicate: Packages.arc.func.Boolf<T>,
        ): boolean;
        public random(): T | null;
        public random(
          _rand: Packages.arc.math.Rand,
        ): T | null;
        public random(_exclude: T): T | null;
        public swap(_first: number, _second: number): void;
        public shuffle(): Packages.arc.struct.Seq<T>;
        public pop(
          _constructor: Packages.arc.func.Prov<T>,
        ): T | null;
        public pop(): T | null;
        public static with<T>(
          _array: Packages.java.lang.Iterable<T>,
        ): Packages.arc.struct.Seq<T>;
        public static with<T>(
          ..._array: T[]
        ): Packages.arc.struct.Seq<T>;
        public with(
          _cons: Packages.arc.func.Cons<
            Packages.arc.struct.Seq<T>
          >,
        ): Packages.arc.struct.Seq<T>;
        public setSize(_newSize: number): T[] | null;
        public flatten<R>(): Packages.arc.struct.Seq<R>;
        public any(): boolean;
        public asMap<K, V>(
          _keygen: Packages.arc.func.Func<T, K>,
          _valgen: Packages.arc.func.Func<T, V>,
        ): Packages.arc.struct.ObjectMap<K, V>;
        public asMap<K>(
          _keygen: Packages.arc.func.Func<T, K>,
        ): Packages.arc.struct.ObjectMap<K, T>;
        public truncate(_newSize: number): void;
        public asSet(): Packages.arc.struct.ObjectSet<T>;
        public select(
          _predicate: Packages.arc.func.Boolf<T>,
        ): Packages.arc.struct.Seq<T>;
        public static select<T>(
          _array: T[],
          _test: Packages.arc.func.Boolf<T>,
        ): Packages.arc.struct.Seq<T>;
        public static withArrays<T>(
          ..._arrays: any[]
        ): Packages.arc.struct.Seq<T>;
        public sumf(
          _summer: Packages.arc.func.Floatf<T>,
        ): number;
        public mapInt(
          _mapper: Packages.arc.func.Intf<T>,
        ): Packages.arc.struct.IntSeq;
        public mapFloat(
          _mapper: Packages.arc.func.Floatf<T>,
        ): Packages.arc.struct.FloatSeq;
        public addUnique(_value: T): boolean;
        public getFrac(_index: number): T | null;
        public firstOpt(): T | null;
        public shrink(): T[] | null;
        public sortComparing<
          U extends Packages.java.lang.Comparable<any>,
        >(
          _keyExtractor: Packages.arc.func.Func<any, any>,
        ): Packages.arc.struct.Seq<T>;
        public selectFrom(
          _base: Packages.arc.struct.Seq<T>,
          _predicate: Packages.arc.func.Boolf<T>,
        ): Packages.arc.struct.Seq<T>;
        public selectRanked(
          _comparator: Packages.java.util.Comparator<T>,
          _kthLowest: number,
        ): T | null;
        public selectRankedIndex(
          _comparator: Packages.java.util.Comparator<T>,
          _kthLowest: number,
        ): number;
        public constructor(
          _ordered: boolean,
          _capacity: number,
          _arrayType:
            | Class<any>
            | Packages.java.lang.Class<any>,
        );
        public constructor(
          _arrayType:
            | Class<any>
            | Packages.java.lang.Class<any>,
        );
        public constructor(
          _array: Packages.arc.struct.Seq<any>,
        );
        public constructor(_array: T[]);
        public constructor(
          _ordered: boolean,
          _array: T[],
          _start: number,
          _count: number,
        );
        public constructor();
        public constructor(_capacity: number);
        public constructor(_ordered: boolean);
        public constructor(
          _ordered: boolean,
          _capacity: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace io {
      declare class File {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare abstract class Enum<
          E extends Packages.java.lang.Enum<E>,
        >
        extends java.lang.Object
        implements
          Packages.java.lang.constant.Constable,
          Packages.java.lang.Comparable<E>,
          Packages.java.io.Serializable
      {
        public static EnumDesc = class<
          E extends Packages.java.lang.Enum<E>,
        > {};
        public name(): string;
        protected finalize(): void;
        public equals(_arg0: any): boolean;
        public toString(): string;
        public hashCode(): number;
        protected clone(): any;
        public compareTo(_arg0: any): number;
        public compareTo(_arg0: E): number;
        public static valueOf<
          T extends Packages.java.lang.Enum<T>,
        >(
          _arg0: Class<T> | Packages.java.lang.Class<T>,
          _arg1: string,
        ): T | null;
        public describeConstable(): Packages.java.util.Optional<
          Packages.java.lang.Enum.EnumDesc<E>
        >;
        public getDeclaringClass(): Packages.java.lang.Class<E>;
        private readObject(
          _arg0: Packages.java.io.ObjectInputStream,
        ): void;
        public ordinal(): number;
        private readObjectNoData(): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace nio {
      declare abstract class ByteBuffer {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace io {
      declare abstract class FileFilter {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace io {
      declare abstract class FilenameFilter {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace io {
      declare abstract class OutputStream {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace io {
      declare class BufferedInputStream {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace io {
      declare abstract class Reader {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace io {
      declare class BufferedReader {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace io {
      declare abstract class Writer {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare abstract class AutoCloseable {
        public close(): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace io {
      declare abstract class Closeable
        implements Packages.java.lang.AutoCloseable
      {
        public close(): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace io {
      declare abstract class DataInput {}
    }
  }
}
declare namespace Packages {
  declare abstract class short {}
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace io {
        declare class Reads
          extends java.lang.Object
          implements Packages.java.io.Closeable
        {
          private static instance: Packages.arc.util.io.Reads;
          public input: Packages.java.io.DataInput;
          public static get(
            _input: Packages.java.io.DataInput,
          ): Packages.arc.util.io.Reads;
          public i(): number;
          public b(_length: number): string[] | null;
          public b(): string;
          public b(_array: string[]): string[] | null;
          public b(
            _array: string[],
            _offset: number,
            _length: number,
          ): string[] | null;
          public s(): Packages.short;
          public str(): string;
          public f(): number;
          public l(): Packages.long;
          public d(): number;
          public us(): number;
          public close(): void;
          public skip(_amount: number): void;
          public checkEOF(): number;
          public bool(): boolean;
          public ub(): number;
          public constructor(
            _input: Packages.java.io.DataInput,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace io {
      declare abstract class DataOutput {}
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace io {
        declare class Writes
          extends java.lang.Object
          implements Packages.java.io.Closeable
        {
          private static instance: Packages.arc.util.io.Writes;
          public output: Packages.java.io.DataOutput;
          public static get(
            _output: Packages.java.io.DataOutput,
          ): Packages.arc.util.io.Writes;
          public i(_i: number): void;
          public b(
            _array: string[],
            _offset: number,
            _length: number,
          ): void;
          public b(_array: string[]): void;
          public b(_i: number): void;
          public s(_i: number): void;
          public str(_str: string): void;
          public f(_f: number): void;
          public l(_i: Packages.long): void;
          public d(_d: number): void;
          public close(): void;
          public bool(_b: boolean): void;
          public constructor(
            _output: Packages.java.io.DataOutput,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class IntIntf {
        public get(_value: number): number;
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare class StringBuilder {}
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare class Color extends java.lang.Object {
        public static white: Packages.arc.graphics.Color;
        public static lightGray: Packages.arc.graphics.Color;
        public static gray: Packages.arc.graphics.Color;
        public static darkGray: Packages.arc.graphics.Color;
        public static black: Packages.arc.graphics.Color;
        public static clear: Packages.arc.graphics.Color;
        public static whiteFloatBits: number;
        public static clearFloatBits: number;
        public static blackFloatBits: number;
        public static whiteRgba: number;
        public static clearRgba: number;
        public static blackRgba: number;
        public static blue: Packages.arc.graphics.Color;
        public static navy: Packages.arc.graphics.Color;
        public static royal: Packages.arc.graphics.Color;
        public static slate: Packages.arc.graphics.Color;
        public static sky: Packages.arc.graphics.Color;
        public static cyan: Packages.arc.graphics.Color;
        public static teal: Packages.arc.graphics.Color;
        public static green: Packages.arc.graphics.Color;
        public static acid: Packages.arc.graphics.Color;
        public static lime: Packages.arc.graphics.Color;
        public static forest: Packages.arc.graphics.Color;
        public static olive: Packages.arc.graphics.Color;
        public static yellow: Packages.arc.graphics.Color;
        public static gold: Packages.arc.graphics.Color;
        public static goldenrod: Packages.arc.graphics.Color;
        public static orange: Packages.arc.graphics.Color;
        public static brown: Packages.arc.graphics.Color;
        public static tan: Packages.arc.graphics.Color;
        public static brick: Packages.arc.graphics.Color;
        public static red: Packages.arc.graphics.Color;
        public static scarlet: Packages.arc.graphics.Color;
        public static crimson: Packages.arc.graphics.Color;
        public static coral: Packages.arc.graphics.Color;
        public static salmon: Packages.arc.graphics.Color;
        public static pink: Packages.arc.graphics.Color;
        public static magenta: Packages.arc.graphics.Color;
        public static purple: Packages.arc.graphics.Color;
        public static violet: Packages.arc.graphics.Color;
        public static maroon: Packages.arc.graphics.Color;
        private static tmpHSV: number[];
        public add(
          _r: number,
          _g: number,
          _b: number,
          _a: number,
        ): Packages.arc.graphics.Color;
        public add(
          _color: Packages.arc.graphics.Color,
        ): Packages.arc.graphics.Color;
        public add(
          _r: number,
          _g: number,
          _b: number,
        ): Packages.arc.graphics.Color;
        public value(
          _amount: number,
        ): Packages.arc.graphics.Color;
        public value(): number;
        public equals(_o: any): boolean;
        public toString(): string;
        public toString(
          _builder: Packages.java.lang.StringBuilder,
        ): void;
        public hashCode(): number;
        public static valueOf(
          _color: Packages.arc.graphics.Color,
          _hex: string,
        ): Packages.arc.graphics.Color;
        public static valueOf(
          _hex: string,
        ): Packages.arc.graphics.Color;
        public b(_b: number): Packages.arc.graphics.Color;
        public a(_a: number): Packages.arc.graphics.Color;
        public set(
          _r: number,
          _g: number,
          _b: number,
        ): Packages.arc.graphics.Color;
        public set(
          _vec: Packages.arc.math.geom.Vec3,
        ): Packages.arc.graphics.Color;
        public set(
          _r: number,
          _g: number,
          _b: number,
          _a: number,
        ): Packages.arc.graphics.Color;
        public set(
          _rgba: number,
        ): Packages.arc.graphics.Color;
        public set(
          _color: Packages.arc.graphics.Color,
        ): Packages.arc.graphics.Color;
        public write(
          _to: Packages.arc.graphics.Color,
        ): Packages.arc.graphics.Color;
        public g(_g: number): Packages.arc.graphics.Color;
        public inv(): Packages.arc.graphics.Color;
        public r(_r: number): Packages.arc.graphics.Color;
        public sum(): number;
        public static bi(_rgba: number): number;
        public sub(
          _r: number,
          _g: number,
          _b: number,
          _a: number,
        ): Packages.arc.graphics.Color;
        public sub(
          _r: number,
          _g: number,
          _b: number,
        ): Packages.arc.graphics.Color;
        public sub(
          _color: Packages.arc.graphics.Color,
        ): Packages.arc.graphics.Color;
        private static parseHex(
          _string: string,
          _from: number,
          _to: number,
        ): number;
        public diff(
          _other: Packages.arc.graphics.Color,
        ): number;
        public mul(
          _color: Packages.arc.graphics.Color,
        ): Packages.arc.graphics.Color;
        public mul(
          _value: number,
        ): Packages.arc.graphics.Color;
        public mul(
          _r: number,
          _g: number,
          _b: number,
          _a: number,
        ): Packages.arc.graphics.Color;
        public clamp(): Packages.arc.graphics.Color;
        public rand(): Packages.arc.graphics.Color;
        public lerp(
          _r: number,
          _g: number,
          _b: number,
          _a: number,
          _t: number,
        ): Packages.arc.graphics.Color;
        public lerp(
          _target: Packages.arc.graphics.Color,
          _t: number,
        ): Packages.arc.graphics.Color;
        public lerp(
          _colors: Packages.arc.graphics.Color[],
          _s: number,
        ): Packages.arc.graphics.Color;
        public cpy(): Packages.arc.graphics.Color;
        public static alpha(_alpha: number): number;
        public rgba(): number;
        public static luminanceAlpha(
          _luminance: number,
          _alpha: number,
        ): number;
        public rgb565(): number;
        public rgb565(
          _value: number,
        ): Packages.arc.graphics.Color;
        public static rgb565(
          _r: number,
          _g: number,
          _b: number,
        ): number;
        public static rgba4444(
          _r: number,
          _g: number,
          _b: number,
          _a: number,
        ): number;
        public rgba4444(): number;
        public rgba4444(
          _value: number,
        ): Packages.arc.graphics.Color;
        public rgb888(
          _value: number,
        ): Packages.arc.graphics.Color;
        public static rgb888(
          _r: number,
          _g: number,
          _b: number,
        ): number;
        public rgb888(): number;
        public rgba8888(): number;
        public static rgba8888(
          _r: number,
          _g: number,
          _b: number,
          _a: number,
        ): number;
        public rgba8888(
          _value: number,
        ): Packages.arc.graphics.Color;
        public static intToFloatColor(
          _value: number,
        ): number;
        public static toDoubleBits(
          _r: number,
          _g: number,
          _b: number,
          _a: number,
        ): number;
        public static toDoubleBits(
          _r: number,
          _g: number,
          _b: number,
          _a: number,
        ): number;
        public toDoubleBits(): number;
        public static floatToIntColor(
          _value: number,
        ): number;
        public fromHsv(
          _h: number,
          _s: number,
          _v: number,
        ): Packages.arc.graphics.Color;
        public fromHsv(
          _hsv: number[],
        ): Packages.arc.graphics.Color;
        public hue(): number;
        public hue(
          _amount: number,
        ): Packages.arc.graphics.Color;
        public saturation(): number;
        public saturation(
          _amount: number,
        ): Packages.arc.graphics.Color;
        public toHsv(_hsv: number[]): number[] | null;
        public abgr(): number;
        public static abgr(
          _r: number,
          _g: number,
          _b: number,
          _a: number,
        ): number;
        public static HSVtoRGB(
          _h: number,
          _s: number,
          _v: number,
        ): Packages.arc.graphics.Color;
        public static HSVtoRGB(
          _h: number,
          _s: number,
          _v: number,
          _alpha: number,
        ): Packages.arc.graphics.Color;
        public static HSVtoRGB(
          _h: number,
          _s: number,
          _v: number,
          _targetColor: Packages.arc.graphics.Color,
        ): Packages.arc.graphics.Color;
        public static RGBtoHSV(
          _r: number,
          _g: number,
          _b: number,
        ): number[] | null;
        public static RGBtoHSV(
          _c: Packages.arc.graphics.Color,
        ): number[] | null;
        private static clampf(_value: number): number;
        public static toFloatBits(
          _r: number,
          _g: number,
          _b: number,
          _a: number,
        ): number;
        public toFloatBits(): number;
        public static toFloatBits(
          _r: number,
          _g: number,
          _b: number,
          _a: number,
        ): number;
        public fromDouble(
          _value: number,
        ): Packages.arc.graphics.Color;
        public argb8888(
          _value: number,
        ): Packages.arc.graphics.Color;
        public argb8888(): number;
        public static argb8888(
          _a: number,
          _r: number,
          _g: number,
          _b: number,
        ): number;
        public static packRgba(
          _r: number,
          _g: number,
          _b: number,
          _a: number,
        ): number;
        public abgr8888(
          _value: number,
        ): Packages.arc.graphics.Color;
        public static grays(
          _value: number,
        ): Packages.arc.graphics.Color;
        public static rgb(
          _r: number,
          _g: number,
          _b: number,
        ): Packages.arc.graphics.Color;
        public randHue(): Packages.arc.graphics.Color;
        public mula(
          _value: number,
        ): Packages.arc.graphics.Color;
        public mulA(
          _a: number,
        ): Packages.arc.graphics.Color;
        public premultiplyAlpha(): Packages.arc.graphics.Color;
        public shiftHue(
          _amount: number,
        ): Packages.arc.graphics.Color;
        public shiftSaturation(
          _amount: number,
        ): Packages.arc.graphics.Color;
        public shiftValue(
          _amount: number,
        ): Packages.arc.graphics.Color;
        public static ri(_rgba: number): number;
        public static gi(_rgba: number): number;
        public static ai(_rgba: number): number;
        public static muli(
          _rgba: number,
          _value: number,
        ): number;
        public static muli(
          _ca: number,
          _cb: number,
        ): number;
        public constructor(
          _color: Packages.arc.graphics.Color,
        );
        public constructor(
          _r: number,
          _g: number,
          _b: number,
        );
        public constructor(
          _r: number,
          _g: number,
          _b: number,
          _a: number,
        );
        public constructor(_rgba8888: number);
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class Intc2 {
        public get(_x: number, _y: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace g2d {
        declare class PixmapRegion extends java.lang
          .Object {
          public pixmap: Packages.arc.graphics.Pixmap;
          public x: number;
          public y: number;
          public width: number;
          public height: number;
          public get(
            _x: number,
            _y: number,
            _color: Packages.arc.graphics.Color,
          ): number;
          public get(_x: number, _y: number): number;
          public set(
            _pixmap: Packages.arc.graphics.Pixmap,
          ): Packages.arc.graphics.g2d.PixmapRegion;
          public set(
            _pixmap: Packages.arc.graphics.Pixmap,
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          ): Packages.arc.graphics.g2d.PixmapRegion;
          public getRaw(_x: number, _y: number): number;
          public getA(_x: number, _y: number): number;
          public crop(): Packages.arc.graphics.Pixmap;
          public crop(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          ): Packages.arc.graphics.Pixmap;
          public constructor(
            _pixmap: Packages.arc.graphics.Pixmap,
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          );
          public constructor(
            _pixmap: Packages.arc.graphics.Pixmap,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare class Pixmap
        extends java.lang.Object
        implements Packages.arc.util.Disposable
      {
        public static Format = class extends Packages.java
          .lang.Enum<Packages.arc.graphics.Pixmap.Format> {
          public static alpha: Packages.arc.graphics.Pixmap.Format;
          public static intensity: Packages.arc.graphics.Pixmap.Format;
          public static luminanceAlpha: Packages.arc.graphics.Pixmap.Format;
          public static rgb565: Packages.arc.graphics.Pixmap.Format;
          public static rgba4444: Packages.arc.graphics.Pixmap.Format;
          public static rgb888: Packages.arc.graphics.Pixmap.Format;
          public static rgba8888: Packages.arc.graphics.Pixmap.Format;
          public static all: Packages.arc.graphics.Pixmap.Format[];
          public glFormat: number;
          public glType: number;
          private static $VALUES: Packages.arc.graphics.Pixmap.Format[];
          public static values():
            | Packages.arc.graphics.Pixmap.Format[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.arc.graphics.Pixmap.Format;
        };
        public width: number;
        public height: number;
        public pixels: Packages.java.nio.ByteBuffer;
        handle: Packages.long;
        public static totalTime: number;
        public get(_x: number, _y: number): number;
        public toString(): string;
        private load(_width: number, _height: number): void;
        private load(
          _encodedData: string[],
          _offset: number,
          _len: number,
          _file: string,
        ): void;
        public static blend(
          _src: number,
          _dst: number,
        ): number;
        public replace(
          _func: Packages.arc.func.IntIntf,
        ): void;
        public fill(_color: number): void;
        public fill(
          _color: Packages.arc.graphics.Color,
        ): void;
        public static empty(_i: number): boolean;
        public empty(_x: number, _y: number): boolean;
        public set(
          _x: number,
          _y: number,
          _color: Packages.arc.graphics.Color,
        ): void;
        public set(
          _x: number,
          _y: number,
          _color: number,
        ): void;
        public in(_x: number, _y: number): boolean;
        public copy(): Packages.arc.graphics.Pixmap;
        public each(_cons: Packages.arc.func.Intc2): void;
        static free(_buffer: Packages.long): void;
        public dispose(): void;
        public isDisposed(): boolean;
        public getRaw(_x: number, _y: number): number;
        public setRaw(
          _x: number,
          _y: number,
          _color: number,
        ): void;
        public draw(
          _pixmap: Packages.arc.graphics.Pixmap,
          _x: number,
          _y: number,
          _width: number,
          _height: number,
          _filter: boolean,
        ): void;
        public draw(
          _pixmap: Packages.arc.graphics.Pixmap,
          _srcx: number,
          _srcy: number,
          _srcWidth: number,
          _srcHeight: number,
          _dstx: number,
          _dsty: number,
          _dstWidth: number,
          _dstHeight: number,
        ): void;
        public draw(
          _pixmap: Packages.arc.graphics.Pixmap,
          _srcx: number,
          _srcy: number,
          _srcWidth: number,
          _srcHeight: number,
          _dstx: number,
          _dsty: number,
          _dstWidth: number,
          _dstHeight: number,
          _filtering: boolean,
        ): void;
        public draw(
          _pixmap: Packages.arc.graphics.Pixmap,
          _srcx: number,
          _srcy: number,
          _srcWidth: number,
          _srcHeight: number,
          _dstx: number,
          _dsty: number,
          _dstWidth: number,
          _dstHeight: number,
          _filtering: boolean,
          _blending: boolean,
        ): void;
        public draw(
          _pixmap: Packages.arc.graphics.Pixmap,
          _x: number,
          _y: number,
          _srcx: number,
          _srcy: number,
          _srcWidth: number,
          _srcHeight: number,
        ): void;
        public draw(
          _region: Packages.arc.graphics.g2d.PixmapRegion,
          _srcx: number,
          _srcy: number,
          _srcWidth: number,
          _srcHeight: number,
          _dstx: number,
          _dsty: number,
          _dstWidth: number,
          _dstHeight: number,
        ): void;
        public draw(
          _region: Packages.arc.graphics.g2d.PixmapRegion,
          _x: number,
          _y: number,
          _srcx: number,
          _srcy: number,
          _srcWidth: number,
          _srcHeight: number,
        ): void;
        public draw(
          _region: Packages.arc.graphics.g2d.PixmapRegion,
          _x: number,
          _y: number,
          _width: number,
          _height: number,
        ): void;
        public draw(
          _region: Packages.arc.graphics.g2d.PixmapRegion,
          _x: number,
          _y: number,
        ): void;
        public draw(
          _region: Packages.arc.graphics.g2d.PixmapRegion,
          _blend: boolean,
        ): void;
        public draw(
          _region: Packages.arc.graphics.g2d.PixmapRegion,
        ): void;
        public draw(
          _pixmap: Packages.arc.graphics.Pixmap,
          _x: number,
          _y: number,
        ): void;
        public draw(
          _pixmap: Packages.arc.graphics.Pixmap,
          _x: number,
          _y: number,
          _width: number,
          _height: number,
        ): void;
        public draw(
          _pixmap: Packages.arc.graphics.Pixmap,
        ): void;
        public draw(
          _pixmap: Packages.arc.graphics.Pixmap,
          _blend: boolean,
        ): void;
        public draw(
          _pixmap: Packages.arc.graphics.Pixmap,
          _x: number,
          _y: number,
          _blending: boolean,
        ): void;
        public outline(
          _color: number,
          _radius: number,
        ): Packages.arc.graphics.Pixmap;
        public outline(
          _color: Packages.arc.graphics.Color,
          _radius: number,
        ): Packages.arc.graphics.Pixmap;
        public getA(_x: number, _y: number): number;
        hline(
          _x1: number,
          _x2: number,
          _y: number,
          _color: number,
        ): void;
        vline(
          _y1: number,
          _y2: number,
          _x: number,
          _color: number,
        ): void;
        circlePoints(
          _cx: number,
          _cy: number,
          _x: number,
          _y: number,
          _col: number,
        ): void;
        static loadJni(
          _nativeData: Packages.long[],
          _buffer: string[],
          _offset: number,
          _len: number,
        ): Packages.java.nio.ByteBuffer;
        static getFailureReason(): string;
        private loadJava(
          _encodedData: string[],
          _offset: number,
          _len: number,
          _file: string,
        ): void;
        static createJni(
          _nativeData: Packages.long[],
          _width: number,
          _height: number,
        ): Packages.java.nio.ByteBuffer;
        public crop(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
        ): Packages.arc.graphics.Pixmap;
        public flipY(): Packages.arc.graphics.Pixmap;
        public flipX(): Packages.arc.graphics.Pixmap;
        public drawLine(
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
          _color: number,
        ): void;
        public drawRect(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
          _color: number,
        ): void;
        public drawCircle(
          _x: number,
          _y: number,
          _radius: number,
          _col: number,
        ): void;
        public fillRect(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
          _color: number,
        ): void;
        public fillCircle(
          _x: number,
          _y: number,
          _radius: number,
          _color: number,
        ): void;
        public getWidth(): number;
        public getHeight(): number;
        public getGLFormat(): number;
        public getGLInternalFormat(): number;
        public getGLType(): number;
        public getPixels(): Packages.java.nio.ByteBuffer;
        public constructor(
          _buffer: Packages.java.nio.ByteBuffer,
          _width: number,
          _height: number,
        );
        public constructor(_file: Packages.arc.files.Fi);
        public constructor(_file: string);
        public constructor(_width: number, _height: number);
        public constructor(_encodedData: string[]);
        public constructor(
          _encodedData: string[],
          _offset: number,
          _len: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace io {
      declare class ByteArrayInputStream {}
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace files {
      declare class Fi extends java.lang.Object {
        public name(): string;
        public parent(): Packages.arc.files.Fi;
        public static get(
          _path: string,
        ): Packages.arc.files.Fi;
        public type(): Packages.arc.Files.FileType;
        public equals(_obj: any): boolean;
        public length(): Packages.long;
        public toString(): string;
        public hashCode(): number;
        public map(
          _mode: Packages.java.nio.channels.FileChannel.MapMode,
        ): Packages.java.nio.ByteBuffer;
        public map(): Packages.java.nio.ByteBuffer;
        public list(
          _filter: Packages.java.io.FileFilter,
        ): Packages.arc.files.Fi[] | null;
        public list(
          _suffix: string,
        ): Packages.arc.files.Fi[] | null;
        public list(
          _filter: Packages.java.io.FilenameFilter,
        ): Packages.arc.files.Fi[] | null;
        public list(): Packages.arc.files.Fi[] | null;
        public file(): Packages.java.io.File;
        public write(
          _append: boolean,
        ): Packages.java.io.OutputStream;
        public write(
          _input: Packages.java.io.InputStream,
          _append: boolean,
        ): void;
        public write(): Packages.java.io.OutputStream;
        public write(
          _append: boolean,
          _bufferSize: number,
        ): Packages.java.io.OutputStream;
        public read(): Packages.java.io.InputStream;
        public read(
          _bufferSize: number,
        ): Packages.java.io.BufferedInputStream;
        public delete(): boolean;
        public reader(): Packages.java.io.Reader;
        public reader(
          _bufferSize: number,
          _charset: string,
        ): Packages.java.io.BufferedReader;
        public reader(
          _bufferSize: number,
        ): Packages.java.io.BufferedReader;
        public reader(
          _charset: string,
        ): Packages.java.io.Reader;
        public writer(
          _append: boolean,
        ): Packages.java.io.Writer;
        public writer(
          _append: boolean,
          _charset: string,
        ): Packages.java.io.Writer;
        public reads(): Packages.arc.util.io.Reads;
        public seq(): Packages.arc.struct.Seq<Packages.arc.files.Fi>;
        public path(): string;
        public walk(
          _cons: Packages.arc.func.Cons<Packages.arc.files.Fi>,
        ): void;
        public exists(): boolean;
        public readBytes(): string[] | null;
        public readBytes(
          _bytes: string[],
          _offset: number,
          _size: number,
        ): number;
        public writeBytes(
          _bytes: string[],
          _offset: number,
          _length: number,
          _append: boolean,
        ): void;
        public writeBytes(_bytes: string[]): void;
        public writeBytes(
          _bytes: string[],
          _append: boolean,
        ): void;
        public findAll(
          _test: Packages.arc.func.Boolf<Packages.arc.files.Fi>,
        ): Packages.arc.struct.Seq<Packages.arc.files.Fi>;
        public findAll(): Packages.arc.struct.Seq<Packages.arc.files.Fi>;
        public isDirectory(): boolean;
        public mkdirs(): boolean;
        public child(_name: string): Packages.arc.files.Fi;
        public lastModified(): Packages.long;
        public readString(_charset: string): string;
        public readString(): string;
        public writeString(_string: string): void;
        public writeString(
          _string: string,
          _append: boolean,
          _charset: string,
        ): void;
        public writeString(
          _string: string,
          _append: boolean,
        ): void;
        public extension(): string;
        public emptyDirectory(): void;
        public emptyDirectory(_preserveTree: boolean): void;
        private static emptyDirectory(
          _file: Packages.java.io.File,
          _preserveTree: boolean,
        ): void;
        private static deleteDirectory(
          _file: Packages.java.io.File,
        ): boolean;
        public deleteDirectory(): boolean;
        private static copyDirectory(
          _sourceDir: Packages.arc.files.Fi,
          _destDir: Packages.arc.files.Fi,
        ): void;
        private static copyFile(
          _source: Packages.arc.files.Fi,
          _dest: Packages.arc.files.Fi,
        ): void;
        private estimateLength(): number;
        public writes(
          _append: boolean,
        ): Packages.arc.util.io.Writes;
        public writes(): Packages.arc.util.io.Writes;
        public writePng(
          _pixmap: Packages.arc.graphics.Pixmap,
        ): void;
        public copyTo(_dest: Packages.arc.files.Fi): void;
        public static tempFile(
          _prefix: string,
        ): Packages.arc.files.Fi;
        public static tempDirectory(
          _prefix: string,
        ): Packages.arc.files.Fi;
        public absolutePath(): string;
        public extEquals(_ext: string): boolean;
        public nameWithoutExtension(): string;
        public pathWithoutExtension(): string;
        public readByteStream(): Packages.java.io.ByteArrayInputStream;
        public writesDeflate(): Packages.arc.util.io.Writes;
        public readsDeflate(): Packages.arc.util.io.Reads;
        public sibling(
          _name: string,
        ): Packages.arc.files.Fi;
        public copyFilesTo(
          _dest: Packages.arc.files.Fi,
        ): void;
        public moveTo(_dest: Packages.arc.files.Fi): void;
        public constructor(
          _fileName: string,
          _type: Packages.arc.Files.FileType,
        );
        public constructor(_file: Packages.java.io.File);
        public constructor(_fileName: string);
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare abstract class ApplicationListener {
      public exit(): void;
      public update(): void;
      public init(): void;
      public resume(): void;
      public resize(_width: number, _height: number): void;
      public dispose(): void;
      public pause(): void;
      public fileDropped(
        _file: Packages.arc.files.Fi,
      ): void;
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace net {
      declare class InetSocketAddress {}
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare abstract class Application
      implements Packages.arc.util.Disposable
    {
      public static ApplicationType = class extends Packages
        .java.lang
        .Enum<Packages.arc.Application.ApplicationType> {
        public static android: Packages.arc.Application.ApplicationType;
        public static desktop: Packages.arc.Application.ApplicationType;
        public static headless: Packages.arc.Application.ApplicationType;
        public static web: Packages.arc.Application.ApplicationType;
        public static iOS: Packages.arc.Application.ApplicationType;
        private static $VALUES: Packages.arc.Application.ApplicationType[];
        public static values():
          | Packages.arc.Application.ApplicationType[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.arc.Application.ApplicationType;
      };
      public exit(): void;
      public getType(): Packages.arc.Application.ApplicationType;
      public post(
        _runnable: Packages.java.lang.Runnable,
      ): void;
      public getVersion(): number;
      public dispose(): void;
      public getListeners(): Packages.arc.struct.Seq<Packages.arc.ApplicationListener>;
      public isAndroid(): boolean;
      public isIOS(): boolean;
      public addListener(
        _listener: Packages.arc.ApplicationListener,
      ): void;
      public removeListener(
        _listener: Packages.arc.ApplicationListener,
      ): void;
      public defaultUpdate(): void;
      public isDesktop(): boolean;
      public isHeadless(): boolean;
      public isMobile(): boolean;
      public isWeb(): boolean;
      public getJavaHeap(): Packages.long;
      public getNativeHeap(): Packages.long;
      public getClipboardText(): string | null;
      public setClipboardText(_text: string): void;
      public openFolder(_file: string): boolean;
      public openURI(_URI: string): boolean;
      public getDnsServers(
        _out: Packages.arc.struct.Seq<Packages.java.net.InetSocketAddress>,
      ): void;
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare abstract class ApplicationCore
      extends java.lang.Object
      implements Packages.arc.ApplicationListener
    {
      protected modules: Packages.arc.ApplicationListener[];
      public add(
        _module: Packages.arc.ApplicationListener,
      ): void;
      public update(): void;
      public init(): void;
      public setup(): void;
      public resume(): void;
      public resize(_width: number, _height: number): void;
      public dispose(): void;
      public pause(): void;
      public fileDropped(
        _file: Packages.arc.files.Fi,
      ): void;
      public constructor();
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace nio {
      declare abstract class Buffer {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace nio {
      declare abstract class IntBuffer {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace nio {
      declare abstract class FloatBuffer {}
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare abstract class GL20 {
        public static GL_ES_VERSION_2_0: number;
        public static GL_DEPTH_BUFFER_BIT: number;
        public static GL_STENCIL_BUFFER_BIT: number;
        public static GL_COLOR_BUFFER_BIT: number;
        public static GL_FALSE: number;
        public static GL_TRUE: number;
        public static GL_POINTS: number;
        public static GL_LINES: number;
        public static GL_LINE_LOOP: number;
        public static GL_LINE_STRIP: number;
        public static GL_TRIANGLES: number;
        public static GL_TRIANGLE_STRIP: number;
        public static GL_TRIANGLE_FAN: number;
        public static GL_ZERO: number;
        public static GL_ONE: number;
        public static GL_SRC_COLOR: number;
        public static GL_ONE_MINUS_SRC_COLOR: number;
        public static GL_SRC_ALPHA: number;
        public static GL_ONE_MINUS_SRC_ALPHA: number;
        public static GL_DST_ALPHA: number;
        public static GL_ONE_MINUS_DST_ALPHA: number;
        public static GL_DST_COLOR: number;
        public static GL_ONE_MINUS_DST_COLOR: number;
        public static GL_SRC_ALPHA_SATURATE: number;
        public static GL_FUNC_ADD: number;
        public static GL_BLEND_EQUATION: number;
        public static GL_BLEND_EQUATION_RGB: number;
        public static GL_BLEND_EQUATION_ALPHA: number;
        public static GL_FUNC_SUBTRACT: number;
        public static GL_FUNC_REVERSE_SUBTRACT: number;
        public static GL_BLEND_DST_RGB: number;
        public static GL_BLEND_SRC_RGB: number;
        public static GL_BLEND_DST_ALPHA: number;
        public static GL_BLEND_SRC_ALPHA: number;
        public static GL_CONSTANT_COLOR: number;
        public static GL_ONE_MINUS_CONSTANT_COLOR: number;
        public static GL_CONSTANT_ALPHA: number;
        public static GL_ONE_MINUS_CONSTANT_ALPHA: number;
        public static GL_BLEND_COLOR: number;
        public static GL_ARRAY_BUFFER: number;
        public static GL_ELEMENT_ARRAY_BUFFER: number;
        public static GL_ARRAY_BUFFER_BINDING: number;
        public static GL_ELEMENT_ARRAY_BUFFER_BINDING: number;
        public static GL_STREAM_DRAW: number;
        public static GL_STATIC_DRAW: number;
        public static GL_DYNAMIC_DRAW: number;
        public static GL_BUFFER_SIZE: number;
        public static GL_BUFFER_USAGE: number;
        public static GL_CURRENT_VERTEX_ATTRIB: number;
        public static GL_FRONT: number;
        public static GL_BACK: number;
        public static GL_FRONT_AND_BACK: number;
        public static GL_TEXTURE_2D: number;
        public static GL_CULL_FACE: number;
        public static GL_BLEND: number;
        public static GL_DITHER: number;
        public static GL_STENCIL_TEST: number;
        public static GL_DEPTH_TEST: number;
        public static GL_SCISSOR_TEST: number;
        public static GL_POLYGON_OFFSET_FILL: number;
        public static GL_SAMPLE_ALPHA_TO_COVERAGE: number;
        public static GL_SAMPLE_COVERAGE: number;
        public static GL_NO_ERROR: number;
        public static GL_INVALID_ENUM: number;
        public static GL_INVALID_VALUE: number;
        public static GL_INVALID_OPERATION: number;
        public static GL_OUT_OF_MEMORY: number;
        public static GL_CW: number;
        public static GL_CCW: number;
        public static GL_LINE_WIDTH: number;
        public static GL_ALIASED_POINT_SIZE_RANGE: number;
        public static GL_ALIASED_LINE_WIDTH_RANGE: number;
        public static GL_CULL_FACE_MODE: number;
        public static GL_FRONT_FACE: number;
        public static GL_DEPTH_RANGE: number;
        public static GL_DEPTH_WRITEMASK: number;
        public static GL_DEPTH_CLEAR_VALUE: number;
        public static GL_DEPTH_FUNC: number;
        public static GL_STENCIL_CLEAR_VALUE: number;
        public static GL_STENCIL_FUNC: number;
        public static GL_STENCIL_FAIL: number;
        public static GL_STENCIL_PASS_DEPTH_FAIL: number;
        public static GL_STENCIL_PASS_DEPTH_PASS: number;
        public static GL_STENCIL_REF: number;
        public static GL_STENCIL_VALUE_MASK: number;
        public static GL_STENCIL_WRITEMASK: number;
        public static GL_STENCIL_BACK_FUNC: number;
        public static GL_STENCIL_BACK_FAIL: number;
        public static GL_STENCIL_BACK_PASS_DEPTH_FAIL: number;
        public static GL_STENCIL_BACK_PASS_DEPTH_PASS: number;
        public static GL_STENCIL_BACK_REF: number;
        public static GL_STENCIL_BACK_VALUE_MASK: number;
        public static GL_STENCIL_BACK_WRITEMASK: number;
        public static GL_VIEWPORT: number;
        public static GL_SCISSOR_BOX: number;
        public static GL_COLOR_CLEAR_VALUE: number;
        public static GL_COLOR_WRITEMASK: number;
        public static GL_UNPACK_ALIGNMENT: number;
        public static GL_PACK_ALIGNMENT: number;
        public static GL_MAX_TEXTURE_SIZE: number;
        public static GL_MAX_TEXTURE_UNITS: number;
        public static GL_MAX_VIEWPORT_DIMS: number;
        public static GL_SUBPIXEL_BITS: number;
        public static GL_RED_BITS: number;
        public static GL_GREEN_BITS: number;
        public static GL_BLUE_BITS: number;
        public static GL_ALPHA_BITS: number;
        public static GL_DEPTH_BITS: number;
        public static GL_STENCIL_BITS: number;
        public static GL_POLYGON_OFFSET_UNITS: number;
        public static GL_POLYGON_OFFSET_FACTOR: number;
        public static GL_TEXTURE_BINDING_2D: number;
        public static GL_SAMPLE_BUFFERS: number;
        public static GL_SAMPLES: number;
        public static GL_SAMPLE_COVERAGE_VALUE: number;
        public static GL_SAMPLE_COVERAGE_INVERT: number;
        public static GL_NUM_COMPRESSED_TEXTURE_FORMATS: number;
        public static GL_COMPRESSED_TEXTURE_FORMATS: number;
        public static GL_DONT_CARE: number;
        public static GL_FASTEST: number;
        public static GL_NICEST: number;
        public static GL_GENERATE_MIPMAP: number;
        public static GL_GENERATE_MIPMAP_HINT: number;
        public static GL_BYTE: number;
        public static GL_UNSIGNED_BYTE: number;
        public static GL_SHORT: number;
        public static GL_UNSIGNED_SHORT: number;
        public static GL_INT: number;
        public static GL_UNSIGNED_INT: number;
        public static GL_FLOAT: number;
        public static GL_FIXED: number;
        public static GL_DEPTH_COMPONENT: number;
        public static GL_ALPHA: number;
        public static GL_RGB: number;
        public static GL_RGBA: number;
        public static GL_LUMINANCE: number;
        public static GL_LUMINANCE_ALPHA: number;
        public static GL_UNSIGNED_SHORT_4_4_4_4: number;
        public static GL_UNSIGNED_SHORT_5_5_5_1: number;
        public static GL_UNSIGNED_SHORT_5_6_5: number;
        public static GL_FRAGMENT_SHADER: number;
        public static GL_VERTEX_SHADER: number;
        public static GL_MAX_VERTEX_ATTRIBS: number;
        public static GL_MAX_VERTEX_UNIFORM_VECTORS: number;
        public static GL_MAX_VARYING_VECTORS: number;
        public static GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS: number;
        public static GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS: number;
        public static GL_MAX_TEXTURE_IMAGE_UNITS: number;
        public static GL_MAX_FRAGMENT_UNIFORM_VECTORS: number;
        public static GL_SHADER_TYPE: number;
        public static GL_DELETE_STATUS: number;
        public static GL_LINK_STATUS: number;
        public static GL_VALIDATE_STATUS: number;
        public static GL_ATTACHED_SHADERS: number;
        public static GL_ACTIVE_UNIFORMS: number;
        public static GL_ACTIVE_UNIFORM_MAX_LENGTH: number;
        public static GL_ACTIVE_ATTRIBUTES: number;
        public static GL_ACTIVE_ATTRIBUTE_MAX_LENGTH: number;
        public static GL_SHADING_LANGUAGE_VERSION: number;
        public static GL_CURRENT_PROGRAM: number;
        public static GL_NEVER: number;
        public static GL_LESS: number;
        public static GL_EQUAL: number;
        public static GL_LEQUAL: number;
        public static GL_GREATER: number;
        public static GL_NOTEQUAL: number;
        public static GL_GEQUAL: number;
        public static GL_ALWAYS: number;
        public static GL_KEEP: number;
        public static GL_REPLACE: number;
        public static GL_INCR: number;
        public static GL_DECR: number;
        public static GL_INVERT: number;
        public static GL_INCR_WRAP: number;
        public static GL_DECR_WRAP: number;
        public static GL_VENDOR: number;
        public static GL_RENDERER: number;
        public static GL_VERSION: number;
        public static GL_EXTENSIONS: number;
        public static GL_NEAREST: number;
        public static GL_LINEAR: number;
        public static GL_NEAREST_MIPMAP_NEAREST: number;
        public static GL_LINEAR_MIPMAP_NEAREST: number;
        public static GL_NEAREST_MIPMAP_LINEAR: number;
        public static GL_LINEAR_MIPMAP_LINEAR: number;
        public static GL_TEXTURE_MAG_FILTER: number;
        public static GL_TEXTURE_MIN_FILTER: number;
        public static GL_TEXTURE_WRAP_S: number;
        public static GL_TEXTURE_WRAP_T: number;
        public static GL_TEXTURE: number;
        public static GL_TEXTURE_CUBE_MAP: number;
        public static GL_TEXTURE_BINDING_CUBE_MAP: number;
        public static GL_TEXTURE_CUBE_MAP_POSITIVE_X: number;
        public static GL_TEXTURE_CUBE_MAP_NEGATIVE_X: number;
        public static GL_TEXTURE_CUBE_MAP_POSITIVE_Y: number;
        public static GL_TEXTURE_CUBE_MAP_NEGATIVE_Y: number;
        public static GL_TEXTURE_CUBE_MAP_POSITIVE_Z: number;
        public static GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: number;
        public static GL_MAX_CUBE_MAP_TEXTURE_SIZE: number;
        public static GL_TEXTURE0: number;
        public static GL_TEXTURE1: number;
        public static GL_TEXTURE2: number;
        public static GL_TEXTURE3: number;
        public static GL_TEXTURE4: number;
        public static GL_TEXTURE5: number;
        public static GL_TEXTURE6: number;
        public static GL_TEXTURE7: number;
        public static GL_TEXTURE8: number;
        public static GL_TEXTURE9: number;
        public static GL_TEXTURE10: number;
        public static GL_TEXTURE11: number;
        public static GL_TEXTURE12: number;
        public static GL_TEXTURE13: number;
        public static GL_TEXTURE14: number;
        public static GL_TEXTURE15: number;
        public static GL_TEXTURE16: number;
        public static GL_TEXTURE17: number;
        public static GL_TEXTURE18: number;
        public static GL_TEXTURE19: number;
        public static GL_TEXTURE20: number;
        public static GL_TEXTURE21: number;
        public static GL_TEXTURE22: number;
        public static GL_TEXTURE23: number;
        public static GL_TEXTURE24: number;
        public static GL_TEXTURE25: number;
        public static GL_TEXTURE26: number;
        public static GL_TEXTURE27: number;
        public static GL_TEXTURE28: number;
        public static GL_TEXTURE29: number;
        public static GL_TEXTURE30: number;
        public static GL_TEXTURE31: number;
        public static GL_ACTIVE_TEXTURE: number;
        public static GL_REPEAT: number;
        public static GL_CLAMP_TO_EDGE: number;
        public static GL_MIRRORED_REPEAT: number;
        public static GL_FLOAT_VEC2: number;
        public static GL_FLOAT_VEC3: number;
        public static GL_FLOAT_VEC4: number;
        public static GL_INT_VEC2: number;
        public static GL_INT_VEC3: number;
        public static GL_INT_VEC4: number;
        public static GL_BOOL: number;
        public static GL_BOOL_VEC2: number;
        public static GL_BOOL_VEC3: number;
        public static GL_BOOL_VEC4: number;
        public static GL_FLOAT_MAT2: number;
        public static GL_FLOAT_MAT3: number;
        public static GL_FLOAT_MAT4: number;
        public static GL_SAMPLER_2D: number;
        public static GL_SAMPLER_CUBE: number;
        public static GL_VERTEX_ATTRIB_ARRAY_ENABLED: number;
        public static GL_VERTEX_ATTRIB_ARRAY_SIZE: number;
        public static GL_VERTEX_ATTRIB_ARRAY_STRIDE: number;
        public static GL_VERTEX_ATTRIB_ARRAY_TYPE: number;
        public static GL_VERTEX_ATTRIB_ARRAY_NORMALIZED: number;
        public static GL_VERTEX_ATTRIB_ARRAY_POINTER: number;
        public static GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: number;
        public static GL_IMPLEMENTATION_COLOR_READ_TYPE: number;
        public static GL_IMPLEMENTATION_COLOR_READ_FORMAT: number;
        public static GL_COMPILE_STATUS: number;
        public static GL_INFO_LOG_LENGTH: number;
        public static GL_SHADER_SOURCE_LENGTH: number;
        public static GL_SHADER_COMPILER: number;
        public static GL_SHADER_BINARY_FORMATS: number;
        public static GL_NUM_SHADER_BINARY_FORMATS: number;
        public static GL_LOW_FLOAT: number;
        public static GL_MEDIUM_FLOAT: number;
        public static GL_HIGH_FLOAT: number;
        public static GL_LOW_INT: number;
        public static GL_MEDIUM_INT: number;
        public static GL_HIGH_INT: number;
        public static GL_FRAMEBUFFER: number;
        public static GL_RENDERBUFFER: number;
        public static GL_RGBA4: number;
        public static GL_RGB5_A1: number;
        public static GL_RGB565: number;
        public static GL_DEPTH_COMPONENT16: number;
        public static GL_STENCIL_INDEX: number;
        public static GL_STENCIL_INDEX8: number;
        public static GL_RENDERBUFFER_WIDTH: number;
        public static GL_RENDERBUFFER_HEIGHT: number;
        public static GL_RENDERBUFFER_INTERNAL_FORMAT: number;
        public static GL_RENDERBUFFER_RED_SIZE: number;
        public static GL_RENDERBUFFER_GREEN_SIZE: number;
        public static GL_RENDERBUFFER_BLUE_SIZE: number;
        public static GL_RENDERBUFFER_ALPHA_SIZE: number;
        public static GL_RENDERBUFFER_DEPTH_SIZE: number;
        public static GL_RENDERBUFFER_STENCIL_SIZE: number;
        public static GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: number;
        public static GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: number;
        public static GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: number;
        public static GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: number;
        public static GL_COLOR_ATTACHMENT0: number;
        public static GL_DEPTH_ATTACHMENT: number;
        public static GL_STENCIL_ATTACHMENT: number;
        public static GL_NONE: number;
        public static GL_FRAMEBUFFER_COMPLETE: number;
        public static GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT: number;
        public static GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: number;
        public static GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS: number;
        public static GL_FRAMEBUFFER_UNSUPPORTED: number;
        public static GL_FRAMEBUFFER_BINDING: number;
        public static GL_RENDERBUFFER_BINDING: number;
        public static GL_MAX_RENDERBUFFER_SIZE: number;
        public static GL_INVALID_FRAMEBUFFER_OPERATION: number;
        public static GL_VERTEX_PROGRAM_POINT_SIZE: number;
        public static GL_COVERAGE_BUFFER_BIT_NV: number;
        public static GL_TEXTURE_MAX_ANISOTROPY_EXT: number;
        public static GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT: number;
        public glActiveTexture(_texture: number): void;
        public glBindTexture(
          _target: number,
          _texture: number,
        ): void;
        public glBlendFunc(
          _sfactor: number,
          _dfactor: number,
        ): void;
        public glClear(_mask: number): void;
        public glClearColor(
          _red: number,
          _green: number,
          _blue: number,
          _alpha: number,
        ): void;
        public glClearDepthf(_depth: number): void;
        public glClearStencil(_s: number): void;
        public glColorMask(
          _red: boolean,
          _green: boolean,
          _blue: boolean,
          _alpha: boolean,
        ): void;
        public glCompressedTexImage2D(
          _target: number,
          _level: number,
          _internalformat: number,
          _width: number,
          _height: number,
          _border: number,
          _imageSize: number,
          _data: Packages.java.nio.Buffer,
        ): void;
        public glCompressedTexSubImage2D(
          _target: number,
          _level: number,
          _xoffset: number,
          _yoffset: number,
          _width: number,
          _height: number,
          _format: number,
          _imageSize: number,
          _data: Packages.java.nio.Buffer,
        ): void;
        public glCopyTexImage2D(
          _target: number,
          _level: number,
          _internalformat: number,
          _x: number,
          _y: number,
          _width: number,
          _height: number,
          _border: number,
        ): void;
        public glCopyTexSubImage2D(
          _target: number,
          _level: number,
          _xoffset: number,
          _yoffset: number,
          _x: number,
          _y: number,
          _width: number,
          _height: number,
        ): void;
        public glCullFace(_mode: number): void;
        public glDeleteTexture(_texture: number): void;
        public glDepthFunc(_func: number): void;
        public glDepthMask(_flag: boolean): void;
        public glDepthRangef(
          _zNear: number,
          _zFar: number,
        ): void;
        public glDisable(_cap: number): void;
        public glDrawArrays(
          _mode: number,
          _first: number,
          _count: number,
        ): void;
        public glDrawElements(
          _mode: number,
          _count: number,
          _type: number,
          _indices: number,
        ): void;
        public glDrawElements(
          _mode: number,
          _count: number,
          _type: number,
          _indices: Packages.java.nio.Buffer,
        ): void;
        public glEnable(_cap: number): void;
        public glFinish(): void;
        public glFlush(): void;
        public glFrontFace(_mode: number): void;
        public glGenTexture(): number;
        public glGetError(): number;
        public glGetIntegerv(
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glGetString(_name: number): string;
        public glHint(_target: number, _mode: number): void;
        public glLineWidth(_width: number): void;
        public glPixelStorei(
          _pname: number,
          _param: number,
        ): void;
        public glPolygonOffset(
          _factor: number,
          _units: number,
        ): void;
        public glReadPixels(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
          _format: number,
          _type: number,
          _pixels: Packages.java.nio.Buffer,
        ): void;
        public glScissor(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
        ): void;
        public glStencilFunc(
          _func: number,
          _ref: number,
          _mask: number,
        ): void;
        public glStencilMask(_mask: number): void;
        public glStencilOp(
          _fail: number,
          _zfail: number,
          _zpass: number,
        ): void;
        public glTexImage2D(
          _target: number,
          _level: number,
          _internalformat: number,
          _width: number,
          _height: number,
          _border: number,
          _format: number,
          _type: number,
          _pixels: Packages.java.nio.Buffer,
        ): void;
        public glTexParameterf(
          _target: number,
          _pname: number,
          _param: number,
        ): void;
        public glTexSubImage2D(
          _target: number,
          _level: number,
          _xoffset: number,
          _yoffset: number,
          _width: number,
          _height: number,
          _format: number,
          _type: number,
          _pixels: Packages.java.nio.Buffer,
        ): void;
        public glViewport(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
        ): void;
        public glAttachShader(
          _program: number,
          _shader: number,
        ): void;
        public glBindAttribLocation(
          _program: number,
          _index: number,
          _name: string,
        ): void;
        public glBindBuffer(
          _target: number,
          _buffer: number,
        ): void;
        public glBindFramebuffer(
          _target: number,
          _framebuffer: number,
        ): void;
        public glBindRenderbuffer(
          _target: number,
          _renderbuffer: number,
        ): void;
        public glBlendColor(
          _red: number,
          _green: number,
          _blue: number,
          _alpha: number,
        ): void;
        public glBlendEquation(_mode: number): void;
        public glBlendEquationSeparate(
          _modeRGB: number,
          _modeAlpha: number,
        ): void;
        public glBlendFuncSeparate(
          _srcRGB: number,
          _dstRGB: number,
          _srcAlpha: number,
          _dstAlpha: number,
        ): void;
        public glBufferData(
          _target: number,
          _size: number,
          _data: Packages.java.nio.Buffer,
          _usage: number,
        ): void;
        public glBufferSubData(
          _target: number,
          _offset: number,
          _size: number,
          _data: Packages.java.nio.Buffer,
        ): void;
        public glCheckFramebufferStatus(
          _target: number,
        ): number;
        public glCompileShader(_shader: number): void;
        public glCreateProgram(): number;
        public glCreateShader(_type: number): number;
        public glDeleteBuffer(_buffer: number): void;
        public glDeleteFramebuffer(
          _framebuffer: number,
        ): void;
        public glDeleteProgram(_program: number): void;
        public glDeleteRenderbuffer(
          _renderbuffer: number,
        ): void;
        public glDeleteShader(_shader: number): void;
        public glDetachShader(
          _program: number,
          _shader: number,
        ): void;
        public glDisableVertexAttribArray(
          _index: number,
        ): void;
        public glEnableVertexAttribArray(
          _index: number,
        ): void;
        public glFramebufferRenderbuffer(
          _target: number,
          _attachment: number,
          _renderbuffertarget: number,
          _renderbuffer: number,
        ): void;
        public glFramebufferTexture2D(
          _target: number,
          _attachment: number,
          _textarget: number,
          _texture: number,
          _level: number,
        ): void;
        public glGenBuffer(): number;
        public glGenerateMipmap(_target: number): void;
        public glGenFramebuffer(): number;
        public glGenRenderbuffer(): number;
        public glGetActiveAttrib(
          _program: number,
          _index: number,
          _size: Packages.java.nio.IntBuffer,
          _type: Packages.java.nio.IntBuffer,
        ): string;
        public glGetActiveUniform(
          _program: number,
          _index: number,
          _size: Packages.java.nio.IntBuffer,
          _type: Packages.java.nio.IntBuffer,
        ): string;
        public glGetAttribLocation(
          _program: number,
          _name: string,
        ): number;
        public glGetBooleanv(
          _pname: number,
          _params: Packages.java.nio.Buffer,
        ): void;
        public glGetBufferParameteriv(
          _target: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glGetFloatv(
          _pname: number,
          _params: Packages.java.nio.FloatBuffer,
        ): void;
        public glGetFramebufferAttachmentParameteriv(
          _target: number,
          _attachment: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glGetProgramiv(
          _program: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glGetProgramInfoLog(
          _program: number,
        ): string;
        public glGetRenderbufferParameteriv(
          _target: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glGetShaderiv(
          _shader: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glGetShaderInfoLog(_shader: number): string;
        public glGetShaderPrecisionFormat(
          _shadertype: number,
          _precisiontype: number,
          _range: Packages.java.nio.IntBuffer,
          _precision: Packages.java.nio.IntBuffer,
        ): void;
        public glGetTexParameterfv(
          _target: number,
          _pname: number,
          _params: Packages.java.nio.FloatBuffer,
        ): void;
        public glGetTexParameteriv(
          _target: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glGetUniformfv(
          _program: number,
          _location: number,
          _params: Packages.java.nio.FloatBuffer,
        ): void;
        public glGetUniformiv(
          _program: number,
          _location: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glGetUniformLocation(
          _program: number,
          _name: string,
        ): number;
        public glGetVertexAttribfv(
          _index: number,
          _pname: number,
          _params: Packages.java.nio.FloatBuffer,
        ): void;
        public glGetVertexAttribiv(
          _index: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glIsBuffer(_buffer: number): boolean;
        public glIsEnabled(_cap: number): boolean;
        public glIsFramebuffer(
          _framebuffer: number,
        ): boolean;
        public glIsProgram(_program: number): boolean;
        public glIsRenderbuffer(
          _renderbuffer: number,
        ): boolean;
        public glIsShader(_shader: number): boolean;
        public glIsTexture(_texture: number): boolean;
        public glLinkProgram(_program: number): void;
        public glReleaseShaderCompiler(): void;
        public glRenderbufferStorage(
          _target: number,
          _internalformat: number,
          _width: number,
          _height: number,
        ): void;
        public glSampleCoverage(
          _value: number,
          _invert: boolean,
        ): void;
        public glShaderSource(
          _shader: number,
          _string: string,
        ): void;
        public glStencilFuncSeparate(
          _face: number,
          _func: number,
          _ref: number,
          _mask: number,
        ): void;
        public glStencilMaskSeparate(
          _face: number,
          _mask: number,
        ): void;
        public glStencilOpSeparate(
          _face: number,
          _fail: number,
          _zfail: number,
          _zpass: number,
        ): void;
        public glTexParameterfv(
          _target: number,
          _pname: number,
          _params: Packages.java.nio.FloatBuffer,
        ): void;
        public glTexParameteri(
          _target: number,
          _pname: number,
          _param: number,
        ): void;
        public glTexParameteriv(
          _target: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glUniform1f(
          _location: number,
          _x: number,
        ): void;
        public glUniform1fv(
          _location: number,
          _count: number,
          _v: number[],
          _offset: number,
        ): void;
        public glUniform1fv(
          _location: number,
          _count: number,
          _v: Packages.java.nio.FloatBuffer,
        ): void;
        public glUniform1i(
          _location: number,
          _x: number,
        ): void;
        public glUniform1iv(
          _location: number,
          _count: number,
          _v: number[],
          _offset: number,
        ): void;
        public glUniform1iv(
          _location: number,
          _count: number,
          _v: Packages.java.nio.IntBuffer,
        ): void;
        public glUniform2f(
          _location: number,
          _x: number,
          _y: number,
        ): void;
        public glUniform2fv(
          _location: number,
          _count: number,
          _v: number[],
          _offset: number,
        ): void;
        public glUniform2fv(
          _location: number,
          _count: number,
          _v: Packages.java.nio.FloatBuffer,
        ): void;
        public glUniform2i(
          _location: number,
          _x: number,
          _y: number,
        ): void;
        public glUniform2iv(
          _location: number,
          _count: number,
          _v: Packages.java.nio.IntBuffer,
        ): void;
        public glUniform2iv(
          _location: number,
          _count: number,
          _v: number[],
          _offset: number,
        ): void;
        public glUniform3f(
          _location: number,
          _x: number,
          _y: number,
          _z: number,
        ): void;
        public glUniform3fv(
          _location: number,
          _count: number,
          _v: number[],
          _offset: number,
        ): void;
        public glUniform3fv(
          _location: number,
          _count: number,
          _v: Packages.java.nio.FloatBuffer,
        ): void;
        public glUniform3i(
          _location: number,
          _x: number,
          _y: number,
          _z: number,
        ): void;
        public glUniform3iv(
          _location: number,
          _count: number,
          _v: number[],
          _offset: number,
        ): void;
        public glUniform3iv(
          _location: number,
          _count: number,
          _v: Packages.java.nio.IntBuffer,
        ): void;
        public glUniform4f(
          _location: number,
          _x: number,
          _y: number,
          _z: number,
          _w: number,
        ): void;
        public glUniform4fv(
          _location: number,
          _count: number,
          _v: Packages.java.nio.FloatBuffer,
        ): void;
        public glUniform4fv(
          _location: number,
          _count: number,
          _v: number[],
          _offset: number,
        ): void;
        public glUniform4i(
          _location: number,
          _x: number,
          _y: number,
          _z: number,
          _w: number,
        ): void;
        public glUniform4iv(
          _location: number,
          _count: number,
          _v: number[],
          _offset: number,
        ): void;
        public glUniform4iv(
          _location: number,
          _count: number,
          _v: Packages.java.nio.IntBuffer,
        ): void;
        public glUniformMatrix2fv(
          _location: number,
          _count: number,
          _transpose: boolean,
          _value: number[],
          _offset: number,
        ): void;
        public glUniformMatrix2fv(
          _location: number,
          _count: number,
          _transpose: boolean,
          _value: Packages.java.nio.FloatBuffer,
        ): void;
        public glUniformMatrix3fv(
          _location: number,
          _count: number,
          _transpose: boolean,
          _value: number[],
          _offset: number,
        ): void;
        public glUniformMatrix3fv(
          _location: number,
          _count: number,
          _transpose: boolean,
          _value: Packages.java.nio.FloatBuffer,
        ): void;
        public glUniformMatrix4fv(
          _location: number,
          _count: number,
          _transpose: boolean,
          _value: number[],
          _offset: number,
        ): void;
        public glUniformMatrix4fv(
          _location: number,
          _count: number,
          _transpose: boolean,
          _value: Packages.java.nio.FloatBuffer,
        ): void;
        public glUseProgram(_program: number): void;
        public glValidateProgram(_program: number): void;
        public glVertexAttrib1f(
          _indx: number,
          _x: number,
        ): void;
        public glVertexAttrib1fv(
          _indx: number,
          _values: Packages.java.nio.FloatBuffer,
        ): void;
        public glVertexAttrib2f(
          _indx: number,
          _x: number,
          _y: number,
        ): void;
        public glVertexAttrib2fv(
          _indx: number,
          _values: Packages.java.nio.FloatBuffer,
        ): void;
        public glVertexAttrib3f(
          _indx: number,
          _x: number,
          _y: number,
          _z: number,
        ): void;
        public glVertexAttrib3fv(
          _indx: number,
          _values: Packages.java.nio.FloatBuffer,
        ): void;
        public glVertexAttrib4f(
          _indx: number,
          _x: number,
          _y: number,
          _z: number,
          _w: number,
        ): void;
        public glVertexAttrib4fv(
          _indx: number,
          _values: Packages.java.nio.FloatBuffer,
        ): void;
        public glVertexAttribPointer(
          _indx: number,
          _size: number,
          _type: number,
          _normalized: boolean,
          _stride: number,
          _ptr: number,
        ): void;
        public glVertexAttribPointer(
          _indx: number,
          _size: number,
          _type: number,
          _normalized: boolean,
          _stride: number,
          _ptr: Packages.java.nio.Buffer,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace nio {
      declare abstract class LongBuffer {}
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare abstract class GL30
        implements Packages.arc.graphics.GL20
      {
        public static GL_READ_BUFFER: number;
        public static GL_UNPACK_ROW_LENGTH: number;
        public static GL_UNPACK_SKIP_ROWS: number;
        public static GL_UNPACK_SKIP_PIXELS: number;
        public static GL_PACK_ROW_LENGTH: number;
        public static GL_PACK_SKIP_ROWS: number;
        public static GL_PACK_SKIP_PIXELS: number;
        public static GL_COLOR: number;
        public static GL_DEPTH: number;
        public static GL_STENCIL: number;
        public static GL_RED: number;
        public static GL_RGB8: number;
        public static GL_RGBA8: number;
        public static GL_RGB10_A2: number;
        public static GL_TEXTURE_BINDING_3D: number;
        public static GL_UNPACK_SKIP_IMAGES: number;
        public static GL_UNPACK_IMAGE_HEIGHT: number;
        public static GL_TEXTURE_3D: number;
        public static GL_TEXTURE_WRAP_R: number;
        public static GL_MAX_3D_TEXTURE_SIZE: number;
        public static GL_UNSIGNED_INT_2_10_10_10_REV: number;
        public static GL_MAX_ELEMENTS_VERTICES: number;
        public static GL_MAX_ELEMENTS_INDICES: number;
        public static GL_TEXTURE_MIN_LOD: number;
        public static GL_TEXTURE_MAX_LOD: number;
        public static GL_TEXTURE_BASE_LEVEL: number;
        public static GL_TEXTURE_MAX_LEVEL: number;
        public static GL_MIN: number;
        public static GL_MAX: number;
        public static GL_DEPTH_COMPONENT24: number;
        public static GL_MAX_TEXTURE_LOD_BIAS: number;
        public static GL_TEXTURE_COMPARE_MODE: number;
        public static GL_TEXTURE_COMPARE_FUNC: number;
        public static GL_CURRENT_QUERY: number;
        public static GL_QUERY_RESULT: number;
        public static GL_QUERY_RESULT_AVAILABLE: number;
        public static GL_BUFFER_MAPPED: number;
        public static GL_BUFFER_MAP_POINTER: number;
        public static GL_STREAM_READ: number;
        public static GL_STREAM_COPY: number;
        public static GL_STATIC_READ: number;
        public static GL_STATIC_COPY: number;
        public static GL_DYNAMIC_READ: number;
        public static GL_DYNAMIC_COPY: number;
        public static GL_MAX_DRAW_BUFFERS: number;
        public static GL_DRAW_BUFFER0: number;
        public static GL_DRAW_BUFFER1: number;
        public static GL_DRAW_BUFFER2: number;
        public static GL_DRAW_BUFFER3: number;
        public static GL_DRAW_BUFFER4: number;
        public static GL_DRAW_BUFFER5: number;
        public static GL_DRAW_BUFFER6: number;
        public static GL_DRAW_BUFFER7: number;
        public static GL_DRAW_BUFFER8: number;
        public static GL_DRAW_BUFFER9: number;
        public static GL_DRAW_BUFFER10: number;
        public static GL_DRAW_BUFFER11: number;
        public static GL_DRAW_BUFFER12: number;
        public static GL_DRAW_BUFFER13: number;
        public static GL_DRAW_BUFFER14: number;
        public static GL_DRAW_BUFFER15: number;
        public static GL_MAX_FRAGMENT_UNIFORM_COMPONENTS: number;
        public static GL_MAX_VERTEX_UNIFORM_COMPONENTS: number;
        public static GL_SAMPLER_3D: number;
        public static GL_SAMPLER_2D_SHADOW: number;
        public static GL_FRAGMENT_SHADER_DERIVATIVE_HINT: number;
        public static GL_PIXEL_PACK_BUFFER: number;
        public static GL_PIXEL_UNPACK_BUFFER: number;
        public static GL_PIXEL_PACK_BUFFER_BINDING: number;
        public static GL_PIXEL_UNPACK_BUFFER_BINDING: number;
        public static GL_FLOAT_MAT2x3: number;
        public static GL_FLOAT_MAT2x4: number;
        public static GL_FLOAT_MAT3x2: number;
        public static GL_FLOAT_MAT3x4: number;
        public static GL_FLOAT_MAT4x2: number;
        public static GL_FLOAT_MAT4x3: number;
        public static GL_SRGB: number;
        public static GL_SRGB8: number;
        public static GL_SRGB8_ALPHA8: number;
        public static GL_COMPARE_REF_TO_TEXTURE: number;
        public static GL_MAJOR_VERSION: number;
        public static GL_MINOR_VERSION: number;
        public static GL_NUM_EXTENSIONS: number;
        public static GL_RGBA32F: number;
        public static GL_RGB32F: number;
        public static GL_RGBA16F: number;
        public static GL_RGB16F: number;
        public static GL_VERTEX_ATTRIB_ARRAY_INTEGER: number;
        public static GL_MAX_ARRAY_TEXTURE_LAYERS: number;
        public static GL_MIN_PROGRAM_TEXEL_OFFSET: number;
        public static GL_MAX_PROGRAM_TEXEL_OFFSET: number;
        public static GL_MAX_VARYING_COMPONENTS: number;
        public static GL_TEXTURE_2D_ARRAY: number;
        public static GL_TEXTURE_BINDING_2D_ARRAY: number;
        public static GL_R11F_G11F_B10F: number;
        public static GL_UNSIGNED_INT_10F_11F_11F_REV: number;
        public static GL_RGB9_E5: number;
        public static GL_UNSIGNED_INT_5_9_9_9_REV: number;
        public static GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH: number;
        public static GL_TRANSFORM_FEEDBACK_BUFFER_MODE: number;
        public static GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: number;
        public static GL_TRANSFORM_FEEDBACK_VARYINGS: number;
        public static GL_TRANSFORM_FEEDBACK_BUFFER_START: number;
        public static GL_TRANSFORM_FEEDBACK_BUFFER_SIZE: number;
        public static GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: number;
        public static GL_RASTERIZER_DISCARD: number;
        public static GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: number;
        public static GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: number;
        public static GL_INTERLEAVED_ATTRIBS: number;
        public static GL_SEPARATE_ATTRIBS: number;
        public static GL_TRANSFORM_FEEDBACK_BUFFER: number;
        public static GL_TRANSFORM_FEEDBACK_BUFFER_BINDING: number;
        public static GL_RGBA32UI: number;
        public static GL_RGB32UI: number;
        public static GL_RGBA16UI: number;
        public static GL_RGB16UI: number;
        public static GL_RGBA8UI: number;
        public static GL_RGB8UI: number;
        public static GL_RGBA32I: number;
        public static GL_RGB32I: number;
        public static GL_RGBA16I: number;
        public static GL_RGB16I: number;
        public static GL_RGBA8I: number;
        public static GL_RGB8I: number;
        public static GL_RED_INTEGER: number;
        public static GL_RGB_INTEGER: number;
        public static GL_RGBA_INTEGER: number;
        public static GL_SAMPLER_2D_ARRAY: number;
        public static GL_SAMPLER_2D_ARRAY_SHADOW: number;
        public static GL_SAMPLER_CUBE_SHADOW: number;
        public static GL_UNSIGNED_INT_VEC2: number;
        public static GL_UNSIGNED_INT_VEC3: number;
        public static GL_UNSIGNED_INT_VEC4: number;
        public static GL_INT_SAMPLER_2D: number;
        public static GL_INT_SAMPLER_3D: number;
        public static GL_INT_SAMPLER_CUBE: number;
        public static GL_INT_SAMPLER_2D_ARRAY: number;
        public static GL_UNSIGNED_INT_SAMPLER_2D: number;
        public static GL_UNSIGNED_INT_SAMPLER_3D: number;
        public static GL_UNSIGNED_INT_SAMPLER_CUBE: number;
        public static GL_UNSIGNED_INT_SAMPLER_2D_ARRAY: number;
        public static GL_BUFFER_ACCESS_FLAGS: number;
        public static GL_BUFFER_MAP_LENGTH: number;
        public static GL_BUFFER_MAP_OFFSET: number;
        public static GL_DEPTH_COMPONENT32F: number;
        public static GL_DEPTH32F_STENCIL8: number;
        public static GL_FLOAT_32_UNSIGNED_INT_24_8_REV: number;
        public static GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: number;
        public static GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: number;
        public static GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE: number;
        public static GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: number;
        public static GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: number;
        public static GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: number;
        public static GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: number;
        public static GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: number;
        public static GL_FRAMEBUFFER_DEFAULT: number;
        public static GL_FRAMEBUFFER_UNDEFINED: number;
        public static GL_DEPTH_STENCIL_ATTACHMENT: number;
        public static GL_DEPTH_STENCIL: number;
        public static GL_UNSIGNED_INT_24_8: number;
        public static GL_DEPTH24_STENCIL8: number;
        public static GL_UNSIGNED_NORMALIZED: number;
        public static GL_DRAW_FRAMEBUFFER_BINDING: number;
        public static GL_READ_FRAMEBUFFER: number;
        public static GL_DRAW_FRAMEBUFFER: number;
        public static GL_READ_FRAMEBUFFER_BINDING: number;
        public static GL_RENDERBUFFER_SAMPLES: number;
        public static GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: number;
        public static GL_MAX_COLOR_ATTACHMENTS: number;
        public static GL_COLOR_ATTACHMENT1: number;
        public static GL_COLOR_ATTACHMENT2: number;
        public static GL_COLOR_ATTACHMENT3: number;
        public static GL_COLOR_ATTACHMENT4: number;
        public static GL_COLOR_ATTACHMENT5: number;
        public static GL_COLOR_ATTACHMENT6: number;
        public static GL_COLOR_ATTACHMENT7: number;
        public static GL_COLOR_ATTACHMENT8: number;
        public static GL_COLOR_ATTACHMENT9: number;
        public static GL_COLOR_ATTACHMENT10: number;
        public static GL_COLOR_ATTACHMENT11: number;
        public static GL_COLOR_ATTACHMENT12: number;
        public static GL_COLOR_ATTACHMENT13: number;
        public static GL_COLOR_ATTACHMENT14: number;
        public static GL_COLOR_ATTACHMENT15: number;
        public static GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: number;
        public static GL_MAX_SAMPLES: number;
        public static GL_HALF_FLOAT: number;
        public static GL_MAP_READ_BIT: number;
        public static GL_MAP_WRITE_BIT: number;
        public static GL_MAP_INVALIDATE_RANGE_BIT: number;
        public static GL_MAP_INVALIDATE_BUFFER_BIT: number;
        public static GL_MAP_FLUSH_EXPLICIT_BIT: number;
        public static GL_MAP_UNSYNCHRONIZED_BIT: number;
        public static GL_RG: number;
        public static GL_RG_INTEGER: number;
        public static GL_R8: number;
        public static GL_RG8: number;
        public static GL_R16F: number;
        public static GL_R32F: number;
        public static GL_RG16F: number;
        public static GL_RG32F: number;
        public static GL_R8I: number;
        public static GL_R8UI: number;
        public static GL_R16I: number;
        public static GL_R16UI: number;
        public static GL_R32I: number;
        public static GL_R32UI: number;
        public static GL_RG8I: number;
        public static GL_RG8UI: number;
        public static GL_RG16I: number;
        public static GL_RG16UI: number;
        public static GL_RG32I: number;
        public static GL_RG32UI: number;
        public static GL_VERTEX_ARRAY_BINDING: number;
        public static GL_R8_SNORM: number;
        public static GL_RG8_SNORM: number;
        public static GL_RGB8_SNORM: number;
        public static GL_RGBA8_SNORM: number;
        public static GL_SIGNED_NORMALIZED: number;
        public static GL_PRIMITIVE_RESTART_FIXED_INDEX: number;
        public static GL_COPY_READ_BUFFER: number;
        public static GL_COPY_WRITE_BUFFER: number;
        public static GL_COPY_READ_BUFFER_BINDING: number;
        public static GL_COPY_WRITE_BUFFER_BINDING: number;
        public static GL_UNIFORM_BUFFER: number;
        public static GL_UNIFORM_BUFFER_BINDING: number;
        public static GL_UNIFORM_BUFFER_START: number;
        public static GL_UNIFORM_BUFFER_SIZE: number;
        public static GL_MAX_VERTEX_UNIFORM_BLOCKS: number;
        public static GL_MAX_FRAGMENT_UNIFORM_BLOCKS: number;
        public static GL_MAX_COMBINED_UNIFORM_BLOCKS: number;
        public static GL_MAX_UNIFORM_BUFFER_BINDINGS: number;
        public static GL_MAX_UNIFORM_BLOCK_SIZE: number;
        public static GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: number;
        public static GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: number;
        public static GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT: number;
        public static GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH: number;
        public static GL_ACTIVE_UNIFORM_BLOCKS: number;
        public static GL_UNIFORM_TYPE: number;
        public static GL_UNIFORM_SIZE: number;
        public static GL_UNIFORM_NAME_LENGTH: number;
        public static GL_UNIFORM_BLOCK_INDEX: number;
        public static GL_UNIFORM_OFFSET: number;
        public static GL_UNIFORM_ARRAY_STRIDE: number;
        public static GL_UNIFORM_MATRIX_STRIDE: number;
        public static GL_UNIFORM_IS_ROW_MAJOR: number;
        public static GL_UNIFORM_BLOCK_BINDING: number;
        public static GL_UNIFORM_BLOCK_DATA_SIZE: number;
        public static GL_UNIFORM_BLOCK_NAME_LENGTH: number;
        public static GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS: number;
        public static GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: number;
        public static GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: number;
        public static GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: number;
        public static GL_INVALID_INDEX: number;
        public static GL_MAX_VERTEX_OUTPUT_COMPONENTS: number;
        public static GL_MAX_FRAGMENT_INPUT_COMPONENTS: number;
        public static GL_MAX_SERVER_WAIT_TIMEOUT: number;
        public static GL_OBJECT_TYPE: number;
        public static GL_SYNC_CONDITION: number;
        public static GL_SYNC_STATUS: number;
        public static GL_SYNC_FLAGS: number;
        public static GL_SYNC_FENCE: number;
        public static GL_SYNC_GPU_COMMANDS_COMPLETE: number;
        public static GL_UNSIGNALED: number;
        public static GL_SIGNALED: number;
        public static GL_ALREADY_SIGNALED: number;
        public static GL_TIMEOUT_EXPIRED: number;
        public static GL_CONDITION_SATISFIED: number;
        public static GL_WAIT_FAILED: number;
        public static GL_SYNC_FLUSH_COMMANDS_BIT: number;
        public static GL_TIMEOUT_IGNORED: Packages.long;
        public static GL_VERTEX_ATTRIB_ARRAY_DIVISOR: number;
        public static GL_ANY_SAMPLES_PASSED: number;
        public static GL_ANY_SAMPLES_PASSED_CONSERVATIVE: number;
        public static GL_SAMPLER_BINDING: number;
        public static GL_RGB10_A2UI: number;
        public static GL_TEXTURE_SWIZZLE_R: number;
        public static GL_TEXTURE_SWIZZLE_G: number;
        public static GL_TEXTURE_SWIZZLE_B: number;
        public static GL_TEXTURE_SWIZZLE_A: number;
        public static GL_GREEN: number;
        public static GL_BLUE: number;
        public static GL_INT_2_10_10_10_REV: number;
        public static GL_TRANSFORM_FEEDBACK: number;
        public static GL_TRANSFORM_FEEDBACK_PAUSED: number;
        public static GL_TRANSFORM_FEEDBACK_ACTIVE: number;
        public static GL_TRANSFORM_FEEDBACK_BINDING: number;
        public static GL_PROGRAM_BINARY_RETRIEVABLE_HINT: number;
        public static GL_PROGRAM_BINARY_LENGTH: number;
        public static GL_NUM_PROGRAM_BINARY_FORMATS: number;
        public static GL_PROGRAM_BINARY_FORMATS: number;
        public static GL_COMPRESSED_R11_EAC: number;
        public static GL_COMPRESSED_SIGNED_R11_EAC: number;
        public static GL_COMPRESSED_RG11_EAC: number;
        public static GL_COMPRESSED_SIGNED_RG11_EAC: number;
        public static GL_COMPRESSED_RGB8_ETC2: number;
        public static GL_COMPRESSED_SRGB8_ETC2: number;
        public static GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: number;
        public static GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: number;
        public static GL_COMPRESSED_RGBA8_ETC2_EAC: number;
        public static GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: number;
        public static GL_TEXTURE_IMMUTABLE_FORMAT: number;
        public static GL_MAX_ELEMENT_INDEX: number;
        public static GL_NUM_SAMPLE_COUNTS: number;
        public static GL_TEXTURE_IMMUTABLE_LEVELS: number;
        public glReadBuffer(_mode: number): void;
        public glDrawRangeElements(
          _mode: number,
          _start: number,
          _end: number,
          _count: number,
          _type: number,
          _offset: number,
        ): void;
        public glDrawRangeElements(
          _mode: number,
          _start: number,
          _end: number,
          _count: number,
          _type: number,
          _indices: Packages.java.nio.Buffer,
        ): void;
        public glTexImage3D(
          _target: number,
          _level: number,
          _internalformat: number,
          _width: number,
          _height: number,
          _depth: number,
          _border: number,
          _format: number,
          _type: number,
          _offset: number,
        ): void;
        public glTexImage3D(
          _target: number,
          _level: number,
          _internalformat: number,
          _width: number,
          _height: number,
          _depth: number,
          _border: number,
          _format: number,
          _type: number,
          _pixels: Packages.java.nio.Buffer,
        ): void;
        public glTexSubImage3D(
          _target: number,
          _level: number,
          _xoffset: number,
          _yoffset: number,
          _zoffset: number,
          _width: number,
          _height: number,
          _depth: number,
          _format: number,
          _type: number,
          _offset: number,
        ): void;
        public glTexSubImage3D(
          _target: number,
          _level: number,
          _xoffset: number,
          _yoffset: number,
          _zoffset: number,
          _width: number,
          _height: number,
          _depth: number,
          _format: number,
          _type: number,
          _pixels: Packages.java.nio.Buffer,
        ): void;
        public glCopyTexSubImage3D(
          _target: number,
          _level: number,
          _xoffset: number,
          _yoffset: number,
          _zoffset: number,
          _x: number,
          _y: number,
          _width: number,
          _height: number,
        ): void;
        public glGenQueries(
          _n: number,
          _ids: Packages.java.nio.IntBuffer,
        ): void;
        public glDeleteQueries(
          _n: number,
          _ids: Packages.java.nio.IntBuffer,
        ): void;
        public glIsQuery(_id: number): boolean;
        public glBeginQuery(
          _target: number,
          _id: number,
        ): void;
        public glEndQuery(_target: number): void;
        public glGetQueryiv(
          _target: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glGetQueryObjectuiv(
          _id: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glUnmapBuffer(_target: number): boolean;
        public glGetBufferPointerv(
          _target: number,
          _pname: number,
        ): Packages.java.nio.Buffer;
        public glDrawBuffers(
          _n: number,
          _bufs: Packages.java.nio.IntBuffer,
        ): void;
        public glUniformMatrix2x3fv(
          _location: number,
          _count: number,
          _transpose: boolean,
          _value: Packages.java.nio.FloatBuffer,
        ): void;
        public glUniformMatrix3x2fv(
          _location: number,
          _count: number,
          _transpose: boolean,
          _value: Packages.java.nio.FloatBuffer,
        ): void;
        public glUniformMatrix2x4fv(
          _location: number,
          _count: number,
          _transpose: boolean,
          _value: Packages.java.nio.FloatBuffer,
        ): void;
        public glUniformMatrix4x2fv(
          _location: number,
          _count: number,
          _transpose: boolean,
          _value: Packages.java.nio.FloatBuffer,
        ): void;
        public glUniformMatrix3x4fv(
          _location: number,
          _count: number,
          _transpose: boolean,
          _value: Packages.java.nio.FloatBuffer,
        ): void;
        public glUniformMatrix4x3fv(
          _location: number,
          _count: number,
          _transpose: boolean,
          _value: Packages.java.nio.FloatBuffer,
        ): void;
        public glBlitFramebuffer(
          _srcX0: number,
          _srcY0: number,
          _srcX1: number,
          _srcY1: number,
          _dstX0: number,
          _dstY0: number,
          _dstX1: number,
          _dstY1: number,
          _mask: number,
          _filter: number,
        ): void;
        public glRenderbufferStorageMultisample(
          _target: number,
          _samples: number,
          _internalformat: number,
          _width: number,
          _height: number,
        ): void;
        public glFramebufferTextureLayer(
          _target: number,
          _attachment: number,
          _texture: number,
          _level: number,
          _layer: number,
        ): void;
        public glFlushMappedBufferRange(
          _target: number,
          _offset: number,
          _length: number,
        ): void;
        public glBindVertexArray(_array: number): void;
        public glDeleteVertexArrays(
          _n: number,
          _arrays: Packages.java.nio.IntBuffer,
        ): void;
        public glGenVertexArrays(
          _n: number,
          _arrays: Packages.java.nio.IntBuffer,
        ): void;
        public glIsVertexArray(_array: number): boolean;
        public glBeginTransformFeedback(
          _primitiveMode: number,
        ): void;
        public glEndTransformFeedback(): void;
        public glBindBufferRange(
          _target: number,
          _index: number,
          _buffer: number,
          _offset: number,
          _size: number,
        ): void;
        public glBindBufferBase(
          _target: number,
          _index: number,
          _buffer: number,
        ): void;
        public glTransformFeedbackVaryings(
          _program: number,
          _varyings: string[],
          _bufferMode: number,
        ): void;
        public glVertexAttribIPointer(
          _index: number,
          _size: number,
          _type: number,
          _stride: number,
          _offset: number,
        ): void;
        public glGetVertexAttribIiv(
          _index: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glGetVertexAttribIuiv(
          _index: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glVertexAttribI4i(
          _index: number,
          _x: number,
          _y: number,
          _z: number,
          _w: number,
        ): void;
        public glVertexAttribI4ui(
          _index: number,
          _x: number,
          _y: number,
          _z: number,
          _w: number,
        ): void;
        public glGetUniformuiv(
          _program: number,
          _location: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glGetFragDataLocation(
          _program: number,
          _name: string,
        ): number;
        public glUniform1uiv(
          _location: number,
          _count: number,
          _value: Packages.java.nio.IntBuffer,
        ): void;
        public glUniform3uiv(
          _location: number,
          _count: number,
          _value: Packages.java.nio.IntBuffer,
        ): void;
        public glUniform4uiv(
          _location: number,
          _count: number,
          _value: Packages.java.nio.IntBuffer,
        ): void;
        public glClearBufferiv(
          _buffer: number,
          _drawbuffer: number,
          _value: Packages.java.nio.IntBuffer,
        ): void;
        public glClearBufferuiv(
          _buffer: number,
          _drawbuffer: number,
          _value: Packages.java.nio.IntBuffer,
        ): void;
        public glClearBufferfv(
          _buffer: number,
          _drawbuffer: number,
          _value: Packages.java.nio.FloatBuffer,
        ): void;
        public glClearBufferfi(
          _buffer: number,
          _drawbuffer: number,
          _depth: number,
          _stencil: number,
        ): void;
        public glGetStringi(
          _name: number,
          _index: number,
        ): string;
        public glCopyBufferSubData(
          _readTarget: number,
          _writeTarget: number,
          _readOffset: number,
          _writeOffset: number,
          _size: number,
        ): void;
        public glGetUniformIndices(
          _program: number,
          _uniformNames: string[],
          _uniformIndices: Packages.java.nio.IntBuffer,
        ): void;
        public glGetActiveUniformsiv(
          _program: number,
          _uniformCount: number,
          _uniformIndices: Packages.java.nio.IntBuffer,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glGetUniformBlockIndex(
          _program: number,
          _uniformBlockName: string,
        ): number;
        public glGetActiveUniformBlockiv(
          _program: number,
          _uniformBlockIndex: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glGetActiveUniformBlockName(
          _program: number,
          _uniformBlockIndex: number,
          _length: Packages.java.nio.Buffer,
          _uniformBlockName: Packages.java.nio.Buffer,
        ): void;
        public glUniformBlockBinding(
          _program: number,
          _uniformBlockIndex: number,
          _uniformBlockBinding: number,
        ): void;
        public glDrawArraysInstanced(
          _mode: number,
          _first: number,
          _count: number,
          _instanceCount: number,
        ): void;
        public glDrawElementsInstanced(
          _mode: number,
          _count: number,
          _type: number,
          _indicesOffset: number,
          _instanceCount: number,
        ): void;
        public glGetInteger64v(
          _pname: number,
          _params: Packages.java.nio.LongBuffer,
        ): void;
        public glGetBufferParameteri64v(
          _target: number,
          _pname: number,
          _params: Packages.java.nio.LongBuffer,
        ): void;
        public glGenSamplers(
          _count: number,
          _samplers: Packages.java.nio.IntBuffer,
        ): void;
        public glDeleteSamplers(
          _count: number,
          _samplers: Packages.java.nio.IntBuffer,
        ): void;
        public glIsSampler(_sampler: number): boolean;
        public glBindSampler(
          _unit: number,
          _sampler: number,
        ): void;
        public glSamplerParameteri(
          _sampler: number,
          _pname: number,
          _param: number,
        ): void;
        public glSamplerParameteriv(
          _sampler: number,
          _pname: number,
          _param: Packages.java.nio.IntBuffer,
        ): void;
        public glSamplerParameterf(
          _sampler: number,
          _pname: number,
          _param: number,
        ): void;
        public glSamplerParameterfv(
          _sampler: number,
          _pname: number,
          _param: Packages.java.nio.FloatBuffer,
        ): void;
        public glGetSamplerParameteriv(
          _sampler: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glGetSamplerParameterfv(
          _sampler: number,
          _pname: number,
          _params: Packages.java.nio.FloatBuffer,
        ): void;
        public glVertexAttribDivisor(
          _index: number,
          _divisor: number,
        ): void;
        public glBindTransformFeedback(
          _target: number,
          _id: number,
        ): void;
        public glDeleteTransformFeedbacks(
          _n: number,
          _ids: Packages.java.nio.IntBuffer,
        ): void;
        public glGenTransformFeedbacks(
          _n: number,
          _ids: Packages.java.nio.IntBuffer,
        ): void;
        public glIsTransformFeedback(_id: number): boolean;
        public glPauseTransformFeedback(): void;
        public glResumeTransformFeedback(): void;
        public glProgramParameteri(
          _program: number,
          _pname: number,
          _value: number,
        ): void;
        public glInvalidateFramebuffer(
          _target: number,
          _numAttachments: number,
          _attachments: Packages.java.nio.IntBuffer,
        ): void;
        public glInvalidateSubFramebuffer(
          _target: number,
          _numAttachments: number,
          _attachments: Packages.java.nio.IntBuffer,
          _x: number,
          _y: number,
          _width: number,
          _height: number,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace gl {
        declare class GLVersion extends java.lang.Object {
          public static GlType = class extends Packages.java
            .lang
            .Enum<Packages.arc.graphics.gl.GLVersion.GlType> {
            public static OpenGL: Packages.arc.graphics.gl.GLVersion.GlType;
            public static GLES: Packages.arc.graphics.gl.GLVersion.GlType;
            public static WebGL: Packages.arc.graphics.gl.GLVersion.GlType;
            public static NONE: Packages.arc.graphics.gl.GLVersion.GlType;
            private static $VALUES: Packages.arc.graphics.gl.GLVersion.GlType[];
            public static values():
              | Packages.arc.graphics.gl.GLVersion.GlType[]
              | null;
            public static valueOf(
              _name: string,
            ): Packages.arc.graphics.gl.GLVersion.GlType;
          };
          public vendorString: string;
          public rendererString: string;
          public type: Packages.arc.graphics.gl.GLVersion.GlType;
          public majorVersion: number;
          public minorVersion: number;
          public releaseVersion: number;
          public toString(): string;
          private parseInt(
            _v: string,
            _defaultValue: number,
          ): number;
          private extractVersion(
            _patternString: string,
            _versionString: string,
          ): void;
          public atLeast(
            _testMajorVersion: number,
            _testMinorVersion: number,
          ): boolean;
          public getDebugVersionString(): string;
          public constructor(
            _appType: Packages.arc.Application.ApplicationType,
            _versionString: string,
            _vendorString: string,
            _rendererString: string,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare abstract class Graphics
      extends java.lang.Object
      implements Packages.arc.util.Disposable
    {
      public static Cursor = class
        implements Packages.arc.util.Disposable
      {
        public static SystemCursor = class
          extends Packages.java.lang
            .Enum<Packages.arc.Graphics.Cursor.SystemCursor>
          implements Packages.arc.Graphics.Cursor
        {
          public static arrow: Packages.arc.Graphics.Cursor.SystemCursor;
          public static ibeam: Packages.arc.Graphics.Cursor.SystemCursor;
          public static crosshair: Packages.arc.Graphics.Cursor.SystemCursor;
          public static hand: Packages.arc.Graphics.Cursor.SystemCursor;
          public static horizontalResize: Packages.arc.Graphics.Cursor.SystemCursor;
          public static verticalResize: Packages.arc.Graphics.Cursor.SystemCursor;
          cursor?: Packages.arc.Graphics.Cursor;
          private static $VALUES: Packages.arc.Graphics.Cursor.SystemCursor[];
          public static values():
            | Packages.arc.Graphics.Cursor.SystemCursor[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.arc.Graphics.Cursor.SystemCursor;
          public set(
            _cursor: Packages.arc.Graphics.Cursor,
          ): void;
          public dispose(): void;
        };
      };
      public static BufferFormat = class extends java.lang
        .Object {
        public r: number;
        public g: number;
        public b: number;
        public a: number;
        public depth: number;
        public stencil: number;
        public samples: number;
        public coverageSampling: boolean;
        public toString(): string;
        public constructor(
          _r: number,
          _g: number,
          _b: number,
          _a: number,
          _depth: number,
          _stencil: number,
          _samples: number,
          _coverageSampling: boolean,
        );
      };
      private lastCursor: any;
      public isHidden(): boolean;
      public clear(
        _r: number,
        _g: number,
        _b: number,
        _a: number,
      ): void;
      public clear(
        _color: Packages.arc.graphics.Color,
      ): void;
      public cursor(
        _cursor: Packages.arc.Graphics.Cursor,
      ): void;
      public dispose(): void;
      public getWidth(): number;
      public getHeight(): number;
      public newCursor(
        _filename: string,
        _scaling: number,
        _outlineColor: Packages.arc.graphics.Color,
        _outlineScaling: number,
      ): Packages.arc.Graphics.Cursor;
      public newCursor(
        _filename: string,
        _scale: number,
      ): Packages.arc.Graphics.Cursor;
      public newCursor(
        _filename: string,
      ): Packages.arc.Graphics.Cursor;
      public newCursor(
        _pixmap: Packages.arc.graphics.Pixmap,
        _scaling: number,
        _outlineColor: Packages.arc.graphics.Color,
        _outlineThickness: number,
      ): Packages.arc.Graphics.Cursor;
      public newCursor(
        _pixmap: Packages.arc.graphics.Pixmap,
        _xHotspot: number,
        _yHotspot: number,
      ): Packages.arc.Graphics.Cursor;
      protected setCursor(
        _cursor: Packages.arc.Graphics.Cursor,
      ): void;
      protected setSystemCursor(
        _systemCursor: Packages.arc.Graphics.Cursor.SystemCursor,
      ): void;
      public isGL30Available(): boolean;
      public getGL20(): Packages.arc.graphics.GL20;
      public setGL20(
        _gl20: Packages.arc.graphics.GL20,
      ): void;
      public getGL30(): Packages.arc.graphics.GL30;
      public setGL30(
        _gl30: Packages.arc.graphics.GL30,
      ): void;
      public isPortrait(): boolean;
      public getAspect(): number;
      public getBackBufferWidth(): number;
      public getBackBufferHeight(): number;
      public getSafeInsets(): number[] | null;
      public getFrameId(): Packages.long;
      public getDeltaTime(): number;
      public getFramesPerSecond(): number;
      public getGLVersion(): Packages.arc.graphics.gl.GLVersion;
      public getPpiX(): number;
      public getPpiY(): number;
      public getPpcX(): number;
      public getPpcY(): number;
      public getDensity(): number;
      public setFullscreen(): boolean;
      public setWindowedMode(
        _width: number,
        _height: number,
      ): boolean;
      public setTitle(_title: string): void;
      public setBorderless(_undecorated: boolean): void;
      public setResizable(_resizable: boolean): void;
      public setVSync(_vsync: boolean): void;
      public getBufferFormat(): Packages.arc.Graphics.BufferFormat;
      public supportsExtension(_extension: string): boolean;
      public isContinuousRendering(): boolean;
      public setContinuousRendering(
        _isContinuous: boolean,
      ): void;
      public requestRendering(): void;
      public isFullscreen(): boolean;
      public restoreCursor(): void;
      public constructor();
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace audio {
      declare abstract class AudioFilter extends java.lang
        .Object {
        protected handle: Packages.long;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace audio {
      declare abstract class AudioSource
        extends java.lang.Object
        implements Packages.arc.util.Disposable
      {
        protected handle: Packages.long;
        public setFilter(
          _filter: Packages.arc.audio.AudioFilter | null,
        ): void;
        public setFilter(
          _index: number,
          _filter: Packages.arc.audio.AudioFilter | null,
        ): void;
        public dispose(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace audio {
      declare class AudioBus extends Packages.arc.audio
        .AudioSource {
        public id: number;
        init(): Packages.arc.audio.AudioBus;
        public stop(): void;
        public setFilter(
          _index: number,
          _filter: Packages.arc.audio.AudioFilter | null,
        ): void;
        public play(): void;
        public setVolume(_volume: number): void;
        public fadeFilterParam(
          _filter: number,
          _attribute: number,
          _value: number,
          _timeSec: number,
        ): void;
        public setFilterParam(
          _filter: number,
          _attribute: number,
          _value: number,
        ): void;
        public playing(): boolean;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace audio {
      declare class Sound extends Packages.arc.audio
        .AudioSource {
        public bus: Packages.arc.audio.AudioBus;
        public file?: Packages.arc.files.Fi;
        framePlayed: Packages.long;
        public toString(): string;
        public load(_file: Packages.arc.files.Fi): void;
        public stop(): void;
        public at(
          _x: number,
          _y: number,
          _pitch: number,
          _volume: number,
          _checkFrame: boolean,
        ): number;
        public at(
          _x: number,
          _y: number,
          _pitch: number,
        ): number;
        public at(_x: number, _y: number): number;
        public at(
          _x: number,
          _y: number,
          _pitch: number,
          _volume: number,
        ): number;
        public at(
          _pos: Packages.arc.math.geom.Position,
          _pitch: number,
        ): number;
        public at(
          _pos: Packages.arc.math.geom.Position,
        ): number;
        public loop(
          _volume: number,
          _pitch: number,
          _pan: number,
        ): number;
        public loop(): number;
        public loop(_volume: number): number;
        public play(
          _volume: number,
          _pitch: number,
          _pan: number,
          _loop: boolean,
        ): number;
        public play(
          _volume: number,
          _pitch: number,
          _pan: number,
          _loop: boolean,
          _checkFrame: boolean,
        ): number;
        public play(
          _volume: number,
          _pitch: number,
          _pan: number,
        ): number;
        public play(): number;
        public play(_volume: number): number;
        public calcFalloff(_x: number, _y: number): number;
        public calcVolume(_x: number, _y: number): number;
        public calcPan(_x: number, _y: number): number;
        public setBus(
          _bus: Packages.arc.audio.AudioBus,
        ): void;
        public constructor();
        public constructor(_file: Packages.arc.files.Fi);
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace audio {
      declare class Music extends Packages.arc.audio
        .AudioSource {
        file?: Packages.arc.files.Fi;
        voice: number;
        looping: boolean;
        volume: number;
        pitch: number;
        pan: number;
        public toString(): string;
        public load(_file: Packages.arc.files.Fi): void;
        public set(_pan: number, _volume: number): void;
        public stop(): void;
        protected static caches(
          _name: string,
        ): Packages.arc.files.Fi[] | null;
        public pause(_pause: boolean): void;
        public isPlaying(): boolean;
        public play(): void;
        public setLooping(_isLooping: boolean): void;
        public setVolume(_volume: number): void;
        public isLooping(): boolean;
        public getVolume(): number;
        public getPosition(): number;
        public setPosition(_position: number): void;
        public constructor(_file: Packages.arc.files.Fi);
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace audio {
      declare class Audio
        extends java.lang.Object
        implements Packages.arc.util.Disposable
      {
        public globalPitch: number;
        public falloff: number;
        sfxVolume: number;
        public soundBus: Packages.arc.audio.AudioBus;
        public musicBus: Packages.arc.audio.AudioBus;
        protected initialize(): void;
        public set(
          _soundId: number,
          _pan: number,
          _volume: number,
        ): void;
        public initialized(): boolean;
        public stop(
          _source: Packages.arc.audio.AudioSource,
        ): void;
        public stop(_soundId: number): void;
        public setFilter(
          _index: number,
          _filter: Packages.arc.audio.AudioFilter | null,
        ): void;
        public dispose(): void;
        public newSound(
          _file: Packages.arc.files.Fi,
        ): Packages.arc.audio.Sound;
        public newMusic(
          _file: Packages.arc.files.Fi,
        ): Packages.arc.audio.Music;
        public isPlaying(_soundId: number): boolean;
        public protect(
          _voice: number,
          _protect: boolean,
        ): void;
        public play(
          _source: Packages.arc.audio.AudioSource,
          _volume: number,
          _pitch: number,
          _pan: number,
          _loop: boolean,
        ): number;
        public setPaused(
          _soundId: number,
          _paused: boolean,
        ): void;
        public setLooping(
          _soundId: number,
          _looping: boolean,
        ): void;
        public setPitch(
          _soundId: number,
          _pitch: number,
        ): void;
        public setVolume(
          _soundId: number,
          _volume: number,
        ): void;
        public fadeFilterParam(
          _voice: number,
          _filter: number,
          _attribute: number,
          _value: number,
          _timeSec: number,
        ): void;
        public setFilterParam(
          _voice: number,
          _filter: number,
          _attribute: number,
          _value: number,
        ): void;
        public countPlaying(
          _source: Packages.arc.audio.AudioSource,
        ): number;
        public constructor();
        public constructor(_enabled: boolean);
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace input {
      declare class KeyCode
        extends Packages.java.lang
          .Enum<Packages.arc.input.KeyCode>
        implements Packages.arc.KeyBinds.KeybindValue
      {
        public static KeyType = class extends Packages.java
          .lang.Enum<Packages.arc.input.KeyCode.KeyType> {
          public static key: Packages.arc.input.KeyCode.KeyType;
          public static mouse: Packages.arc.input.KeyCode.KeyType;
          public static controller: Packages.arc.input.KeyCode.KeyType;
          public static scroll: Packages.arc.input.KeyCode.KeyType;
          private static $VALUES: Packages.arc.input.KeyCode.KeyType[];
          public static values():
            | Packages.arc.input.KeyCode.KeyType[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.arc.input.KeyCode.KeyType;
        };
        public static controllerA: Packages.arc.input.KeyCode;
        public static controllerB: Packages.arc.input.KeyCode;
        public static controllerX: Packages.arc.input.KeyCode;
        public static controllerY: Packages.arc.input.KeyCode;
        public static controllerGuide: Packages.arc.input.KeyCode;
        public static controllerLBumper: Packages.arc.input.KeyCode;
        public static controllerRBumper: Packages.arc.input.KeyCode;
        public static controllerBack: Packages.arc.input.KeyCode;
        public static controllerStart: Packages.arc.input.KeyCode;
        public static controllerLStick: Packages.arc.input.KeyCode;
        public static controllerRStick: Packages.arc.input.KeyCode;
        public static controllerdPadUp: Packages.arc.input.KeyCode;
        public static controllerdPadDown: Packages.arc.input.KeyCode;
        public static controllerdPadLeft: Packages.arc.input.KeyCode;
        public static controllerdPadRight: Packages.arc.input.KeyCode;
        public static controllerLTrigger: Packages.arc.input.KeyCode;
        public static controllerRTrigger: Packages.arc.input.KeyCode;
        public static controllerLStickYAxis: Packages.arc.input.KeyCode;
        public static controllerLStickXAxis: Packages.arc.input.KeyCode;
        public static controllerRStickYAxis: Packages.arc.input.KeyCode;
        public static controllerRStickXAxis: Packages.arc.input.KeyCode;
        public static mouseLeft: Packages.arc.input.KeyCode;
        public static mouseRight: Packages.arc.input.KeyCode;
        public static mouseMiddle: Packages.arc.input.KeyCode;
        public static mouseBack: Packages.arc.input.KeyCode;
        public static mouseForward: Packages.arc.input.KeyCode;
        public static scroll: Packages.arc.input.KeyCode;
        public static anyKey: Packages.arc.input.KeyCode;
        public static num0: Packages.arc.input.KeyCode;
        public static num1: Packages.arc.input.KeyCode;
        public static num2: Packages.arc.input.KeyCode;
        public static num3: Packages.arc.input.KeyCode;
        public static num4: Packages.arc.input.KeyCode;
        public static num5: Packages.arc.input.KeyCode;
        public static num6: Packages.arc.input.KeyCode;
        public static num7: Packages.arc.input.KeyCode;
        public static num8: Packages.arc.input.KeyCode;
        public static num9: Packages.arc.input.KeyCode;
        public static a: Packages.arc.input.KeyCode;
        public static altLeft: Packages.arc.input.KeyCode;
        public static altRight: Packages.arc.input.KeyCode;
        public static apostrophe: Packages.arc.input.KeyCode;
        public static at: Packages.arc.input.KeyCode;
        public static b: Packages.arc.input.KeyCode;
        public static back: Packages.arc.input.KeyCode;
        public static backslash: Packages.arc.input.KeyCode;
        public static c: Packages.arc.input.KeyCode;
        public static call: Packages.arc.input.KeyCode;
        public static camera: Packages.arc.input.KeyCode;
        public static clear: Packages.arc.input.KeyCode;
        public static comma: Packages.arc.input.KeyCode;
        public static d: Packages.arc.input.KeyCode;
        public static del: Packages.arc.input.KeyCode;
        public static backspace: Packages.arc.input.KeyCode;
        public static forwardDel: Packages.arc.input.KeyCode;
        public static dpadCenter: Packages.arc.input.KeyCode;
        public static dpadDown: Packages.arc.input.KeyCode;
        public static dpadLeft: Packages.arc.input.KeyCode;
        public static dpadRight: Packages.arc.input.KeyCode;
        public static dpadUp: Packages.arc.input.KeyCode;
        public static center: Packages.arc.input.KeyCode;
        public static down: Packages.arc.input.KeyCode;
        public static left: Packages.arc.input.KeyCode;
        public static right: Packages.arc.input.KeyCode;
        public static up: Packages.arc.input.KeyCode;
        public static e: Packages.arc.input.KeyCode;
        public static endcall: Packages.arc.input.KeyCode;
        public static enter: Packages.arc.input.KeyCode;
        public static envelope: Packages.arc.input.KeyCode;
        public static equals: Packages.arc.input.KeyCode;
        public static explorer: Packages.arc.input.KeyCode;
        public static f: Packages.arc.input.KeyCode;
        public static focus: Packages.arc.input.KeyCode;
        public static g: Packages.arc.input.KeyCode;
        public static backtick: Packages.arc.input.KeyCode;
        public static h: Packages.arc.input.KeyCode;
        public static headsetHook: Packages.arc.input.KeyCode;
        public static home: Packages.arc.input.KeyCode;
        public static i: Packages.arc.input.KeyCode;
        public static j: Packages.arc.input.KeyCode;
        public static k: Packages.arc.input.KeyCode;
        public static l: Packages.arc.input.KeyCode;
        public static leftBracket: Packages.arc.input.KeyCode;
        public static m: Packages.arc.input.KeyCode;
        public static mediaFastForward: Packages.arc.input.KeyCode;
        public static mediaNext: Packages.arc.input.KeyCode;
        public static mediaPlayPause: Packages.arc.input.KeyCode;
        public static mediaPrevious: Packages.arc.input.KeyCode;
        public static mediaRewind: Packages.arc.input.KeyCode;
        public static mediaStop: Packages.arc.input.KeyCode;
        public static menu: Packages.arc.input.KeyCode;
        public static minus: Packages.arc.input.KeyCode;
        public static mute: Packages.arc.input.KeyCode;
        public static n: Packages.arc.input.KeyCode;
        public static notification: Packages.arc.input.KeyCode;
        public static num: Packages.arc.input.KeyCode;
        public static o: Packages.arc.input.KeyCode;
        public static p: Packages.arc.input.KeyCode;
        public static period: Packages.arc.input.KeyCode;
        public static plus: Packages.arc.input.KeyCode;
        public static pound: Packages.arc.input.KeyCode;
        public static power: Packages.arc.input.KeyCode;
        public static q: Packages.arc.input.KeyCode;
        public static r: Packages.arc.input.KeyCode;
        public static rightBracket: Packages.arc.input.KeyCode;
        public static s: Packages.arc.input.KeyCode;
        public static search: Packages.arc.input.KeyCode;
        public static semicolon: Packages.arc.input.KeyCode;
        public static shiftLeft: Packages.arc.input.KeyCode;
        public static shiftRight: Packages.arc.input.KeyCode;
        public static slash: Packages.arc.input.KeyCode;
        public static softLeft: Packages.arc.input.KeyCode;
        public static softRight: Packages.arc.input.KeyCode;
        public static space: Packages.arc.input.KeyCode;
        public static star: Packages.arc.input.KeyCode;
        public static sym: Packages.arc.input.KeyCode;
        public static t: Packages.arc.input.KeyCode;
        public static tab: Packages.arc.input.KeyCode;
        public static u: Packages.arc.input.KeyCode;
        public static unknown: Packages.arc.input.KeyCode;
        public static v: Packages.arc.input.KeyCode;
        public static volumeDown: Packages.arc.input.KeyCode;
        public static volumeUp: Packages.arc.input.KeyCode;
        public static w: Packages.arc.input.KeyCode;
        public static x: Packages.arc.input.KeyCode;
        public static y: Packages.arc.input.KeyCode;
        public static z: Packages.arc.input.KeyCode;
        public static metaAltLeftOn: Packages.arc.input.KeyCode;
        public static metaAltOn: Packages.arc.input.KeyCode;
        public static metaAltRightOn: Packages.arc.input.KeyCode;
        public static metaShiftLeftOn: Packages.arc.input.KeyCode;
        public static metaShiftOn: Packages.arc.input.KeyCode;
        public static metaShiftRightOn: Packages.arc.input.KeyCode;
        public static metaSymOn: Packages.arc.input.KeyCode;
        public static controlLeft: Packages.arc.input.KeyCode;
        public static controlRight: Packages.arc.input.KeyCode;
        public static escape: Packages.arc.input.KeyCode;
        public static end: Packages.arc.input.KeyCode;
        public static insert: Packages.arc.input.KeyCode;
        public static pageUp: Packages.arc.input.KeyCode;
        public static pageDown: Packages.arc.input.KeyCode;
        public static pictSymbols: Packages.arc.input.KeyCode;
        public static switchCharset: Packages.arc.input.KeyCode;
        public static buttonCircle: Packages.arc.input.KeyCode;
        public static buttonA: Packages.arc.input.KeyCode;
        public static buttonB: Packages.arc.input.KeyCode;
        public static buttonC: Packages.arc.input.KeyCode;
        public static buttonX: Packages.arc.input.KeyCode;
        public static buttonY: Packages.arc.input.KeyCode;
        public static buttonZ: Packages.arc.input.KeyCode;
        public static buttonL1: Packages.arc.input.KeyCode;
        public static buttonR1: Packages.arc.input.KeyCode;
        public static buttonL2: Packages.arc.input.KeyCode;
        public static buttonR2: Packages.arc.input.KeyCode;
        public static buttonThumbL: Packages.arc.input.KeyCode;
        public static buttonThumbR: Packages.arc.input.KeyCode;
        public static buttonStart: Packages.arc.input.KeyCode;
        public static buttonSelect: Packages.arc.input.KeyCode;
        public static buttonMode: Packages.arc.input.KeyCode;
        public static numpad0: Packages.arc.input.KeyCode;
        public static numpad1: Packages.arc.input.KeyCode;
        public static numpad2: Packages.arc.input.KeyCode;
        public static numpad3: Packages.arc.input.KeyCode;
        public static numpad4: Packages.arc.input.KeyCode;
        public static numpad5: Packages.arc.input.KeyCode;
        public static numpad6: Packages.arc.input.KeyCode;
        public static numpad7: Packages.arc.input.KeyCode;
        public static numpad8: Packages.arc.input.KeyCode;
        public static numpad9: Packages.arc.input.KeyCode;
        public static colon: Packages.arc.input.KeyCode;
        public static f1: Packages.arc.input.KeyCode;
        public static f2: Packages.arc.input.KeyCode;
        public static f3: Packages.arc.input.KeyCode;
        public static f4: Packages.arc.input.KeyCode;
        public static f5: Packages.arc.input.KeyCode;
        public static f6: Packages.arc.input.KeyCode;
        public static f7: Packages.arc.input.KeyCode;
        public static f8: Packages.arc.input.KeyCode;
        public static f9: Packages.arc.input.KeyCode;
        public static f10: Packages.arc.input.KeyCode;
        public static f11: Packages.arc.input.KeyCode;
        public static f12: Packages.arc.input.KeyCode;
        public static unset: Packages.arc.input.KeyCode;
        public static application: Packages.arc.input.KeyCode;
        public static asterisk: Packages.arc.input.KeyCode;
        public static capsLock: Packages.arc.input.KeyCode;
        public static pause: Packages.arc.input.KeyCode;
        public static printScreen: Packages.arc.input.KeyCode;
        public static scrollLock: Packages.arc.input.KeyCode;
        public static all: Packages.arc.input.KeyCode[];
        public static numbers: Packages.arc.input.KeyCode[];
        public type: Packages.arc.input.KeyCode.KeyType;
        public value: string;
        public axis: boolean;
        private static $VALUES: Packages.arc.input.KeyCode[];
        public toString(): string;
        public static values():
          | Packages.arc.input.KeyCode[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.arc.input.KeyCode;
        public static byOrdinal(
          _id: number,
        ): Packages.arc.input.KeyCode;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace input {
      declare abstract class InputDevice extends java.lang
        .Object {
        public static DeviceType = class extends Packages
          .java.lang
          .Enum<Packages.arc.input.InputDevice.DeviceType> {
          public static keyboard: Packages.arc.input.InputDevice.DeviceType;
          public static controller: Packages.arc.input.InputDevice.DeviceType;
          private static $VALUES: Packages.arc.input.InputDevice.DeviceType[];
          public static values():
            | Packages.arc.input.InputDevice.DeviceType[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.arc.input.InputDevice.DeviceType;
        };
        public name(): string;
        public type(): Packages.arc.input.InputDevice.DeviceType;
        public isPressed(
          _key: Packages.arc.input.KeyCode,
        ): boolean;
        public isTapped(
          _key: Packages.arc.input.KeyCode,
        ): boolean;
        public isReleased(
          _key: Packages.arc.input.KeyCode,
        ): boolean;
        public getAxis(
          _keyCode: Packages.arc.input.KeyCode,
        ): number;
        public postUpdate(): void;
        public preUpdate(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace input {
      declare abstract class InputProcessor {
        public keyDown(
          _keycode: Packages.arc.input.KeyCode,
        ): boolean;
        public touchDown(
          _screenX: number,
          _screenY: number,
          _pointer: number,
          _button: Packages.arc.input.KeyCode,
        ): boolean;
        public touchDragged(
          _screenX: number,
          _screenY: number,
          _pointer: number,
        ): boolean;
        public touchUp(
          _screenX: number,
          _screenY: number,
          _pointer: number,
          _button: Packages.arc.input.KeyCode,
        ): boolean;
        public mouseMoved(
          _screenX: number,
          _screenY: number,
        ): boolean;
        public scrolled(
          _amountX: number,
          _amountY: number,
        ): boolean;
        public keyUp(
          _keycode: Packages.arc.input.KeyCode,
        ): boolean;
        public keyTyped(_character: string): boolean;
        public connected(
          _device: Packages.arc.input.InputDevice,
        ): void;
        public disconnected(
          _device: Packages.arc.input.InputDevice,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class IntSet extends java.lang.Object {
        public static IntSetIterator = class extends java
          .lang.Object {
          static INDEX_ILLEGAL: number;
          static INDEX_ZERO: number;
          set: Packages.arc.struct.IntSet;
          public hasNext: boolean;
          nextIndex: number;
          currentIndex: number;
          valid: boolean;
          public remove(): void;
          public toArray(): Packages.arc.struct.IntSeq;
          public next(): number;
          public reset(): void;
          findNextIndex(): void;
          public constructor(
            _set: Packages.arc.struct.IntSet,
          );
        };
        private static PRIME1: number;
        private static PRIME2: number;
        private static PRIME3: number;
        private static EMPTY: number;
        public size: number;
        keyTable: number[];
        capacity: number;
        stashSize: number;
        hasZeroValue: boolean;
        private loadFactor: number;
        private hashShift: number;
        private mask: number;
        private threshold: number;
        private stashCapacity: number;
        private pushIterations: number;
        private iterator1: Packages.arc.struct.IntSet.IntSetIterator;
        private iterator2: Packages.arc.struct.IntSet.IntSetIterator;
        public add(_key: number): boolean;
        public remove(_key: number): boolean;
        public equals(_obj: any): boolean;
        public toString(): string;
        public hashCode(): number;
        public clear(_maximumCapacity: number): void;
        public clear(): void;
        public isEmpty(): boolean;
        public iterator(): Packages.arc.struct.IntSet.IntSetIterator;
        public contains(_key: number): boolean;
        public addAll(
          _array: number[],
          _offset: number,
          _length: number,
        ): void;
        public addAll(..._array: number[]): void;
        public addAll(
          _array: Packages.arc.struct.IntSeq,
        ): void;
        public addAll(
          _array: Packages.arc.struct.IntSeq,
          _offset: number,
          _length: number,
        ): void;
        public addAll(
          _set: Packages.arc.struct.IntSet,
        ): void;
        public first(): number;
        public ensureCapacity(
          _additionalCapacity: number,
        ): void;
        public each(_cons: Packages.arc.func.Intc): void;
        private resize(_newSize: number): void;
        private push(
          _insertKey: number,
          _index1: number,
          _key1: number,
          _index2: number,
          _key2: number,
          _index3: number,
          _key3: number,
        ): void;
        public static with(
          ..._array: number[]
        ): Packages.arc.struct.IntSet;
        public shrink(_maximumCapacity: number): void;
        private addStash(_key: number): void;
        private addResize(_key: number): void;
        private hash2(_h: number): number;
        private hash3(_h: number): number;
        removeStash(_key: number): boolean;
        removeStashIndex(_index: number): void;
        private containsKeyStash(_key: number): boolean;
        public constructor(
          _set: Packages.arc.struct.IntSet,
        );
        public constructor(
          _initialCapacity: number,
          _loadFactor: number,
        );
        public constructor(_initialCapacity: number);
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class IntFloatMap
        extends java.lang.Object
        implements
          Packages.java.lang
            .Iterable<Packages.arc.struct.IntFloatMap.Entry>
      {
        public static Entries = class
          extends Packages.arc.struct.IntFloatMap
            .MapIterator
          implements
            Packages.java.lang
              .Iterable<Packages.arc.struct.IntFloatMap.Entry>,
            Packages.java.util
              .Iterator<Packages.arc.struct.IntFloatMap.Entry>
        {
          private entry: Packages.arc.struct.IntFloatMap.Entry;
          public remove(): void;
          public iterator(): Packages.java.util.Iterator<Packages.arc.struct.IntFloatMap.Entry>;
          public hasNext(): boolean;
          public next(): any;
          public next(): Packages.arc.struct.IntFloatMap.Entry;
          public reset(): void;
          public constructor(
            _map: Packages.arc.struct.IntFloatMap,
          );
        };
        public static Entry = class extends java.lang
          .Object {
          public key: number;
          public value: number;
          public toString(): string;
          public constructor();
        };
        public static Values = class extends Packages.arc
          .struct.IntFloatMap.MapIterator {
          public remove(): void;
          public toArray(): Packages.arc.struct.FloatSeq;
          public hasNext(): boolean;
          public next(): number;
          public reset(): void;
          public constructor(
            _map: Packages.arc.struct.IntFloatMap,
          );
        };
        public static Keys = class extends Packages.arc
          .struct.IntFloatMap.MapIterator {
          public remove(): void;
          public toArray(): Packages.arc.struct.IntSeq;
          public hasNext(): boolean;
          public next(): number;
          public reset(): void;
          public constructor(
            _map: Packages.arc.struct.IntFloatMap,
          );
        };
        private static MapIterator = class extends java.lang
          .Object {
          static INDEX_ILLEGAL: number;
          static INDEX_ZERO: number;
          map: Packages.arc.struct.IntFloatMap;
          public hasNext: boolean;
          nextIndex: number;
          currentIndex: number;
          valid: boolean;
          public remove(): void;
          public reset(): void;
          findNextIndex(): void;
          public constructor(
            _map: Packages.arc.struct.IntFloatMap,
          );
        };
        private static PRIME1: number;
        private static PRIME2: number;
        private static PRIME3: number;
        private static EMPTY: number;
        public size: number;
        keyTable: number[];
        valueTable: number[];
        capacity: number;
        stashSize: number;
        zeroValue: number;
        hasZeroValue: boolean;
        private loadFactor: number;
        private hashShift: number;
        private mask: number;
        private threshold: number;
        private stashCapacity: number;
        private pushIterations: number;
        private entries1: Packages.arc.struct.IntFloatMap.Entries;
        private entries2: Packages.arc.struct.IntFloatMap.Entries;
        private values1: Packages.arc.struct.IntFloatMap.Values;
        private values2: Packages.arc.struct.IntFloatMap.Values;
        private keys1: Packages.arc.struct.IntFloatMap.Keys;
        private keys2: Packages.arc.struct.IntFloatMap.Keys;
        public remove(
          _key: number,
          _defaultValue: number,
        ): number;
        public get(
          _key: number,
          _defaultValue: number,
        ): number;
        public get(_key: number): number;
        public put(_key: number, _value: number): void;
        public equals(_obj: any): boolean;
        public toString(): string;
        public values(): Packages.arc.struct.IntFloatMap.Values;
        public hashCode(): number;
        public clear(): void;
        public clear(_maximumCapacity: number): void;
        public isEmpty(): boolean;
        public iterator(): Packages.java.util.Iterator<Packages.arc.struct.IntFloatMap.Entry>;
        public putAll(
          _map: Packages.arc.struct.IntFloatMap,
        ): void;
        public increment(
          _key: number,
          _defaultValue: number,
          _increment: number,
        ): number;
        public increment(
          _key: number,
          _increment: number,
        ): number;
        public containsKey(_key: number): boolean;
        public keys(): Packages.arc.struct.IntFloatMap.Keys;
        public containsValue(
          _value: number,
          _epsilon: number,
        ): boolean;
        public containsValue(_value: number): boolean;
        public entries(): Packages.arc.struct.IntFloatMap.Entries;
        public ensureCapacity(
          _additionalCapacity: number,
        ): void;
        private resize(_newSize: number): void;
        private push(
          _insertKey: number,
          _insertValue: number,
          _index1: number,
          _key1: number,
          _index2: number,
          _key2: number,
          _index3: number,
          _key3: number,
        ): void;
        public shrink(_maximumCapacity: number): void;
        private hash2(_h: number): number;
        private hash3(_h: number): number;
        private putStash(
          _key: number,
          _value: number,
        ): void;
        private putResize(
          _key: number,
          _value: number,
        ): void;
        private getStash(
          _key: number,
          _defaultValue: number,
        ): number;
        removeStash(
          _key: number,
          _defaultValue: number,
        ): number;
        removeStashIndex(_index: number): void;
        private containsKeyStash(_key: number): boolean;
        public findKey(
          _value: number,
          _notFound: number,
        ): number;
        private getAndIncrementStash(
          _key: number,
          _defaultValue: number,
          _increment: number,
        ): number;
        public constructor(
          _map: Packages.arc.struct.IntFloatMap,
        );
        public constructor(
          _initialCapacity: number,
          _loadFactor: number,
        );
        public constructor(_initialCapacity: number);
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace input {
      declare class KeyboardDevice
        extends Packages.arc.input.InputDevice
        implements Packages.arc.input.InputProcessor
      {
        private pressed: Packages.arc.struct.IntSet;
        private lastFramePressed: Packages.arc.struct.IntSet;
        private justPressed: Packages.arc.struct.IntSet;
        private axes: Packages.arc.struct.IntFloatMap;
        public name(): string;
        public type(): Packages.arc.input.InputDevice.DeviceType;
        public keyDown(
          _key: Packages.arc.input.KeyCode,
        ): boolean;
        public isPressed(
          _key: Packages.arc.input.KeyCode,
        ): boolean;
        public isTapped(
          _key: Packages.arc.input.KeyCode,
        ): boolean;
        public isReleased(
          _key: Packages.arc.input.KeyCode,
        ): boolean;
        public getAxis(
          _keyCode: Packages.arc.input.KeyCode,
        ): number;
        public touchDown(
          _screenX: number,
          _screenY: number,
          _pointer: number,
          _button: Packages.arc.input.KeyCode,
        ): boolean;
        public touchUp(
          _screenX: number,
          _screenY: number,
          _pointer: number,
          _button: Packages.arc.input.KeyCode,
        ): boolean;
        public scrolled(
          _amountX: number,
          _amountY: number,
        ): boolean;
        public keyUp(
          _key: Packages.arc.input.KeyCode,
        ): boolean;
        public postUpdate(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class SnapshotSeq<T> extends Packages.arc
        .struct.Seq<T> {
        private snapshot: T[];
        private recycled: T[];
        private snapshots: number;
        public remove(
          _value: T,
          _identity: boolean,
        ): boolean;
        public remove(_index: number): T | null;
        public insert(_index: number, _value: T): void;
        public clear(): Packages.arc.struct.Seq<T>;
        public end(): void;
        public begin(): T[] | null;
        public set(_index: number, _value: T): void;
        public reverse(): Packages.arc.struct.Seq<T>;
        public sort(
          _comparator: Packages.java.util.Comparator<any>,
        ): Packages.arc.struct.Seq<T>;
        public sort(): Packages.arc.struct.Seq<T>;
        public removeRange(
          _start: number,
          _end: number,
        ): void;
        public removeAll(
          _array: Packages.arc.struct.Seq<any>,
          _identity: boolean,
        ): boolean;
        private modified(): void;
        public swap(_first: number, _second: number): void;
        public shuffle(): Packages.arc.struct.Seq<T>;
        public pop(): T | null;
        public static with<T>(
          ..._array: T[]
        ): Packages.arc.struct.SnapshotSeq<T>;
        public setSize(_newSize: number): T[] | null;
        public truncate(_newSize: number): void;
        public constructor(
          _ordered: boolean,
          _array: T[],
          _startIndex: number,
          _count: number,
        );
        public constructor(
          _arrayType:
            | Class<any>
            | Packages.java.lang.Class<any>,
        );
        public constructor(_capacity: number);
        public constructor(_array: T[]);
        public constructor();
        public constructor(
          _array: Packages.arc.struct.Seq<T>,
        );
        public constructor(
          _ordered: boolean,
          _capacity: number,
          _arrayType:
            | Class<any>
            | Packages.java.lang.Class<any>,
        );
        public constructor(
          _ordered: boolean,
          _capacity: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace input {
      declare class InputMultiplexer
        extends java.lang.Object
        implements Packages.arc.input.InputProcessor
      {
        private processors: Packages.arc.struct.SnapshotSeq<Packages.arc.input.InputProcessor>;
        public clear(): void;
        public size(): number;
        public keyDown(
          _keycode: Packages.arc.input.KeyCode,
        ): boolean;
        public addProcessor(
          _index: number,
          _processor: Packages.arc.input.InputProcessor,
        ): void;
        public addProcessor(
          _processor: Packages.arc.input.InputProcessor,
        ): void;
        public removeProcessor(_index: number): void;
        public removeProcessor(
          _processor: Packages.arc.input.InputProcessor,
        ): void;
        public getProcessors(): Packages.arc.struct.SnapshotSeq<Packages.arc.input.InputProcessor>;
        public touchDown(
          _screenX: number,
          _screenY: number,
          _pointer: number,
          _button: Packages.arc.input.KeyCode,
        ): boolean;
        public touchDragged(
          _screenX: number,
          _screenY: number,
          _pointer: number,
        ): boolean;
        public touchUp(
          _screenX: number,
          _screenY: number,
          _pointer: number,
          _button: Packages.arc.input.KeyCode,
        ): boolean;
        public mouseMoved(
          _screenX: number,
          _screenY: number,
        ): boolean;
        public scrolled(
          _amountX: number,
          _amountY: number,
        ): boolean;
        public keyUp(
          _keycode: Packages.arc.input.KeyCode,
        ): boolean;
        public keyTyped(_character: string): boolean;
        public connected(
          _device: Packages.arc.input.InputDevice,
        ): void;
        public disconnected(
          _device: Packages.arc.input.InputDevice,
        ): void;
        public setProcessors(
          ..._processors: Packages.arc.input.InputProcessor[]
        ): void;
        public setProcessors(
          _processors: Packages.arc.struct.Seq<Packages.arc.input.InputProcessor>,
        ): void;
        public constructor();
        public constructor(
          ..._processors: Packages.arc.input.InputProcessor[]
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare abstract class Input extends java.lang.Object {
      public static Peripheral = class extends Packages.java
        .lang.Enum<Packages.arc.Input.Peripheral> {
        public static hardwareKeyboard: Packages.arc.Input.Peripheral;
        public static onscreenKeyboard: Packages.arc.Input.Peripheral;
        public static multitouchScreen: Packages.arc.Input.Peripheral;
        public static accelerometer: Packages.arc.Input.Peripheral;
        public static compass: Packages.arc.Input.Peripheral;
        public static vibrator: Packages.arc.Input.Peripheral;
        public static gyroscope: Packages.arc.Input.Peripheral;
        public static rotationVector: Packages.arc.Input.Peripheral;
        public static pressure: Packages.arc.Input.Peripheral;
        private static $VALUES: Packages.arc.Input.Peripheral[];
        public static values():
          | Packages.arc.Input.Peripheral[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.arc.Input.Peripheral;
      };
      public static Orientation = class extends Packages
        .java.lang.Enum<Packages.arc.Input.Orientation> {
        public static landscape: Packages.arc.Input.Orientation;
        public static portrait: Packages.arc.Input.Orientation;
        private static $VALUES: Packages.arc.Input.Orientation[];
        public static values():
          | Packages.arc.Input.Orientation[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.arc.Input.Orientation;
      };
      public static TextInput = class extends java.lang
        .Object {
        public multiline: boolean;
        public allowEmpty: boolean;
        public title: string;
        public text: string;
        public message: string;
        public numeric: boolean;
        public accepted: Packages.arc.func.Cons<string>;
        public canceled: Packages.java.lang.Runnable;
        public maxLength: number;
        public constructor();
      };
      protected keyboard: Packages.arc.input.KeyboardDevice;
      protected devices: Packages.arc.struct.Seq<Packages.arc.input.InputDevice>;
      protected inputMultiplexer: Packages.arc.input.InputMultiplexer;
      protected caughtKeys: Packages.arc.struct.IntSet;
      protected mouseReturn: Packages.arc.math.geom.Vec2;
      public shift(): boolean;
      public alt(): boolean;
      public getRotation(): number;
      public axis(
        _key: Packages.arc.KeyBinds.KeyBind,
      ): number;
      public axis(_key: Packages.arc.input.KeyCode): number;
      public mouse(): Packages.arc.math.geom.Vec2;
      public mouseX(_pointer: number): number;
      public mouseX(): number;
      public mouseY(_pointer: number): number;
      public mouseY(): number;
      public useKeyboard(): boolean;
      public isTouched(): boolean;
      public isTouched(_pointer: number): boolean;
      public getPressure(): number;
      public getPressure(_pointer: number): number;
      public keyDown(
        _key: Packages.arc.input.KeyCode,
      ): boolean;
      public keyDown(
        _key: Packages.arc.KeyBinds.KeyBind,
      ): boolean;
      public addProcessor(
        _processor: Packages.arc.input.InputProcessor,
      ): void;
      public removeProcessor(
        _processor: Packages.arc.input.InputProcessor,
      ): void;
      public mouseWorld(
        _x: number,
        _y: number,
      ): Packages.arc.math.geom.Vec2;
      public mouseWorld(): Packages.arc.math.geom.Vec2;
      public mouseScreen(
        _x: number,
        _y: number,
      ): Packages.arc.math.geom.Vec2;
      public mouseWorldX(): number;
      public mouseWorldY(): number;
      public setUseKeyboard(_useKeyboard: boolean): void;
      public deltaX(): number;
      public deltaX(_pointer: number): number;
      public deltaY(_pointer: number): number;
      public deltaY(): number;
      public justTouched(): boolean;
      public getTouches(): number;
      public ctrl(): boolean;
      public keyTap(
        _key: Packages.arc.input.KeyCode,
      ): boolean;
      public keyTap(
        _key: Packages.arc.KeyBinds.KeyBind,
      ): boolean;
      public keyRelease(
        _key: Packages.arc.input.KeyCode,
      ): boolean;
      public keyRelease(
        _key: Packages.arc.KeyBinds.KeyBind,
      ): boolean;
      public axisTap(
        _key: Packages.arc.KeyBinds.KeyBind,
      ): number;
      public getTextInput(
        _input: Packages.arc.Input.TextInput,
      ): void;
      public setOnscreenKeyboardVisible(
        _visible: boolean,
      ): void;
      public vibrate(_milliseconds: number): void;
      public vibrate(
        _pattern: Packages.long[],
        _repeat: number,
      ): void;
      public cancelVibrate(): void;
      public getAccelerometer(): Packages.arc.math.geom.Vec3;
      public getGyroscope(): Packages.arc.math.geom.Vec3;
      public getOrientation(): Packages.arc.math.geom.Vec3;
      public getRotationMatrix(_matrix: number[]): void;
      public getCurrentEventTime(): Packages.long;
      public setCatch(
        _code: Packages.arc.input.KeyCode,
        _c: boolean,
      ): void;
      public isCatch(
        _code: Packages.arc.input.KeyCode,
      ): boolean;
      public getInputProcessors(): Packages.arc.struct.Seq<Packages.arc.input.InputProcessor>;
      public getInputMultiplexer(): Packages.arc.input.InputMultiplexer;
      public getDevices(): Packages.arc.struct.Seq<Packages.arc.input.InputDevice>;
      public getKeyboard(): Packages.arc.input.KeyboardDevice;
      public isPeripheralAvailable(
        _peripheral: Packages.arc.Input.Peripheral,
      ): boolean;
      public getNativeOrientation(): Packages.arc.Input.Orientation;
      public constructor();
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare abstract class Files {
      public static FileType = class extends Packages.java
        .lang.Enum<Packages.arc.Files.FileType> {
        public static classpath: Packages.arc.Files.FileType;
        public static internal: Packages.arc.Files.FileType;
        public static external: Packages.arc.Files.FileType;
        public static absolute: Packages.arc.Files.FileType;
        public static local: Packages.arc.Files.FileType;
        private static $VALUES: Packages.arc.Files.FileType[];
        public static values():
          | Packages.arc.Files.FileType[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.arc.Files.FileType;
      };
      public get(
        _path: string,
        _type: Packages.arc.Files.FileType,
      ): Packages.arc.files.Fi;
      public cache(_path: string): Packages.arc.files.Fi;
      public absolute(_path: string): Packages.arc.files.Fi;
      public local(_path: string): Packages.arc.files.Fi;
      public internal(_path: string): Packages.arc.files.Fi;
      public classpath(
        _path: string,
      ): Packages.arc.files.Fi;
      public external(_path: string): Packages.arc.files.Fi;
      public getExternalStoragePath(): string;
      public getCachePath(): string;
      public isExternalStorageAvailable(): boolean;
      public getLocalStoragePath(): string;
      public isLocalStorageAvailable(): boolean;
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare class HashMap<K, V> {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare class Throwable {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare namespace concurrent {
        declare abstract class ExecutorService {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace io {
      declare class ByteArrayOutputStream {}
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace io {
        declare class ReusableByteInStream extends Packages
          .java.io.ByteArrayInputStream {
          public position(): number;
          public setBytes(
            _bytes: string[],
            _offset: number,
            _length: number,
          ): void;
          public setBytes(_bytes: string[]): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare namespace regex {
        declare class Pattern {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace serialization {
        declare class JsonValue
          extends java.lang.Object
          implements
            Packages.java.lang
              .Iterable<Packages.arc.util.serialization.JsonValue>
        {
          public static ValueType = class extends Packages
            .java.lang
            .Enum<Packages.arc.util.serialization.JsonValue.ValueType> {
            public static object: Packages.arc.util.serialization.JsonValue.ValueType;
            public static array: Packages.arc.util.serialization.JsonValue.ValueType;
            public static stringValue: Packages.arc.util.serialization.JsonValue.ValueType;
            public static doubleValue: Packages.arc.util.serialization.JsonValue.ValueType;
            public static longValue: Packages.arc.util.serialization.JsonValue.ValueType;
            public static booleanValue: Packages.arc.util.serialization.JsonValue.ValueType;
            public static nullValue: Packages.arc.util.serialization.JsonValue.ValueType;
            private static $VALUES: Packages.arc.util.serialization.JsonValue.ValueType[];
            public static values():
              | Packages.arc.util.serialization.JsonValue.ValueType[]
              | null;
            public static valueOf(
              _name: string,
            ): Packages.arc.util.serialization.JsonValue.ValueType;
          };
          public static PrettyPrintSettings = class extends java
            .lang.Object {
            public outputType: Packages.arc.util.serialization.JsonWriter.OutputType;
            public singleLineColumns: number;
            public wrapNumericArrays: boolean;
            public constructor();
          };
          public JsonIterator = class
            extends java.lang.Object
            implements
              Packages.java.lang
                .Iterable<Packages.arc.util.serialization.JsonValue>,
              Packages.java.util
                .Iterator<Packages.arc.util.serialization.JsonValue>
          {
            entry: Packages.arc.util.serialization.JsonValue;
            current: Packages.arc.util.serialization.JsonValue;
            this$0: Packages.arc.util.serialization.JsonValue;
            public remove(): void;
            public iterator(): Packages.java.util.Iterator<Packages.arc.util.serialization.JsonValue>;
            public hasNext(): boolean;
            public next(): any;
            public next(): Packages.arc.util.serialization.JsonValue;
            public constructor(
              _this$0: Packages.arc.util.serialization.JsonValue,
            );
          };
          public size: number;
          private stringValue?: string;
          private doubleValue: number;
          private longValue: Packages.long;
          public name(): string;
          public remove(
            _index: number,
          ): Packages.arc.util.serialization.JsonValue;
          public remove(
            _name: string,
          ): Packages.arc.util.serialization.JsonValue;
          public parent(): Packages.arc.util.serialization.JsonValue;
          public get(
            _name: string,
          ): Packages.arc.util.serialization.JsonValue;
          public get(
            _index: number,
          ): Packages.arc.util.serialization.JsonValue;
          public type(): Packages.arc.util.serialization.JsonValue.ValueType;
          public toString(): string;
          public isArray(): boolean;
          public getBoolean(_index: number): boolean;
          public getBoolean(
            _name: string,
            _defaultValue: boolean,
          ): boolean;
          public getBoolean(_name: string): boolean;
          public getByte(
            _name: string,
            _defaultValue: string,
          ): string;
          public getByte(_index: number): string;
          public getByte(_name: string): string;
          public getShort(
            _name: string,
            _defaultValue: Packages.short,
          ): Packages.short;
          public getShort(_name: string): Packages.short;
          public getShort(_index: number): Packages.short;
          public getChar(
            _name: string,
            _defaultValue: string,
          ): string;
          public getChar(_name: string): string;
          public getChar(_index: number): string;
          public getInt(
            _name: string,
            _defaultValue: number,
          ): number;
          public getInt(_index: number): number;
          public getInt(_name: string): number;
          public getLong(_index: number): Packages.long;
          public getLong(_name: string): Packages.long;
          public getLong(
            _name: string,
            _defaultValue: Packages.long,
          ): Packages.long;
          public getFloat(
            _name: string,
            _defaultValue: number,
          ): number;
          public getFloat(_index: number): number;
          public getFloat(_name: string): number;
          public getDouble(
            _name: string,
            _defaultValue: number,
          ): number;
          public getDouble(_index: number): number;
          public getDouble(_name: string): number;
          public iterator(): Packages.java.util.Iterator<any>;
          public iterator(): Packages.arc.util.serialization.JsonValue.JsonIterator;
          public next(): Packages.arc.util.serialization.JsonValue;
          private static indent(
            _count: number,
            _buffer: Packages.java.lang.StringBuilder,
          ): void;
          private static indent(
            _count: number,
            _buffer: Packages.java.io.Writer,
          ): void;
          public set(_value: string): void;
          public set(
            _value: number,
            _stringValue: string,
          ): void;
          public set(
            _value: Packages.long,
            _stringValue: string,
          ): void;
          public set(_value: boolean): void;
          public trace(): string;
          public prev(): Packages.arc.util.serialization.JsonValue;
          public setName(_name: string): void;
          public isNull(): boolean;
          private mismatch(_type: string): void;
          public child(): Packages.arc.util.serialization.JsonValue;
          public asInt(): number;
          public getString(_index: number): string;
          public getString(
            _name: string,
            _defaultValue: string,
          ): string;
          public getString(_name: string): string;
          public has(_name: string): boolean;
          private static isNumeric(
            _object: Packages.arc.util.serialization.JsonValue,
          ): boolean;
          public asByteArray(): string[] | null;
          private typeMismatch(
            _type: string,
          ): Packages.java.lang.RuntimeException;
          private json(
            _object: Packages.arc.util.serialization.JsonValue,
            _buffer: Packages.java.lang.StringBuilder,
            _outputType: Packages.arc.util.serialization.JsonWriter.OutputType,
          ): void;
          public addChild(
            _value: Packages.arc.util.serialization.JsonValue,
          ): void;
          public addChild(
            _name: string,
            _value: Packages.arc.util.serialization.JsonValue,
          ): void;
          public toJson(
            _outputType: Packages.arc.util.serialization.JsonWriter.OutputType,
          ): string;
          public isObject(): boolean;
          public asFloat(): number;
          public getChild(
            _name: string,
          ): Packages.arc.util.serialization.JsonValue;
          public isNumber(): boolean;
          public asLong(): Packages.long;
          public asDouble(): number;
          public asString(): string;
          public asShort(): Packages.short;
          public asByte(): string;
          public isBoolean(): boolean;
          public asBoolean(): boolean;
          public isString(): boolean;
          public isValue(): boolean;
          public asChar(): string;
          public isDouble(): boolean;
          public isLong(): boolean;
          private static isFlat(
            _object: Packages.arc.util.serialization.JsonValue,
          ): boolean;
          public require(
            _index: number,
          ): Packages.arc.util.serialization.JsonValue;
          public require(
            _name: string,
          ): Packages.arc.util.serialization.JsonValue;
          public asStringArray(): string[] | null;
          public asFloatArray(): number[] | null;
          public asDoubleArray(): number[] | null;
          public asLongArray(): Packages.long[] | null;
          public asIntArray(): number[] | null;
          public asBooleanArray(): boolean[] | null;
          public asShortArray(): Packages.short[] | null;
          public asCharArray(): string[] | null;
          public hasChild(_name: string): boolean;
          public setNext(
            _next: Packages.arc.util.serialization.JsonValue,
          ): void;
          public setPrev(
            _prev: Packages.arc.util.serialization.JsonValue,
          ): void;
          public prettyPrint(
            _outputType: Packages.arc.util.serialization.JsonWriter.OutputType,
            _singleLineColumns: number,
          ): string;
          private prettyPrint(
            _object: Packages.arc.util.serialization.JsonValue,
            _writer: Packages.java.io.Writer,
            _indent: number,
            _settings: Packages.arc.util.serialization.JsonValue.PrettyPrintSettings,
          ): void;
          public prettyPrint(
            _settings: Packages.arc.util.serialization.JsonValue.PrettyPrintSettings,
          ): string;
          private prettyPrint(
            _object: Packages.arc.util.serialization.JsonValue,
            _buffer: Packages.java.lang.StringBuilder,
            _indent: number,
            _settings: Packages.arc.util.serialization.JsonValue.PrettyPrintSettings,
          ): void;
          public prettyPrint(
            _outputType: Packages.arc.util.serialization.JsonWriter.OutputType,
            _writer: Packages.java.io.Writer,
          ): void;
          public setType(
            _type: Packages.arc.util.serialization.JsonValue.ValueType,
          ): void;
          public constructor(_value: Packages.long);
          public constructor(
            _value: number,
            _stringValue: string,
          );
          public constructor(
            _value: Packages.long,
            _stringValue: string,
          );
          public constructor(_value: boolean);
          public constructor(
            _type: Packages.arc.util.serialization.JsonValue.ValueType,
          );
          public constructor(_value: string);
          public constructor(_value: number);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace serialization {
        declare abstract class BaseJsonReader {
          public parse(
            _input: Packages.java.io.InputStream,
          ): Packages.arc.util.serialization.JsonValue;
          public parse(
            _file: Packages.arc.files.Fi,
          ): Packages.arc.util.serialization.JsonValue;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace io {
      declare class DataInputStream {}
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace serialization {
        declare class UBJsonReader
          extends java.lang.Object
          implements
            Packages.arc.util.serialization.BaseJsonReader
        {
          public oldFormat: boolean;
          protected parse(
            _din: Packages.java.io.DataInputStream,
            _type: string,
          ): Packages.arc.util.serialization.JsonValue;
          public parse(
            _din: Packages.java.io.DataInputStream,
          ): Packages.arc.util.serialization.JsonValue;
          public parse(
            _file: Packages.arc.files.Fi,
          ): Packages.arc.util.serialization.JsonValue;
          public parse(
            _input: Packages.java.io.InputStream,
          ): Packages.arc.util.serialization.JsonValue;
          protected readString(
            _din: Packages.java.io.DataInputStream,
            _size: Packages.long,
          ): string;
          protected parseObject(
            _din: Packages.java.io.DataInputStream,
          ): Packages.arc.util.serialization.JsonValue;
          protected parseArray(
            _din: Packages.java.io.DataInputStream,
          ): Packages.arc.util.serialization.JsonValue;
          protected readUChar(
            _din: Packages.java.io.DataInputStream,
          ): Packages.short;
          protected parseString(
            _din: Packages.java.io.DataInputStream,
            _sOptional: boolean,
            _type: string,
          ): string;
          protected parseString(
            _din: Packages.java.io.DataInputStream,
            _type: string,
          ): string;
          protected parseData(
            _din: Packages.java.io.DataInputStream,
            _blockType: string,
          ): Packages.arc.util.serialization.JsonValue;
          protected parseSize(
            _din: Packages.java.io.DataInputStream,
            _useIntOnError: boolean,
            _defaultValue: Packages.long,
          ): Packages.long;
          protected parseSize(
            _din: Packages.java.io.DataInputStream,
            _type: string,
            _useIntOnError: boolean,
            _defaultValue: Packages.long,
          ): Packages.long;
          protected readUInt(
            _din: Packages.java.io.DataInputStream,
          ): Packages.long;
          protected readUShort(
            _din: Packages.java.io.DataInputStream,
          ): number;
          public parseWihoutClosing(
            _din: Packages.java.io.DataInputStream,
          ): Packages.arc.util.serialization.JsonValue;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class OrderedMap<K, V> extends Packages.arc
        .struct.ObjectMap<K, V> {
        public static OrderedMapEntries = class<
          K,
          V,
        > extends Packages.arc.struct.ObjectMap.Entries<
          K,
          V
        > {
          private keys: Packages.arc.struct.Seq<K>;
          public remove(): void;
          public next(): any;
          public next(): Packages.arc.struct.ObjectMap.Entry<
            K,
            V
          >;
          public reset(): void;
          public constructor(
            _map: Packages.arc.struct.OrderedMap<K, V>,
          );
        };
        public static OrderedMapValues = class<
          V,
        > extends Packages.arc.struct.ObjectMap.Values<V> {
          private keys: Packages.arc.struct.Seq<any>;
          public remove(): void;
          public next(): V | null;
          public reset(): void;
          public constructor(
            _map: Packages.arc.struct.OrderedMap<any, V>,
          );
        };
        public static OrderedMapKeys = class<
          K,
        > extends Packages.arc.struct.ObjectMap.Keys<K> {
          private keys: Packages.arc.struct.Seq<K>;
          public remove(): void;
          public next(): K | null;
          public reset(): void;
          public constructor(
            _map: Packages.arc.struct.OrderedMap<K, any>,
          );
        };
        public remove(_key: K): V | null;
        public put(_key: K, _value: V): V | null;
        public toString(): string;
        public values(): Packages.arc.struct.ObjectMap.Values<V>;
        public clear(): void;
        public clear(_maximumCapacity: number): void;
        public iterator(): Packages.arc.struct.ObjectMap.Entries<
          K,
          V
        >;
        public iterator(): Packages.java.util.Iterator<any>;
        public static of<K, V>(
          ..._values: any[]
        ): Packages.arc.struct.OrderedMap<K, V>;
        public keys(): Packages.arc.struct.ObjectMap.Keys<K>;
        public entries(): Packages.arc.struct.ObjectMap.Entries<
          K,
          V
        >;
        public removeIndex(_index: number): V | null;
        public orderedKeys(): Packages.arc.struct.Seq<K>;
        public constructor(
          _initialCapacity: number,
          _loadFactor: number,
        );
        public constructor(_initialCapacity: number);
        public constructor();
        public constructor(
          _map: Packages.arc.struct.OrderedMap<any, any>,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace serialization {
        declare abstract class BaseJsonWriter
          implements Packages.java.io.Closeable
        {
          public name(
            _name: string,
          ): Packages.arc.util.serialization.BaseJsonWriter;
          public value(
            _value: any,
          ): Packages.arc.util.serialization.BaseJsonWriter;
          public array(): Packages.arc.util.serialization.BaseJsonWriter;
          public array(
            _name: string,
          ): Packages.arc.util.serialization.BaseJsonWriter;
          public set(
            _name: string,
            _value: any,
          ): Packages.arc.util.serialization.BaseJsonWriter;
          public object(
            _name: string,
          ): Packages.arc.util.serialization.BaseJsonWriter;
          public object(): Packages.arc.util.serialization.BaseJsonWriter;
          public pop(): Packages.arc.util.serialization.BaseJsonWriter;
          public setOutputType(
            _outputType: Packages.arc.util.serialization.JsonWriter.OutputType,
          ): void;
          public setQuoteLongValues(
            _quoteLongValues: boolean,
          ): void;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace serialization {
        declare class Json extends java.lang.Object {
          public static Serializer = class<T> {
            public write(
              _json: Packages.arc.util.serialization.Json,
              _object: T,
              _knownType:
                | Class
                | Packages.java.lang.Class<any>,
            ): void;
            public read(
              _json: Packages.arc.util.serialization.Json,
              _jsonData: Packages.arc.util.serialization.JsonValue,
              _type: Class | Packages.java.lang.Class<any>,
            ): T | null;
          };
          public static FieldMetadata = class extends java
            .lang.Object {
            public field: Packages.java.lang.reflect.Field;
            public elementType?: Packages.java.lang.Class<any>;
            public keyType?: Packages.java.lang.Class<any>;
            public constructor(
              _field: Packages.java.lang.reflect.Field,
            );
          };
          public static JsonSerializable = class {
            public write(
              _json: Packages.arc.util.serialization.Json,
            ): void;
            public read(
              _json: Packages.arc.util.serialization.Json,
              _jsonData: Packages.arc.util.serialization.JsonValue,
            ): void;
          };
          private static debug: boolean;
          private typeToFields: Packages.arc.struct.ObjectMap<
            Packages.java.lang.Class<any>,
            Packages.arc.struct.OrderedMap<
              string,
              Packages.arc.util.serialization.Json.FieldMetadata
            >
          >;
          private tagToClass: Packages.arc.struct.ObjectMap<
            string,
            Packages.java.lang.Class<any>
          >;
          private classToTag: Packages.arc.struct.ObjectMap<
            Packages.java.lang.Class<any>,
            string
          >;
          private classToSerializer: Packages.arc.struct.ObjectMap<
            Packages.java.lang.Class<any>,
            Packages.arc.util.serialization.Json.Serializer<any>
          >;
          private classToDefaultValues: Packages.arc.struct.ObjectMap<
            Packages.java.lang.Class<any>,
            any[]
          >;
          private equals1: any[];
          private equals2: any[];
          private writer: Packages.arc.util.serialization.BaseJsonWriter;
          private typeName: string;
          private usePrototypes: boolean;
          private outputType: Packages.arc.util.serialization.JsonWriter.OutputType;
          private quoteLongValues: boolean;
          private ignoreUnknownFields: boolean;
          private ignoreDeprecated: boolean;
          private readDeprecated: boolean;
          private enumNames: boolean;
          private defaultSerializer: Packages.arc.util.serialization.Json.Serializer<any>;
          public getClass(
            _tag: string,
          ): Packages.java.lang.Class<any>;
          protected newInstance(
            _type: Class | Packages.java.lang.Class<any>,
          ): any;
          public copyFields(_from: any, _to: any): void;
          public copyFields(
            _from: any,
            _to: any,
            _setFinals: boolean,
          ): void;
          public getFields(
            _type: Class | Packages.java.lang.Class<any>,
          ): Packages.arc.struct.OrderedMap<
            string,
            Packages.arc.util.serialization.Json.FieldMetadata
          >;
          public readFields(
            _object: any,
            _jsonMap: Packages.arc.util.serialization.JsonValue,
          ): void;
          public writeFields(_object: any): void;
          public readValue<T>(
            _name: string,
            _type: Class<T> | Packages.java.lang.Class<T>,
            _defaultValue: T,
            _jsonMap: Packages.arc.util.serialization.JsonValue,
          ): T | null;
          public readValue<T>(
            _name: string,
            _type: Class<T> | Packages.java.lang.Class<T>,
            _jsonMap: Packages.arc.util.serialization.JsonValue,
          ): T | null;
          public readValue<T>(
            _type: Class<T> | Packages.java.lang.Class<T>,
            _elementType:
              | Class
              | Packages.java.lang.Class<any>,
            _jsonData: Packages.arc.util.serialization.JsonValue,
          ): T | null;
          public readValue<T>(
            _name: string,
            _type: Class<T> | Packages.java.lang.Class<T>,
            _elementType:
              | Class
              | Packages.java.lang.Class<any>,
            _jsonMap: Packages.arc.util.serialization.JsonValue,
          ): T | null;
          public readValue<T>(
            _type: Class<T> | Packages.java.lang.Class<T>,
            _elementType:
              | Class
              | Packages.java.lang.Class<any>,
            _jsonData: Packages.arc.util.serialization.JsonValue,
            _keytype: Class | Packages.java.lang.Class<any>,
          ): T | null;
          public readValue<T>(
            _name: string,
            _type: Class<T> | Packages.java.lang.Class<T>,
            _elementType:
              | Class
              | Packages.java.lang.Class<any>,
            _defaultValue: T,
            _jsonMap: Packages.arc.util.serialization.JsonValue,
          ): T | null;
          public readValue<T>(
            _type: Class<T> | Packages.java.lang.Class<T>,
            _elementType:
              | Class
              | Packages.java.lang.Class<any>,
            _defaultValue: T,
            _jsonData: Packages.arc.util.serialization.JsonValue,
          ): T | null;
          public readValue<T>(
            _type: Class<T> | Packages.java.lang.Class<T>,
            _jsonData: Packages.arc.util.serialization.JsonValue,
          ): T | null;
          public readField(
            _object: any,
            _name: string,
            _elementType:
              | Class
              | Packages.java.lang.Class<any>,
            _jsonData: Packages.arc.util.serialization.JsonValue,
          ): void;
          public readField(
            _object: any,
            _name: string,
            _jsonData: Packages.arc.util.serialization.JsonValue,
          ): void;
          public readField(
            _object: any,
            _field: Packages.java.lang.reflect.Field,
            _jsonName: string,
            _elementType:
              | Class
              | Packages.java.lang.Class<any>,
            _jsonMap: Packages.arc.util.serialization.JsonValue,
          ): void;
          public readField(
            _object: any,
            _fieldName: string,
            _jsonName: string,
            _jsonData: Packages.arc.util.serialization.JsonValue,
          ): void;
          public readField(
            _object: any,
            _fieldName: string,
            _jsonName: string,
            _elementType:
              | Class
              | Packages.java.lang.Class<any>,
            _jsonMap: Packages.arc.util.serialization.JsonValue,
          ): void;
          public getTag(
            _type: Class | Packages.java.lang.Class<any>,
          ): string;
          static getElementType(
            _field: Packages.java.lang.reflect.Field,
            _index: number,
          ): Packages.java.lang.Class<any>;
          public setWriter(
            _writer: Packages.arc.util.serialization.BaseJsonWriter,
          ): void;
          public writeValue(
            _name: string,
            _value: any,
            _knownType:
              | Class
              | Packages.java.lang.Class<any>,
            _elementType:
              | Class
              | Packages.java.lang.Class<any>,
          ): void;
          public writeValue(
            _name: string,
            _value: any,
            _knownType:
              | Class
              | Packages.java.lang.Class<any>,
          ): void;
          public writeValue(
            _value: any,
            _knownType:
              | Class
              | Packages.java.lang.Class<any>,
            _elementType:
              | Class
              | Packages.java.lang.Class<any>,
          ): void;
          public writeValue(_value: any): void;
          public writeValue(
            _value: any,
            _knownType:
              | Class
              | Packages.java.lang.Class<any>,
          ): void;
          public writeValue(
            _name: string,
            _value: any,
          ): void;
          public setOutputType(
            _outputType: Packages.arc.util.serialization.JsonWriter.OutputType,
          ): void;
          public setQuoteLongValues(
            _quoteLongValues: boolean,
          ): void;
          public toJson(
            _object: any,
            _knownType:
              | Class
              | Packages.java.lang.Class<any>,
            _file: Packages.arc.files.Fi,
          ): void;
          public toJson(
            _object: any,
            _knownType:
              | Class
              | Packages.java.lang.Class<any>,
            _elementType:
              | Class
              | Packages.java.lang.Class<any>,
          ): string;
          public toJson(
            _object: any,
            _knownType:
              | Class
              | Packages.java.lang.Class<any>,
            _elementType:
              | Class
              | Packages.java.lang.Class<any>,
            _writer: Packages.java.io.Writer,
          ): void;
          public toJson(
            _object: any,
            _knownType:
              | Class
              | Packages.java.lang.Class<any>,
            _writer: Packages.java.io.Writer,
          ): void;
          public toJson(
            _object: any,
            _writer: Packages.java.io.Writer,
          ): void;
          public toJson(
            _object: any,
            _knownType:
              | Class
              | Packages.java.lang.Class<any>,
            _elementType:
              | Class
              | Packages.java.lang.Class<any>,
            _file: Packages.arc.files.Fi,
          ): void;
          public toJson(_object: any): string;
          public toJson(
            _object: any,
            _knownType:
              | Class
              | Packages.java.lang.Class<any>,
          ): string;
          public toJson(
            _object: any,
            _file: Packages.arc.files.Fi,
          ): void;
          private getDefaultValues(
            _type: Class | Packages.java.lang.Class<any>,
          ): any[] | null;
          public writeField(
            _object: any,
            _name: string,
          ): void;
          public writeField(
            _object: any,
            _name: string,
            _elementType:
              | Class
              | Packages.java.lang.Class<any>,
          ): void;
          public writeField(
            _object: any,
            _fieldName: string,
            _jsonName: string,
          ): void;
          public writeField(
            _object: any,
            _fieldName: string,
            _jsonName: string,
            _elementType:
              | Class
              | Packages.java.lang.Class<any>,
          ): void;
          public writeObjectStart(
            _name: string,
            _actualType:
              | Class
              | Packages.java.lang.Class<any>,
            _knownType:
              | Class
              | Packages.java.lang.Class<any>,
          ): void;
          public writeObjectStart(
            _actualType:
              | Class
              | Packages.java.lang.Class<any>,
            _knownType:
              | Class
              | Packages.java.lang.Class<any>,
          ): void;
          public writeObjectStart(): void;
          public writeObjectStart(_name: string): void;
          public writeObjectEnd(): void;
          public writeArrayStart(_name: string): void;
          public writeArrayStart(): void;
          public writeArrayEnd(): void;
          private convertToString(
            _e: Packages.java.lang.Enum<any>,
          ): string;
          protected convertToString(_object: any): string;
          public writeType(
            _type: Class | Packages.java.lang.Class<any>,
          ): void;
          protected ignoreUnknownField(
            _type: Class | Packages.java.lang.Class<any>,
            _fieldName: string,
          ): boolean;
          public prettyPrint(_json: string): string;
          public prettyPrint(
            _object: any,
            _singleLineColumns: number,
          ): string;
          public prettyPrint(_object: any): string;
          public prettyPrint(
            _json: string,
            _settings: Packages.arc.util.serialization.JsonValue.PrettyPrintSettings,
          ): string;
          public prettyPrint(
            _object: any,
            _settings: Packages.arc.util.serialization.JsonValue.PrettyPrintSettings,
          ): string;
          public prettyPrint(
            _json: string,
            _singleLineColumns: number,
          ): string;
          public getIgnoreUnknownFields(): boolean;
          public setIgnoreUnknownFields(
            _ignoreUnknownFields: boolean,
          ): void;
          public setIgnoreDeprecated(
            _ignoreDeprecated: boolean,
          ): void;
          public setReadDeprecated(
            _readDeprecated: boolean,
          ): void;
          public setEnumNames(_enumNames: boolean): void;
          public addClassTag(
            _tag: string,
            _type: Class | Packages.java.lang.Class<any>,
          ): void;
          public setTypeName(_typeName: string): void;
          public setDefaultSerializer(
            _defaultSerializer: Packages.arc.util.serialization.Json.Serializer<any>,
          ): void;
          public setSerializer<T>(
            _type: Class<T> | Packages.java.lang.Class<T>,
            _serializer: Packages.arc.util.serialization.Json.Serializer<T>,
          ): void;
          public getSerializer<T>(
            _type: Class<T> | Packages.java.lang.Class<T>,
          ): Packages.arc.util.serialization.Json.Serializer<T>;
          public setUsePrototypes(
            _usePrototypes: boolean,
          ): void;
          public setElementType(
            _type: Class | Packages.java.lang.Class<any>,
            _fieldName: string,
            _elementType:
              | Class
              | Packages.java.lang.Class<any>,
          ): void;
          public toUBJson(
            _object: any,
            _knownType:
              | Class
              | Packages.java.lang.Class<any>,
            _stream: Packages.java.io.OutputStream,
          ): void;
          public getWriter(): Packages.arc.util.serialization.BaseJsonWriter;
          public fromJson<T>(
            _type: Class<T> | Packages.java.lang.Class<T>,
            _reader: Packages.java.io.Reader,
          ): T | null;
          public fromJson<T>(
            _type: Class<T> | Packages.java.lang.Class<T>,
            _file: Packages.arc.files.Fi,
          ): T | null;
          public fromJson<T>(
            _type: Class<T> | Packages.java.lang.Class<T>,
            _data: string[],
            _offset: number,
            _length: number,
          ): T | null;
          public fromJson<T>(
            _type: Class<T> | Packages.java.lang.Class<T>,
            _elementType:
              | Class
              | Packages.java.lang.Class<any>,
            _json: string,
          ): T | null;
          public fromJson<T>(
            _type: Class<T> | Packages.java.lang.Class<T>,
            _json: string,
          ): T | null;
          public fromJson<T>(
            _type: Class<T> | Packages.java.lang.Class<T>,
            _elementType:
              | Class
              | Packages.java.lang.Class<any>,
            _data: string[],
            _offset: number,
            _length: number,
          ): T | null;
          public fromJson<T>(
            _type: Class<T> | Packages.java.lang.Class<T>,
            _elementType:
              | Class
              | Packages.java.lang.Class<any>,
            _reader: Packages.java.io.Reader,
          ): T | null;
          public fromJson<T>(
            _type: Class<T> | Packages.java.lang.Class<T>,
            _input: Packages.java.io.InputStream,
          ): T | null;
          public fromJson<T>(
            _type: Class<T> | Packages.java.lang.Class<T>,
            _elementType:
              | Class
              | Packages.java.lang.Class<any>,
            _input: Packages.java.io.InputStream,
          ): T | null;
          public fromJson<T>(
            _type: Class<T> | Packages.java.lang.Class<T>,
            _elementType:
              | Class
              | Packages.java.lang.Class<any>,
            _file: Packages.arc.files.Fi,
          ): T | null;
          public constructor();
          public constructor(
            _outputType: Packages.arc.util.serialization.JsonWriter.OutputType,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare class Long {}
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare class Settings extends java.lang.Object {
      protected static typeBool: string;
      protected static typeInt: string;
      protected static typeLong: string;
      protected static typeFloat: string;
      protected static typeString: string;
      protected static typeBinary: string;
      protected static maxBackups: number;
      protected dataDirectory: Packages.arc.files.Fi;
      protected appName: string;
      protected values: Packages.java.util.HashMap<
        string,
        any
      >;
      protected errorHandler: Packages.arc.func.Cons<Packages.java.lang.Throwable>;
      protected hasErrored: boolean;
      protected shouldAutosave: boolean;
      protected loaded: boolean;
      protected executor: Packages.java.util.concurrent.ExecutorService;
      protected byteStream: Packages.java.io.ByteArrayOutputStream;
      protected byteInputStream: Packages.arc.util.io.ReusableByteInStream;
      protected ureader: Packages.arc.util.serialization.UBJsonReader;
      protected json: Packages.arc.util.serialization.Json;
      public remove(_name: string): void;
      public get(_name: string, _def: any): any;
      public put(_name: string, _object: any): void;
      public getInt(_name: string): number;
      public getInt(_name: string, _def: number): number;
      public getLong(
        _name: string,
      ): Packages.java.lang.Long;
      public getLong(
        _name: string,
        _def: Packages.long,
      ): Packages.long;
      public getFloat(_name: string): number;
      public getFloat(_name: string, _def: number): number;
      public load(): void;
      public clear(): void;
      public getBytes(_name: string): string[] | null;
      public getBytes(
        _name: string,
        _def: string[],
      ): string[] | null;
      public getDefault(_name: string): any;
      public putAll(
        _map: Packages.arc.struct.ObjectMap<string, any>,
      ): void;
      public defaults(..._objects: any[]): void;
      public keys(): Packages.java.lang.Iterable<string>;
      public modified(): boolean;
      public getString(_name: string, _def: string): string;
      public getString(_name: string): string;
      public has(_name: string): boolean;
      public autosave(): void;
      public loadValues(): void;
      public loadValues(_file: Packages.arc.files.Fi): void;
      public saveValues(): void;
      public forceSave(): void;
      public getSettingsFile(): Packages.arc.files.Fi;
      public getBackupSettingsFile(): Packages.arc.files.Fi;
      public getBackupFolder(): Packages.arc.files.Fi;
      public getDataDirectory(): Packages.arc.files.Fi;
      public putJson(
        _name: string,
        _elementType:
          | Class<any>
          | Packages.java.lang.Class<any>,
        _value: any,
      ): void;
      public putJson(_name: string, _value: any): void;
      public getJson<T>(
        _name: string,
        _type: Class<T> | Packages.java.lang.Class<T>,
        _def: Packages.arc.func.Prov<T>,
      ): T | null;
      public getJson<T>(
        _name: string,
        _type: Class<T> | Packages.java.lang.Class<T>,
        _elementType: Class | Packages.java.lang.Class<any>,
        _def: Packages.arc.func.Prov<T>,
      ): T | null;
      public getBool(_name: string, _def: boolean): boolean;
      public getBool(_name: string): boolean;
      public setJson(
        _json: Packages.arc.util.serialization.Json,
      ): void;
      public getAppName(): string;
      public setAppName(_name: string): void;
      public setErrorHandler(
        _handler: Packages.arc.func.Cons<Packages.java.lang.Throwable>,
      ): void;
      public setAutosave(_autosave: boolean): void;
      public manualSave(): void;
      public setDataDirectory(
        _file: Packages.arc.files.Fi,
      ): void;
      public isModified(): boolean;
      public getBoolOnce(
        _name: string,
        _run: Packages.java.lang.Runnable,
      ): void;
      public getBoolOnce(_name: string): boolean;
      public keySize(): number;
      public constructor();
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare class KeyBinds extends java.lang.Object {
      public static Section = class extends java.lang
        .Object {
        public name: string;
        public binds: Packages.arc.struct.ObjectMap<
          Packages.arc.input.InputDevice.DeviceType,
          Packages.arc.struct.OrderedMap<
            Packages.arc.KeyBinds.KeyBind,
            Packages.arc.KeyBinds.Axis
          >
        >;
        public device: Packages.arc.input.InputDevice;
      };
      public static KeyBind = class {
        public name(): string;
        public defaultValue(
          _type: Packages.arc.input.InputDevice.DeviceType,
        ): Packages.arc.KeyBinds.KeybindValue;
        public category(): string;
      };
      public static KeybindValue = class {};
      public static Axis = class
        extends java.lang.Object
        implements Packages.arc.KeyBinds.KeybindValue
      {
        public min: Packages.arc.input.KeyCode;
        public max: Packages.arc.input.KeyCode;
        public key: Packages.arc.input.KeyCode;
        public equals(_o: any): boolean;
        public toString(): string;
        public constructor(
          _key: Packages.arc.input.KeyCode,
        );
        public constructor(
          _min: Packages.arc.input.KeyCode,
          _max: Packages.arc.input.KeyCode,
        );
      };
      private defaultSection: Packages.arc.KeyBinds.Section;
      private defaultCache: Packages.arc.struct.ObjectMap<
        Packages.arc.KeyBinds.KeyBind,
        Packages.arc.struct.ObjectMap<
          Packages.arc.input.InputDevice.DeviceType,
          Packages.arc.KeyBinds.Axis
        >
      >;
      private definitions: Packages.arc.KeyBinds.KeyBind[];
      private sections: Packages.arc.KeyBinds.Section[];
      public get(
        _name: Packages.arc.KeyBinds.KeyBind,
      ): Packages.arc.KeyBinds.Axis;
      public get(
        _section: Packages.arc.KeyBinds.Section,
        _def: Packages.arc.KeyBinds.KeyBind,
      ): Packages.arc.KeyBinds.Axis;
      public get(
        _section: Packages.arc.KeyBinds.Section,
        _type: Packages.arc.input.InputDevice.DeviceType,
        _def: Packages.arc.KeyBinds.KeyBind,
      ): Packages.arc.KeyBinds.Axis;
      private load(
        _name: string,
      ): Packages.arc.KeyBinds.Axis;
      load(): void;
      private save(
        _axis: Packages.arc.KeyBinds.Axis,
        _name: string,
      ): void;
      save(): void;
      public setDefaults(
        _defs: Packages.arc.KeyBinds.KeyBind[],
        ..._sectionArr: Packages.arc.KeyBinds.Section[]
      ): void;
      public resetToDefaults(): void;
      public resetToDefault(
        _section: Packages.arc.KeyBinds.Section,
        _bind: Packages.arc.KeyBinds.KeyBind,
      ): void;
      public getSections():
        | Packages.arc.KeyBinds.Section[]
        | null;
      public getKeybinds():
        | Packages.arc.KeyBinds.KeyBind[]
        | null;
      public constructor();
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare class Locale {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace text {
      declare class MessageFormat {}
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class TextFormatter extends java.lang.Object {
        private messageFormat: Packages.java.text.MessageFormat;
        private buffer: Packages.java.lang.StringBuilder;
        public format(
          _pattern: string,
          ..._args: any[]
        ): string;
        private replaceEscapeChars(
          _pattern: string,
        ): string;
        private simpleFormat(
          _pattern: string,
          ..._args: any[]
        ): string;
        public constructor(
          _locale: Packages.java.util.Locale,
          _useMessageFormat: boolean,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class I18NBundle extends java.lang.Object {
        private static DEFAULT_ENCODING: string;
        private static ROOT_LOCALE: Packages.java.util.Locale;
        private static simpleFormatter: boolean;
        private parent: Packages.arc.util.I18NBundle;
        private locale: Packages.java.util.Locale;
        private properties: Packages.arc.struct.ObjectMap<
          string,
          string
        >;
        private formatter: Packages.arc.util.TextFormatter;
        public get(_key: string): string;
        public get(_key: string, _def: string): string;
        private load(
          _reader: Packages.java.io.Reader,
        ): void;
        public format(
          _key: string,
          ..._args: any[]
        ): string;
        public getParent(): Packages.arc.util.I18NBundle;
        public getProperties(): Packages.arc.struct.ObjectMap<
          string,
          string
        >;
        public setProperties(
          _properties: Packages.arc.struct.ObjectMap<
            string,
            string
          >,
        ): void;
        public debug(_placeholder: string): void;
        public getLocale(): Packages.java.util.Locale;
        private setLocale(
          _locale: Packages.java.util.Locale,
        ): void;
        public getKeys(): Packages.java.lang.Iterable<string>;
        private static getCandidateLocales(
          _locale: Packages.java.util.Locale,
        ): Packages.arc.struct.Seq<Packages.java.util.Locale>;
        private static getFallbackLocale(
          _locale: Packages.java.util.Locale,
        ): Packages.java.util.Locale;
        private static loadBundle(
          _baseFileHandle: Packages.arc.files.Fi,
          _encoding: string,
          _targetLocale: Packages.java.util.Locale,
        ): Packages.arc.util.I18NBundle;
        public has(_key: string): boolean;
        public static createEmptyBundle(): Packages.arc.util.I18NBundle;
        public formatString(
          _string: string,
          ..._args: any[]
        ): string;
        public formatFloat(
          _key: string,
          _value: number,
          _places: number,
        ): string;
        private static createBundleImpl(
          _baseFileHandle: Packages.arc.files.Fi,
          _locale: Packages.java.util.Locale,
          _encoding: string,
        ): Packages.arc.util.I18NBundle;
        private static loadBundleChain(
          _baseFileHandle: Packages.arc.files.Fi,
          _encoding: string,
          _candidateLocales: Packages.arc.struct.Seq<Packages.java.util.Locale>,
          _candidateIndex: number,
          _baseBundle: Packages.arc.util.I18NBundle,
        ): Packages.arc.util.I18NBundle;
        private static toFileHandle(
          _baseFileHandle: Packages.arc.files.Fi,
          _locale: Packages.java.util.Locale,
        ): Packages.arc.files.Fi;
        private static checkFileExistence(
          _fh: Packages.arc.files.Fi,
        ): boolean;
        public getOrNull(_key: string): string;
        public static getSimpleFormatter(): boolean;
        public static setSimpleFormatter(
          _enabled: boolean,
        ): void;
        public static createBundle(
          _baseFileHandle: Packages.arc.files.Fi,
          _encoding: string,
        ): Packages.arc.util.I18NBundle;
        public static createBundle(
          _baseFileHandle: Packages.arc.files.Fi,
        ): Packages.arc.util.I18NBundle;
        public static createBundle(
          _baseFileHandle: Packages.arc.files.Fi,
          _locale: Packages.java.util.Locale,
          _encoding: string,
        ): Packages.arc.util.I18NBundle;
        public static createBundle(
          _baseFileHandle: Packages.arc.files.Fi,
          _locale: Packages.java.util.Locale,
        ): Packages.arc.util.I18NBundle;
        public getNotNull(_key: string): string;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare abstract class Shape2D {
          public contains(
            _point: Packages.arc.math.geom.Vec2,
          ): boolean;
          public contains(_x: number, _y: number): boolean;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class Circle
          extends java.lang.Object
          implements Packages.arc.math.geom.Shape2D
        {
          public x: number;
          public y: number;
          public radius: number;
          public equals(_o: any): boolean;
          public toString(): string;
          public hashCode(): number;
          public contains(_x: number, _y: number): boolean;
          public contains(
            _c: Packages.arc.math.geom.Circle,
          ): boolean;
          public contains(
            _point: Packages.arc.math.geom.Vec2,
          ): boolean;
          public set(
            _position: Packages.arc.math.geom.Vec2,
            _radius: number,
          ): Packages.arc.math.geom.Circle;
          public set(
            _center: Packages.arc.math.geom.Vec2,
            _edge: Packages.arc.math.geom.Vec2,
          ): Packages.arc.math.geom.Circle;
          public set(
            _x: number,
            _y: number,
            _radius: number,
          ): Packages.arc.math.geom.Circle;
          public set(
            _circle: Packages.arc.math.geom.Circle,
          ): Packages.arc.math.geom.Circle;
          public setPosition(
            _x: number,
            _y: number,
          ): Packages.arc.math.geom.Circle;
          public setPosition(
            _position: Packages.arc.math.geom.Vec2,
          ): Packages.arc.math.geom.Circle;
          public setX(_x: number): void;
          public setY(_y: number): void;
          public overlaps(
            _c: Packages.arc.math.geom.Circle,
          ): boolean;
          public area(): number;
          public setRadius(_radius: number): void;
          public circumference(): number;
          public constructor(
            _center: Packages.arc.math.geom.Vec2,
            _edge: Packages.arc.math.geom.Vec2,
          );
          public constructor(
            _circle: Packages.arc.math.geom.Circle,
          );
          public constructor(
            _position: Packages.arc.math.geom.Vec2,
            _radius: number,
          );
          public constructor(
            _x: number,
            _y: number,
            _radius: number,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class Rect
          extends java.lang.Object
          implements Packages.arc.math.geom.Shape2D
        {
          public static tmp: Packages.arc.math.geom.Rect;
          public static tmp2: Packages.arc.math.geom.Rect;
          public x: number;
          public y: number;
          public width: number;
          public height: number;
          public equals(_obj: any): boolean;
          public toString(): string;
          public hashCode(): number;
          public contains(
            _point: Packages.arc.math.geom.Vec2,
          ): boolean;
          public contains(
            _rect: Packages.arc.math.geom.Rect,
          ): boolean;
          public static contains(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
            _px: number,
            _py: number,
          ): boolean;
          public contains(_x: number, _y: number): boolean;
          public contains(
            _circle: Packages.arc.math.geom.Circle,
          ): boolean;
          public merge(
            _vecs: Packages.arc.math.geom.Vec2[],
          ): Packages.arc.math.geom.Rect;
          public merge(
            _vec: Packages.arc.math.geom.Vec2,
          ): Packages.arc.math.geom.Rect;
          public merge(
            _x: number,
            _y: number,
          ): Packages.arc.math.geom.Rect;
          public merge(
            _rect: Packages.arc.math.geom.Rect,
          ): Packages.arc.math.geom.Rect;
          public set(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          ): Packages.arc.math.geom.Rect;
          public set(
            _rect: Packages.arc.math.geom.Rect,
          ): Packages.arc.math.geom.Rect;
          public getSize(
            _size: Packages.arc.math.geom.Vec2,
          ): Packages.arc.math.geom.Vec2;
          public normalize(): Packages.arc.math.geom.Rect;
          public grow(
            _amountX: number,
            _amountY: number,
          ): Packages.arc.math.geom.Rect;
          public grow(
            _amount: number,
          ): Packages.arc.math.geom.Rect;
          public move(
            _cx: number,
            _cy: number,
          ): Packages.arc.math.geom.Rect;
          public setSize(
            _width: number,
            _height: number,
          ): Packages.arc.math.geom.Rect;
          public setSize(
            _sizeXY: number,
          ): Packages.arc.math.geom.Rect;
          public getX(): number;
          public getY(): number;
          public fromString(
            _v: string,
          ): Packages.arc.math.geom.Rect;
          public getWidth(): number;
          public getHeight(): number;
          public setCenter(
            _position: Packages.arc.math.geom.Vec2,
          ): Packages.arc.math.geom.Rect;
          public setCenter(
            _x: number,
            _y: number,
          ): Packages.arc.math.geom.Rect;
          public getPosition(
            _position: Packages.arc.math.geom.Vec2,
          ): Packages.arc.math.geom.Vec2;
          public setPosition(
            _position: Packages.arc.math.geom.Vec2,
          ): Packages.arc.math.geom.Rect;
          public setPosition(
            _x: number,
            _y: number,
          ): Packages.arc.math.geom.Rect;
          public getAspectRatio(): number;
          public setCentered(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          ): Packages.arc.math.geom.Rect;
          public setCentered(
            _x: number,
            _y: number,
            _size: number,
          ): Packages.arc.math.geom.Rect;
          public setX(
            _x: number,
          ): Packages.arc.math.geom.Rect;
          public setY(
            _y: number,
          ): Packages.arc.math.geom.Rect;
          public setWidth(
            _width: number,
          ): Packages.arc.math.geom.Rect;
          public setHeight(
            _height: number,
          ): Packages.arc.math.geom.Rect;
          public overlaps(
            _r: Packages.arc.math.geom.Rect,
          ): boolean;
          public overlaps(
            _rx: number,
            _ry: number,
            _rwidth: number,
            _rheight: number,
          ): boolean;
          public getCenter(
            _vector: Packages.arc.math.geom.Vec2,
          ): Packages.arc.math.geom.Vec2;
          public fitOutside(
            _rect: Packages.arc.math.geom.Rect,
          ): Packages.arc.math.geom.Rect;
          public fitInside(
            _rect: Packages.arc.math.geom.Rect,
          ): Packages.arc.math.geom.Rect;
          public area(): number;
          public perimeter(): number;
          public constructor(
            _rect: Packages.arc.math.geom.Rect,
          );
          public constructor(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare class Camera extends java.lang.Object {
        private static tmpVector: Packages.arc.math.geom.Vec2;
        public position: Packages.arc.math.geom.Vec2;
        public mat: Packages.arc.math.Mat;
        public inv: Packages.arc.math.Mat;
        public width: number;
        public height: number;
        public update(): void;
        public bounds(
          _out: Packages.arc.math.geom.Rect,
        ): Packages.arc.math.geom.Rect;
        public resize(
          _viewportWidth: number,
          _viewportHeight: number,
        ): void;
        public unproject(
          _screenX: number,
          _screenY: number,
        ): Packages.arc.math.geom.Vec2;
        public unproject(
          _screenCoords: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.geom.Vec2;
        public unproject(
          _screenCoords: Packages.arc.math.geom.Vec2,
          _viewportX: number,
          _viewportY: number,
          _viewportWidth: number,
          _viewportHeight: number,
        ): Packages.arc.math.geom.Vec2;
        public project(
          _worldCoords: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.geom.Vec2;
        public project(
          _worldCoords: Packages.arc.math.geom.Vec2,
          _viewportX: number,
          _viewportY: number,
          _viewportWidth: number,
          _viewportHeight: number,
        ): Packages.arc.math.geom.Vec2;
        public project(
          _screenX: number,
          _screenY: number,
        ): Packages.arc.math.geom.Vec2;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare abstract class TextureData {
        public static load(
          _file: Packages.arc.files.Fi,
          _useMipMaps: boolean,
        ): Packages.arc.graphics.TextureData;
        public prepare(): void;
        public getFormat(): Packages.arc.graphics.Pixmap.Format;
        public getWidth(): number;
        public getHeight(): number;
        public useMipMaps(): boolean;
        public getPixmap(): Packages.arc.graphics.Pixmap;
        public disposePixmap(): boolean;
        public isPrepared(): boolean;
        public isCustom(): boolean;
        public consumeCustomData(_target: number): void;
        public consumePixmap(): Packages.arc.graphics.Pixmap;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare abstract class GLTexture
        extends java.lang.Object
        implements Packages.arc.util.Disposable
      {
        public glTarget: number;
        public width: number;
        public height: number;
        protected glHandle: number;
        protected minFilter: Packages.arc.graphics.Texture.TextureFilter;
        protected magFilter: Packages.arc.graphics.Texture.TextureFilter;
        protected uWrap: Packages.arc.graphics.Texture.TextureWrap;
        protected vWrap: Packages.arc.graphics.Texture.TextureWrap;
        public bind(_unit: number): void;
        public bind(): void;
        public setFilter(
          _minFilter: Packages.arc.graphics.Texture.TextureFilter,
          _magFilter: Packages.arc.graphics.Texture.TextureFilter,
        ): void;
        public setFilter(
          _filter: Packages.arc.graphics.Texture.TextureFilter,
        ): void;
        public dispose(): void;
        public setWrap(
          _u: Packages.arc.graphics.Texture.TextureWrap,
          _v: Packages.arc.graphics.Texture.TextureWrap,
        ): void;
        public setWrap(
          _wrap: Packages.arc.graphics.Texture.TextureWrap,
        ): void;
        protected static uploadImageData(
          _target: number,
          _data: Packages.arc.graphics.TextureData,
        ): void;
        public static uploadImageData(
          _target: number,
          _data: Packages.arc.graphics.TextureData,
          _miplevel: number,
        ): void;
        public unsafeSetFilter(
          _minFilter: Packages.arc.graphics.Texture.TextureFilter,
          _magFilter: Packages.arc.graphics.Texture.TextureFilter,
          _force: boolean,
        ): void;
        public unsafeSetFilter(
          _minFilter: Packages.arc.graphics.Texture.TextureFilter,
          _magFilter: Packages.arc.graphics.Texture.TextureFilter,
        ): void;
        public unsafeSetWrap(
          _u: Packages.arc.graphics.Texture.TextureWrap,
          _v: Packages.arc.graphics.Texture.TextureWrap,
          _force: boolean,
        ): void;
        public unsafeSetWrap(
          _u: Packages.arc.graphics.Texture.TextureWrap,
          _v: Packages.arc.graphics.Texture.TextureWrap,
        ): void;
        public getDepth(): number;
        public getMinFilter(): Packages.arc.graphics.Texture.TextureFilter;
        public getMagFilter(): Packages.arc.graphics.Texture.TextureFilter;
        public getUWrap(): Packages.arc.graphics.Texture.TextureWrap;
        public getVWrap(): Packages.arc.graphics.Texture.TextureWrap;
        public getTextureObjectHandle(): number;
        public constructor(_glTarget: number);
        public constructor(
          _glTarget: number,
          _glHandle: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare class Texture extends Packages.arc.graphics
        .GLTexture {
        public static TextureFilter = class extends Packages
          .java.lang
          .Enum<Packages.arc.graphics.Texture.TextureFilter> {
          public static nearest: Packages.arc.graphics.Texture.TextureFilter;
          public static linear: Packages.arc.graphics.Texture.TextureFilter;
          public static mipMap: Packages.arc.graphics.Texture.TextureFilter;
          public static mipMapNearestNearest: Packages.arc.graphics.Texture.TextureFilter;
          public static mipMapLinearNearest: Packages.arc.graphics.Texture.TextureFilter;
          public static mipMapNearestLinear: Packages.arc.graphics.Texture.TextureFilter;
          public static mipMapLinearLinear: Packages.arc.graphics.Texture.TextureFilter;
          public static all: Packages.arc.graphics.Texture.TextureFilter[];
          public glEnum: number;
          private static $VALUES: Packages.arc.graphics.Texture.TextureFilter[];
          public static values():
            | Packages.arc.graphics.Texture.TextureFilter[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.arc.graphics.Texture.TextureFilter;
          public isMipMap(): boolean;
        };
        public static TextureWrap = class extends Packages
          .java.lang
          .Enum<Packages.arc.graphics.Texture.TextureWrap> {
          public static mirroredRepeat: Packages.arc.graphics.Texture.TextureWrap;
          public static clampToEdge: Packages.arc.graphics.Texture.TextureWrap;
          public static repeat: Packages.arc.graphics.Texture.TextureWrap;
          public static all: Packages.arc.graphics.Texture.TextureWrap[];
          glEnum: number;
          private static $VALUES: Packages.arc.graphics.Texture.TextureWrap[];
          public static values():
            | Packages.arc.graphics.Texture.TextureWrap[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.arc.graphics.Texture.TextureWrap;
          public getGLEnum(): number;
        };
        data: Packages.arc.graphics.TextureData;
        public toString(): string;
        public load(
          _data: Packages.arc.graphics.TextureData,
        ): void;
        public static createEmpty(
          _data: Packages.arc.graphics.TextureData,
        ): Packages.arc.graphics.Texture;
        public isDisposed(): boolean;
        public draw(
          _pixmap: Packages.arc.graphics.Pixmap,
        ): void;
        public draw(
          _pixmap: Packages.arc.graphics.Pixmap,
          _x: number,
          _y: number,
        ): void;
        public getTextureData(): Packages.arc.graphics.TextureData;
        public getDepth(): number;
        public constructor(
          _pixmap: Packages.arc.graphics.Pixmap,
          _useMipMaps: boolean,
        );
        public constructor(_width: number, _height: number);
        public constructor(
          _data: Packages.arc.graphics.TextureData,
        );
        public constructor(_internalPath: string);
        public constructor(_file: Packages.arc.files.Fi);
        public constructor(
          _file: Packages.arc.files.Fi,
          _useMipMaps: boolean,
        );
        public constructor(
          _pixmap: Packages.arc.graphics.Pixmap,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare class Blending extends java.lang.Object {
        public static normal: Packages.arc.graphics.Blending;
        public static additive: Packages.arc.graphics.Blending;
        public static disabled: Packages.arc.graphics.Blending;
        public src: number;
        public dst: number;
        public srcAlpha: number;
        public dstAlpha: number;
        public apply(): void;
        public constructor(_src: number, _dst: number);
        public constructor(
          _src: number,
          _dst: number,
          _srcAlpha: number,
          _dstAlpha: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class ObjectIntMap<K>
        extends java.lang.Object
        implements
          Packages.java.lang.Iterable<
            Packages.arc.struct.ObjectIntMap.Entry<K>
          >
      {
        public static Entries = class<K>
          extends Packages.arc.struct.ObjectIntMap
            .MapIterator<K>
          implements
            Packages.java.lang.Iterable<
              Packages.arc.struct.ObjectIntMap.Entry<K>
            >,
            Packages.java.util.Iterator<
              Packages.arc.struct.ObjectIntMap.Entry<K>
            >
        {
          private entry: Packages.arc.struct.ObjectIntMap.Entry<K>;
          public remove(): void;
          public toArray(): Packages.arc.struct.Seq<
            Packages.arc.struct.ObjectIntMap.Entry<K>
          >;
          public iterator(): Packages.arc.struct.ObjectIntMap.Entries<K>;
          public iterator(): Packages.java.util.Iterator<any>;
          public hasNext(): boolean;
          public next(): any;
          public next(): Packages.arc.struct.ObjectIntMap.Entry<K>;
          public reset(): void;
          public constructor(
            _map: Packages.arc.struct.ObjectIntMap<K>,
          );
        };
        public static Entry = class<K> extends java.lang
          .Object {
          public key: K;
          public value: number;
          public toString(): string;
          public constructor();
        };
        public static Values = class extends Packages.arc
          .struct.ObjectIntMap.MapIterator<any> {
          public remove(): void;
          public toArray(): Packages.arc.struct.IntSeq;
          public hasNext(): boolean;
          public next(): number;
          public reset(): void;
          public constructor(
            _map: Packages.arc.struct.ObjectIntMap<any>,
          );
        };
        public static Keys = class<K>
          extends Packages.arc.struct.ObjectIntMap
            .MapIterator<K>
          implements
            Packages.java.util.Iterator<K>,
            Packages.java.lang.Iterable<K>
        {
          public remove(): void;
          public toArray(): Packages.arc.struct.Seq<K>;
          public toArray(
            _array: Packages.arc.struct.Seq<K>,
          ): Packages.arc.struct.Seq<K>;
          public iterator(): Packages.java.util.Iterator<any>;
          public iterator(): Packages.arc.struct.ObjectIntMap.Keys<K>;
          public hasNext(): boolean;
          public next(): K | null;
          public reset(): void;
          public constructor(
            _map: Packages.arc.struct.ObjectIntMap<K>,
          );
        };
        private static MapIterator = class<K> extends java
          .lang.Object {
          map: Packages.arc.struct.ObjectIntMap<K>;
          public hasNext: boolean;
          nextIndex: number;
          currentIndex: number;
          valid: boolean;
          public remove(): void;
          public reset(): void;
          findNextIndex(): void;
          public constructor(
            _map: Packages.arc.struct.ObjectIntMap<K>,
          );
        };
        private static PRIME1: number;
        private static PRIME2: number;
        private static PRIME3: number;
        public size: number;
        keyTable: K[];
        valueTable: number[];
        capacity: number;
        stashSize: number;
        private loadFactor: number;
        private hashShift: number;
        private mask: number;
        private threshold: number;
        private stashCapacity: number;
        private pushIterations: number;
        private entries1: Packages.arc.struct.ObjectIntMap.Entries<any>;
        private entries2: Packages.arc.struct.ObjectIntMap.Entries<any>;
        private values1: Packages.arc.struct.ObjectIntMap.Values;
        private values2: Packages.arc.struct.ObjectIntMap.Values;
        private keys1: Packages.arc.struct.ObjectIntMap.Keys<any>;
        private keys2: Packages.arc.struct.ObjectIntMap.Keys<any>;
        public remove(_key: K): number;
        public remove(
          _key: K,
          _defaultValue: number,
        ): number;
        public get(_key: K, _defaultValue: number): number;
        public get(_key: K): number;
        public put(_key: K, _value: number): void;
        public equals(_obj: any): boolean;
        public toString(): string;
        public values(): Packages.arc.struct.ObjectIntMap.Values;
        public hashCode(): number;
        public clear(_maximumCapacity: number): void;
        public clear(): void;
        public isEmpty(): boolean;
        public iterator(): Packages.java.util.Iterator<any>;
        public iterator(): Packages.arc.struct.ObjectIntMap.Entries<K>;
        public putAll(..._values: any[]): void;
        public putAll(
          _map: Packages.arc.struct.ObjectIntMap<any>,
        ): void;
        public increment(_key: K, _amount: number): number;
        public increment(_key: K): number;
        public increment(
          _key: K,
          _defaultValue: number,
          _increment: number,
        ): number;
        public containsKey(_key: K): boolean;
        public keys(): Packages.arc.struct.ObjectIntMap.Keys<K>;
        public containsValue(_value: number): boolean;
        public entries(): Packages.arc.struct.ObjectIntMap.Entries<K>;
        public ensureCapacity(
          _additionalCapacity: number,
        ): void;
        private resize(_newSize: number): void;
        private push(
          _insertKey: K,
          _insertValue: number,
          _index1: number,
          _key1: K,
          _index2: number,
          _key2: K,
          _index3: number,
          _key3: K,
        ): void;
        public shrink(_maximumCapacity: number): void;
        private hash2(_h: number): number;
        private hash3(_h: number): number;
        private putStash(_key: K, _value: number): void;
        private putResize(_key: K, _value: number): void;
        private getStash(
          _key: K,
          _defaultValue: number,
        ): number;
        removeStash(_key: K, _defaultValue: number): number;
        removeStashIndex(_index: number): void;
        private containsKeyStash(_key: K): boolean;
        public findKey(_value: number): K | null;
        private getAndIncrementStash(
          _key: K,
          _defaultValue: number,
          _increment: number,
        ): number;
        public constructor(
          _map: Packages.arc.struct.ObjectIntMap<any>,
        );
        public constructor(
          _initialCapacity: number,
          _loadFactor: number,
        );
        public constructor(_initialCapacity: number);
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace gl {
        declare class Shader
          extends java.lang.Object
          implements Packages.arc.util.Disposable
        {
          public static positionAttribute: string;
          public static normalAttribute: string;
          public static colorAttribute: string;
          public static mixColorAttribute: string;
          public static texcoordAttribute: string;
          public static pedantic: boolean;
          public static prependVertexCode: string;
          public static prependFragmentCode: string;
          private uniforms: Packages.arc.struct.ObjectIntMap<string>;
          private uniformTypes: Packages.arc.struct.ObjectIntMap<string>;
          private uniformSizes: Packages.arc.struct.ObjectIntMap<string>;
          private attributes: Packages.arc.struct.ObjectIntMap<string>;
          private attributeTypes: Packages.arc.struct.ObjectIntMap<string>;
          private attributeSizes: Packages.arc.struct.ObjectIntMap<string>;
          private vertexShaderSource: string;
          private fragmentShaderSource: string;
          params: Packages.java.nio.IntBuffer;
          type: Packages.java.nio.IntBuffer;
          private log: string;
          private uniformNames: string[];
          private attributeNames: string[];
          private program: number;
          private vertexShaderHandle: number;
          private fragmentShaderHandle: number;
          private disposed: boolean;
          private static val: number[];
          public apply(): void;
          public isCompiled(): boolean;
          public getAttributes(): string[] | null;
          public bind(): void;
          public dispose(): void;
          public isDisposed(): boolean;
          public setUniformMatrix4(
            _name: string,
            _val: number[],
          ): void;
          public setUniformMatrix4(
            _name: string,
            _mat: Packages.arc.math.Mat,
          ): void;
          public setUniformMatrix4(
            _name: string,
            _mat: Packages.arc.math.Mat,
            _near: number,
            _far: number,
          ): void;
          protected preprocess(
            _source: string,
            _fragment: boolean,
          ): string;
          private compileShaders(
            _vertexShader: string,
            _fragmentShader: string,
          ): void;
          private fetchAttributes(): void;
          private fetchUniforms(): void;
          private loadShader(
            _type: number,
            _source: string,
          ): number;
          protected createProgram(): number;
          private linkProgram(_program: number): number;
          public fetchUniformLocation(
            _name: string,
            _pedantic: boolean,
          ): number;
          private fetchUniformLocation(
            _name: string,
          ): number;
          public getUniformLocation(_name: string): number;
          public setUniformMatrix(
            _location: number,
            _matrix: Packages.arc.math.Mat,
            _transpose: boolean,
          ): void;
          public setUniformMatrix(
            _name: string,
            _matrix: Packages.arc.math.Mat,
            _transpose: boolean,
          ): void;
          public setUniformMatrix(
            _location: number,
            _matrix: Packages.arc.math.Mat,
          ): void;
          public setUniformMatrix(
            _name: string,
            _matrix: Packages.arc.math.Mat,
          ): void;
          public static copyTransform(
            _matrix: Packages.arc.math.Mat,
            _near: number,
            _far: number,
          ): number[] | null;
          public static copyTransform(
            _matrix: Packages.arc.math.Mat,
          ): number[] | null;
          public setUniformMatrix4fv(
            _name: string,
            _buffer: Packages.java.nio.FloatBuffer,
            _count: number,
            _transpose: boolean,
          ): void;
          public setUniformMatrix4fv(
            _name: string,
            _values: number[],
            _offset: number,
            _length: number,
          ): void;
          public setUniformMatrix4fv(
            _location: number,
            _values: number[],
            _offset: number,
            _length: number,
          ): void;
          public setUniformf(
            _location: number,
            _value: number,
          ): void;
          public setUniformf(
            _name: string,
            _value1: number,
            _value2: number,
          ): void;
          public setUniformf(
            _name: string,
            _value: number,
          ): void;
          public setUniformf(
            _location: number,
            _values: Packages.arc.graphics.Color,
          ): void;
          public setUniformf(
            _name: string,
            _values: Packages.arc.graphics.Color,
          ): void;
          public setUniformf(
            _location: number,
            _values: Packages.arc.math.geom.Vec3,
          ): void;
          public setUniformf(
            _name: string,
            _values: Packages.arc.math.geom.Vec3,
          ): void;
          public setUniformf(
            _location: number,
            _values: Packages.arc.math.geom.Vec2,
          ): void;
          public setUniformf(
            _name: string,
            _values: Packages.arc.math.geom.Vec2,
          ): void;
          public setUniformf(
            _location: number,
            _value1: number,
            _value2: number,
            _value3: number,
            _value4: number,
          ): void;
          public setUniformf(
            _name: string,
            _value1: number,
            _value2: number,
            _value3: number,
            _value4: number,
          ): void;
          public setUniformf(
            _location: number,
            _value1: number,
            _value2: number,
            _value3: number,
          ): void;
          public setUniformf(
            _location: number,
            _value1: number,
            _value2: number,
          ): void;
          public setUniformf(
            _name: string,
            _value1: number,
            _value2: number,
            _value3: number,
          ): void;
          private fetchAttributeLocation(
            _name: string,
          ): number;
          public getLog(): string;
          public setUniformi(
            _name: string,
            _value1: number,
            _value2: number,
          ): void;
          public setUniformi(
            _location: number,
            _value1: number,
            _value2: number,
          ): void;
          public setUniformi(
            _name: string,
            _value: number,
          ): void;
          public setUniformi(
            _location: number,
            _value1: number,
            _value2: number,
            _value3: number,
          ): void;
          public setUniformi(
            _location: number,
            _value: number,
          ): void;
          public setUniformi(
            _location: number,
            _value1: number,
            _value2: number,
            _value3: number,
            _value4: number,
          ): void;
          public setUniformi(
            _name: string,
            _value1: number,
            _value2: number,
            _value3: number,
            _value4: number,
          ): void;
          public setUniformi(
            _name: string,
            _value1: number,
            _value2: number,
            _value3: number,
          ): void;
          public setUniform1fv(
            _location: number,
            _values: number[],
            _offset: number,
            _length: number,
          ): void;
          public setUniform1fv(
            _name: string,
            _values: number[],
            _offset: number,
            _length: number,
          ): void;
          public setUniform2fv(
            _name: string,
            _values: number[],
            _offset: number,
            _length: number,
          ): void;
          public setUniform2fv(
            _location: number,
            _values: number[],
            _offset: number,
            _length: number,
          ): void;
          public setUniform3fv(
            _name: string,
            _values: number[],
            _offset: number,
            _length: number,
          ): void;
          public setUniform3fv(
            _location: number,
            _values: number[],
            _offset: number,
            _length: number,
          ): void;
          public setUniform4fv(
            _name: string,
            _values: number[],
            _offset: number,
            _length: number,
          ): void;
          public setUniform4fv(
            _location: number,
            _values: number[],
            _offset: number,
            _length: number,
          ): void;
          public setUniformMatrix3fv(
            _name: string,
            _buffer: Packages.java.nio.FloatBuffer,
            _count: number,
            _transpose: boolean,
          ): void;
          public disableVertexAttribute(
            _name: string,
          ): void;
          public hasAttribute(_name: string): boolean;
          public getAttributeType(_name: string): number;
          public getAttributeLocation(
            _name: string,
          ): number;
          public getAttributeSize(_name: string): number;
          public hasUniform(_name: string): boolean;
          public getUniformType(_name: string): number;
          public getUniformSize(_name: string): number;
          public getUniforms(): string[] | null;
          public getVertexShaderSource(): string;
          public getFragmentShaderSource(): string;
          public constructor(
            _vertexShader: string,
            _fragmentShader: string,
          );
          public constructor(
            _vertexShader: Packages.arc.files.Fi,
            _fragmentShader: Packages.arc.files.Fi,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace g2d {
        declare class TextureRegion extends java.lang
          .Object {
          public texture: Packages.arc.graphics.Texture;
          public u: number;
          public v: number;
          public u2: number;
          public v2: number;
          public width: number;
          public height: number;
          public scale: number;
          public toString(): string;
          public static split(
            _texture: Packages.arc.graphics.Texture,
            _tileWidth: number,
            _tileHeight: number,
          ):
            | Packages.arc.graphics.g2d.TextureRegion[][]
            | null;
          public split(
            _tileWidth: number,
            _tileHeight: number,
          ):
            | Packages.arc.graphics.g2d.TextureRegion[][]
            | null;
          public scl(): number;
          public set(
            _texture: Packages.arc.graphics.Texture,
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          ): void;
          public set(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          ): void;
          public set(
            _region: Packages.arc.graphics.g2d.TextureRegion,
          ): void;
          public set(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          ): Packages.arc.graphics.g2d.TextureRegion;
          public set(
            _texture: Packages.arc.graphics.Texture,
          ): void;
          public set(
            _u: number,
            _v: number,
            _u2: number,
            _v2: number,
          ): void;
          public flip(_x: boolean, _y: boolean): void;
          public found(): boolean;
          public getX(): number;
          public getY(): number;
          public scroll(
            _xAmount: number,
            _yAmount: number,
          ): void;
          public setX(_x: number): void;
          public setX(_x: number): void;
          public setY(_y: number): void;
          public setY(_y: number): void;
          public setWidth(_width: number): void;
          public setWidth(_width: number): void;
          public setHeight(_height: number): void;
          public setHeight(_height: number): void;
          public ratio(): number;
          public setV(_v: number): void;
          public isFlipX(): boolean;
          public setU2(_u2: number): void;
          public isFlipY(): boolean;
          public setV2(_v2: number): void;
          public asAtlas(): Packages.arc.graphics.g2d.TextureAtlas.AtlasRegion;
          public setU(_u: number): void;
          public constructor(
            _texture: Packages.arc.graphics.Texture,
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          );
          public constructor(
            _texture: Packages.arc.graphics.Texture,
            _u: number,
            _v: number,
            _u2: number,
            _v2: number,
          );
          public constructor(
            _region: Packages.arc.graphics.g2d.TextureRegion,
          );
          public constructor(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          );
          public constructor();
          public constructor(
            _texture: Packages.arc.graphics.Texture,
          );
          public constructor(
            _texture: Packages.arc.graphics.Texture,
            _width: number,
            _height: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace g2d {
        declare abstract class Batch
          extends java.lang.Object
          implements Packages.arc.util.Disposable
        {
          protected idx: number;
          protected lastTexture: Packages.arc.graphics.Texture;
          protected apply: boolean;
          protected transformMatrix: Packages.arc.math.Mat;
          protected projectionMatrix: Packages.arc.math.Mat;
          protected combinedMatrix: Packages.arc.math.Mat;
          protected blending: Packages.arc.graphics.Blending;
          protected shader: Packages.arc.graphics.gl.Shader;
          protected customShader: Packages.arc.graphics.gl.Shader;
          protected ownsShader: boolean;
          protected colorPacked: number;
          protected mixColorPacked: number;
          protected flush(): void;
          protected z(_z: number): void;
          public dispose(): void;
          protected draw(
            _texture: Packages.arc.graphics.Texture,
            _spriteVertices: number[],
            _offset: number,
            _count: number,
          ): void;
          protected draw(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _x: number,
            _y: number,
            _originX: number,
            _originY: number,
            _width: number,
            _height: number,
            _rotation: number,
          ): void;
          protected draw(
            _request: Packages.java.lang.Runnable,
          ): void;
          protected getShader(): Packages.arc.graphics.gl.Shader;
          protected setShader(
            _shader: Packages.arc.graphics.gl.Shader,
            _apply: boolean,
          ): void;
          protected setShader(
            _shader: Packages.arc.graphics.gl.Shader,
          ): void;
          protected setSort(_sort: boolean): void;
          protected setPackedColor(
            _packedColor: number,
          ): void;
          protected getPackedColor(): number;
          protected setPackedMixColor(
            _packedColor: number,
          ): void;
          protected getPackedMixColor(): number;
          protected discard(): void;
          protected setBlending(
            _blending: Packages.arc.graphics.Blending,
          ): void;
          protected getBlending(): Packages.arc.graphics.Blending;
          protected getProjection(): Packages.arc.math.Mat;
          protected getTransform(): Packages.arc.math.Mat;
          protected setProjection(
            _projection: Packages.arc.math.Mat,
          ): void;
          protected setTransform(
            _transform: Packages.arc.math.Mat,
          ): void;
          protected setupMatrices(): void;
          protected switchTexture(
            _texture: Packages.arc.graphics.Texture,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace event {
        declare class Touchable extends Packages.java.lang
          .Enum<Packages.arc.scene.event.Touchable> {
          public static enabled: Packages.arc.scene.event.Touchable;
          public static disabled: Packages.arc.scene.event.Touchable;
          public static childrenOnly: Packages.arc.scene.event.Touchable;
          private static $VALUES: Packages.arc.scene.event.Touchable[];
          public static values():
            | Packages.arc.scene.event.Touchable[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.arc.scene.event.Touchable;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace utils {
        declare abstract class Cullable {
          public setCullingArea(
            _cullingArea: Packages.arc.math.geom.Rect,
          ): void;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace style {
        declare abstract class Drawable {
          public draw(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          ): void;
          public draw(
            _x: number,
            _y: number,
            _originX: number,
            _originY: number,
            _width: number,
            _height: number,
            _scaleX: number,
            _scaleY: number,
            _rotation: number,
          ): void;
          public imageSize(): number;
          public getTopHeight(): number;
          public getLeftWidth(): number;
          public getBottomHeight(): number;
          public getRightWidth(): number;
          public getMinWidth(): number;
          public getMinHeight(): number;
          public setLeftWidth(_leftWidth: number): void;
          public setRightWidth(_rightWidth: number): void;
          public setTopHeight(_topHeight: number): void;
          public setBottomHeight(
            _bottomHeight: number,
          ): void;
          public setMinWidth(_minWidth: number): void;
          public setMinHeight(_minHeight: number): void;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace ui {
        declare namespace layout {
          declare class WidgetGroup extends Packages.arc
            .scene.Group {
            private layoutEnabled: boolean;
            public validate(): void;
            public draw(): void;
            public setFillParent(
              _fillParent: boolean,
            ): void;
            public needsLayout(): boolean;
            protected sizeChanged(): void;
            public invalidate(): void;
            protected childrenChanged(): void;
            public getPrefWidth(): number;
            public getPrefHeight(): number;
            public invalidateHierarchy(): void;
            public layout(): void;
            public getMinWidth(): number;
            public getMinHeight(): number;
            public setLayoutEnabled(
              _enabled: boolean,
            ): void;
            private setLayoutEnabled(
              _parent: Packages.arc.scene.Group,
              _enabled: boolean,
            ): void;
            public pack(): void;
            public constructor();
            public constructor(
              ..._actors: Packages.arc.scene.Element[]
            );
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace pooling {
        declare abstract class Pool<T> extends java.lang
          .Object {
          public static Poolable = class {
            public reset(): void;
          };
          public max: number;
          private freeObjects: Packages.arc.struct.Seq<T>;
          public peak: number;
          public clear(): void;
          protected reset(_object: T): void;
          public free(_object: T): void;
          public obtain(): T | null;
          protected newObject(): T | null;
          public freeAll(
            _objects: Packages.arc.struct.Seq<T>,
          ): void;
          public getFree(): number;
          public constructor(
            _initialCapacity: number,
            _max: number,
          );
          public constructor(_initialCapacity: number);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace utils {
        declare abstract class Disableable {
          public isDisabled(): boolean;
          public setDisabled(_isDisabled: boolean): void;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace style {
        declare abstract class Style extends java.lang
          .Object {
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace ui {
        declare class ButtonGroup<
          T extends Packages.arc.scene.ui.Button,
        > extends java.lang.Object {
          private buttons: Packages.arc.struct.Seq<T>;
          private checkedButtons: Packages.arc.struct.Seq<T>;
          private minCheckCount: number;
          private maxCheckCount: number;
          private uncheckLast: boolean;
          private lastChecked: T;
          public add(..._buttons: T[]): void;
          public add(_button: T): void;
          public remove(..._buttons: T[]): void;
          public remove(_button: T): void;
          public clear(): void;
          protected canCheck(
            _button: T,
            _newState: boolean,
          ): boolean;
          public setChecked(_text: string): void;
          public uncheckAll(): void;
          public getChecked(): T | null;
          public getCheckedIndex(): number;
          public getAllChecked(): Packages.arc.struct.Seq<T>;
          public getButtons(): Packages.arc.struct.Seq<T>;
          public setMinCheckCount(
            _minCheckCount: number,
          ): void;
          public setMaxCheckCount(
            _maxCheckCount: number,
          ): void;
          public setUncheckLast(
            _uncheckLast: boolean,
          ): void;
          public constructor();
          public constructor(..._buttons: T[]);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class Boolp {
        public get(): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace event {
        declare class InputEvent extends Packages.arc.scene
          .event.SceneEvent {
          public static InputEventType = class extends Packages
            .java.lang
            .Enum<Packages.arc.scene.event.InputEvent.InputEventType> {
            public static touchDown: Packages.arc.scene.event.InputEvent.InputEventType;
            public static touchUp: Packages.arc.scene.event.InputEvent.InputEventType;
            public static touchDragged: Packages.arc.scene.event.InputEvent.InputEventType;
            public static mouseMoved: Packages.arc.scene.event.InputEvent.InputEventType;
            public static enter: Packages.arc.scene.event.InputEvent.InputEventType;
            public static exit: Packages.arc.scene.event.InputEvent.InputEventType;
            public static scrolled: Packages.arc.scene.event.InputEvent.InputEventType;
            public static keyDown: Packages.arc.scene.event.InputEvent.InputEventType;
            public static keyUp: Packages.arc.scene.event.InputEvent.InputEventType;
            public static keyTyped: Packages.arc.scene.event.InputEvent.InputEventType;
            private static $VALUES: Packages.arc.scene.event.InputEvent.InputEventType[];
            public static values():
              | Packages.arc.scene.event.InputEvent.InputEventType[]
              | null;
            public static valueOf(
              _name: string,
            ): Packages.arc.scene.event.InputEvent.InputEventType;
          };
          public type: Packages.arc.scene.event.InputEvent.InputEventType;
          public stageX: number;
          public stageY: number;
          public pointer: number;
          public scrollAmountX: number;
          public scrollAmountY: number;
          public keyCode: Packages.arc.input.KeyCode;
          public character: string;
          public relatedActor: Packages.arc.scene.Element;
          public toString(): string;
          public reset(): void;
          public toCoordinates(
            _actor: Packages.arc.scene.Element,
            _actorCoords: Packages.arc.math.geom.Vec2,
          ): Packages.arc.math.geom.Vec2;
          public isTouchFocusCancel(): boolean;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace event {
        declare class InputListener
          extends java.lang.Object
          implements Packages.arc.scene.event.EventListener
        {
          private static tmpCoords: Packages.arc.math.geom.Vec2;
          public exit(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
            _toActor: Packages.arc.scene.Element,
          ): void;
          public handle(
            _e: Packages.arc.scene.event.SceneEvent,
          ): boolean;
          public keyDown(
            _event: Packages.arc.scene.event.InputEvent,
            _keycode: Packages.arc.input.KeyCode,
          ): boolean;
          public enter(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
            _fromActor: Packages.arc.scene.Element,
          ): void;
          public touchDown(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
            _button: Packages.arc.input.KeyCode,
          ): boolean;
          public touchDragged(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
          ): void;
          public touchUp(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
            _button: Packages.arc.input.KeyCode,
          ): void;
          public mouseMoved(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
          ): boolean;
          public scrolled(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _amountX: number,
            _amountY: number,
          ): boolean;
          public keyUp(
            _event: Packages.arc.scene.event.InputEvent,
            _keycode: Packages.arc.input.KeyCode,
          ): boolean;
          public keyTyped(
            _event: Packages.arc.scene.event.InputEvent,
            _character: string,
          ): boolean;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace event {
        declare class ClickListener extends Packages.arc
          .scene.event.InputListener {
          public static visualPressedDuration: number;
          protected tapSquareSize: number;
          protected touchDownX: number;
          protected touchDownY: number;
          protected pressedPointer: number;
          protected pressedButton: Packages.arc.input.KeyCode;
          protected button: Packages.arc.input.KeyCode;
          protected pressed: boolean;
          protected over: boolean;
          protected overAny: boolean;
          protected cancelled: boolean;
          protected visualPressedTime: Packages.long;
          protected tapCountInterval: Packages.long;
          protected tapCount: number;
          protected lastTapTime: Packages.long;
          protected stop: boolean;
          public exit(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
            _toActor: Packages.arc.scene.Element,
          ): void;
          public cancel(): void;
          public isPressed(): boolean;
          public enter(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
            _fromActor: Packages.arc.scene.Element,
          ): void;
          public touchDown(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
            _button: Packages.arc.input.KeyCode,
          ): boolean;
          public touchDragged(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
          ): void;
          public touchUp(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
            _button: Packages.arc.input.KeyCode,
          ): void;
          public isOver(): boolean;
          public isOver(
            _element: Packages.arc.scene.Element,
            _x: number,
            _y: number,
          ): boolean;
          public invalidateTapSquare(): void;
          public inTapSquare(): boolean;
          public inTapSquare(
            _x: number,
            _y: number,
          ): boolean;
          public isVisualPressed(): boolean;
          public getTapSquareSize(): number;
          public setTapSquareSize(
            _halfTapSquareSize: number,
          ): void;
          public setTapCountInterval(
            _tapCountInterval: number,
          ): void;
          public getTapCount(): number;
          public setTapCount(_tapCount: number): void;
          public getTouchDownX(): number;
          public getTouchDownY(): number;
          public getPressedButton(): Packages.arc.input.KeyCode;
          public getPressedPointer(): number;
          public getButton(): Packages.arc.input.KeyCode;
          public clicked(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
          ): void;
          public setButton(
            _button: Packages.arc.input.KeyCode,
          ): void;
          public constructor();
          public constructor(
            _button: Packages.arc.input.KeyCode,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace ui {
        declare class Button
          extends Packages.arc.scene.ui.layout.Table
          implements Packages.arc.scene.utils.Disableable
        {
          public static ButtonStyle = class extends Packages
            .arc.scene.style.Style {
            public up: Packages.arc.scene.style.Drawable;
            public down: Packages.arc.scene.style.Drawable;
            public over: Packages.arc.scene.style.Drawable;
            public checked: Packages.arc.scene.style.Drawable;
            public checkedOver: Packages.arc.scene.style.Drawable;
            public disabled: Packages.arc.scene.style.Drawable;
            public pressedOffsetX: number;
            public pressedOffsetY: number;
            public unpressedOffsetX: number;
            public unpressedOffsetY: number;
            public checkedOffsetX: number;
            public checkedOffsetY: number;
            public constructor();
            public constructor(
              _up: Packages.arc.scene.style.Drawable,
              _down: Packages.arc.scene.style.Drawable,
              _checked: Packages.arc.scene.style.Drawable,
            );
            public constructor(
              _style: Packages.arc.scene.ui.Button.ButtonStyle,
            );
          };
          buttonGroup: Packages.arc.scene.ui.ButtonGroup<any>;
          disabledProvider: Packages.arc.func.Boolp;
          private style: Packages.arc.scene.ui.Button.ButtonStyle;
          private clickListener: Packages.arc.scene.event.ClickListener;
          private programmaticChangeEvents: boolean;
          private initialize(): void;
          public draw(): void;
          public isPressed(): boolean;
          public act(_delta: number): void;
          public getStyle(): Packages.arc.scene.ui.Button.ButtonStyle;
          public isOver(): boolean;
          public isDisabled(): boolean;
          public setChecked(_isChecked: boolean): void;
          setChecked(
            _isChecked: boolean,
            _fireEvent: boolean,
          ): void;
          public setStyle(
            _style: Packages.arc.scene.ui.Button.ButtonStyle,
          ): void;
          public getPrefWidth(): number;
          public getPrefHeight(): number;
          public getMinWidth(): number;
          public getMinHeight(): number;
          public setProgrammaticChangeEvents(
            _programmaticChangeEvents: boolean,
          ): void;
          public setDisabled(
            _prov: Packages.arc.func.Boolp,
          ): void;
          public setDisabled(_isDisabled: boolean): void;
          public isChecked(): boolean;
          public getClickListener(): Packages.arc.scene.event.ClickListener;
          public toggle(): void;
          public childrenPressed(): boolean;
          public getButtonGroup(): Packages.arc.scene.ui.ButtonGroup<any>;
          public constructor(
            _up: Packages.arc.scene.style.Drawable,
            _down: Packages.arc.scene.style.Drawable,
            _checked: Packages.arc.scene.style.Drawable,
          );
          public constructor(
            _up: Packages.arc.scene.style.Drawable,
            _down: Packages.arc.scene.style.Drawable,
          );
          public constructor(
            _up: Packages.arc.scene.style.Drawable,
          );
          public constructor();
          public constructor(
            _style: Packages.arc.scene.ui.Button.ButtonStyle,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class Scaling extends Packages.java.lang
        .Enum<Packages.arc.util.Scaling> {
        public static fit: Packages.arc.util.Scaling;
        public static bounded: Packages.arc.util.Scaling;
        public static fill: Packages.arc.util.Scaling;
        public static fillX: Packages.arc.util.Scaling;
        public static fillY: Packages.arc.util.Scaling;
        public static stretch: Packages.arc.util.Scaling;
        public static stretchX: Packages.arc.util.Scaling;
        public static stretchY: Packages.arc.util.Scaling;
        public static none: Packages.arc.util.Scaling;
        private static temp: Packages.arc.math.geom.Vec2;
        private static $VALUES: Packages.arc.util.Scaling[];
        public static values():
          | Packages.arc.util.Scaling[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.arc.util.Scaling;
        public apply(
          _sourceWidth: number,
          _sourceHeight: number,
          _targetWidth: number,
          _targetHeight: number,
        ): Packages.arc.math.geom.Vec2;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace ui {
        declare namespace layout {
          declare class Cell<
              T extends Packages.arc.scene.Element,
            >
            extends java.lang.Object
            implements
              Packages.arc.util.pooling.Pool.Poolable
          {
            private static dset: boolean;
            static unset: number;
            element: Packages.arc.scene.Element;
            elementX: number;
            elementY: number;
            elementWidth: number;
            elementHeight: number;
            endRow: boolean;
            column: number;
            cellAboveIndex: number;
            computedPadTop: number;
            computedPadLeft: number;
            computedPadBottom: number;
            computedPadRight: number;
            private table: Packages.arc.scene.ui.layout.Table;
            public name(
              _name: string,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public group<
              N extends Packages.arc.scene.ui.Button,
            >(
              _group: Packages.arc.scene.ui.ButtonGroup<N>,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public get(): T | null;
            public toString(): string;
            public update(
              _updater: Packages.arc.func.Cons<T>,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            clear(): void;
            public wrap(): Packages.arc.scene.ui.layout.Cell<T>;
            public size(
              _width: number,
              _height: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public size(
              _size: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public fill(
              _x: number,
              _y: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public fill(
              _x: boolean,
              _y: boolean,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public fill(
              _fill: boolean,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public fill(): Packages.arc.scene.ui.layout.Cell<T>;
            scl(_value: number): number;
            public set(
              _cell: Packages.arc.scene.ui.layout.Cell<any>,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public static defaults(): Packages.arc.scene.ui.layout.Cell<any>;
            public expand(
              _x: boolean,
              _y: boolean,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public expand(
              _x: number,
              _y: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public expand(): Packages.arc.scene.ui.layout.Cell<T>;
            public top(): Packages.arc.scene.ui.layout.Cell<T>;
            public reset(): void;
            public checked(
              _toggle: boolean,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public checked(
              _toggle: Packages.arc.func.Boolf<T>,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public grow(): Packages.arc.scene.ui.layout.Cell<T>;
            public color(
              _color: Packages.arc.graphics.Color,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public left(): Packages.arc.scene.ui.layout.Cell<T>;
            public right(): Packages.arc.scene.ui.layout.Cell<T>;
            public valid(
              _val: Packages.arc.scene.ui.TextField.TextFieldValidator,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public self(
              _c: Packages.arc.func.Cons<
                Packages.arc.scene.ui.layout.Cell<T>
              >,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public getTable(): Packages.arc.scene.ui.layout.Table;
            public bottom(): Packages.arc.scene.ui.layout.Cell<T>;
            public visible(
              _visible: boolean,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public visible(
              _prov: Packages.arc.func.Boolp,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public pad(
              _pad: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public pad(
              _top: number,
              _left: number,
              _bottom: number,
              _right: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public maxSize(
              _size: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public maxSize(
              _width: number,
              _height: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public style(
              _style: Packages.arc.scene.style.Style,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public width(
              _width: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public with(
              _c: Packages.arc.func.Cons<T>,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public minWidth(): number;
            public minWidth(
              _minWidth: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public maxWidth(): number;
            public maxWidth(
              _maxWidth: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public padRight(
              _padRight: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public setElement<
              A extends Packages.arc.scene.Element,
            >(
              _newElement: A,
            ): Packages.arc.scene.ui.layout.Cell<A>;
            public tooltip(
              _text: string,
              _mobile: boolean,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public tooltip(
              _text: string,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public tooltip(
              _builder: Packages.arc.func.Cons<Packages.arc.scene.ui.layout.Table>,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public height(
              _height: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public margin(
              _margin: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public scaling(
              _scaling: Packages.arc.util.Scaling,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public touchable(
              _touchable: Packages.arc.func.Prov<Packages.arc.scene.event.Touchable>,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public touchable(
              _touchable: Packages.arc.scene.event.Touchable,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public marginBottom(
              _margin: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public marginLeft(
              _margin: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public marginTop(
              _margin: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public marginRight(
              _margin: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public center(): Packages.arc.scene.ui.layout.Cell<T>;
            public disabled(
              _vis: Packages.arc.func.Boolf<T>,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public disabled(
              _disabled: boolean,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public setLayout(
              _table: Packages.arc.scene.ui.layout.Table,
            ): void;
            public colspan(
              _colspan: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public row(): void;
            public padTop(
              _padTop: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public padLeft(
              _padLeft: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public growX(): Packages.arc.scene.ui.layout.Cell<T>;
            public expandY(): Packages.arc.scene.ui.layout.Cell<T>;
            public expandX(): Packages.arc.scene.ui.layout.Cell<T>;
            public padBottom(
              _padBottom: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public prefWidth(): number;
            public prefHeight(): number;
            public minHeight(
              _minHeight: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public minHeight(): number;
            public maxHeight(
              _maxHeight: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public maxHeight(): number;
            public uniformX(): Packages.arc.scene.ui.layout.Cell<T>;
            public uniformY(): Packages.arc.scene.ui.layout.Cell<T>;
            public fillX(): Packages.arc.scene.ui.layout.Cell<T>;
            public fillY(): Packages.arc.scene.ui.layout.Cell<T>;
            public setBounds(
              _x: number,
              _y: number,
              _width: number,
              _height: number,
            ): void;
            public align(
              _align: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public ellipsis(
              _ellipsis: boolean,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public fontScale(
              _scale: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public scrollX(
              _allowScrollX: boolean,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public scrollY(
              _allowScrollY: boolean,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public labelAlign(
              _label: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public labelAlign(
              _label: number,
              _line: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public clearElement(): Packages.arc.scene.ui.layout.Cell<T>;
            public hasElement(): boolean;
            public maxTextLength(
              _length: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public wrapLabel(
              _toggle: boolean,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public growY(): Packages.arc.scene.ui.layout.Cell<T>;
            public uniform(
              _x: boolean,
              _y: boolean,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public uniform(): Packages.arc.scene.ui.layout.Cell<T>;
            public isEndRow(): boolean;
            public minSize(
              _width: number,
              _height: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public minSize(
              _size: number,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public constructor();
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare abstract class CharSequence {}
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace g2d {
        declare class GlyphLayout
          extends java.lang.Object
          implements Packages.arc.util.pooling.Pool.Poolable
        {
          public static GlyphRun = class
            extends java.lang.Object
            implements
              Packages.arc.util.pooling.Pool.Poolable
          {
            public color: Packages.arc.graphics.Color;
            public glyphs: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.Font.Glyph>;
            public xAdvances: Packages.arc.struct.FloatSeq;
            public x: number;
            public y: number;
            public width: number;
            public toString(): string;
            public reset(): void;
            public constructor();
          };
          public runs: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.GlyphLayout.GlyphRun>;
          private colorStack: Packages.arc.struct.Seq<Packages.arc.graphics.Color>;
          public ignoreMarkup: boolean;
          public width: number;
          public height: number;
          public toString(): string;
          private wrap(
            _fontData: Packages.arc.graphics.g2d.Font.FontData,
            _first: Packages.arc.graphics.g2d.GlyphLayout.GlyphRun,
            _glyphRunPool: Packages.arc.util.pooling.Pool<Packages.arc.graphics.g2d.GlyphLayout.GlyphRun>,
            _wrapIndex: number,
            _widthIndex: number,
          ): Packages.arc.graphics.g2d.GlyphLayout.GlyphRun;
          public reset(): void;
          public free(): void;
          public setText(
            _font: Packages.arc.graphics.g2d.Font,
            _str: Packages.java.lang.CharSequence,
          ): void;
          public setText(
            _font: Packages.arc.graphics.g2d.Font,
            _str: Packages.java.lang.CharSequence,
            _color: Packages.arc.graphics.Color,
            _targetWidth: number,
            _halign: number,
            _wrap: boolean,
          ): void;
          public setText(
            _font: Packages.arc.graphics.g2d.Font,
            _str: Packages.java.lang.CharSequence,
            _start: number,
            _end: number,
            _color: Packages.arc.graphics.Color,
            _targetWidth: number,
            _halign: number,
            _wrap: boolean,
            _truncate: string,
          ): void;
          private truncate(
            _fontData: Packages.arc.graphics.g2d.Font.FontData,
            _run: Packages.arc.graphics.g2d.GlyphLayout.GlyphRun,
            _targetWidth: number,
            _truncate: string,
            _widthIndex: number,
            _glyphRunPool: Packages.arc.util.pooling.Pool<Packages.arc.graphics.g2d.GlyphLayout.GlyphRun>,
          ): void;
          public static obtain(): Packages.arc.graphics.g2d.GlyphLayout;
          private parseColorMarkup(
            _str: Packages.java.lang.CharSequence,
            _start: number,
            _end: number,
            _colorPool: Packages.arc.util.pooling.Pool<Packages.arc.graphics.Color>,
          ): number;
          private adjustLastGlyph(
            _fontData: Packages.arc.graphics.g2d.Font.FontData,
            _run: Packages.arc.graphics.g2d.GlyphLayout.GlyphRun,
          ): void;
          public constructor(
            _font: Packages.arc.graphics.g2d.Font,
            _str: Packages.java.lang.CharSequence,
            _start: number,
            _end: number,
            _color: Packages.arc.graphics.Color,
            _targetWidth: number,
            _halign: number,
            _wrap: boolean,
            _truncate: string,
          );
          public constructor(
            _font: Packages.arc.graphics.g2d.Font,
            _str: Packages.java.lang.CharSequence,
            _color: Packages.arc.graphics.Color,
            _targetWidth: number,
            _halign: number,
            _wrap: boolean,
          );
          public constructor(
            _font: Packages.arc.graphics.g2d.Font,
            _str: Packages.java.lang.CharSequence,
          );
          public constructor(_ignoreMarkup: boolean);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace g2d {
        declare class FontCache extends java.lang.Object {
          private static tempColor: Packages.arc.graphics.Color;
          private font: Packages.arc.graphics.g2d.Font;
          private layouts: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.GlyphLayout>;
          private pooledLayouts: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.GlyphLayout>;
          private color: Packages.arc.graphics.Color;
          private integer: boolean;
          private glyphCount: number;
          private x: number;
          private y: number;
          private currentTint: number;
          private pageVertices: number[][];
          private idx: number[];
          private pageGlyphIndices: Packages.arc.struct.IntSeq[];
          private tempGlyphCount: number[];
          public clear(): void;
          public setColor(
            _color: Packages.arc.graphics.Color,
          ): void;
          public setColor(
            _r: number,
            _g: number,
            _b: number,
            _a: number,
          ): void;
          public setText(
            _str: Packages.java.lang.CharSequence,
            _x: number,
            _y: number,
          ): Packages.arc.graphics.g2d.GlyphLayout;
          public setText(
            _str: Packages.java.lang.CharSequence,
            _x: number,
            _y: number,
            _targetWidth: number,
            _halign: number,
            _wrap: boolean,
          ): Packages.arc.graphics.g2d.GlyphLayout;
          public setText(
            _str: Packages.java.lang.CharSequence,
            _x: number,
            _y: number,
            _start: number,
            _end: number,
            _targetWidth: number,
            _halign: number,
            _wrap: boolean,
          ): Packages.arc.graphics.g2d.GlyphLayout;
          public setText(
            _layout: Packages.arc.graphics.g2d.GlyphLayout,
            _x: number,
            _y: number,
          ): void;
          public setText(
            _str: Packages.java.lang.CharSequence,
            _x: number,
            _y: number,
            _start: number,
            _end: number,
            _targetWidth: number,
            _halign: number,
            _wrap: boolean,
            _truncate: string,
          ): Packages.arc.graphics.g2d.GlyphLayout;
          private addToCache(
            _layout: Packages.arc.graphics.g2d.GlyphLayout,
            _x: number,
            _y: number,
          ): void;
          public getX(): number;
          public getY(): number;
          public translate(
            _xAmount: number,
            _yAmount: number,
          ): void;
          public draw(): void;
          public draw(_alphaModulation: number): void;
          public draw(_start: number, _end: number): void;
          public setPosition(_x: number, _y: number): void;
          public usesIntegerPositions(): boolean;
          public getFont(): Packages.arc.graphics.g2d.Font;
          public tint(
            _tint: Packages.arc.graphics.Color,
          ): void;
          public getColor(): Packages.arc.graphics.Color;
          public setColors(
            _tint: Packages.arc.graphics.Color,
          ): void;
          public setColors(_color: number): void;
          public setColors(
            _color: number,
            _start: number,
            _end: number,
          ): void;
          public setColors(
            _tint: Packages.arc.graphics.Color,
            _start: number,
            _end: number,
          ): void;
          public setColors(
            _r: number,
            _g: number,
            _b: number,
            _a: number,
          ): void;
          private requirePageGlyphs(
            _page: number,
            _glyphCount: number,
          ): void;
          private requireGlyphs(
            _layout: Packages.arc.graphics.g2d.GlyphLayout,
          ): void;
          private addGlyph(
            _glyph: Packages.arc.graphics.g2d.Font.Glyph,
            _x: number,
            _y: number,
            _color: number,
          ): void;
          public getVertices(): number[] | null;
          public getVertices(
            _page: number,
          ): number[] | null;
          public addText(
            _str: Packages.java.lang.CharSequence,
            _x: number,
            _y: number,
          ): Packages.arc.graphics.g2d.GlyphLayout;
          public addText(
            _str: Packages.java.lang.CharSequence,
            _x: number,
            _y: number,
            _targetWidth: number,
            _halign: number,
            _wrap: boolean,
          ): Packages.arc.graphics.g2d.GlyphLayout;
          public addText(
            _str: Packages.java.lang.CharSequence,
            _x: number,
            _y: number,
            _start: number,
            _end: number,
            _targetWidth: number,
            _halign: number,
            _wrap: boolean,
            _truncate: string,
          ): Packages.arc.graphics.g2d.GlyphLayout;
          public addText(
            _str: Packages.java.lang.CharSequence,
            _x: number,
            _y: number,
            _start: number,
            _end: number,
            _targetWidth: number,
            _halign: number,
            _wrap: boolean,
          ): Packages.arc.graphics.g2d.GlyphLayout;
          public addText(
            _layout: Packages.arc.graphics.g2d.GlyphLayout,
            _x: number,
            _y: number,
          ): void;
          public setUseIntegerPositions(
            _use: boolean,
          ): void;
          public setAlphas(_alpha: number): void;
          public getVertexCount(_page: number): number;
          public getLayouts(): Packages.arc.struct.Seq<Packages.arc.graphics.g2d.GlyphLayout>;
          public constructor(
            _font: Packages.arc.graphics.g2d.Font,
          );
          public constructor(
            _font: Packages.arc.graphics.g2d.Font,
            _integer: boolean,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace g2d {
        declare class Font
          extends java.lang.Object
          implements Packages.arc.util.Disposable
        {
          public static FontData = class extends java.lang
            .Object {
            public glyphs: Packages.arc.graphics.g2d.Font.Glyph[][];
            public imagePaths: string[];
            public fontFile: Packages.arc.files.Fi;
            public flipped: boolean;
            public padTop: number;
            public padRight: number;
            public padBottom: number;
            public padLeft: number;
            public lineHeight: number;
            public capHeight: number;
            public ascent: number;
            public descent: number;
            public down: number;
            public blankLineScale: number;
            public scaleX: number;
            public scaleY: number;
            public markupEnabled: boolean;
            public cursorX: number;
            public missingGlyph: Packages.arc.graphics.g2d.Font.Glyph;
            public spaceXadvance: number;
            public xHeight: number;
            public breakChars: string[];
            public xChars: string[];
            public capChars: string[];
            public isWhitespace(_c: string): boolean;
            public load(
              _fontFile: Packages.arc.files.Fi,
              _flip: boolean,
            ): void;
            public scale(_amount: number): void;
            public setScale(
              _scaleX: number,
              _scaleY: number,
            ): void;
            public setScale(_scaleXY: number): void;
            public getImagePath(_index: number): string;
            public hasGlyph(_ch: string): boolean;
            public setGlyph(
              _ch: number,
              _glyph: Packages.arc.graphics.g2d.Font.Glyph,
            ): void;
            public getFirstGlyph(): Packages.arc.graphics.g2d.Font.Glyph;
            public isBreakChar(_c: string): boolean;
            public setLineHeight(_height: number): void;
            public getGlyphs(
              _run: Packages.arc.graphics.g2d.GlyphLayout.GlyphRun,
              _str: Packages.java.lang.CharSequence,
              _start: number,
              _end: number,
              _lastGlyph: Packages.arc.graphics.g2d.Font.Glyph,
            ): void;
            public getWrapIndex(
              _glyphs: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.Font.Glyph>,
              _start: number,
            ): number;
            public getImagePaths(): string[] | null;
            public getFontFile(): Packages.arc.files.Fi;
            public setGlyphRegion(
              _glyph: Packages.arc.graphics.g2d.Font.Glyph,
              _region: Packages.arc.graphics.g2d.TextureRegion,
            ): void;
            public getGlyph(
              _ch: string,
            ): Packages.arc.graphics.g2d.Font.Glyph;
            public constructor();
            public constructor(
              _fontFile: Packages.arc.files.Fi,
              _flip: boolean,
            );
          };
          public static Glyph = class extends java.lang
            .Object {
            public id: number;
            public srcX: number;
            public srcY: number;
            public width: number;
            public height: number;
            public u: number;
            public v: number;
            public u2: number;
            public v2: number;
            public xoffset: number;
            public yoffset: number;
            public xadvance: number;
            public kerning: string[][];
            public fixedWidth: boolean;
            public page: number;
            public toString(): string;
            public setKerning(
              _ch: number,
              _value: number,
            ): void;
            public getKerning(_ch: string): number;
            public constructor();
          };
          private static LOG2_PAGE_SIZE: number;
          private static PAGE_SIZE: number;
          private static PAGES: number;
          public data: Packages.arc.graphics.g2d.Font.FontData;
          private cache: Packages.arc.graphics.g2d.FontCache;
          regions: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.TextureRegion>;
          integer: boolean;
          private flipped: boolean;
          public toString(): string;
          static indexOf(
            _text: Packages.java.lang.CharSequence,
            _ch: string,
            _start: number,
          ): number;
          protected load(
            _data: Packages.arc.graphics.g2d.Font.FontData,
          ): void;
          public getCache(): Packages.arc.graphics.g2d.FontCache;
          public getRegion(): Packages.arc.graphics.g2d.TextureRegion;
          public getRegion(
            _index: number,
          ): Packages.arc.graphics.g2d.TextureRegion;
          public setColor(
            _color: Packages.arc.graphics.Color,
          ): void;
          public setColor(
            _r: number,
            _g: number,
            _b: number,
            _a: number,
          ): void;
          public dispose(): void;
          public getData(): Packages.arc.graphics.g2d.Font.FontData;
          public getLineHeight(): number;
          public isDisposed(): boolean;
          public draw(
            _str: Packages.java.lang.CharSequence,
            _x: number,
            _y: number,
            _halign: number,
          ): Packages.arc.graphics.g2d.GlyphLayout;
          public draw(
            _str: Packages.java.lang.CharSequence,
            _x: number,
            _y: number,
            _start: number,
            _end: number,
            _targetWidth: number,
            _halign: number,
            _wrap: boolean,
          ): Packages.arc.graphics.g2d.GlyphLayout;
          public draw(
            _str: Packages.java.lang.CharSequence,
            _x: number,
            _y: number,
          ): Packages.arc.graphics.g2d.GlyphLayout;
          public draw(
            _str: Packages.java.lang.CharSequence,
            _x: number,
            _y: number,
            _color: Packages.arc.graphics.Color,
            _scale: number,
            _integer: boolean,
            _halign: number,
          ): Packages.arc.graphics.g2d.GlyphLayout;
          public draw(
            _str: Packages.java.lang.CharSequence,
            _x: number,
            _y: number,
            _start: number,
            _end: number,
            _targetWidth: number,
            _halign: number,
            _wrap: boolean,
            _truncate: string,
          ): Packages.arc.graphics.g2d.GlyphLayout;
          public draw(
            _str: Packages.java.lang.CharSequence,
            _x: number,
            _y: number,
            _targetWidth: number,
            _halign: number,
            _wrap: boolean,
          ): Packages.arc.graphics.g2d.GlyphLayout;
          public draw(
            _layout: Packages.arc.graphics.g2d.GlyphLayout,
            _x: number,
            _y: number,
          ): void;
          public getRegions(): Packages.arc.struct.Seq<Packages.arc.graphics.g2d.TextureRegion>;
          public usesIntegerPositions(): boolean;
          public newFontCache(): Packages.arc.graphics.g2d.FontCache;
          public getScaleX(): number;
          public getScaleY(): number;
          public isFlipped(): boolean;
          public getDescent(): number;
          public getCapHeight(): number;
          public getColor(): Packages.arc.graphics.Color;
          public ownsTexture(): boolean;
          public setUseIntegerPositions(
            _integer: boolean,
          ): void;
          public getSpaceXadvance(): number;
          public getXHeight(): number;
          public getAscent(): number;
          public setFixedWidthGlyphs(
            _glyphs: Packages.java.lang.CharSequence,
          ): void;
          public setOwnsTexture(
            _ownsTexture: boolean,
          ): void;
          public constructor(
            _fontFile: Packages.arc.files.Fi,
            _imageFile: Packages.arc.files.Fi,
            _flip: boolean,
          );
          public constructor(
            _fontFile: Packages.arc.files.Fi,
            _imageFile: Packages.arc.files.Fi,
            _flip: boolean,
            _integer: boolean,
          );
          public constructor(
            _data: Packages.arc.graphics.g2d.Font.FontData,
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _integer: boolean,
          );
          public constructor(
            _data: Packages.arc.graphics.g2d.Font.FontData,
            _pageRegions: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.TextureRegion>,
            _integer: boolean,
          );
          public constructor(
            _fontFile: Packages.arc.files.Fi,
            _region: Packages.arc.graphics.g2d.TextureRegion,
          );
          public constructor(
            _fontFile: Packages.arc.files.Fi,
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _flip: boolean,
          );
          public constructor(
            _fontFile: Packages.arc.files.Fi,
          );
          public constructor(
            _fontFile: Packages.arc.files.Fi,
            _flip: boolean,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace ui {
        declare class Label extends Packages.arc.scene
          .Element {
          public static LabelStyle = class extends Packages
            .arc.scene.style.Style {
            public font: Packages.arc.graphics.g2d.Font;
            public fontColor: Packages.arc.graphics.Color;
            public background: Packages.arc.scene.style.Drawable;
            public constructor();
            public constructor(
              _font: Packages.arc.graphics.g2d.Font,
              _fontColor: Packages.arc.graphics.Color,
            );
            public constructor(
              _style: Packages.arc.scene.ui.Label.LabelStyle,
            );
          };
          protected static tempColor: Packages.arc.graphics.Color;
          protected static prefSizeLayout: Packages.arc.graphics.g2d.GlyphLayout;
          protected prefSize: Packages.arc.math.geom.Vec2;
          protected text: Packages.java.lang.StringBuilder;
          protected style: Packages.arc.scene.ui.Label.LabelStyle;
          protected cache: Packages.arc.graphics.g2d.FontCache;
          protected labelAlign: number;
          protected lineAlign: number;
          protected wrap: boolean;
          protected lastPrefHeight: number;
          protected prefSizeInvalid: boolean;
          protected fontScaleX: number;
          protected fontScaleY: number;
          protected fontScaleChanged: boolean;
          protected ellipsis: string;
          public toString(): string;
          public getText(): Packages.java.lang.StringBuilder;
          public setText(
            _sup: Packages.arc.func.Prov<Packages.java.lang.CharSequence>,
          ): void;
          public setText(
            _newText: Packages.java.lang.CharSequence,
          ): void;
          public getFontScaleX(): number;
          public draw(): void;
          public setWrap(_wrap: boolean): void;
          public getStyle(): Packages.arc.scene.ui.Label.LabelStyle;
          public invalidate(): void;
          public setFontScale(_fontScale: number): void;
          public setFontScale(
            _fontScaleX: number,
            _fontScaleY: number,
          ): void;
          public setStyle(
            _style: Packages.arc.scene.ui.Label.LabelStyle,
          ): void;
          public getPrefWidth(): number;
          public getPrefHeight(): number;
          public layout(): void;
          public textEquals(
            _other: Packages.java.lang.CharSequence,
          ): boolean;
          private setTextInternal(
            _newText: Packages.java.lang.CharSequence,
          ): void;
          private computePrefSize(): void;
          private scaleAndComputePrefSize(): void;
          public setAlignment(_alignment: number): void;
          public setAlignment(
            _labelAlign: number,
            _lineAlign: number,
          ): void;
          public getGlyphLayout(): Packages.arc.graphics.g2d.GlyphLayout;
          public getLabelAlign(): number;
          public getLineAlign(): number;
          public setFontScaleX(_fontScaleX: number): void;
          public getFontScaleY(): number;
          public setFontScaleY(_fontScaleY: number): void;
          public setEllipsis(_ellipsis: boolean): void;
          public setEllipsis(_ellipsis: string): void;
          public getFontCache(): Packages.arc.graphics.g2d.FontCache;
          public constructor(
            _text: Packages.java.lang.CharSequence,
            _style: Packages.arc.scene.ui.Label.LabelStyle,
          );
          public constructor(
            _text: Packages.java.lang.CharSequence,
          );
          public constructor(
            _sup: Packages.arc.func.Prov<Packages.java.lang.CharSequence>,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class Timer extends java.lang.Object {
        static TimerThread = class
          extends java.lang.Object
          implements
            Packages.java.lang.Runnable,
            Packages.arc.ApplicationListener
        {
          files: Packages.arc.Files;
          instances: Packages.arc.struct.Seq<Packages.arc.util.Timer>;
          instance: Packages.arc.util.Timer;
          private pauseMillis: Packages.long;
          public run(): void;
          public resume(): void;
          public dispose(): void;
          public pause(): void;
          public constructor();
        };
        public static Task = class
          extends java.lang.Object
          implements Packages.java.lang.Runnable
        {
          app: Packages.arc.Application;
          executeTimeMillis: Packages.long;
          intervalMillis: Packages.long;
          repeatCount: number;
          timer: Packages.arc.util.Timer;
          public run(): void;
          public cancel(): void;
          public isScheduled(): boolean;
          public getExecuteTimeMillis(): Packages.long;
          public constructor();
        };
        static threadLock: any;
        tasks: Packages.arc.struct.Seq<Packages.arc.util.Timer.Task>;
        update(
          _timeMillis: Packages.long,
          _waitMillis: Packages.long,
        ): Packages.long;
        public clear(): void;
        public isEmpty(): boolean;
        public start(): void;
        public stop(): void;
        public delay(_delayMillis: Packages.long): void;
        private static thread(): Packages.arc.util.Timer.TimerThread;
        public static instance(): Packages.arc.util.Timer;
        public static post(
          _task: Packages.arc.util.Timer.Task,
        ): Packages.arc.util.Timer.Task;
        public postTask(
          _task: Packages.arc.util.Timer.Task,
        ): Packages.arc.util.Timer.Task;
        public scheduleTask(
          _task: Packages.arc.util.Timer.Task,
          _delaySeconds: number,
        ): Packages.arc.util.Timer.Task;
        public scheduleTask(
          _task: Packages.arc.util.Timer.Task,
          _delaySeconds: number,
          _intervalSeconds: number,
          _repeatCount: number,
        ): Packages.arc.util.Timer.Task;
        public scheduleTask(
          _task: Packages.arc.util.Timer.Task,
          _delaySeconds: number,
          _intervalSeconds: number,
        ): Packages.arc.util.Timer.Task;
        public static schedule(
          _task: Packages.arc.util.Timer.Task,
          _delaySeconds: number,
          _intervalSeconds: number,
        ): Packages.arc.util.Timer.Task;
        public static schedule(
          _task: Packages.java.lang.Runnable,
          _delaySeconds: number,
        ): Packages.arc.util.Timer.Task;
        public static schedule(
          _task: Packages.arc.util.Timer.Task,
          _delaySeconds: number,
        ): Packages.arc.util.Timer.Task;
        public static schedule(
          _task: Packages.arc.util.Timer.Task,
          _delaySeconds: number,
          _intervalSeconds: number,
          _repeatCount: number,
        ): Packages.arc.util.Timer.Task;
        public static schedule(
          _task: Packages.java.lang.Runnable,
          _delaySeconds: number,
          _intervalSeconds: number,
        ): Packages.arc.util.Timer.Task;
        public static schedule(
          _task: Packages.java.lang.Runnable,
          _delaySeconds: number,
          _intervalSeconds: number,
          _repeatCount: number,
        ): Packages.arc.util.Timer.Task;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace ui {
        declare class TextField
          extends Packages.arc.scene.Element
          implements Packages.arc.scene.utils.Disableable
        {
          public static TextFieldStyle = class extends Packages
            .arc.scene.style.Style {
            public font: Packages.arc.graphics.g2d.Font;
            public fontColor: Packages.arc.graphics.Color;
            public focusedFontColor: Packages.arc.graphics.Color;
            public disabledFontColor: Packages.arc.graphics.Color;
            public background: Packages.arc.scene.style.Drawable;
            public focusedBackground: Packages.arc.scene.style.Drawable;
            public disabledBackground: Packages.arc.scene.style.Drawable;
            public invalidBackground: Packages.arc.scene.style.Drawable;
            public cursor: Packages.arc.scene.style.Drawable;
            public selection: Packages.arc.scene.style.Drawable;
            public messageFont: Packages.arc.graphics.g2d.Font;
            public messageFontColor: Packages.arc.graphics.Color;
            public constructor();
            public constructor(
              _style: Packages.arc.scene.ui.TextField.TextFieldStyle,
            );
          };
          KeyRepeatTask = class extends Packages.arc.util
            .Timer.Task {
            keycode: Packages.arc.input.KeyCode;
            this$0: Packages.arc.scene.ui.TextField;
            public run(): void;
          };
          public TextFieldClickListener = class extends Packages
            .arc.scene.event.ClickListener {
            this$0: Packages.arc.scene.ui.TextField;
            public keyDown(
              _event: Packages.arc.scene.event.InputEvent,
              _keycode: Packages.arc.input.KeyCode,
            ): boolean;
            public touchDown(
              _event: Packages.arc.scene.event.InputEvent,
              _x: number,
              _y: number,
              _pointer: number,
              _button: Packages.arc.input.KeyCode,
            ): boolean;
            public touchDragged(
              _event: Packages.arc.scene.event.InputEvent,
              _x: number,
              _y: number,
              _pointer: number,
            ): void;
            public touchUp(
              _event: Packages.arc.scene.event.InputEvent,
              _x: number,
              _y: number,
              _pointer: number,
              _button: Packages.arc.input.KeyCode,
            ): void;
            public keyUp(
              _event: Packages.arc.scene.event.InputEvent,
              _keycode: Packages.arc.input.KeyCode,
            ): boolean;
            public keyTyped(
              _event: Packages.arc.scene.event.InputEvent,
              _character: string,
            ): boolean;
            public clicked(
              _event: Packages.arc.scene.event.InputEvent,
              _x: number,
              _y: number,
            ): void;
            protected setCursorPosition(
              _x: number,
              _y: number,
            ): void;
            protected goHome(_jump: boolean): void;
            protected goEnd(_jump: boolean): void;
            protected scheduleKeyRepeatTask(
              _keycode: Packages.arc.input.KeyCode,
            ): void;
            protected checkFocusTraverse(
              _character: string,
            ): boolean;
            public constructor(
              _this$0: Packages.arc.scene.ui.TextField,
            );
          };
          public static TextFieldValidator = class {
            public valid(_text: string): boolean;
          };
          public static TextFieldFilter = class {
            public static digitsOnly: Packages.arc.scene.ui.TextField.TextFieldFilter;
            public static floatsOnly: Packages.arc.scene.ui.TextField.TextFieldFilter;
            public acceptChar(
              _textField: Packages.arc.scene.ui.TextField,
              _c: string,
            ): boolean;
          };
          public static TextFieldListener = class {
            public keyTyped(
              _textField: Packages.arc.scene.ui.TextField,
              _c: string,
            ): void;
          };
          protected static BACKSPACE: string;
          protected static TAB: string;
          protected static DELETE: string;
          protected static BULLET: string;
          private static tmp1: Packages.arc.math.geom.Vec2;
          private static tmp2: Packages.arc.math.geom.Vec2;
          private static tmp3: Packages.arc.math.geom.Vec2;
          public static keyRepeatInitialTime: number;
          public static keyRepeatTime: number;
          public imeData: any;
          protected layout: Packages.arc.graphics.g2d.GlyphLayout;
          protected glyphPositions: Packages.arc.struct.FloatSeq;
          protected text: string;
          protected cursor: number;
          protected selectionStart: number;
          protected hasSelection: boolean;
          protected writeEnters: boolean;
          protected displayText: Packages.java.lang.CharSequence;
          protected fontOffset: number;
          protected textHeight: number;
          protected textOffset: number;
          protected inputDialogListener: Packages.arc.scene.event.InputListener;
          protected style: Packages.arc.scene.ui.TextField.TextFieldStyle;
          protected inputListener: Packages.arc.scene.event.InputListener;
          protected listener: Packages.arc.scene.ui.TextField.TextFieldListener;
          protected validator: Packages.arc.scene.ui.TextField.TextFieldValidator;
          protected filter: Packages.arc.scene.ui.TextField.TextFieldFilter;
          protected focusTraversal: boolean;
          protected onlyFontChars: boolean;
          protected disabled: boolean;
          protected undoText: string;
          protected lastChangeTime: Packages.long;
          protected passwordMode: boolean;
          protected renderOffset: number;
          protected cursorOn: boolean;
          protected hasInputDialog: boolean;
          protected lastBlink: Packages.long;
          protected keyRepeatTask: Packages.arc.scene.ui.TextField.KeyRepeatTask;
          protected programmaticChangeEvents: boolean;
          protected messageText: string;
          protected textHAlign: number;
          protected selectionX: number;
          protected selectionWidth: number;
          protected passwordBuffer: Packages.java.lang.StringBuilder;
          protected passwordCharacter: string;
          protected visibleTextStart: number;
          protected visibleTextEnd: number;
          protected maxLength: number;
          protected blinkTime: number;
          insert(
            _position: number,
            _text: Packages.java.lang.CharSequence,
            _to: string,
          ): string;
          public next(_up: boolean): void;
          protected initialize(): void;
          delete(_fireChangeEvent: boolean): number;
          public copy(): void;
          public getFilter(): Packages.arc.scene.ui.TextField.TextFieldFilter;
          public appendText(_str: string): void;
          public getText(): string;
          public isValid(): boolean;
          public setFilter(
            _filter: Packages.arc.scene.ui.TextField.TextFieldFilter,
          ): void;
          public setText(_str: string): void;
          public draw(): void;
          public getStyle(): Packages.arc.scene.ui.TextField.TextFieldStyle;
          public isDisabled(): boolean;
          public setStyle(
            _style: Packages.arc.scene.ui.TextField.TextFieldStyle,
          ): void;
          public getPrefWidth(): number;
          public getPrefHeight(): number;
          public cut(): void;
          cut(_fireChangeEvent: boolean): void;
          protected updateDisplayText(): void;
          withinMaxLength(_size: number): boolean;
          changeText(
            _oldText: string,
            _newText: string,
          ): boolean;
          public clearSelection(): void;
          private findNextTextField(
            _elements: Packages.arc.struct.Seq<Packages.arc.scene.Element>,
            _best: Packages.arc.scene.ui.TextField,
            _bestCoords: Packages.arc.math.geom.Vec2,
            _currentCoords: Packages.arc.math.geom.Vec2,
            _up: boolean,
          ): Packages.arc.scene.ui.TextField;
          public setTextFieldListener(
            _listener: Packages.arc.scene.ui.TextField.TextFieldListener,
          ): void;
          public paste(
            _content: string,
            _fireChangeEvent: boolean,
          ): void;
          public setSelection(
            _selectionStart: number,
            _selectionEnd: number,
          ): void;
          protected continueCursor(
            _index: number,
            _offset: number,
          ): boolean;
          public clearText(): void;
          public removeInputDialog(): void;
          public getMaxLength(): number;
          public setMaxLength(_maxLength: number): void;
          public setOnlyFontChars(
            _onlyFontChars: boolean,
          ): void;
          public getDefaultInputListener(): Packages.arc.scene.event.InputListener;
          public typed(
            _cons: Packages.arc.func.Cons<string>,
          ): void;
          public typed(
            _ch: string,
            _run: Packages.java.lang.Runnable,
          ): void;
          public setValidator(
            _validator: Packages.arc.scene.ui.TextField.TextFieldValidator,
          ): void;
          public getValidator(): Packages.arc.scene.ui.TextField.TextFieldValidator;
          public setFocusTraversal(
            _focusTraversal: boolean,
          ): void;
          public getMessageText(): string;
          public setMessageText(_messageText: string): void;
          public getProgrammaticChangeEvents(): boolean;
          public setProgrammaticChangeEvents(
            _programmaticChangeEvents: boolean,
          ): void;
          public getSelectionStart(): number;
          public getSelection(): string;
          public selectAll(): void;
          public getCursorPosition(): number;
          public setCursorPosition(
            _cursorPosition: number,
          ): void;
          public isPasswordMode(): boolean;
          public setPasswordMode(
            _passwordMode: boolean,
          ): void;
          public setPasswordCharacter(
            _passwordCharacter: string,
          ): void;
          public setBlinkTime(_blinkTime: number): void;
          public setDisabled(_disabled: boolean): void;
          protected moveCursor(
            _forward: boolean,
            _jump: boolean,
          ): void;
          public setAlignment(_alignment: number): void;
          protected createInputListener(): Packages.arc.scene.event.InputListener;
          public addInputDialog(): void;
          private getBackgroundDrawable(): Packages.arc.scene.style.Drawable;
          protected isWordCharacter(_c: string): boolean;
          protected letterUnderCursor(_x: number): number;
          protected wordUnderCursor(
            _at: number,
          ): number[] | null;
          wordUnderCursor(_x: number): number[] | null;
          protected getTextY(
            _font: Packages.arc.graphics.g2d.Font,
            _background: Packages.arc.scene.style.Drawable,
          ): number;
          protected calculateOffsets(): void;
          protected drawSelection(
            _selection: Packages.arc.scene.style.Drawable,
            _font: Packages.arc.graphics.g2d.Font,
            _x: number,
            _y: number,
          ): void;
          protected drawText(
            _font: Packages.arc.graphics.g2d.Font,
            _x: number,
            _y: number,
          ): void;
          private blink(): void;
          protected drawCursor(
            _cursorPatch: Packages.arc.scene.style.Drawable,
            _font: Packages.arc.graphics.g2d.Font,
            _x: number,
            _y: number,
          ): void;
          public constructor(
            _text: string,
            _style: Packages.arc.scene.ui.TextField.TextFieldStyle,
          );
          public constructor(_text: string);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace ui {
        declare namespace layout {
          declare class Stack extends Packages.arc.scene.ui
            .layout.WidgetGroup {
            private prefWidth: number;
            private prefHeight: number;
            private minWidth: number;
            private minHeight: number;
            private sizeInvalid: boolean;
            public add(
              _actor: Packages.arc.scene.Element,
            ): void;
            public invalidate(): void;
            private computeSize(): void;
            public getPrefWidth(): number;
            public getPrefHeight(): number;
            public layout(): void;
            public getMinWidth(): number;
            public getMinHeight(): number;
            public constructor();
            public constructor(
              ..._actors: Packages.arc.scene.Element[]
            );
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace ui {
        declare class TextButton extends Packages.arc.scene
          .ui.Button {
          public static TextButtonStyle = class extends Packages
            .arc.scene.ui.Button.ButtonStyle {
            public font: Packages.arc.graphics.g2d.Font;
            public fontColor: Packages.arc.graphics.Color;
            public downFontColor: Packages.arc.graphics.Color;
            public overFontColor: Packages.arc.graphics.Color;
            public checkedFontColor: Packages.arc.graphics.Color;
            public checkedOverFontColor: Packages.arc.graphics.Color;
            public disabledFontColor: Packages.arc.graphics.Color;
            public constructor();
            public constructor(
              _up: Packages.arc.scene.style.Drawable,
              _down: Packages.arc.scene.style.Drawable,
              _checked: Packages.arc.scene.style.Drawable,
              _font: Packages.arc.graphics.g2d.Font,
            );
            public constructor(
              _style: Packages.arc.scene.ui.TextButton.TextButtonStyle,
            );
          };
          protected label: Packages.arc.scene.ui.Label;
          private style: Packages.arc.scene.ui.TextButton.TextButtonStyle;
          public getText(): Packages.java.lang.CharSequence;
          public setText(_text: string): void;
          public draw(): void;
          public getStyle(): Packages.arc.scene.ui.Button.ButtonStyle;
          public getStyle(): Packages.arc.scene.ui.TextButton.TextButtonStyle;
          public setStyle(
            _style: Packages.arc.scene.ui.Button.ButtonStyle,
          ): void;
          public getLabel(): Packages.arc.scene.ui.Label;
          public getLabelCell(): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.Label>;
          public constructor(_text: string);
          public constructor(
            _text: string,
            _style: Packages.arc.scene.ui.TextButton.TextButtonStyle,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace g2d {
        declare class NinePatch extends java.lang.Object {
          public static TOP_LEFT: number;
          public static TOP_CENTER: number;
          public static TOP_RIGHT: number;
          public static MIDDLE_LEFT: number;
          public static MIDDLE_CENTER: number;
          public static MIDDLE_RIGHT: number;
          public static BOTTOM_LEFT: number;
          public static BOTTOM_CENTER: number;
          public static BOTTOM_RIGHT: number;
          private static tmpDrawColor: Packages.arc.graphics.Color;
          private color: Packages.arc.graphics.Color;
          private texture: Packages.arc.graphics.Texture;
          private bottomLeft: number;
          private bottomCenter: number;
          private bottomRight: number;
          private middleLeft: number;
          private middleCenter: number;
          private middleRight: number;
          private topLeft: number;
          private topCenter: number;
          private topRight: number;
          private leftWidth: number;
          private rightWidth: number;
          private middleWidth: number;
          private middleHeight: number;
          private topHeight: number;
          private bottomHeight: number;
          private vertices: number[];
          private idx: number;
          private padLeft: number;
          private padRight: number;
          private padTop: number;
          private padBottom: number;
          private add(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _color: number,
            _isStretchW: boolean,
            _isStretchH: boolean,
          ): number;
          private load(
            _patches: Packages.arc.graphics.g2d.TextureRegion[],
          ): void;
          public scale(
            _scaleX: number,
            _scaleY: number,
          ): void;
          private set(
            _idx: number,
            _x: number,
            _y: number,
            _width: number,
            _height: number,
            _color: number,
          ): void;
          public setColor(
            _color: Packages.arc.graphics.Color,
          ): void;
          public draw(
            _x: number,
            _y: number,
            _originX: number,
            _originY: number,
            _width: number,
            _height: number,
            _scaleX: number,
            _scaleY: number,
            _rotation: number,
          ): void;
          public draw(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          ): void;
          public setPadding(
            _left: number,
            _right: number,
            _top: number,
            _bottom: number,
          ): void;
          private prepareVertices(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          ): void;
          public getMiddleWidth(): number;
          public setMiddleWidth(_middleWidth: number): void;
          public getMiddleHeight(): number;
          public setMiddleHeight(
            _middleHeight: number,
          ): void;
          public getTotalWidth(): number;
          public getTotalHeight(): number;
          public getPadLeft(): number;
          public setPadLeft(_left: number): void;
          public getPadRight(): number;
          public setPadRight(_right: number): void;
          public getPadTop(): number;
          public setPadTop(_top: number): void;
          public getPadBottom(): number;
          public setPadBottom(_bottom: number): void;
          public getTexture(): Packages.arc.graphics.Texture;
          public getTopHeight(): number;
          public getLeftWidth(): number;
          public getBottomHeight(): number;
          public getRightWidth(): number;
          public getColor(): Packages.arc.graphics.Color;
          public setLeftWidth(_leftWidth: number): void;
          public setRightWidth(_rightWidth: number): void;
          public setTopHeight(_topHeight: number): void;
          public setBottomHeight(
            _bottomHeight: number,
          ): void;
          public constructor(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _color: Packages.arc.graphics.Color,
          );
          public constructor(
            _region: Packages.arc.graphics.g2d.TextureRegion,
          );
          public constructor(
            ..._patches: Packages.arc.graphics.g2d.TextureRegion[]
          );
          public constructor(
            _ninePatch: Packages.arc.graphics.g2d.NinePatch,
          );
          public constructor(
            _ninePatch: Packages.arc.graphics.g2d.NinePatch,
            _color: Packages.arc.graphics.Color,
          );
          public constructor(
            _texture: Packages.arc.graphics.Texture,
            _left: number,
            _right: number,
            _top: number,
            _bottom: number,
          );
          public constructor(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _left: number,
            _right: number,
            _top: number,
            _bottom: number,
          );
          public constructor(
            _texture: Packages.arc.graphics.Texture,
            _color: Packages.arc.graphics.Color,
          );
          public constructor(
            _texture: Packages.arc.graphics.Texture,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace ui {
        declare class Image extends Packages.arc.scene
          .Element {
          protected imageX: number;
          protected imageY: number;
          protected imageWidth: number;
          protected imageHeight: number;
          private scaling: Packages.arc.util.Scaling;
          private align: number;
          private drawable: Packages.arc.scene.style.Drawable;
          public getRegion(): Packages.arc.graphics.g2d.TextureRegion;
          public draw(): void;
          public getDrawable(): Packages.arc.scene.style.Drawable;
          public setDrawable(
            _region: Packages.arc.graphics.g2d.TextureRegion,
          ): void;
          public setDrawable(
            _drawable: Packages.arc.scene.style.Drawable,
          ): void;
          public getPrefWidth(): number;
          public getPrefHeight(): number;
          public layout(): void;
          public getMinWidth(): number;
          public getMinHeight(): number;
          public setScaling(
            _scaling: Packages.arc.util.Scaling,
          ): Packages.arc.scene.ui.Image;
          public setAlign(_align: number): void;
          public getImageX(): number;
          public getImageY(): number;
          public getImageWidth(): number;
          public getImageHeight(): number;
          public constructor(
            _texture: Packages.arc.graphics.Texture,
          );
          public constructor(
            _drawable: Packages.arc.scene.style.Drawable,
          );
          public constructor(
            _drawable: Packages.arc.scene.style.Drawable,
            _scaling: Packages.arc.util.Scaling,
          );
          public constructor(
            _drawable: Packages.arc.scene.style.Drawable,
            _scaling: Packages.arc.util.Scaling,
            _align: number,
          );
          public constructor();
          public constructor(
            _name: Packages.arc.scene.style.Drawable,
            _color: Packages.arc.graphics.Color,
          );
          public constructor(
            _patch: Packages.arc.graphics.g2d.NinePatch,
          );
          public constructor(
            _region: Packages.arc.graphics.g2d.TextureRegion,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace ui {
        declare class CheckBox extends Packages.arc.scene.ui
          .TextButton {
          public static CheckBoxStyle = class extends Packages
            .arc.scene.ui.TextButton.TextButtonStyle {
            public checkboxOn: Packages.arc.scene.style.Drawable;
            public checkboxOff: Packages.arc.scene.style.Drawable;
            public checkboxOver: Packages.arc.scene.style.Drawable;
            public checkboxOnDisabled: Packages.arc.scene.style.Drawable;
            public checkboxOffDisabled: Packages.arc.scene.style.Drawable;
            public checkboxOnOver: Packages.arc.scene.style.Drawable;
            public constructor();
          };
          private image: Packages.arc.scene.ui.Image;
          private imageCell: Packages.arc.scene.ui.layout.Cell<any>;
          private style: Packages.arc.scene.ui.CheckBox.CheckBoxStyle;
          public draw(): void;
          public getStyle(): Packages.arc.scene.ui.TextButton.TextButtonStyle;
          public getStyle(): Packages.arc.scene.ui.CheckBox.CheckBoxStyle;
          public getStyle(): Packages.arc.scene.ui.Button.ButtonStyle;
          public getImageCell(): Packages.arc.scene.ui.layout.Cell<any>;
          public setStyle(
            _style: Packages.arc.scene.ui.Button.ButtonStyle,
          ): void;
          public getImage(): Packages.arc.scene.ui.Image;
          public constructor(_text: string);
          public constructor(
            _text: string,
            _style: Packages.arc.scene.ui.CheckBox.CheckBoxStyle,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class Boolc {
        public get(_b: boolean): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace ui {
        declare class ImageButton extends Packages.arc.scene
          .ui.Button {
          public static ImageButtonStyle = class extends Packages
            .arc.scene.ui.Button.ButtonStyle {
            public imageUp: Packages.arc.scene.style.Drawable;
            public imageDown: Packages.arc.scene.style.Drawable;
            public imageOver: Packages.arc.scene.style.Drawable;
            public imageChecked: Packages.arc.scene.style.Drawable;
            public imageCheckedOver: Packages.arc.scene.style.Drawable;
            public imageDisabled: Packages.arc.scene.style.Drawable;
            public imageUpColor: Packages.arc.graphics.Color;
            public imageCheckedColor: Packages.arc.graphics.Color;
            public imageDownColor: Packages.arc.graphics.Color;
            public imageOverColor: Packages.arc.graphics.Color;
            public imageDisabledColor: Packages.arc.graphics.Color;
            public constructor();
            public constructor(
              _up: Packages.arc.scene.style.Drawable,
              _down: Packages.arc.scene.style.Drawable,
              _checked: Packages.arc.scene.style.Drawable,
              _imageUp: Packages.arc.scene.style.Drawable,
              _imageDown: Packages.arc.scene.style.Drawable,
              _imageChecked: Packages.arc.scene.style.Drawable,
            );
            public constructor(
              _style: Packages.arc.scene.ui.ImageButton.ImageButtonStyle,
            );
          };
          private image: Packages.arc.scene.ui.Image;
          private style: Packages.arc.scene.ui.ImageButton.ImageButtonStyle;
          public draw(): void;
          public getStyle(): Packages.arc.scene.ui.Button.ButtonStyle;
          public getStyle(): Packages.arc.scene.ui.ImageButton.ImageButtonStyle;
          public getImageCell(): Packages.arc.scene.ui.layout.Cell<any>;
          public resizeImage(_size: number): void;
          public setStyle(
            _style: Packages.arc.scene.ui.Button.ButtonStyle,
          ): void;
          protected updateImage(): void;
          public replaceImage(
            _element: Packages.arc.scene.Element,
          ): void;
          public getImage(): Packages.arc.scene.ui.Image;
          public constructor(
            _style: Packages.arc.scene.ui.ImageButton.ImageButtonStyle,
          );
          public constructor(
            _imageUp: Packages.arc.scene.style.Drawable,
          );
          public constructor(
            _imageUp: Packages.arc.scene.style.Drawable,
            _imageDown: Packages.arc.scene.style.Drawable,
          );
          public constructor(
            _imageUp: Packages.arc.scene.style.Drawable,
            _imageDown: Packages.arc.scene.style.Drawable,
            _imageChecked: Packages.arc.scene.style.Drawable,
          );
          public constructor();
          public constructor(
            _icon: Packages.arc.scene.style.Drawable,
            _stylen: Packages.arc.scene.ui.ImageButton.ImageButtonStyle,
          );
          public constructor(
            _region: Packages.arc.graphics.g2d.TextureRegion,
          );
          public constructor(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _stylen: Packages.arc.scene.ui.ImageButton.ImageButtonStyle,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace ui {
        declare class TextArea extends Packages.arc.scene.ui
          .TextField {
          public TextAreaListener = class extends Packages
            .arc.scene.ui.TextField.TextFieldClickListener {
            this$0: Packages.arc.scene.ui.TextArea;
            public keyDown(
              _event: Packages.arc.scene.event.InputEvent,
              _keycode: Packages.arc.input.KeyCode,
            ): boolean;
            public keyTyped(
              _event: Packages.arc.scene.event.InputEvent,
              _character: string,
            ): boolean;
            protected setCursorPosition(
              _x: number,
              _y: number,
            ): void;
            protected goHome(_jump: boolean): void;
            protected goEnd(_jump: boolean): void;
            protected checkFocusTraverse(
              _character: string,
            ): boolean;
            public constructor(
              _this$0: Packages.arc.scene.ui.TextArea,
            );
          };
          protected linesBreak: Packages.arc.struct.IntSeq;
          protected cursorLine: number;
          protected firstLineShowing: number;
          protected moveOffset: number;
          protected lastText: string;
          protected linesShowing: number;
          protected prefRows: number;
          protected initialize(): void;
          protected sizeChanged(): void;
          public getPrefHeight(): number;
          public setSelection(
            _selectionStart: number,
            _selectionEnd: number,
          ): void;
          protected continueCursor(
            _index: number,
            _offset: number,
          ): boolean;
          protected moveCursor(
            _forward: boolean,
            _jump: boolean,
          ): void;
          public newLineAtEnd(): boolean;
          public getLines(): number;
          showCursor(): void;
          private calculateCurrentLineIndex(
            _cursor: number,
          ): number;
          updateCurrentLine(): void;
          public setPrefRows(_prefRows: number): void;
          public moveCursorLine(_line: number): void;
          public getCursorLine(): number;
          public getFirstLineShowing(): number;
          public getLinesShowing(): number;
          public getCursorX(): number;
          public getCursorY(): number;
          protected createInputListener(): Packages.arc.scene.event.InputListener;
          protected letterUnderCursor(_x: number): number;
          protected getTextY(
            _font: Packages.arc.graphics.g2d.Font,
            _background: Packages.arc.scene.style.Drawable,
          ): number;
          protected calculateOffsets(): void;
          protected drawSelection(
            _selection: Packages.arc.scene.style.Drawable,
            _font: Packages.arc.graphics.g2d.Font,
            _x: number,
            _y: number,
          ): void;
          protected drawText(
            _font: Packages.arc.graphics.g2d.Font,
            _x: number,
            _y: number,
          ): void;
          protected drawCursor(
            _cursorPatch: Packages.arc.scene.style.Drawable,
            _font: Packages.arc.graphics.g2d.Font,
            _x: number,
            _y: number,
          ): void;
          public constructor(_text: string);
          public constructor(
            _text: string,
            _style: Packages.arc.scene.ui.TextField.TextFieldStyle,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare abstract class Action
        extends java.lang.Object
        implements Packages.arc.util.pooling.Pool.Poolable
      {
        protected actor: Packages.arc.scene.Element;
        protected target: Packages.arc.scene.Element;
        private pool: Packages.arc.util.pooling.Pool<Packages.arc.scene.Action>;
        public toString(): string;
        public getTarget(): Packages.arc.scene.Element;
        public setTarget(
          _target: Packages.arc.scene.Element,
        ): void;
        public reset(): void;
        public getPool(): Packages.arc.util.pooling.Pool<Packages.arc.scene.Action>;
        public act(_delta: number): boolean;
        public setActor(
          _actor: Packages.arc.scene.Element,
        ): void;
        public restart(): void;
        public getActor(): Packages.arc.scene.Element;
        public setPool(
          _pool: Packages.arc.util.pooling.Pool<any>,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace ui {
        declare namespace layout {
          declare class Collapser extends Packages.arc.scene
            .ui.layout.WidgetGroup {
            private CollapseAction = class extends Packages
              .arc.scene.Action {
              this$0: Packages.arc.scene.ui.layout.Collapser;
              public act(_delta: number): boolean;
            };
            table: Packages.arc.scene.ui.layout.Table;
            collapsedFunc?: Packages.arc.func.Boolp;
            private collapseAction: Packages.arc.scene.ui.layout.Collapser.CollapseAction;
            collapsed: boolean;
            autoAnimate: boolean;
            actionRunning: boolean;
            currentHeight: number;
            seconds: number;
            public draw(): void;
            public act(_delta: number): void;
            public setCollapsed(
              _collapse: boolean,
              _withAnimation: boolean,
            ): void;
            public setCollapsed(_collapse: boolean): void;
            public setCollapsed(
              _autoAnimate: boolean,
              _collapsed: Packages.arc.func.Boolp,
            ): Packages.arc.scene.ui.layout.Collapser;
            public setCollapsed(
              _collapsed: Packages.arc.func.Boolp,
            ): Packages.arc.scene.ui.layout.Collapser;
            protected childrenChanged(): void;
            public getPrefWidth(): number;
            public getPrefHeight(): number;
            public layout(): void;
            public getMinWidth(): number;
            public getMinHeight(): number;
            public setDuration(
              _seconds: number,
            ): Packages.arc.scene.ui.layout.Collapser;
            public setTable(
              _table: Packages.arc.scene.ui.layout.Table,
            ): void;
            public toggle(): void;
            public toggle(_animated: boolean): void;
            private updateTouchable(): void;
            public isCollapsed(): boolean;
            public constructor(
              _cons: Packages.arc.func.Cons<Packages.arc.scene.ui.layout.Table>,
              _collapsed: boolean,
            );
            public constructor(
              _table: Packages.arc.scene.ui.layout.Table,
              _collapsed: boolean,
            );
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace input {
      declare class GestureDetector
        extends java.lang.Object
        implements Packages.arc.input.InputProcessor
      {
        public static GestureListener = class {
          public pan(
            _x: number,
            _y: number,
            _deltaX: number,
            _deltaY: number,
          ): boolean;
          public touchDown(
            _x: number,
            _y: number,
            _pointer: number,
            _button: Packages.arc.input.KeyCode,
          ): boolean;
          public fling(
            _velocityX: number,
            _velocityY: number,
            _button: Packages.arc.input.KeyCode,
          ): boolean;
          public tap(
            _x: number,
            _y: number,
            _count: number,
            _button: Packages.arc.input.KeyCode,
          ): boolean;
          public longPress(_x: number, _y: number): boolean;
          public zoom(
            _initialDistance: number,
            _distance: number,
          ): boolean;
          public pinch(
            _initialPointer1: Packages.arc.math.geom.Vec2,
            _initialPointer2: Packages.arc.math.geom.Vec2,
            _pointer1: Packages.arc.math.geom.Vec2,
            _pointer2: Packages.arc.math.geom.Vec2,
          ): boolean;
          public panStop(
            _x: number,
            _y: number,
            _pointer: number,
            _button: Packages.arc.input.KeyCode,
          ): boolean;
          public pinchStop(): void;
        };
        static VelocityTracker = class extends java.lang
          .Object {
          sampleSize: number;
          lastX: number;
          lastY: number;
          deltaX: number;
          deltaY: number;
          lastTime: Packages.long;
          numSamples: number;
          meanX: number[];
          meanY: number[];
          meanTime: Packages.long[];
          public update(
            _x: number,
            _y: number,
            _currTime: Packages.long,
          ): void;
          public start(
            _x: number,
            _y: number,
            _timeStamp: Packages.long,
          ): void;
          private getSum(
            _values: number[],
            _numSamples: number,
          ): number;
          private getAverage(
            _values: Packages.long[],
            _numSamples: number,
          ): Packages.long;
          private getAverage(
            _values: number[],
            _numSamples: number,
          ): number;
          public getVelocityX(): number;
          public getVelocityY(): number;
        };
        listener: Packages.arc.input.GestureDetector.GestureListener;
        private tracker: Packages.arc.input.GestureDetector.VelocityTracker;
        private pointer2: Packages.arc.math.geom.Vec2;
        private initialPointer1: Packages.arc.math.geom.Vec2;
        private initialPointer2: Packages.arc.math.geom.Vec2;
        longPressFired: boolean;
        pointer1: Packages.arc.math.geom.Vec2;
        private longPressTask: Packages.arc.util.Timer.Task;
        private tapRectangleWidth: number;
        private tapRectangleHeight: number;
        private tapCountInterval: Packages.long;
        private longPressSeconds: number;
        private maxFlingDelay: Packages.long;
        private inTapRectangle: boolean;
        private tapCount: number;
        private lastTapTime: Packages.long;
        private lastTapX: number;
        private lastTapY: number;
        private lastTapPointer: number;
        private lastTapButton: Packages.arc.input.KeyCode;
        private pinching: boolean;
        private panning: boolean;
        private tapRectangleCenterX: number;
        private tapRectangleCenterY: number;
        private gestureStartTime: Packages.long;
        public reset(): void;
        public cancel(): void;
        public touchDown(
          _x: number,
          _y: number,
          _pointer: number,
          _button: Packages.arc.input.KeyCode,
        ): boolean;
        public touchDown(
          _x: number,
          _y: number,
          _pointer: number,
          _button: Packages.arc.input.KeyCode,
        ): boolean;
        public touchDragged(
          _x: number,
          _y: number,
          _pointer: number,
        ): boolean;
        public touchDragged(
          _x: number,
          _y: number,
          _pointer: number,
        ): boolean;
        public touchUp(
          _x: number,
          _y: number,
          _pointer: number,
          _button: Packages.arc.input.KeyCode,
        ): boolean;
        public touchUp(
          _x: number,
          _y: number,
          _pointer: number,
          _button: Packages.arc.input.KeyCode,
        ): boolean;
        public invalidateTapSquare(): void;
        public setTapSquareSize(
          _halfTapSquareSize: number,
        ): void;
        public setTapCountInterval(
          _tapCountInterval: number,
        ): void;
        public isPanning(): boolean;
        private isWithinTapRectangle(
          _x: number,
          _y: number,
          _centerX: number,
          _centerY: number,
        ): boolean;
        public isLongPressed(_duration: number): boolean;
        public isLongPressed(): boolean;
        public setTapRectangleSize(
          _halfTapRectangleWidth: number,
          _halfTapRectangleHeight: number,
        ): void;
        public getListener(): Packages.arc.input.GestureDetector.GestureListener;
        public setLongPressSeconds(
          _longPressSeconds: number,
        ): void;
        public setMaxFlingDelay(
          _maxFlingDelay: Packages.long,
        ): void;
        public constructor(
          _halfTapRectangleWidth: number,
          _halfTapRectangleHeight: number,
          _tapCountInterval: number,
          _longPressDuration: number,
          _maxFlingDelay: number,
          _listener: Packages.arc.input.GestureDetector.GestureListener,
        );
        public constructor(
          _halfTapSquareSize: number,
          _tapCountInterval: number,
          _longPressDuration: number,
          _maxFlingDelay: number,
          _listener: Packages.arc.input.GestureDetector.GestureListener,
        );
        public constructor(
          _listener: Packages.arc.input.GestureDetector.GestureListener,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace event {
        declare class ElementGestureListener
          extends java.lang.Object
          implements Packages.arc.scene.event.EventListener
        {
          static tmpCoords: Packages.arc.math.geom.Vec2;
          static tmpCoords2: Packages.arc.math.geom.Vec2;
          private detector: Packages.arc.input.GestureDetector;
          event: Packages.arc.scene.event.InputEvent;
          actor: Packages.arc.scene.Element;
          touchDownTarget: Packages.arc.scene.Element;
          public handle(
            _e: Packages.arc.scene.event.SceneEvent,
          ): boolean;
          public pan(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _deltaX: number,
            _deltaY: number,
          ): void;
          public touchDown(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
            _button: Packages.arc.input.KeyCode,
          ): void;
          public touchUp(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
            _button: Packages.arc.input.KeyCode,
          ): void;
          public fling(
            _event: Packages.arc.scene.event.InputEvent,
            _velocityX: number,
            _velocityY: number,
            _button: Packages.arc.input.KeyCode,
          ): void;
          public getGestureDetector(): Packages.arc.input.GestureDetector;
          public tap(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _count: number,
            _button: Packages.arc.input.KeyCode,
          ): void;
          public longPress(
            _actor: Packages.arc.scene.Element,
            _x: number,
            _y: number,
          ): boolean;
          public zoom(
            _event: Packages.arc.scene.event.InputEvent,
            _initialDistance: number,
            _distance: number,
          ): void;
          public pinch(
            _event: Packages.arc.scene.event.InputEvent,
            _initialPointer1: Packages.arc.math.geom.Vec2,
            _initialPointer2: Packages.arc.math.geom.Vec2,
            _pointer1: Packages.arc.math.geom.Vec2,
            _pointer2: Packages.arc.math.geom.Vec2,
          ): void;
          public getTouchDownTarget(): Packages.arc.scene.Element;
          public constructor();
          public constructor(
            _halfTapSquareSize: number,
            _tapCountInterval: number,
            _longPressDuration: number,
            _maxFlingDelay: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace ui {
        declare class ScrollPane extends Packages.arc.scene
          .ui.layout.WidgetGroup {
          public static ScrollPaneStyle = class extends Packages
            .arc.scene.style.Style {
            public background: Packages.arc.scene.style.Drawable;
            public corner: Packages.arc.scene.style.Drawable;
            public hScroll: Packages.arc.scene.style.Drawable;
            public hScrollKnob: Packages.arc.scene.style.Drawable;
            public vScroll: Packages.arc.scene.style.Drawable;
            public vScrollKnob: Packages.arc.scene.style.Drawable;
            public constructor();
            public constructor(
              _style: Packages.arc.scene.ui.ScrollPane.ScrollPaneStyle,
            );
          };
          hScrollBounds: Packages.arc.math.geom.Rect;
          vScrollBounds: Packages.arc.math.geom.Rect;
          hKnobBounds: Packages.arc.math.geom.Rect;
          vKnobBounds: Packages.arc.math.geom.Rect;
          lastPoint: Packages.arc.math.geom.Vec2;
          private widgetAreaBounds: Packages.arc.math.geom.Rect;
          private widgetCullingArea: Packages.arc.math.geom.Rect;
          private scissorBounds: Packages.arc.math.geom.Rect;
          protected disableX: boolean;
          protected disableY: boolean;
          vScrollOnRight: boolean;
          hScrollOnBottom: boolean;
          amountX: number;
          amountY: number;
          visualAmountX: number;
          visualAmountY: number;
          maxX: number;
          maxY: number;
          touchScrollH: boolean;
          touchScrollV: boolean;
          areaWidth: number;
          areaHeight: number;
          fadeAlpha: number;
          fadeAlphaSeconds: number;
          fadeDelay: number;
          fadeDelaySeconds: number;
          flickScroll: boolean;
          velocityX: number;
          velocityY: number;
          flingTimer: number;
          flingTime: number;
          draggingPointer: number;
          private style: Packages.arc.scene.ui.ScrollPane.ScrollPaneStyle;
          private widget: Packages.arc.scene.Element;
          private flickScrollListener: Packages.arc.scene.event.ElementGestureListener;
          private fadeScrollBars: boolean;
          private smoothScrolling: boolean;
          private overscrollX: boolean;
          private overscrollY: boolean;
          private overscrollDistance: number;
          private overscrollSpeedMin: number;
          private overscrollSpeedMax: number;
          private forceScrollX: boolean;
          private forceScrollY: boolean;
          private scrollbarsOnTop: boolean;
          private variableSizeKnobs: boolean;
          private clip: boolean;
          public cancel(): void;
          public hit(
            _x: number,
            _y: number,
            _touchable: boolean,
          ): Packages.arc.scene.Element;
          clamp(): void;
          public draw(): void;
          public act(_delta: number): void;
          public cancelTouchFocus(): void;
          public getStyle(): Packages.arc.scene.ui.ScrollPane.ScrollPaneStyle;
          public removeChild(
            _actor: Packages.arc.scene.Element,
            _unfocus: boolean,
          ): boolean;
          public removeChild(
            _actor: Packages.arc.scene.Element,
          ): boolean;
          public setStyle(
            _style: Packages.arc.scene.ui.ScrollPane.ScrollPaneStyle,
          ): void;
          public setClip(_clip: boolean): void;
          public getPrefWidth(): number;
          public getPrefHeight(): number;
          public layout(): void;
          public getMinWidth(): number;
          public getMinHeight(): number;
          public fling(
            _flingTime: number,
            _velocityX: number,
            _velocityY: number,
          ): void;
          public getWidget(): Packages.arc.scene.Element;
          protected getMouseWheelX(): number;
          protected getMouseWheelY(): number;
          public setScrollXForce(_pixels: number): void;
          public getScrollX(): number;
          public setScrollYForce(_pixels: number): void;
          public getScrollY(): number;
          public updateVisualScroll(): void;
          public getVisualScrollX(): number;
          public getVisualScrollY(): number;
          public setScrollPercentX(_percentX: number): void;
          public setScrollPercentY(_percentY: number): void;
          public setFlickScroll(
            _flickScroll: boolean,
          ): void;
          public setFlickScrollTapSquareSize(
            _halfTapSquareSize: number,
          ): void;
          public getMaxX(): number;
          public getMaxY(): number;
          public getScrollBarHeight(): number;
          public getScrollBarWidth(): number;
          public getScrollWidth(): number;
          public getScrollHeight(): number;
          public isScrollX(): boolean;
          public setScrollX(_pixels: number): void;
          public isScrollY(): boolean;
          public setScrollY(_pixels: number): void;
          public setScrollingDisabled(
            _x: boolean,
            _y: boolean,
          ): void;
          public setScrollingDisabledX(_x: boolean): void;
          public setScrollingDisabledY(_y: boolean): void;
          public isScrollingDisabledX(): boolean;
          public isScrollingDisabledY(): boolean;
          public isLeftEdge(): boolean;
          public isRightEdge(): boolean;
          public isTopEdge(): boolean;
          public isBottomEdge(): boolean;
          public isDragging(): boolean;
          public isFlinging(): boolean;
          public getVelocityX(): number;
          public setVelocityX(_velocityX: number): void;
          public getVelocityY(): number;
          public setVelocityY(_velocityY: number): void;
          public setOverscroll(
            _overscrollX: boolean,
            _overscrollY: boolean,
          ): void;
          public setupOverscroll(
            _distance: number,
            _speedMin: number,
            _speedMax: number,
          ): void;
          public setForceScroll(
            _x: boolean,
            _y: boolean,
          ): void;
          public isForceScrollX(): boolean;
          public isForceScrollY(): boolean;
          public setFlingTime(_flingTime: number): void;
          public setClamp(_clamp: boolean): void;
          public setScrollBarPositions(
            _bottom: boolean,
            _right: boolean,
          ): void;
          public setFadeScrollBars(
            _fadeScrollBars: boolean,
          ): void;
          public setupFadeScrollBars(
            _fadeAlphaSeconds: number,
            _fadeDelaySeconds: number,
          ): void;
          public setSmoothScrolling(
            _smoothScrolling: boolean,
          ): void;
          public setScrollbarsOnTop(
            _scrollbarsOnTop: boolean,
          ): void;
          public getVariableSizeKnobs(): boolean;
          public setVariableSizeKnobs(
            _variableSizeKnobs: boolean,
          ): void;
          public setCancelTouchFocus(
            _cancelTouchFocus: boolean,
          ): void;
          public setWidget(
            _widget: Packages.arc.scene.Element,
          ): void;
          protected scrollX(_pixelsX: number): void;
          protected scrollY(_pixelsY: number): void;
          public isPanning(): boolean;
          resetFade(): void;
          protected visualScrollX(_pixelsX: number): void;
          protected visualScrollY(_pixelsY: number): void;
          public getScrollPercentX(): number;
          public getScrollPercentY(): number;
          public getVisualScrollPercentX(): number;
          public getVisualScrollPercentY(): number;
          public scrollTo(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
            _centerHorizontal: boolean,
            _centerVertical: boolean,
          ): void;
          public scrollTo(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          ): void;
          public constructor(
            _widget: Packages.arc.scene.Element,
          );
          public constructor(
            _widget: Packages.arc.scene.Element,
            _style: Packages.arc.scene.ui.ScrollPane.ScrollPaneStyle,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace ui {
        declare class ProgressBar
          extends Packages.arc.scene.Element
          implements Packages.arc.scene.utils.Disableable
        {
          public static ProgressBarStyle = class extends Packages
            .arc.scene.style.Style {
            public background: Packages.arc.scene.style.Drawable;
            public disabledBackground: Packages.arc.scene.style.Drawable;
            public knob: Packages.arc.scene.style.Drawable;
            public disabledKnob: Packages.arc.scene.style.Drawable;
            public knobBefore: Packages.arc.scene.style.Drawable;
            public knobAfter: Packages.arc.scene.style.Drawable;
            public disabledKnobBefore: Packages.arc.scene.style.Drawable;
            public disabledKnobAfter: Packages.arc.scene.style.Drawable;
            public constructor();
            public constructor(
              _background: Packages.arc.scene.style.Drawable,
              _knob: Packages.arc.scene.style.Drawable,
            );
            public constructor(
              _style: Packages.arc.scene.ui.ProgressBar.ProgressBarStyle,
            );
          };
          vertical: boolean;
          position: number;
          disabled: boolean;
          private style: Packages.arc.scene.ui.ProgressBar.ProgressBarStyle;
          private min: number;
          private max: number;
          private stepSize: number;
          private value: number;
          private animateFromValue: number;
          private animateDuration: number;
          private animateTime: number;
          private animateInterpolation: Packages.arc.math.Interp;
          private visualInterpolation: Packages.arc.math.Interp;
          private round: boolean;
          public getValue(): number;
          public setValue(_value: number): boolean;
          public getPercent(): number;
          protected clamp(_value: number): number;
          public draw(): void;
          public act(_delta: number): void;
          public getStyle(): Packages.arc.scene.ui.ProgressBar.ProgressBarStyle;
          public isDisabled(): boolean;
          public setStyle(
            _style: Packages.arc.scene.ui.ProgressBar.ProgressBarStyle,
          ): void;
          public getPrefWidth(): number;
          public getPrefHeight(): number;
          public setDisabled(_disabled: boolean): void;
          protected getKnobDrawable(): Packages.arc.scene.style.Drawable;
          public getMinValue(): number;
          public getMaxValue(): number;
          public getVisualPercent(): number;
          public getVisualValue(): number;
          public setRound(_round: boolean): void;
          protected getKnobPosition(): number;
          public setRange(_min: number, _max: number): void;
          public getStepSize(): number;
          public setStepSize(_stepSize: number): void;
          public setAnimateDuration(
            _duration: number,
          ): void;
          public setAnimateInterpolation(
            _animateInterpolation: Packages.arc.math.Interp,
          ): void;
          public setVisualInterpolation(
            _interpolation: Packages.arc.math.Interp,
          ): void;
          public isVertical(): boolean;
          public constructor(
            _min: number,
            _max: number,
            _stepSize: number,
            _vertical: boolean,
            _style: Packages.arc.scene.ui.ProgressBar.ProgressBarStyle,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class Floatc {
        public get(_f: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace ui {
        declare class Slider extends Packages.arc.scene.ui
          .ProgressBar {
          public static SliderStyle = class extends Packages
            .arc.scene.ui.ProgressBar.ProgressBarStyle {
            public knobOver: Packages.arc.scene.style.Drawable;
            public knobDown: Packages.arc.scene.style.Drawable;
            public constructor();
          };
          draggingPointer: number;
          mouseOver: boolean;
          private visualInterpolationInverse: Packages.arc.math.Interp;
          private snapValues: number[];
          private threshold: number;
          protected snap(_value: number): number;
          public getStyle(): Packages.arc.scene.ui.ProgressBar.ProgressBarStyle;
          public getStyle(): Packages.arc.scene.ui.Slider.SliderStyle;
          public setStyle(
            _style: Packages.arc.scene.ui.Slider.SliderStyle,
          ): void;
          public moved(
            _listener: Packages.arc.func.Floatc,
          ): void;
          public isDragging(): boolean;
          protected getKnobDrawable(): Packages.arc.scene.style.Drawable;
          calculatePositionAndValue(
            _x: number,
            _y: number,
          ): boolean;
          public setSnapToValues(
            _values: number[],
            _threshold: number,
          ): void;
          public setVisualInterpolationInverse(
            _interpolation: Packages.arc.math.Interp,
          ): void;
          public constructor(
            _min: number,
            _max: number,
            _stepSize: number,
            _vertical: boolean,
          );
          public constructor(
            _min: number,
            _max: number,
            _stepSize: number,
            _vertical: boolean,
            _style: Packages.arc.scene.ui.Slider.SliderStyle,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace ui {
        declare namespace layout {
          declare class Table extends Packages.arc.scene.ui
            .layout.WidgetGroup {
            public static DrawRect = class {
              public draw(
                _x: number,
                _y: number,
                _width: number,
                _height: number,
              ): void;
            };
            private static columnWeightedWidth: number[];
            private static rowWeightedHeight: number[];
            private static cellPool: Packages.arc.util.pooling.Pool<
              Packages.arc.scene.ui.layout.Cell<any>
            >;
            private cells: Packages.arc.struct.Seq<
              Packages.arc.scene.ui.layout.Cell<any>
            >;
            private cellDefaults: Packages.arc.scene.ui.layout.Cell<any>;
            marginBot: number;
            round: boolean;
            private columns: number;
            private rows: number;
            private implicitEndRow: boolean;
            private rowDefaults: Packages.arc.scene.ui.layout.Cell<any>;
            private sizeInvalid: boolean;
            private columnMinWidth: number[];
            private rowMinHeight: number[];
            private columnPrefWidth: number[];
            private rowPrefHeight: number[];
            private tableMinWidth: number;
            private tableMinHeight: number;
            private tablePrefWidth: number;
            private tablePrefHeight: number;
            private columnWidth: number[];
            private rowHeight: number[];
            private expandWidth: number[];
            private expandHeight: number[];
            private clip: boolean;
            public add(
              _text: Packages.java.lang.CharSequence,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.Label>;
            public add(
              _text: Packages.java.lang.CharSequence,
              _color: Packages.arc.graphics.Color,
              _scl: number,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.Label>;
            public add(
              _text: Packages.java.lang.CharSequence,
              _labelStyle: Packages.arc.scene.ui.Label.LabelStyle,
              _scl: number,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.Label>;
            public add(
              _text: Packages.java.lang.CharSequence,
              _scl: number,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.Label>;
            public add<
              T extends Packages.arc.scene.Element,
            >(
              _element: T,
            ): Packages.arc.scene.ui.layout.Cell<T>;
            public add(
              ..._elements: Packages.arc.scene.Element[]
            ): void;
            public add(
              _text: Packages.java.lang.CharSequence,
              _labelStyle: Packages.arc.scene.ui.Label.LabelStyle,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.Label>;
            public add(): Packages.arc.scene.ui.layout.Cell<any>;
            public add(
              _text: Packages.java.lang.CharSequence,
              _color: Packages.arc.graphics.Color,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.Label>;
            public fill(): Packages.arc.scene.ui.layout.Table;
            public field(
              _text: string,
              _style: Packages.arc.scene.ui.TextField.TextFieldStyle,
              _listener: Packages.arc.func.Cons<string>,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.TextField>;
            public field(
              _text: string,
              _listener: Packages.arc.func.Cons<string>,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.TextField>;
            public field(
              _text: string,
              _filter: Packages.arc.scene.ui.TextField.TextFieldFilter,
              _listener: Packages.arc.func.Cons<string>,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.TextField>;
            public stack(
              ..._elements: Packages.arc.scene.Element[]
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.layout.Stack>;
            public defaults(): Packages.arc.scene.ui.layout.Cell<any>;
            public table(
              _background: Packages.arc.scene.style.Drawable,
              _cons: Packages.arc.func.Cons<Packages.arc.scene.ui.layout.Table>,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.layout.Table>;
            public table(
              _cons: Packages.arc.func.Cons<Packages.arc.scene.ui.layout.Table>,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.layout.Table>;
            public table(
              _background: Packages.arc.scene.style.Drawable,
              _align: number,
              _cons: Packages.arc.func.Cons<Packages.arc.scene.ui.layout.Table>,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.layout.Table>;
            public table(
              _background: Packages.arc.scene.style.Drawable,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.layout.Table>;
            public table(): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.layout.Table>;
            public top(): Packages.arc.scene.ui.layout.Table;
            public reset(): void;
            public check(
              _text: string,
              _listener: Packages.arc.func.Boolc,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.CheckBox>;
            public check(
              _text: string,
              _imagesize: number,
              _checked: boolean,
              _listener: Packages.arc.func.Boolc,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.CheckBox>;
            public check(
              _text: string,
              _checked: boolean,
              _listener: Packages.arc.func.Boolc,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.CheckBox>;
            public left(): Packages.arc.scene.ui.layout.Table;
            public right(): Packages.arc.scene.ui.layout.Table;
            public bottom(): Packages.arc.scene.ui.layout.Table;
            public label(
              _text: Packages.arc.func.Prov<Packages.java.lang.CharSequence>,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.Label>;
            public image(
              _name: Packages.arc.scene.style.Drawable,
              _color: Packages.arc.graphics.Color,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.Image>;
            public image(
              _region: Packages.arc.graphics.g2d.TextureRegion,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.Image>;
            public image(): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.Image>;
            public image(
              _name: Packages.arc.scene.style.Drawable,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.Image>;
            public image(
              _reg: Packages.arc.func.Prov<Packages.arc.graphics.g2d.TextureRegion>,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.Image>;
            public hit(
              _x: number,
              _y: number,
              _touchable: boolean,
            ): Packages.arc.scene.Element;
            public margin(
              _pad: number,
            ): Packages.arc.scene.ui.layout.Table;
            public margin(
              _top: number,
              _left: number,
              _bottom: number,
              _right: number,
            ): Packages.arc.scene.ui.layout.Table;
            public draw(): void;
            public marginBottom(
              _padBottom: number,
            ): Packages.arc.scene.ui.layout.Table;
            public marginLeft(
              _padLeft: number,
            ): Packages.arc.scene.ui.layout.Table;
            public marginTop(
              _padTop: number,
            ): Packages.arc.scene.ui.layout.Table;
            public marginRight(
              _padRight: number,
            ): Packages.arc.scene.ui.layout.Table;
            public button(
              _icon: Packages.arc.scene.style.Drawable,
              _isize: number,
              _listener: Packages.java.lang.Runnable,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.ImageButton>;
            public button(
              _icon: Packages.arc.scene.style.Drawable,
              _listener: Packages.java.lang.Runnable,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.ImageButton>;
            public button(
              _icon: Packages.arc.scene.style.Drawable,
              _style: Packages.arc.scene.ui.ImageButton.ImageButtonStyle,
              _isize: number,
              _listener: Packages.java.lang.Runnable,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.ImageButton>;
            public button(
              _icon: Packages.arc.scene.style.Drawable,
              _style: Packages.arc.scene.ui.ImageButton.ImageButtonStyle,
              _listener: Packages.java.lang.Runnable,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.ImageButton>;
            public button(
              _text: string,
              _image: Packages.arc.scene.style.Drawable,
              _style: Packages.arc.scene.ui.TextButton.TextButtonStyle,
              _clicked: Packages.java.lang.Runnable,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.TextButton>;
            public button(
              _text: string,
              _image: Packages.arc.scene.style.Drawable,
              _style: Packages.arc.scene.ui.TextButton.TextButtonStyle,
              _imagesize: number,
              _clicked: Packages.java.lang.Runnable,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.TextButton>;
            public button(
              _text: string,
              _image: Packages.arc.scene.style.Drawable,
              _imagesize: number,
              _clicked: Packages.java.lang.Runnable,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.TextButton>;
            public button(
              _text: string,
              _image: Packages.arc.scene.style.Drawable,
              _clicked: Packages.java.lang.Runnable,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.TextButton>;
            public button(
              _cons: Packages.arc.func.Cons<Packages.arc.scene.ui.Button>,
              _listener: Packages.java.lang.Runnable,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.Button>;
            public button(
              _cons: Packages.arc.func.Cons<Packages.arc.scene.ui.Button>,
              _style: Packages.arc.scene.ui.Button.ButtonStyle,
              _listener: Packages.java.lang.Runnable,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.Button>;
            public button(
              _text: string,
              _listener: Packages.java.lang.Runnable,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.TextButton>;
            public button(
              _text: string,
              _style: Packages.arc.scene.ui.TextButton.TextButtonStyle,
              _listener: Packages.java.lang.Runnable,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.TextButton>;
            public center(): Packages.arc.scene.ui.layout.Table;
            public rect(
              _draw: Packages.arc.scene.ui.layout.Table.DrawRect,
            ): Packages.arc.scene.ui.layout.Cell<any>;
            public area(
              _text: string,
              _listener: Packages.arc.func.Cons<string>,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.TextArea>;
            public area(
              _text: string,
              _style: Packages.arc.scene.ui.TextField.TextFieldStyle,
              _listener: Packages.arc.func.Cons<string>,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.TextArea>;
            public removeChild(
              _element: Packages.arc.scene.Element,
              _unfocus: boolean,
            ): boolean;
            public removeChild(
              _element: Packages.arc.scene.Element,
            ): boolean;
            public invalidate(): void;
            private obtainCell(): Packages.arc.scene.ui.layout.Cell<any>;
            protected drawBackground(
              _x: number,
              _y: number,
            ): void;
            public getMarginLeft(): number;
            public getMarginBottom(): number;
            public getMarginRight(): number;
            public getMarginTop(): number;
            public setBackground(
              _background: Packages.arc.scene.style.Drawable,
            ): void;
            private endRow(): void;
            public row(): Packages.arc.scene.ui.layout.Table;
            public collapser(
              _table: Packages.arc.scene.ui.layout.Table,
              _animate: boolean,
              _shown: Packages.arc.func.Boolp,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.layout.Collapser>;
            public collapser(
              _cons: Packages.arc.func.Cons<Packages.arc.scene.ui.layout.Table>,
              _animate: boolean,
              _shown: Packages.arc.func.Boolp,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.layout.Collapser>;
            public collapser(
              _cons: Packages.arc.func.Cons<Packages.arc.scene.ui.layout.Table>,
              _shown: Packages.arc.func.Boolp,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.layout.Collapser>;
            public collapser(
              _table: Packages.arc.scene.ui.layout.Table,
              _shown: Packages.arc.func.Boolp,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.layout.Collapser>;
            public pane(
              _element: Packages.arc.scene.Element,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.ScrollPane>;
            public pane(
              _consumer: Packages.arc.func.Cons<Packages.arc.scene.ui.layout.Table>,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.ScrollPane>;
            public pane(
              _style: Packages.arc.scene.ui.ScrollPane.ScrollPaneStyle,
              _element: Packages.arc.scene.Element,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.ScrollPane>;
            public pane(
              _style: Packages.arc.scene.ui.ScrollPane.ScrollPaneStyle,
              _consumer: Packages.arc.func.Cons<Packages.arc.scene.ui.layout.Table>,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.ScrollPane>;
            public getCells(): Packages.arc.struct.Seq<
              Packages.arc.scene.ui.layout.Cell<any>
            >;
            public buttonCenter(
              _text: string,
              _image: Packages.arc.scene.style.Drawable,
              _clicked: Packages.java.lang.Runnable,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.TextButton>;
            public buttonCenter(
              _text: string,
              _image: Packages.arc.scene.style.Drawable,
              _style: Packages.arc.scene.ui.TextButton.TextButtonStyle,
              _imagesize: number,
              _clicked: Packages.java.lang.Runnable,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.TextButton>;
            public buttonCenter(
              _text: string,
              _image: Packages.arc.scene.style.Drawable,
              _imagesize: number,
              _clicked: Packages.java.lang.Runnable,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.TextButton>;
            public slider(
              _min: number,
              _max: number,
              _step: number,
              _defvalue: number,
              _listener: Packages.arc.func.Floatc,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.Slider>;
            public slider(
              _min: number,
              _max: number,
              _step: number,
              _defvalue: number,
              _onUp: boolean,
              _listener: Packages.arc.func.Floatc,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.Slider>;
            public slider(
              _min: number,
              _max: number,
              _step: number,
              _listener: Packages.arc.func.Floatc,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.Slider>;
            public getCell<
              T extends Packages.arc.scene.Element,
            >(
              _actor: T,
            ): Packages.arc.scene.ui.layout.Cell<any>;
            private computeSize(): void;
            private ensureSize(
              _array: number[],
              _size: number,
            ): number[] | null;
            public getBackground(): Packages.arc.scene.style.Drawable;
            public getClip(): boolean;
            public setClip(_enabled: boolean): void;
            public clearChildren(): void;
            public background(
              _background: Packages.arc.scene.style.Drawable,
            ): Packages.arc.scene.ui.layout.Table;
            public getPrefWidth(): number;
            public getPrefHeight(): number;
            public layout(): void;
            private layout(
              _layoutX: number,
              _layoutY: number,
              _layoutWidth: number,
              _layoutHeight: number,
            ): void;
            public align(
              _align: number,
            ): Packages.arc.scene.ui.layout.Table;
            public getMinWidth(): number;
            public getMinHeight(): number;
            public labelWrap(
              _text: Packages.arc.func.Prov<Packages.java.lang.CharSequence>,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.Label>;
            public labelWrap(
              _text: string,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.Label>;
            public imageDraw(
              _reg: Packages.arc.func.Prov<Packages.arc.scene.style.Drawable>,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.Image>;
            public buttonRow(
              _text: string,
              _image: Packages.arc.scene.style.Drawable,
              _clicked: Packages.java.lang.Runnable,
            ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.TextButton>;
            public getAlign(): number;
            public getRow(_y: number): number;
            public setRound(_round: boolean): void;
            public getRows(): number;
            public getColumns(): number;
            public getRowHeight(_rowIndex: number): number;
            public getColumnWidth(
              _columnIndex: number,
            ): number;
            public constructor(
              _cons: Packages.arc.func.Cons<Packages.arc.scene.ui.layout.Table>,
            );
            public constructor(
              _background: Packages.arc.scene.style.Drawable,
              _cons: Packages.arc.func.Cons<Packages.arc.scene.ui.layout.Table>,
            );
            public constructor(
              _background: Packages.arc.scene.style.Drawable,
            );
            public constructor();
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare abstract class Group
        extends Packages.arc.scene.Element
        implements Packages.arc.scene.utils.Cullable
      {
        private static tmp: Packages.arc.math.geom.Vec2;
        protected children: Packages.arc.struct.SnapshotSeq<Packages.arc.scene.Element>;
        private worldTransform: Packages.arc.math.Affine2;
        private computedTransform: Packages.arc.math.Mat;
        private oldTransform: Packages.arc.math.Mat;
        protected transform: boolean;
        protected cullingArea: Packages.arc.math.geom.Rect;
        public toString(): string;
        toString(
          _buffer: Packages.java.lang.StringBuilder,
          _indent: number,
        ): void;
        public clear(): void;
        public fill(
          _background: Packages.arc.scene.style.Drawable,
          _cons: Packages.arc.func.Cons<Packages.arc.scene.ui.layout.Table>,
        ): void;
        public fill(
          _cons: Packages.arc.func.Cons<Packages.arc.scene.ui.layout.Table>,
        ): void;
        public fill(
          _rect: Packages.arc.scene.ui.layout.Table.DrawRect,
        ): Packages.arc.scene.Element;
        public find<T extends Packages.arc.scene.Element>(
          _pred: Packages.arc.func.Boolf<Packages.arc.scene.Element>,
        ): T | null;
        public find<T extends Packages.arc.scene.Element>(
          _name: string,
        ): T | null;
        public forEach(
          _cons: Packages.arc.func.Cons<Packages.arc.scene.Element>,
        ): void;
        public getChildren(): Packages.arc.struct.SnapshotSeq<Packages.arc.scene.Element>;
        public hit(
          _x: number,
          _y: number,
          _touchable: boolean,
        ): Packages.arc.scene.Element;
        public draw(): void;
        protected setScene(
          _stage: Packages.arc.scene.Scene,
        ): void;
        public act(_delta: number): void;
        public setTransform(_transform: boolean): void;
        public findVisible<
          T extends Packages.arc.scene.Element,
        >(_name: string): T | null;
        public addChild(
          _actor: Packages.arc.scene.Element,
        ): void;
        public removeChild(
          _actor: Packages.arc.scene.Element,
          _unfocus: boolean,
        ): boolean;
        public removeChild(
          _actor: Packages.arc.scene.Element,
        ): boolean;
        public addChildAt(
          _index: number,
          _actor: Packages.arc.scene.Element,
        ): void;
        public addChildBefore(
          _actorBefore: Packages.arc.scene.Element,
          _actor: Packages.arc.scene.Element,
        ): void;
        public addChildAfter(
          _actorAfter: Packages.arc.scene.Element,
          _actor: Packages.arc.scene.Element,
        ): void;
        public swapActor(
          _first: Packages.arc.scene.Element,
          _second: Packages.arc.scene.Element,
        ): boolean;
        public swapActor(
          _first: number,
          _second: number,
        ): boolean;
        public hasChildren(): boolean;
        public isTransform(): boolean;
        protected computeTransform(): Packages.arc.math.Mat;
        protected applyTransform(
          _transform: Packages.arc.math.Mat,
        ): void;
        protected drawChildren(): void;
        protected resetTransform(): void;
        protected childrenChanged(): void;
        public clearChildren(): void;
        public localToDescendantCoordinates(
          _descendant: Packages.arc.scene.Element,
          _localCoords: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.geom.Vec2;
        public getCullingArea(): Packages.arc.math.geom.Rect;
        public setCullingArea(
          _cullingArea: Packages.arc.math.geom.Rect,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class DelayedRemovalSeq<T> extends Packages
        .arc.struct.Seq<T> {
        private iterating: number;
        public remove(
          _value: T,
          _identity: boolean,
        ): boolean;
        public remove(_index: number): T | null;
        public insert(_index: number, _value: T): void;
        public clear(): Packages.arc.struct.Seq<T>;
        public end(): void;
        public begin(): void;
        public set(_index: number, _value: T): void;
        public reverse(): Packages.arc.struct.Seq<T>;
        public sort(): Packages.arc.struct.Seq<T>;
        public sort(
          _comparator: Packages.java.util.Comparator<any>,
        ): Packages.arc.struct.Seq<T>;
        public removeRange(
          _start: number,
          _end: number,
        ): void;
        public swap(_first: number, _second: number): void;
        public shuffle(): Packages.arc.struct.Seq<T>;
        public pop(): T | null;
        public static with<T>(
          ..._array: T[]
        ): Packages.arc.struct.DelayedRemovalSeq<T>;
        public setSize(_newSize: number): T[] | null;
        public truncate(_newSize: number): void;
        private removeIntern(_index: number): void;
        public constructor(
          _ordered: boolean,
          _array: T[],
          _startIndex: number,
          _count: number,
        );
        public constructor(
          _arrayType:
            | Class<any>
            | Packages.java.lang.Class<any>,
        );
        public constructor(_capacity: number);
        public constructor(_array: T[]);
        public constructor();
        public constructor(
          _array: Packages.arc.struct.Seq<any>,
        );
        public constructor(
          _ordered: boolean,
          _capacity: number,
          _arrayType:
            | Class<any>
            | Packages.java.lang.Class<any>,
        );
        public constructor(
          _ordered: boolean,
          _capacity: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class Floatc2 {
        public get(_x: number, _y: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare class Element extends java.lang.Object {
        public color: Packages.arc.graphics.Color;
        public originX: number;
        public originY: number;
        public scaleX: number;
        public scaleY: number;
        public rotation: number;
        public name: string;
        public fillParent: boolean;
        public translation: Packages.arc.math.geom.Vec2;
        public userObject: any;
        public parent: Packages.arc.scene.Group;
        public visibility: Packages.arc.func.Boolp;
        public touchablility: Packages.arc.func.Prov<Packages.arc.scene.event.Touchable>;
        public cullable: boolean;
        private listeners: Packages.arc.struct.DelayedRemovalSeq<Packages.arc.scene.event.EventListener>;
        private captureListeners: Packages.arc.struct.DelayedRemovalSeq<Packages.arc.scene.event.EventListener>;
        public x: number;
        public y: number;
        protected width: number;
        protected height: number;
        protected parentAlpha: number;
        private stage: Packages.arc.scene.Scene;
        private layoutEnabled: boolean;
        public remove(): boolean;
        public toString(): string;
        public notify(
          _event: Packages.arc.scene.event.SceneEvent,
          _capture: boolean,
        ): boolean;
        public update(
          _r: Packages.java.lang.Runnable,
        ): Packages.arc.scene.Element;
        public clear(): void;
        public validate(): void;
        public getActions(): Packages.arc.struct.Seq<Packages.arc.scene.Action>;
        public actions(
          ..._actions: Packages.arc.scene.Action[]
        ): void;
        public visible(
          _vis: Packages.arc.func.Boolp,
        ): Packages.arc.scene.Element;
        public changed(
          _r: Packages.java.lang.Runnable,
        ): void;
        public setScale(
          _scaleX: number,
          _scaleY: number,
        ): void;
        public setScale(_scaleXY: number): void;
        public setColor(
          _r: number,
          _g: number,
          _b: number,
          _a: number,
        ): void;
        public setColor(
          _color: Packages.arc.graphics.Color,
        ): void;
        public setSize(_size: number): void;
        public setSize(
          _width: number,
          _height: number,
        ): void;
        public hit(
          _x: number,
          _y: number,
          _touchable: boolean,
        ): Packages.arc.scene.Element;
        public getListeners(): Packages.arc.struct.Seq<Packages.arc.scene.event.EventListener>;
        public addListener(
          _listener: Packages.arc.scene.event.EventListener,
        ): boolean;
        public removeListener(
          _listener: Packages.arc.scene.event.EventListener,
        ): boolean;
        public getX(_alignment: number): number;
        public getY(_alignment: number): number;
        public getRotation(): number;
        public draw(): void;
        public getWidth(): number;
        public getHeight(): number;
        public keyDown(
          _key: Packages.arc.input.KeyCode,
          _l: Packages.java.lang.Runnable,
        ): void;
        public keyDown(
          _cons: Packages.arc.func.Cons<Packages.arc.input.KeyCode>,
        ): void;
        public touchable(
          _touch: Packages.arc.func.Prov<Packages.arc.scene.event.Touchable>,
        ): void;
        protected setScene(
          _stage: Packages.arc.scene.Scene,
        ): void;
        public isDescendantOf(
          _actor: Packages.arc.scene.Element,
        ): boolean;
        public isDescendantOf(
          _actor: Packages.arc.func.Boolf<Packages.arc.scene.Element>,
        ): boolean;
        public act(_delta: number): void;
        public fire(
          _event: Packages.arc.scene.event.SceneEvent,
        ): boolean;
        public getScene(): Packages.arc.scene.Scene;
        public setFillParent(_fillParent: boolean): void;
        public scrolled(
          _cons: Packages.arc.func.Floatc,
        ): void;
        public addAction(
          _action: Packages.arc.scene.Action,
        ): void;
        public addCaptureListener(
          _listener: Packages.arc.scene.event.EventListener,
        ): boolean;
        public removeCaptureListener(
          _listener: Packages.arc.scene.event.EventListener,
        ): boolean;
        public parentToLocalCoordinates(
          _parentCoords: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.geom.Vec2;
        public hasMouse(): boolean;
        public hasKeyboard(): boolean;
        public hasScroll(): boolean;
        public setPosition(
          _x: number,
          _y: number,
          _alignment: number,
        ): void;
        public setPosition(_x: number, _y: number): void;
        public setWidth(_width: number): void;
        public setHeight(_height: number): void;
        public needsLayout(): boolean;
        public clearActions(): void;
        public clearListeners(): void;
        protected sizeChanged(): void;
        public invalidate(): void;
        protected rotationChanged(): void;
        public setOrigin(
          _originX: number,
          _originY: number,
        ): void;
        public setOrigin(_alignment: number): void;
        public setZIndex(_index: number): void;
        public clipBegin(): boolean;
        public clipBegin(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
        ): boolean;
        public stageToLocalCoordinates(
          _stageCoords: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.geom.Vec2;
        public localToAscendantCoordinates(
          _ascendant: Packages.arc.scene.Element,
          _localCoords: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.geom.Vec2;
        public localToParentCoordinates(
          _localCoords: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.geom.Vec2;
        public getPrefWidth(): number;
        public getPrefHeight(): number;
        public invalidateHierarchy(): void;
        public layout(): void;
        public clicked(
          _r: Packages.java.lang.Runnable,
        ): Packages.arc.scene.event.ClickListener;
        public clicked(
          _button: Packages.arc.input.KeyCode,
          _r: Packages.java.lang.Runnable,
        ): Packages.arc.scene.event.ClickListener;
        public clicked(
          _tweaker: Packages.arc.func.Cons<Packages.arc.scene.event.ClickListener>,
          _runner: Packages.arc.func.Cons<Packages.arc.scene.event.ClickListener>,
        ): Packages.arc.scene.event.ClickListener;
        public clicked(
          _tweaker: Packages.arc.func.Cons<Packages.arc.scene.event.ClickListener>,
          _r: Packages.java.lang.Runnable,
        ): Packages.arc.scene.event.ClickListener;
        public updateVisibility(): void;
        public requestKeyboard(): void;
        public requestScroll(): void;
        public dragged(
          _cons: Packages.arc.func.Floatc2,
        ): void;
        public getCaptureListeners(): Packages.arc.struct.Seq<Packages.arc.scene.event.EventListener>;
        public removeAction(
          _action: Packages.arc.scene.Action,
        ): void;
        public hasActions(): boolean;
        public isAscendantOf(
          _actor: Packages.arc.scene.Element,
        ): boolean;
        public hasParent(): boolean;
        public isTouchable(): boolean;
        public moveBy(_x: number, _y: number): void;
        public getTop(): number;
        public getRight(): number;
        public sizeBy(
          _width: number,
          _height: number,
        ): void;
        public sizeBy(_size: number): void;
        public setBounds(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
        ): void;
        public scaleBy(
          _scaleX: number,
          _scaleY: number,
        ): void;
        public scaleBy(_scale: number): void;
        public setRotation(_degrees: number): void;
        public setRotationOrigin(
          _degrees: number,
          _align: number,
        ): void;
        public rotateBy(_amountInDegrees: number): void;
        public toFront(): void;
        public toBack(): void;
        public getZIndex(): number;
        public clipEnd(): void;
        public screenToLocalCoordinates(
          _screenCoords: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.geom.Vec2;
        public localToStageCoordinates(
          _localCoords: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.geom.Vec2;
        public getMinWidth(): number;
        public getMinHeight(): number;
        public getMaxWidth(): number;
        public getMaxHeight(): number;
        public setLayoutEnabled(_enabled: boolean): void;
        public pack(): void;
        public keepInStage(): void;
        public setTranslation(_x: number, _y: number): void;
        public fireClick(): void;
        public tapped(
          _r: Packages.java.lang.Runnable,
        ): Packages.arc.scene.event.InputListener;
        public hovered(
          _r: Packages.java.lang.Runnable,
        ): void;
        public exited(
          _r: Packages.java.lang.Runnable,
        ): void;
        public released(
          _r: Packages.java.lang.Runnable,
        ): void;
        public change(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace event {
        declare class SceneEvent
          extends java.lang.Object
          implements Packages.arc.util.pooling.Pool.Poolable
        {
          public targetActor: Packages.arc.scene.Element;
          public listenerActor: Packages.arc.scene.Element;
          public capture: boolean;
          public bubbles: boolean;
          public handled: boolean;
          public stopped: boolean;
          public cancelled: boolean;
          public stop(): void;
          public handle(): void;
          public reset(): void;
          public cancel(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace event {
        declare abstract class EventListener {
          public handle(
            _event: Packages.arc.scene.event.SceneEvent,
          ): boolean;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace viewport {
        declare abstract class Viewport extends java.lang
          .Object {
          private tmp: Packages.arc.math.geom.Vec2;
          private camera: Packages.arc.graphics.Camera;
          private worldWidth: number;
          private worldHeight: number;
          private screenX: number;
          private screenY: number;
          private screenWidth: number;
          private screenHeight: number;
          public update(
            _screenWidth: number,
            _screenHeight: number,
            _centerCamera: boolean,
          ): void;
          public update(
            _screenWidth: number,
            _screenHeight: number,
          ): void;
          public apply(_centerCamera: boolean): void;
          public apply(): void;
          public unproject(
            _screenCoords: Packages.arc.math.geom.Vec2,
          ): Packages.arc.math.geom.Vec2;
          public project(
            _worldCoords: Packages.arc.math.geom.Vec2,
          ): Packages.arc.math.geom.Vec2;
          public getCamera(): Packages.arc.graphics.Camera;
          public getWorldWidth(): number;
          public getWorldHeight(): number;
          public getScreenHeight(): number;
          public toScreenCoordinates(
            _worldCoords: Packages.arc.math.geom.Vec2,
            _transformMatrix: Packages.arc.math.Mat,
          ): Packages.arc.math.geom.Vec2;
          public calculateScissors(
            _batchTransform: Packages.arc.math.Mat,
            _area: Packages.arc.math.geom.Rect,
            _scissor: Packages.arc.math.geom.Rect,
          ): void;
          public getScreenX(): number;
          public getScreenWidth(): number;
          public getScreenY(): number;
          public setCamera(
            _camera: Packages.arc.graphics.Camera,
          ): void;
          public setWorldWidth(_worldWidth: number): void;
          public setWorldHeight(_worldHeight: number): void;
          public setWorldSize(
            _worldWidth: number,
            _worldHeight: number,
          ): void;
          public setScreenX(_screenX: number): void;
          public setScreenY(_screenY: number): void;
          public setScreenWidth(_screenWidth: number): void;
          public setScreenHeight(
            _screenHeight: number,
          ): void;
          public setScreenPosition(
            _screenX: number,
            _screenY: number,
          ): void;
          public setScreenSize(
            _screenWidth: number,
            _screenHeight: number,
          ): void;
          public setScreenBounds(
            _screenX: number,
            _screenY: number,
            _screenWidth: number,
            _screenHeight: number,
          ): void;
          public getLeftGutterWidth(): number;
          public getRightGutterX(): number;
          public getRightGutterWidth(): number;
          public getBottomGutterHeight(): number;
          public getTopGutterY(): number;
          public getTopGutterHeight(): number;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace event {
        declare abstract class FocusListener
          extends java.lang.Object
          implements Packages.arc.scene.event.EventListener
        {
          public static FocusEvent = class extends Packages
            .arc.scene.event.SceneEvent {
            public static Type = class extends Packages.java
              .lang
              .Enum<Packages.arc.scene.event.FocusListener.FocusEvent.Type> {
              public static keyboard: Packages.arc.scene.event.FocusListener.FocusEvent.Type;
              public static scroll: Packages.arc.scene.event.FocusListener.FocusEvent.Type;
              private static $VALUES: Packages.arc.scene.event.FocusListener.FocusEvent.Type[];
              public static values():
                | Packages.arc.scene.event.FocusListener.FocusEvent.Type[]
                | null;
              public static valueOf(
                _name: string,
              ): Packages.arc.scene.event.FocusListener.FocusEvent.Type;
            };
            public focused: boolean;
            public type: Packages.arc.scene.event.FocusListener.FocusEvent.Type;
            public relatedActor: Packages.arc.scene.Element;
            public reset(): void;
            public constructor();
          };
          public handle(
            _event: Packages.arc.scene.event.SceneEvent,
          ): boolean;
          public keyboardFocusChanged(
            _event: Packages.arc.scene.event.FocusListener.FocusEvent,
            _element: Packages.arc.scene.Element,
            _focused: boolean,
          ): void;
          public scrollFocusChanged(
            _event: Packages.arc.scene.event.FocusListener.FocusEvent,
            _element: Packages.arc.scene.Element,
            _focused: boolean,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace ui {
        declare class Dialog extends Packages.arc.scene.ui
          .layout.Table {
          public static DialogStyle = class extends Packages
            .arc.scene.style.Style {
            public background: Packages.arc.scene.style.Drawable;
            public titleFont: Packages.arc.graphics.g2d.Font;
            public titleFontColor: Packages.arc.graphics.Color;
            public stageBackground: Packages.arc.scene.style.Drawable;
            public constructor();
          };
          private static defaultShowAction: Packages.arc.func.Prov<Packages.arc.scene.Action>;
          private static defaultHideAction: Packages.arc.func.Prov<Packages.arc.scene.Action>;
          protected ignoreTouchDown: Packages.arc.scene.event.InputListener;
          private static tmpPosition: Packages.arc.math.geom.Vec2;
          private static tmpSize: Packages.arc.math.geom.Vec2;
          private static MOVE: number;
          protected edge: number;
          protected dragging: boolean;
          center: boolean;
          resizeBorder: number;
          private style: Packages.arc.scene.ui.Dialog.DialogStyle;
          private lastWidth: number;
          private lastHeight: number;
          previousKeyboardFocus: Packages.arc.scene.Element;
          previousScrollFocus: Packages.arc.scene.Element;
          focusListener: Packages.arc.scene.event.FocusListener;
          public cont: Packages.arc.scene.ui.layout.Table;
          public buttons: Packages.arc.scene.ui.layout.Table;
          public title: Packages.arc.scene.ui.Label;
          public titleTable: Packages.arc.scene.ui.layout.Table;
          public hit(
            _x: number,
            _y: number,
            _touchable: boolean,
          ): Packages.arc.scene.Element;
          public draw(): void;
          public setResizable(_isResizable: boolean): void;
          protected setScene(
            _stage: Packages.arc.scene.Scene,
          ): void;
          public act(_delta: number): void;
          public getStyle(): Packages.arc.scene.ui.Dialog.DialogStyle;
          public setCentered(_center: boolean): void;
          public setStyle(
            _style: Packages.arc.scene.ui.Dialog.DialogStyle,
          ): void;
          public isDragging(): boolean;
          public toggle(): void;
          public shown(
            _run: Packages.java.lang.Runnable,
          ): void;
          public isMovable(): boolean;
          public isModal(): boolean;
          public isResizable(): boolean;
          keepWithinStage(): void;
          public centerWindow(): void;
          protected drawStageBackground(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          ): void;
          public resized(
            _run: Packages.java.lang.Runnable,
          ): void;
          public resized(
            _invoke: boolean,
            _run: Packages.java.lang.Runnable,
          ): void;
          public closeOnBack(
            _callback: Packages.java.lang.Runnable,
          ): void;
          public closeOnBack(): void;
          public isShown(): boolean;
          public hide(): void;
          public hide(
            _action: Packages.arc.scene.Action,
          ): void;
          public show(
            _stage: Packages.arc.scene.Scene,
            _action: Packages.arc.scene.Action,
          ): Packages.arc.scene.ui.Dialog;
          public show(): Packages.arc.scene.ui.Dialog;
          public show(
            _stage: Packages.arc.scene.Scene,
          ): Packages.arc.scene.ui.Dialog;
          public setMovable(_isMovable: boolean): void;
          public setModal(_isModal: boolean): void;
          public setKeepWithinStage(
            _keepWithinStage: boolean,
          ): void;
          public isCentered(): boolean;
          public setResizeBorder(
            _resizeBorder: number,
          ): void;
          public updateScrollFocus(): void;
          public static setHideAction(
            _prov: Packages.arc.func.Prov<Packages.arc.scene.Action>,
          ): void;
          public static setShowAction(
            _prov: Packages.arc.func.Prov<Packages.arc.scene.Action>,
          ): void;
          public hidden(
            _run: Packages.java.lang.Runnable,
          ): void;
          public resizedShown(
            _run: Packages.java.lang.Runnable,
          ): void;
          public addCloseButton(): void;
          public constructor(
            _title: string,
            _style: Packages.arc.scene.ui.Dialog.DialogStyle,
          );
          public constructor(_title: string);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare class Scene
        extends java.lang.Object
        implements Packages.arc.input.InputProcessor
      {
        private static TouchFocus = class
          extends java.lang.Object
          implements Packages.arc.util.pooling.Pool.Poolable
        {
          listener: Packages.arc.scene.event.EventListener;
          listenerActor: Packages.arc.scene.Element;
          target: Packages.arc.scene.Element;
          pointer: number;
          button: Packages.arc.input.KeyCode;
          public reset(): void;
        };
        public root: Packages.arc.scene.Group;
        public marginLeft: number;
        public marginRight: number;
        public marginTop: number;
        public marginBottom: number;
        private styleDefaults: Packages.arc.struct.ObjectMap<
          Packages.java.lang.Class<any>,
          any
        >;
        private tempCoords: Packages.arc.math.geom.Vec2;
        private pointerOverActors: Packages.arc.scene.Element[];
        private pointerTouched: boolean[];
        private pointerScreenX: number[];
        private pointerScreenY: number[];
        private touchFocuses: Packages.arc.struct.SnapshotSeq<Packages.arc.scene.Scene.TouchFocus>;
        private viewport: Packages.arc.util.viewport.Viewport;
        private mouseScreenX: number;
        private mouseScreenY: number;
        private mouseOverElement: Packages.arc.scene.Element;
        private keyboardFocus: Packages.arc.scene.Element;
        private scrollFocus: Packages.arc.scene.Element;
        private actionsRequestRendering: boolean;
        public add(
          _actor: Packages.arc.scene.Element,
        ): void;
        public clear(): void;
        public find(
          _name: string,
        ): Packages.arc.scene.Element;
        public find(
          _pred: Packages.arc.func.Boolf<Packages.arc.scene.Element>,
        ): Packages.arc.scene.Element;
        public table(
          _style: Packages.arc.scene.style.Drawable,
          _cons: Packages.arc.func.Cons<Packages.arc.scene.ui.layout.Table>,
        ): Packages.arc.scene.ui.layout.Table;
        public table(
          _cons: Packages.arc.func.Cons<Packages.arc.scene.ui.layout.Table>,
        ): Packages.arc.scene.ui.layout.Table;
        public table(): Packages.arc.scene.ui.layout.Table;
        public resize(
          _width: number,
          _height: number,
        ): void;
        public hit(
          _stageX: number,
          _stageY: number,
          _touchable: boolean,
        ): Packages.arc.scene.Element;
        public addListener(
          _listener: Packages.arc.scene.event.EventListener,
        ): boolean;
        public removeListener(
          _listener: Packages.arc.scene.event.EventListener,
        ): boolean;
        public draw(): void;
        public getWidth(): number;
        public getHeight(): number;
        public keyDown(
          _keyCode: Packages.arc.input.KeyCode,
        ): boolean;
        public getKeyboardFocus(): Packages.arc.scene.Element;
        public getScrollFocus(): Packages.arc.scene.Element;
        public getCamera(): Packages.arc.graphics.Camera;
        public act(): void;
        public act(_delta: number): void;
        public screenToStageCoordinates(
          _screenCoords: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.geom.Vec2;
        private fireEnterAndExit(
          _overLast: Packages.arc.scene.Element,
          _screenX: number,
          _screenY: number,
          _pointer: number,
        ): Packages.arc.scene.Element;
        public findVisible(
          _name: string,
        ): Packages.arc.scene.Element;
        protected isInsideViewport(
          _screenX: number,
          _screenY: number,
        ): boolean;
        public touchDown(
          _screenX: number,
          _screenY: number,
          _pointer: number,
          _button: Packages.arc.input.KeyCode,
        ): boolean;
        public touchDragged(
          _screenX: number,
          _screenY: number,
          _pointer: number,
        ): boolean;
        public touchUp(
          _screenX: number,
          _screenY: number,
          _pointer: number,
          _button: Packages.arc.input.KeyCode,
        ): boolean;
        public mouseMoved(
          _screenX: number,
          _screenY: number,
        ): boolean;
        public scrolled(
          _amountX: number,
          _amountY: number,
        ): boolean;
        public keyUp(
          _keyCode: Packages.arc.input.KeyCode,
        ): boolean;
        public keyTyped(_character: string): boolean;
        public cancelTouchFocusExcept(
          _exceptListener: Packages.arc.scene.event.EventListener,
          _exceptActor: Packages.arc.scene.Element,
        ): void;
        public addAction(
          _action: Packages.arc.scene.Action,
        ): void;
        public addCaptureListener(
          _listener: Packages.arc.scene.event.EventListener,
        ): boolean;
        public removeCaptureListener(
          _listener: Packages.arc.scene.event.EventListener,
        ): boolean;
        public unfocusAll(): void;
        public setScrollFocus(
          _actor: Packages.arc.scene.Element,
        ): boolean;
        public setKeyboardFocus(
          _actor: Packages.arc.scene.Element,
        ): boolean;
        public cancelTouchFocus(
          _actor: Packages.arc.scene.Element,
        ): void;
        public cancelTouchFocus(): void;
        public toScreenCoordinates(
          _coords: Packages.arc.math.geom.Vec2,
          _transformMatrix: Packages.arc.math.Mat,
        ): Packages.arc.math.geom.Vec2;
        public calculateScissors(
          _localRect: Packages.arc.math.geom.Rect,
          _scissorRect: Packages.arc.math.geom.Rect,
        ): void;
        public addStyle<T>(
          _type: Class<T> | Packages.java.lang.Class<T>,
          _style: T,
        ): void;
        public getStyle<T>(
          _type: Class<T> | Packages.java.lang.Class<T>,
        ): T | null;
        public hasStyle<T>(
          _type: Class<T> | Packages.java.lang.Class<T>,
        ): boolean;
        public registerStyles(
          _type: Class<any> | Packages.java.lang.Class<any>,
        ): void;
        public registerStyles(_obj: any): void;
        public hasField(): boolean;
        public hasMouse(): boolean;
        public hasMouse(
          _mousex: number,
          _mousey: number,
        ): boolean;
        public hasDialog(): boolean;
        public hasKeyboard(): boolean;
        public hasScroll(): boolean;
        public getDialog(): Packages.arc.scene.ui.Dialog;
        public addTouchFocus(
          _listener: Packages.arc.scene.event.EventListener,
          _listenerActor: Packages.arc.scene.Element,
          _target: Packages.arc.scene.Element,
          _pointer: number,
          _button: Packages.arc.input.KeyCode,
        ): void;
        public removeTouchFocus(
          _listener: Packages.arc.scene.event.EventListener,
          _listenerActor: Packages.arc.scene.Element,
          _target: Packages.arc.scene.Element,
          _pointer: number,
          _button: Packages.arc.input.KeyCode,
        ): void;
        public getElements(): Packages.arc.struct.Seq<Packages.arc.scene.Element>;
        public unfocus(
          _actor: Packages.arc.scene.Element,
        ): void;
        public getViewport(): Packages.arc.util.viewport.Viewport;
        public setViewport(
          _viewport: Packages.arc.util.viewport.Viewport,
        ): void;
        public stageToScreenCoordinates(
          _stageCoords: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.geom.Vec2;
        public getActionsRequestRendering(): boolean;
        public setActionsRequestRendering(
          _actionsRequestRendering: boolean,
        ): void;
        public constructor();
        public constructor(
          _viewport: Packages.arc.util.viewport.Viewport,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace assets {
      declare class AssetLoaderParameters<T> extends java
        .lang.Object {
        public static LoadedCallback = class {
          public finishedLoading(
            _assetManager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _type: Class | Packages.java.lang.Class<any>,
          ): void;
        };
        public loadedCallback: Packages.arc.assets.AssetLoaderParameters.LoadedCallback;
        public constructor();
        public constructor(
          _loadedCallback: Packages.arc.assets.AssetLoaderParameters.LoadedCallback,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace assets {
      declare namespace loaders {
        declare abstract class FileHandleResolver {
          public resolve(
            _fileName: string,
          ): Packages.arc.files.Fi;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace assets {
      declare class AssetDescriptor<T> extends java.lang
        .Object {
        public fileName: string;
        public type: Packages.java.lang.Class<T>;
        public params: Packages.arc.assets.AssetLoaderParameters<any>;
        public file: Packages.arc.files.Fi;
        public loaded: Packages.arc.func.Cons<T>;
        public errored?: Packages.arc.func.Cons<Packages.java.lang.Throwable>;
        public toString(): string;
        public constructor(
          _file: Packages.arc.files.Fi,
          _assetType:
            | Class<T>
            | Packages.java.lang.Class<T>,
          _params: Packages.arc.assets.AssetLoaderParameters<T>,
        );
        public constructor(
          _fileName: string,
          _assetType:
            | Class<T>
            | Packages.java.lang.Class<T>,
          _params: Packages.arc.assets.AssetLoaderParameters<T>,
        );
        public constructor(
          _file: Packages.arc.files.Fi,
          _assetType:
            | Class<T>
            | Packages.java.lang.Class<T>,
        );
        public constructor(
          _fileName: string,
          _assetType:
            | Class<T>
            | Packages.java.lang.Class<T>,
        );
        public constructor(
          _assetType:
            | Class<T>
            | Packages.java.lang.Class<T>,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace assets {
      declare namespace loaders {
        declare abstract class AssetLoader<
          T,
          P extends
            Packages.arc.assets.AssetLoaderParameters<T>,
        > extends java.lang.Object {
          private resolver: Packages.arc.assets.loaders.FileHandleResolver;
          public resolve(
            _fileName: string,
          ): Packages.arc.files.Fi;
          public getDependencies(
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: P,
          ): Packages.arc.struct.Seq<
            Packages.arc.assets.AssetDescriptor<any>
          >;
          public constructor(
            _resolver: Packages.arc.assets.loaders.FileHandleResolver,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare namespace concurrent {
        declare abstract class Callable<V> {
          public call(): V | null;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare namespace concurrent {
        declare abstract class Future<V> {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace assets {
      declare class AssetLoadingTask
        extends java.lang.Object
        implements
          Packages.java.util.concurrent.Callable<void>
      {
        assetDesc: Packages.arc.assets.AssetDescriptor<any>;
        loader: Packages.arc.assets.loaders.AssetLoader<anyany>;
        executor: Packages.java.util.concurrent.ExecutorService;
        startTime: Packages.long;
        manager: Packages.arc.assets.AssetManager;
        asyncDone: boolean;
        dependenciesLoaded: boolean;
        dependencies: Packages.arc.struct.Seq<
          Packages.arc.assets.AssetDescriptor<any>
        >;
        depsFuture: Packages.java.util.concurrent.Future<void>;
        loadFuture: Packages.java.util.concurrent.Future<void>;
        asset: any;
        ticks: number;
        cancel: boolean;
        public update(): boolean;
        private resolve(
          _loader: Packages.arc.assets.loaders.AssetLoader<anyany>,
          _assetDesc: Packages.arc.assets.AssetDescriptor<any>,
        ): Packages.arc.files.Fi;
        public call(): any;
        public call(): void;
        public getAsset(): any;
        private removeDuplicates(
          _array: Packages.arc.struct.Seq<
            Packages.arc.assets.AssetDescriptor<any>
          >,
        ): void;
        private handleSyncLoader(): void;
        private handleAsyncLoader(): void;
        public constructor(
          _manager: Packages.arc.assets.AssetManager,
          _assetDesc: Packages.arc.assets.AssetDescriptor<any>,
          _loader: Packages.arc.assets.loaders.AssetLoader<anyany>,
          _threadPool: Packages.java.util.concurrent.ExecutorService,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace assets {
      declare abstract class AssetErrorListener {
        public error(
          _asset: Packages.arc.assets.AssetDescriptor<any>,
          _throwable: Packages.java.lang.Throwable,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace assets {
      declare abstract class Loadable {
        public getName(): string;
        public getDependencies(): Packages.arc.struct.Seq<
          Packages.arc.assets.AssetDescriptor<any>
        >;
        public loadSync(): void;
        public loadAsync(): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace assets {
      declare class AssetManager
        extends java.lang.Object
        implements Packages.arc.util.Disposable
      {
        static RefCountedContainer = class extends java.lang
          .Object {
          object: any;
          count: number;
          public constructor(_object: any);
        };
        assets: Packages.arc.struct.ObjectMap<
          Packages.java.lang.Class<any>,
          Packages.arc.struct.ObjectMap<
            string,
            Packages.arc.assets.AssetManager.RefCountedContainer
          >
        >;
        assetTypes: Packages.arc.struct.ObjectMap<
          string,
          Packages.java.lang.Class<any>
        >;
        assetDependencies: Packages.arc.struct.ObjectMap<
          string,
          Packages.arc.struct.Seq<string>
        >;
        injected: Packages.arc.struct.ObjectSet<string>;
        loaders: Packages.arc.struct.ObjectMap<
          Packages.java.lang.Class<any>,
          Packages.arc.struct.ObjectMap<
            string,
            Packages.arc.assets.loaders.AssetLoader<anyany>
          >
        >;
        loadQueue: Packages.arc.struct.Seq<
          Packages.arc.assets.AssetDescriptor<any>
        >;
        executor: Packages.java.util.concurrent.ExecutorService;
        tasks: Packages.arc.struct.Seq<Packages.arc.assets.AssetLoadingTask>;
        resolver: Packages.arc.assets.loaders.FileHandleResolver;
        listener: Packages.arc.assets.AssetErrorListener;
        loaded: number;
        toLoad: number;
        peakTasks: number;
        public get<T>(
          _assetDescriptor: Packages.arc.assets.AssetDescriptor<T>,
        ): T | null;
        public get<T>(
          _fileName: string,
          _type: Class<T> | Packages.java.lang.Class<T>,
        ): T | null;
        public get<T>(_fileName: string): T | null;
        public update(): boolean;
        public update(_millis: number): boolean;
        public load<T>(
          _fileName: string,
          _type: Class<T> | Packages.java.lang.Class<T>,
        ): Packages.arc.assets.AssetDescriptor<T>;
        public load<T>(
          _fileName: string,
          _type: Class<T> | Packages.java.lang.Class<T>,
          _parameter: Packages.arc.assets.AssetLoaderParameters<T>,
        ): Packages.arc.assets.AssetDescriptor<T>;
        public load<T>(
          _desc: Packages.arc.assets.AssetDescriptor<T>,
        ): Packages.arc.assets.AssetDescriptor<T>;
        public load(
          _load: Packages.arc.assets.Loadable,
        ): Packages.arc.assets.AssetDescriptor<any>;
        public clear(): void;
        public contains(_fileName: string): boolean;
        public contains(
          _fileName: string,
          _type: Class | Packages.java.lang.Class<any>,
        ): boolean;
        public isLoaded(_fileName: string): boolean;
        public isLoaded(
          _assetDesc: Packages.arc.assets.AssetDescriptor<any>,
        ): boolean;
        public isLoaded(
          _fileName: string,
          _type: Class | Packages.java.lang.Class<any>,
        ): boolean;
        public unload(_fileName: string): void;
        public getLoader<T>(
          _type: Class<T> | Packages.java.lang.Class<T>,
          _fileName: string,
        ): Packages.arc.assets.loaders.AssetLoader<anyany>;
        public getLoader<T>(
          _type: Class<T> | Packages.java.lang.Class<T>,
        ): Packages.arc.assets.loaders.AssetLoader<anyany>;
        public getAll<T>(
          _type: Class<T> | Packages.java.lang.Class<T>,
          _out: Packages.arc.struct.Seq<T>,
        ): Packages.arc.struct.Seq<T>;
        public dispose(): void;
        public loadRun(
          _name: string,
          _type: Class<any> | Packages.java.lang.Class<any>,
          _loadasync: Packages.java.lang.Runnable,
          _loadsync: Packages.java.lang.Runnable,
        ): Packages.arc.assets.AssetDescriptor<any>;
        public loadRun(
          _name: string,
          _type: Class<any> | Packages.java.lang.Class<any>,
          _loadasync: Packages.java.lang.Runnable,
        ): Packages.arc.assets.AssetDescriptor<any>;
        private nextTask(): void;
        private updateTask(): boolean;
        private handleTaskError(
          _t: Packages.java.lang.Throwable,
        ): void;
        public finishLoadingAsset(_fileName: string): void;
        public finishLoadingAsset(
          _assetDesc: Packages.arc.assets.AssetDescriptor<any>,
        ): void;
        private injectDependency(
          _parentAssetFilename: string,
          _dependendAssetDesc: Packages.arc.assets.AssetDescriptor<any>,
        ): void;
        private incrementRefCountedDependencies(
          _parent: string,
        ): void;
        private addTask(
          _assetDesc: Packages.arc.assets.AssetDescriptor<any>,
        ): void;
        protected taskFailed(
          _assetDesc: Packages.arc.assets.AssetDescriptor<any>,
          _ex: Packages.java.lang.RuntimeException,
        ): void;
        protected addAsset<T>(
          _fileName: string,
          _type: Class<T> | Packages.java.lang.Class<T>,
          _asset: T,
        ): void;
        public getFileHandleResolver(): Packages.arc.assets.loaders.FileHandleResolver;
        public containsAsset<T>(_asset: T): boolean;
        public getAssetFileName<T>(_asset: T): string;
        public getCurrentLoading(): Packages.arc.assets.AssetDescriptor<any>;
        public isFinished(): boolean;
        public finishLoading(): void;
        injectDependencies(
          _parentAssetFilename: string,
          _dependendAssetDescs: Packages.arc.struct.Seq<
            Packages.arc.assets.AssetDescriptor<any>
          >,
        ): void;
        public getLoadedAssets(): number;
        public getQueuedAssets(): number;
        public getProgress(): number;
        public setErrorListener(
          _listener: Packages.arc.assets.AssetErrorListener,
        ): void;
        public getReferenceCount(_fileName: string): number;
        public setReferenceCount(
          _fileName: string,
          _refCount: number,
        ): void;
        public getDiagnostics(): string;
        public getAssetNames(): Packages.arc.struct.Seq<string>;
        public getDependencies(
          _fileName: string,
        ): Packages.arc.struct.Seq<string>;
        public getAssetType(
          _fileName: string,
        ): Packages.java.lang.Class<any>;
        public setLoader<
          T,
          P extends
            Packages.arc.assets.AssetLoaderParameters<T>,
        >(
          _type: Class<T> | Packages.java.lang.Class<T>,
          _suffix: string,
          _loader: Packages.arc.assets.loaders.AssetLoader<
            T,
            P
          >,
        ): void;
        public setLoader<
          T,
          P extends
            Packages.arc.assets.AssetLoaderParameters<T>,
        >(
          _type: Class<T> | Packages.java.lang.Class<T>,
          _loader: Packages.arc.assets.loaders.AssetLoader<
            T,
            P
          >,
        ): void;
        public constructor(
          _resolver: Packages.arc.assets.loaders.FileHandleResolver,
          _defaultLoaders: boolean,
        );
        public constructor(
          _resolver: Packages.arc.assets.loaders.FileHandleResolver,
        );
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace g2d {
        declare class TextureAtlas
          extends java.lang.Object
          implements Packages.arc.util.Disposable
        {
          public static AtlasRegion = class extends Packages
            .arc.graphics.g2d.TextureRegion {
            public pixmapRegion: Packages.arc.graphics.g2d.PixmapRegion;
            public name: string;
            public offsetX: number;
            public offsetY: number;
            public packedWidth: number;
            public packedHeight: number;
            public originalWidth: number;
            public originalHeight: number;
            public rotate: boolean;
            public splits: number[];
            public pads: number[];
            public toString(): string;
            public flip(_x: boolean, _y: boolean): void;
            public getRotatedPackedWidth(): number;
            public getRotatedPackedHeight(): number;
            public constructor(
              _region: Packages.arc.graphics.g2d.TextureRegion,
            );
            public constructor(
              _region: Packages.arc.graphics.g2d.TextureAtlas.AtlasRegion,
            );
            public constructor();
            public constructor(
              _texture: Packages.arc.graphics.Texture,
              _x: number,
              _y: number,
              _width: number,
              _height: number,
            );
          };
          public static TextureAtlasData = class extends java
            .lang.Object {
            public static AtlasPage = class extends java
              .lang.Object {
              public textureFile: Packages.arc.files.Fi;
              public width: number;
              public height: number;
              public useMipMaps: boolean;
              public minFilter: Packages.arc.graphics.Texture.TextureFilter;
              public magFilter: Packages.arc.graphics.Texture.TextureFilter;
              public uWrap: Packages.arc.graphics.Texture.TextureWrap;
              public vWrap: Packages.arc.graphics.Texture.TextureWrap;
              public texture: Packages.arc.graphics.Texture;
              public constructor(
                _handle: Packages.arc.files.Fi,
                _width: number,
                _height: number,
                _useMipMaps: boolean,
                _minFilter: Packages.arc.graphics.Texture.TextureFilter,
                _magFilter: Packages.arc.graphics.Texture.TextureFilter,
                _uWrap: Packages.arc.graphics.Texture.TextureWrap,
                _vWrap: Packages.arc.graphics.Texture.TextureWrap,
              );
            };
            public static Region = class extends java.lang
              .Object {
              public page: Packages.arc.graphics.g2d.TextureAtlas.TextureAtlasData.AtlasPage;
              public name: string;
              public offsetX: number;
              public offsetY: number;
              public originalWidth: number;
              public originalHeight: number;
              public rotate: boolean;
              public left: number;
              public top: number;
              public width: number;
              public height: number;
              public flip: boolean;
              public splits: number[];
              public pads: number[];
              public constructor();
            };
            public static formatVersion: string;
            public static formatHeader: string[];
            pages: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.TextureAtlas.TextureAtlasData.AtlasPage>;
            regions: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.TextureAtlas.TextureAtlasData.Region>;
            public getRegions(): Packages.arc.struct.Seq<Packages.arc.graphics.g2d.TextureAtlas.TextureAtlasData.Region>;
            public getPages(): Packages.arc.struct.Seq<Packages.arc.graphics.g2d.TextureAtlas.TextureAtlasData.AtlasPage>;
            public constructor(
              _packFile: Packages.arc.files.Fi,
              _imagesDir: Packages.arc.files.Fi,
              _flip: boolean,
            );
          };
          private textures: Packages.arc.struct.ObjectSet<Packages.arc.graphics.Texture>;
          private regions: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.TextureAtlas.AtlasRegion>;
          private drawables: Packages.arc.struct.ObjectMap<
            string,
            Packages.arc.scene.style.Drawable
          >;
          private regionmap: Packages.arc.struct.ObjectMap<
            string,
            Packages.arc.graphics.g2d.TextureAtlas.AtlasRegion
          >;
          private pixmaps: Packages.arc.struct.ObjectMap<
            Packages.arc.graphics.Texture,
            Packages.arc.graphics.Pixmap
          >;
          protected error: Packages.arc.graphics.g2d.TextureAtlas.AtlasRegion;
          protected drawableScale: number;
          private load(
            _data: Packages.arc.graphics.g2d.TextureAtlas.TextureAtlasData,
          ): void;
          public find(
            _name: string,
            _def: string,
          ): Packages.arc.graphics.g2d.TextureRegion;
          public find(
            _name: string,
            _def: Packages.arc.graphics.g2d.TextureRegion,
          ): Packages.arc.graphics.g2d.TextureRegion;
          public find(
            _name: string,
          ): Packages.arc.graphics.g2d.TextureAtlas.AtlasRegion;
          public dispose(): void;
          public has(_s: string): boolean;
          public white(): Packages.arc.graphics.g2d.TextureAtlas.AtlasRegion;
          public texture(): Packages.arc.graphics.Texture;
          public getPixmap(
            _name: string,
          ): Packages.arc.graphics.g2d.PixmapRegion;
          public getPixmap(
            _region: Packages.arc.graphics.g2d.TextureRegion,
          ): Packages.arc.graphics.g2d.PixmapRegion;
          public getPixmap(
            _region: Packages.arc.graphics.g2d.TextureAtlas.AtlasRegion,
          ): Packages.arc.graphics.g2d.PixmapRegion;
          public addRegion(
            _name: string,
            _textureRegion: Packages.arc.graphics.g2d.TextureRegion,
          ): Packages.arc.graphics.g2d.TextureAtlas.AtlasRegion;
          public addRegion(
            _name: string,
            _texture: Packages.arc.graphics.Texture,
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          ): Packages.arc.graphics.g2d.TextureAtlas.AtlasRegion;
          public drawable(
            _name: string,
          ): Packages.arc.scene.style.Drawable;
          public static blankAtlas(): Packages.arc.graphics.g2d.TextureAtlas;
          public setDrawableScale(_scale: number): void;
          public getPixmaps(): Packages.arc.struct.ObjectMap<
            Packages.arc.graphics.Texture,
            Packages.arc.graphics.Pixmap
          >;
          public disposePixmap(
            _texture: Packages.arc.graphics.Texture,
          ): void;
          public getRegions(): Packages.arc.struct.Seq<Packages.arc.graphics.g2d.TextureAtlas.AtlasRegion>;
          public getRegionMap(): Packages.arc.struct.ObjectMap<
            string,
            Packages.arc.graphics.g2d.TextureAtlas.AtlasRegion
          >;
          public setErrorRegion(_name: string): boolean;
          public isFound(
            _region: Packages.arc.graphics.g2d.TextureRegion,
          ): boolean;
          public getDrawable<
            T extends Packages.arc.scene.style.Drawable,
          >(_name: string): T | null;
          public createPatch(
            _name: string,
          ): Packages.arc.graphics.g2d.NinePatch;
          public getTextures(): Packages.arc.struct.ObjectSet<Packages.arc.graphics.Texture>;
          public constructor(
            _packFile: Packages.arc.files.Fi,
          );
          public constructor(
            _packFile: Packages.arc.files.Fi,
            _flip: boolean,
          );
          public constructor(
            _packFile: Packages.arc.files.Fi,
            _imagesDir: Packages.arc.files.Fi,
          );
          public constructor(
            _packFile: Packages.arc.files.Fi,
            _imagesDir: Packages.arc.files.Fi,
            _flip: boolean,
          );
          public constructor(
            _data: Packages.arc.graphics.g2d.TextureAtlas.TextureAtlasData,
          );
          public constructor();
          public constructor(_internalPackFile: string);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare class Core extends java.lang.Object {
      public static app: Packages.arc.Application;
      public static graphics: Packages.arc.Graphics;
      public static audio: Packages.arc.audio.Audio;
      public static input: Packages.arc.Input;
      public static files: Packages.arc.Files;
      public static settings: Packages.arc.Settings;
      public static keybinds: Packages.arc.KeyBinds;
      public static bundle: Packages.arc.util.I18NBundle;
      public static camera: Packages.arc.graphics.Camera;
      public static batch: Packages.arc.graphics.g2d.Batch;
      public static scene: Packages.arc.scene.Scene;
      public static assets: Packages.arc.assets.AssetManager;
      public static atlas: Packages.arc.graphics.g2d.TextureAtlas;
      public static gl: Packages.arc.graphics.GL20;
      public static gl20: Packages.arc.graphics.GL20;
      public static gl30: Packages.arc.graphics.GL30;
      public constructor();
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare class Events extends java.lang.Object {
      private static events: Packages.arc.struct.ObjectMap<
        any,
        Packages.arc.struct.Seq<Packages.arc.func.Cons<any>>
      >;
      public static run(
        _type: any,
        _listener: Packages.java.lang.Runnable,
      ): void;
      public static remove<T>(
        _type: Class<T> | Packages.java.lang.Class<T>,
        _listener: Packages.arc.func.Cons<T>,
      ): boolean;
      public static clear(): void;
      public static on<T>(
        _type: Class<T> | Packages.java.lang.Class<T>,
        _listener: Packages.arc.func.Cons<T>,
      ): void;
      public static fire<T>(
        _ctype: Class<any> | Packages.java.lang.Class<any>,
        _type: T,
      ): void;
      public static fire<
        T extends Packages.java.lang.Enum<T>,
      >(_type: Packages.java.lang.Enum<T>): void;
      public static fire<T>(_type: T): void;
      public constructor();
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace audio {
      declare class Filters extends java.lang.Object {
        public static FreeverbFilter = class extends Packages
          .arc.audio.AudioFilter {
          public set(
            _mode: number,
            _roomSize: number,
            _damp: number,
            _width: number,
          ): void;
          public constructor();
        };
        public static RobotizeFilter = class extends Packages
          .arc.audio.AudioFilter {
          public set(
            _freq: number,
            _waveform: number,
          ): void;
          public constructor();
        };
        public static BassBoostFilter = class extends Packages
          .arc.audio.AudioFilter {
          public set(_amount: number): void;
          public constructor();
        };
        public static WaveShaperFilter = class extends Packages
          .arc.audio.AudioFilter {
          public set(_amount: number): void;
          public constructor();
        };
        public static FlangerFilter = class extends Packages
          .arc.audio.AudioFilter {
          public set(
            _delay: number,
            _frequency: number,
          ): void;
          public constructor();
        };
        public static LofiFilter = class extends Packages
          .arc.audio.AudioFilter {
          public set(
            _sampleRate: number,
            _depth: number,
          ): void;
          public constructor();
        };
        public static EchoFilter = class extends Packages
          .arc.audio.AudioFilter {
          public set(
            _delay: number,
            _decay: number,
            _filter: number,
          ): void;
          public constructor();
        };
        public static BiquadFilter = class extends Packages
          .arc.audio.AudioFilter {
          public set(
            _type: number,
            _frequency: number,
            _resonance: number,
          ): void;
          public constructor();
        };
        public static paramWet: number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace audio {
      declare class Soloud extends java.lang.Object {
        static version(): number;
        static init(): void;
        static backendString(): string;
        static backendSamplerate(): number;
        static backendBufferSize(): number;
        static backendChannels(): number;
        static idValid(_voice: number): boolean;
        static idProtected(
          _id: number,
          _protect: boolean,
        ): void;
        static sourcePlay(_handle: Packages.long): number;
        static sourcePlay(
          _handle: Packages.long,
          _volume: number,
          _pitch: number,
          _pan: number,
          _loop: boolean,
        ): number;
        static sourceStop(_handle: Packages.long): void;
        static idStop(_voice: number): void;
        static idPause(_id: number, _pause: boolean): void;
        static idLooping(
          _voice: number,
          _looping: boolean,
        ): void;
        static idPitch(_id: number, _pitch: number): void;
        static idVolume(_id: number, _volume: number): void;
        static idPan(_id: number, _pan: number): void;
        static filterFade(
          _voice: number,
          _filter: number,
          _attribute: number,
          _value: number,
          _timeSec: number,
        ): void;
        static filterSet(
          _voice: number,
          _filter: number,
          _attribute: number,
          _value: number,
        ): void;
        static setGlobalFilter(
          _index: number,
          _handle: Packages.long,
        ): void;
        static sourceCount(_handle: Packages.long): number;
        static stopAll(): void;
        static deinit(): void;
        static sourceFilter(
          _handle: Packages.long,
          _index: number,
          _filter: Packages.long,
        ): void;
        static busNew(): Packages.long;
        static wavLoad(
          _bytes: string[],
          _length: number,
        ): Packages.long;
        static sourcePlayBus(
          _handle: Packages.long,
          _busHandle: Packages.long,
          _volume: number,
          _pitch: number,
          _pan: number,
          _loop: boolean,
        ): number;
        static streamLoad(_path: string): Packages.long;
        static idGetPause(_voice: number): boolean;
        static idPosition(_voice: number): number;
        static idSeek(_id: number, _seconds: number): void;
        static filterFreeverb(): Packages.long;
        static freeverbSet(
          _handle: Packages.long,
          _mode: number,
          _roomSize: number,
          _damp: number,
          _width: number,
        ): void;
        static filterRobotize(): Packages.long;
        static robotizeSet(
          _handle: Packages.long,
          _freq: number,
          _waveform: number,
        ): void;
        static filterBassBoost(): Packages.long;
        static bassBoostSet(
          _handle: Packages.long,
          _amount: number,
        ): void;
        static filterWaveShaper(): Packages.long;
        static waveShaperSet(
          _handle: Packages.long,
          _amount: number,
        ): void;
        static filterFlanger(): Packages.long;
        static flangerSet(
          _handle: Packages.long,
          _delay: number,
          _frequency: number,
        ): void;
        static filterLofi(): Packages.long;
        static lofiSet(
          _handle: Packages.long,
          _sampleRate: number,
          _bitDepth: number,
        ): void;
        static filterEcho(): Packages.long;
        static echoSet(
          _handle: Packages.long,
          _delay: number,
          _decay: number,
          _filter: number,
        ): void;
        static filterBiquad(): Packages.long;
        static biquadSet(
          _handle: Packages.long,
          _type: number,
          _frequency: number,
          _resonance: number,
        ): void;
        static backendId(): number;
        static pauseAll(_paused: boolean): void;
        static idGetVolume(_id: number): number;
        static idGetLooping(_voice: number): boolean;
        static streamLength(_handle: Packages.long): number;
        static sourceDestroy(_handle: Packages.long): void;
        static sourceInaudible(
          _handle: Packages.long,
          _tick: boolean,
          _play: boolean,
        ): void;
        static sourceLoop(
          _handle: Packages.long,
          _loop: boolean,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare namespace zip {
        declare class ZipEntry {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare namespace zip {
        declare class ZipFile {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace files {
      declare class ZipFi extends Packages.arc.files.Fi {
        private children?: Packages.arc.files.ZipFi[];
        private allFiles: Packages.arc.struct.Seq<Packages.arc.files.ZipFi>;
        private allDirectories: Packages.arc.struct.Seq<Packages.arc.files.ZipFi>;
        private entry?: Packages.java.util.zip.ZipEntry;
        private zip: Packages.java.util.zip.ZipFile;
        public name(): string;
        public parent(): Packages.arc.files.Fi;
        public length(): Packages.long;
        public toString(): string;
        public list(): Packages.arc.files.Fi[] | null;
        public read(): Packages.java.io.InputStream;
        public delete(): boolean;
        public path(): string;
        public exists(): boolean;
        public isDirectory(): boolean;
        public child(_name: string): Packages.arc.files.Fi;
        private static countSlashes(_str: string): number;
        private static isChild(
          _file: Packages.arc.files.ZipFi,
          _dir: Packages.arc.files.ZipFi,
        ): boolean;
        public constructor(
          _zipFileLoc: Packages.arc.files.Fi,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class ObjectFloatMap<K>
        extends java.lang.Object
        implements
          Packages.java.lang.Iterable<
            Packages.arc.struct.ObjectFloatMap.Entry<K>
          >
      {
        public static Entries = class<K>
          extends Packages.arc.struct.ObjectFloatMap
            .MapIterator<K>
          implements
            Packages.java.util.Iterator<
              Packages.arc.struct.ObjectFloatMap.Entry<K>
            >,
            Packages.java.lang.Iterable<
              Packages.arc.struct.ObjectFloatMap.Entry<K>
            >
        {
          private entry: Packages.arc.struct.ObjectFloatMap.Entry<K>;
          public remove(): void;
          public iterator(): Packages.java.util.Iterator<any>;
          public iterator(): Packages.arc.struct.ObjectFloatMap.Entries<K>;
          public hasNext(): boolean;
          public next(): any;
          public next(): Packages.arc.struct.ObjectFloatMap.Entry<K>;
          public reset(): void;
          public constructor(
            _map: Packages.arc.struct.ObjectFloatMap<K>,
          );
        };
        public static Entry = class<K> extends java.lang
          .Object {
          public key: K;
          public value: number;
          public toString(): string;
          public constructor();
        };
        public static Values = class extends Packages.arc
          .struct.ObjectFloatMap.MapIterator<any> {
          public remove(): void;
          public toArray(): Packages.arc.struct.FloatSeq;
          public hasNext(): boolean;
          public next(): number;
          public reset(): void;
          public constructor(
            _map: Packages.arc.struct.ObjectFloatMap<any>,
          );
        };
        public static Keys = class<K>
          extends Packages.arc.struct.ObjectFloatMap
            .MapIterator<K>
          implements
            Packages.java.util.Iterator<K>,
            Packages.java.lang.Iterable<K>
        {
          public remove(): void;
          public toArray(): Packages.arc.struct.Seq<K>;
          public toArray(
            _array: Packages.arc.struct.Seq<K>,
          ): Packages.arc.struct.Seq<K>;
          public iterator(): Packages.java.util.Iterator<any>;
          public iterator(): Packages.arc.struct.ObjectFloatMap.Keys<K>;
          public hasNext(): boolean;
          public next(): K | null;
          public reset(): void;
          public constructor(
            _map: Packages.arc.struct.ObjectFloatMap<K>,
          );
        };
        private static MapIterator = class<K> extends java
          .lang.Object {
          map: Packages.arc.struct.ObjectFloatMap<K>;
          public hasNext: boolean;
          nextIndex: number;
          currentIndex: number;
          valid: boolean;
          public remove(): void;
          public reset(): void;
          findNextIndex(): void;
          public constructor(
            _map: Packages.arc.struct.ObjectFloatMap<K>,
          );
        };
        private static PRIME1: number;
        private static PRIME2: number;
        private static PRIME3: number;
        public size: number;
        keyTable: K[];
        valueTable: number[];
        capacity: number;
        stashSize: number;
        private loadFactor: number;
        private hashShift: number;
        private mask: number;
        private threshold: number;
        private stashCapacity: number;
        private pushIterations: number;
        private entries1: Packages.arc.struct.ObjectFloatMap.Entries<any>;
        private entries2: Packages.arc.struct.ObjectFloatMap.Entries<any>;
        private values1: Packages.arc.struct.ObjectFloatMap.Values;
        private values2: Packages.arc.struct.ObjectFloatMap.Values;
        private keys1: Packages.arc.struct.ObjectFloatMap.Keys<any>;
        private keys2: Packages.arc.struct.ObjectFloatMap.Keys<any>;
        public remove(
          _key: K,
          _defaultValue: number,
        ): number;
        public get(_key: K, _defaultValue: number): number;
        public put(_key: K, _value: number): void;
        public equals(_obj: any): boolean;
        public toString(): string;
        public values(): Packages.arc.struct.ObjectFloatMap.Values;
        public hashCode(): number;
        public clear(_maximumCapacity: number): void;
        public clear(): void;
        public isEmpty(): boolean;
        public iterator(): Packages.java.util.Iterator<any>;
        public iterator(): Packages.arc.struct.ObjectFloatMap.Entries<K>;
        public putAll(
          _map: Packages.arc.struct.ObjectFloatMap<any>,
        ): void;
        public increment(
          _key: K,
          _defaultValue: number,
          _increment: number,
        ): number;
        public containsKey(_key: K): boolean;
        public keys(): Packages.arc.struct.ObjectFloatMap.Keys<K>;
        public containsValue(_value: number): boolean;
        public entries(): Packages.arc.struct.ObjectFloatMap.Entries<K>;
        public ensureCapacity(
          _additionalCapacity: number,
        ): void;
        public each(
          _cons: Packages.arc.func.Cons<
            Packages.arc.struct.ObjectFloatMap.Entry<K>
          >,
        ): void;
        private resize(_newSize: number): void;
        private push(
          _insertKey: K,
          _insertValue: number,
          _index1: number,
          _key1: K,
          _index2: number,
          _key2: K,
          _index3: number,
          _key3: K,
        ): void;
        public shrink(_maximumCapacity: number): void;
        private hash2(_h: number): number;
        private hash3(_h: number): number;
        private putStash(_key: K, _value: number): void;
        private putResize(_key: K, _value: number): void;
        private getStash(
          _key: K,
          _defaultValue: number,
        ): number;
        removeStash(_key: K, _defaultValue: number): number;
        removeStashIndex(_index: number): void;
        private containsKeyStash(_key: K): boolean;
        public findKey(_value: number): K | null;
        private getAndIncrementStash(
          _key: K,
          _defaultValue: number,
          _increment: number,
        ): number;
        public constructor(
          _map: Packages.arc.struct.ObjectFloatMap<any>,
        );
        public constructor(
          _initialCapacity: number,
          _loadFactor: number,
        );
        public constructor(_initialCapacity: number);
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace flabel {
      declare abstract class FListener {
        public end(): void;
        public event(_event: string): void;
        public replaceVariable(_variable: string): string;
        public onChar(_ch: string): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace flabel {
      declare class FGlyph
        extends Packages.arc.graphics.g2d.Font.Glyph
        implements Packages.arc.util.pooling.Pool.Poolable
      {
        public run: Packages.arc.graphics.g2d.GlyphLayout.GlyphRun;
        internalIndex: number;
        public color: Packages.arc.graphics.Color;
        public set(
          _from: Packages.arc.graphics.g2d.Font.Glyph,
        ): void;
        public reset(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace flabel {
      declare class FLabel extends Packages.arc.scene.ui
        .Label {
        private variables: Packages.arc.struct.ObjectMap<
          string,
          string
        >;
        protected tokenEntries: Packages.arc.struct.Seq<Packages.arc.flabel.FParser.TokenEntry>;
        private clearColor: Packages.arc.graphics.Color;
        private listener: Packages.arc.flabel.FListener;
        forceMarkupColor: boolean;
        private originalText: Packages.java.lang.StringBuilder;
        private glyphCache: Packages.arc.struct.Seq<Packages.arc.flabel.FGlyph>;
        private glyphRunCapacities: Packages.arc.struct.IntSeq;
        private offsetCache: Packages.arc.struct.IntSeq;
        private layoutLineBreaks: Packages.arc.struct.IntSeq;
        private activeEffects: Packages.arc.struct.Seq<Packages.arc.flabel.FEffect>;
        private textSpeed: number;
        private charCooldown: number;
        private rawCharIndex: number;
        private glyphCharIndex: number;
        private glyphCharCompensation: number;
        private cachedGlyphCharIndex: number;
        private lastLayoutX: number;
        private lastLayoutY: number;
        private parsed: boolean;
        private paused: boolean;
        private ended: boolean;
        private skipping: boolean;
        private ignoringEvents: boolean;
        private ignoringEffects: boolean;
        private defaultToken: string;
        public remove(): boolean;
        public resume(): void;
        protected setText(
          _newText: Packages.java.lang.CharSequence,
          _modifyOriginalText: boolean,
        ): void;
        public setText(
          _newText: Packages.java.lang.CharSequence,
        ): void;
        public pause(): void;
        public draw(): void;
        public act(_delta: number): void;
        public restart(): void;
        public restart(
          _newText: Packages.java.lang.CharSequence,
        ): void;
        public layout(): void;
        protected saveOriginalText(): void;
        public getDefaultToken(): string;
        public parseTokens(): void;
        public skipToTheEnd(
          _ignoreEvents: boolean,
          _ignoreEffects: boolean,
        ): void;
        public skipToTheEnd(_ignoreEvents: boolean): void;
        public skipToTheEnd(): void;
        public getOriginalText(): Packages.java.lang.StringBuilder;
        private processCharProgression(): void;
        private layoutCache(): void;
        private addMissingGlyphs(): void;
        protected restoreOriginalText(): void;
        public getTypingListener(): Packages.arc.flabel.FListener;
        public setTypingListener(
          _listener: Packages.arc.flabel.FListener,
        ): void;
        public getClearColor(): Packages.arc.graphics.Color;
        public setForceMarkupColor(
          _forceMarkupColor: boolean,
        ): void;
        public setDefaultToken(_defaultToken: string): void;
        public cancelSkipping(): void;
        public isPaused(): boolean;
        public hasEnded(): boolean;
        public getVariables(): Packages.arc.struct.ObjectMap<
          string,
          string
        >;
        public setVariable(
          _var: string,
          _value: string,
        ): void;
        public setVariables(
          _variableMap: Packages.arc.struct.ObjectMap<
            string,
            string
          >,
        ): void;
        public clearVariables(): void;
        public constructor(
          _text: Packages.java.lang.CharSequence,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace flabel {
      declare abstract class FEffect extends java.lang
        .Object {
        private static fadeoutSplit: number;
        public indexStart: number;
        public indexEnd: number;
        public duration: number;
        public endToken: string;
        protected totalTime: number;
        public update(_delta: number): void;
        public apply(
          _label: Packages.arc.flabel.FLabel,
          _glyph: Packages.arc.flabel.FGlyph,
          _glyphIndex: number,
          _delta: number,
        ): void;
        protected getLineHeight(
          _label: Packages.arc.flabel.FLabel,
        ): number;
        public isFinished(): boolean;
        protected onApply(
          _label: Packages.arc.flabel.FLabel,
          _glyph: Packages.arc.flabel.FGlyph,
          _localIndex: number,
          _delta: number,
        ): void;
        protected calculateProgress(
          _modifier: number,
          _offset: number,
        ): number;
        protected calculateProgress(
          _modifier: number,
          _offset: number,
          _pingpong: boolean,
        ): number;
        protected calculateProgress(
          _modifier: number,
        ): number;
        protected calculateFadeout(): number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace flabel {
      declare class FConfig extends java.lang.Object {
        public static forceColorMarkupByDefault: boolean;
        public static defaultWaitValue: number;
        public static defaultSpeedPerChar: number;
        public static charLimitPerFrame: number;
        public static defaultClearColor: Packages.arc.graphics.Color;
        public static intervalMultipliersByChar: Packages.arc.struct.ObjectFloatMap<string>;
        public static globalVars: Packages.arc.struct.ObjectMap<
          string,
          string
        >;
        static effects: Packages.arc.struct.ObjectMap<
          string,
          Packages.arc.func.Prov<Packages.arc.flabel.FEffect>
        >;
        static dirtyEffectMaps: boolean;
        public static registerEffect(
          _tokenName: string,
          _effect: Packages.arc.func.Prov<Packages.arc.flabel.FEffect>,
        ): void;
        public static unregisterEffect(
          _tokenName: string,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class LongSeq extends java.lang.Object {
        public items: Packages.long[];
        public size: number;
        public ordered: boolean;
        public add(
          _value1: Packages.long,
          _value2: Packages.long,
        ): void;
        public add(
          _value1: Packages.long,
          _value2: Packages.long,
          _value3: Packages.long,
        ): void;
        public add(
          _value1: Packages.long,
          _value2: Packages.long,
          _value3: Packages.long,
          _value4: Packages.long,
        ): void;
        public add(_value: Packages.long): void;
        public get(_index: number): Packages.long;
        public equals(_object: any): boolean;
        public toString(_separator: string): string;
        public toString(): string;
        public hashCode(): number;
        public indexOf(_value: Packages.long): number;
        public insert(
          _index: number,
          _value: Packages.long,
        ): void;
        public clear(): void;
        public lastIndexOf(_value: string): number;
        public isEmpty(): boolean;
        public toArray(): Packages.long[] | null;
        public contains(_value: Packages.long): boolean;
        public addAll(
          _array: Packages.arc.struct.LongSeq,
        ): void;
        public addAll(
          _array: Packages.long[],
          _offset: number,
          _length: number,
        ): void;
        public addAll(..._array: Packages.long[]): void;
        public addAll(
          _array: Packages.arc.struct.LongSeq,
          _offset: number,
          _length: number,
        ): void;
        public first(): Packages.long;
        public set(
          _index: number,
          _value: Packages.long,
        ): void;
        public ensureCapacity(
          _additionalCapacity: number,
        ): Packages.long[] | null;
        public reverse(): void;
        public peek(): Packages.long;
        public sort(): void;
        public removeRange(
          _start: number,
          _end: number,
        ): void;
        public removeAll(
          _array: Packages.arc.struct.LongSeq,
        ): boolean;
        protected resize(
          _newSize: number,
        ): Packages.long[] | null;
        public incr(
          _index: number,
          _value: Packages.long,
        ): void;
        public random(): Packages.long;
        public swap(_first: number, _second: number): void;
        public shuffle(): void;
        public pop(): Packages.long;
        public static with(
          ..._array: Packages.long[]
        ): Packages.arc.struct.LongSeq;
        public setSize(
          _newSize: number,
        ): Packages.long[] | null;
        public mul(
          _index: number,
          _value: Packages.long,
        ): void;
        public truncate(_newSize: number): void;
        public shrink(): Packages.long[] | null;
        public removeIndex(_index: number): Packages.long;
        public removeValue(_value: Packages.long): boolean;
        public constructor(
          _ordered: boolean,
          _array: Packages.long[],
          _startIndex: number,
          _count: number,
        );
        public constructor(_array: Packages.long[]);
        public constructor(
          _array: Packages.arc.struct.LongSeq,
        );
        public constructor();
        public constructor(_capacity: number);
        public constructor(
          _ordered: boolean,
          _capacity: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class LongMap<V>
        extends java.lang.Object
        implements
          Packages.java.lang.Iterable<
            Packages.arc.struct.LongMap.Entry<V>
          >
      {
        public static Entries = class<V>
          extends Packages.arc.struct.LongMap.MapIterator<V>
          implements
            Packages.java.util.Iterator<
              Packages.arc.struct.LongMap.Entry<V>
            >,
            Packages.java.lang.Iterable<
              Packages.arc.struct.LongMap.Entry<V>
            >
        {
          private entry: Packages.arc.struct.LongMap.Entry<V>;
          public remove(): void;
          public iterator(): Packages.java.util.Iterator<
            Packages.arc.struct.LongMap.Entry<V>
          >;
          public hasNext(): boolean;
          public next(): any;
          public next(): Packages.arc.struct.LongMap.Entry<V>;
          public reset(): void;
          public constructor(
            _map: Packages.arc.struct.LongMap<any>,
          );
        };
        public static Entry = class<V> extends java.lang
          .Object {
          public key: Packages.long;
          public value: V;
          public toString(): string;
          public constructor();
        };
        public static Values = class<V>
          extends Packages.arc.struct.LongMap.MapIterator<V>
          implements
            Packages.java.util.Iterator<V>,
            Packages.java.lang.Iterable<V>
        {
          public remove(): void;
          public toArray(): Packages.arc.struct.Seq<V>;
          public iterator(): Packages.java.util.Iterator<V>;
          public hasNext(): boolean;
          public next(): V | null;
          public reset(): void;
          public constructor(
            _map: Packages.arc.struct.LongMap<V>,
          );
        };
        public static Keys = class extends Packages.arc
          .struct.LongMap.MapIterator<any> {
          public remove(): void;
          public toArray(): Packages.arc.struct.LongSeq;
          public next(): Packages.long;
          public reset(): void;
          public constructor(
            _map: Packages.arc.struct.LongMap<any>,
          );
        };
        private static MapIterator = class<V> extends java
          .lang.Object {
          static INDEX_ILLEGAL: number;
          static INDEX_ZERO: number;
          map: Packages.arc.struct.LongMap<V>;
          public hasNext: boolean;
          nextIndex: number;
          currentIndex: number;
          valid: boolean;
          public remove(): void;
          public reset(): void;
          findNextIndex(): void;
          public constructor(
            _map: Packages.arc.struct.LongMap<V>,
          );
        };
        private static PRIME1: number;
        private static PRIME2: number;
        private static PRIME3: number;
        private static EMPTY: number;
        public size: number;
        keyTable: Packages.long[];
        valueTable: V[];
        capacity: number;
        stashSize: number;
        zeroValue: V;
        hasZeroValue: boolean;
        private loadFactor: number;
        private hashShift: number;
        private mask: number;
        private threshold: number;
        private stashCapacity: number;
        private pushIterations: number;
        private entries1: Packages.arc.struct.LongMap.Entries<any>;
        private entries2: Packages.arc.struct.LongMap.Entries<any>;
        private values1: Packages.arc.struct.LongMap.Values<any>;
        private values2: Packages.arc.struct.LongMap.Values<any>;
        private keys1: Packages.arc.struct.LongMap.Keys;
        private keys2: Packages.arc.struct.LongMap.Keys;
        public remove(_key: Packages.long): V | null;
        public get(
          _key: Packages.long,
          _defaultValue: V,
        ): V | null;
        public get(_key: Packages.long): V | null;
        public put(
          _key: Packages.long,
          _value: V,
        ): V | null;
        public equals(_obj: any): boolean;
        public toString(): string;
        public values(): Packages.arc.struct.LongMap.Values<V>;
        public hashCode(): number;
        public clear(_maximumCapacity: number): void;
        public clear(): void;
        public isEmpty(): boolean;
        public iterator(): Packages.java.util.Iterator<
          Packages.arc.struct.LongMap.Entry<V>
        >;
        public putAll(
          _map: Packages.arc.struct.LongMap<any>,
        ): void;
        public containsKey(_key: Packages.long): boolean;
        public keys(): Packages.arc.struct.LongMap.Keys;
        public containsValue(
          _value: any,
          _identity: boolean,
        ): boolean;
        public entries(): Packages.arc.struct.LongMap.Entries<V>;
        public ensureCapacity(
          _additionalCapacity: number,
        ): void;
        private resize(_newSize: number): void;
        private push(
          _insertKey: Packages.long,
          _insertValue: V,
          _index1: number,
          _key1: Packages.long,
          _index2: number,
          _key2: Packages.long,
          _index3: number,
          _key3: Packages.long,
        ): void;
        public shrink(_maximumCapacity: number): void;
        private hash2(_h: Packages.long): number;
        private hash3(_h: Packages.long): number;
        private putStash(
          _key: Packages.long,
          _value: V,
        ): void;
        private putResize(
          _key: Packages.long,
          _value: V,
        ): void;
        private getStash(
          _key: Packages.long,
          _defaultValue: V,
        ): V | null;
        removeStash(_key: Packages.long): V | null;
        removeStashIndex(_index: number): void;
        private containsKeyStash(
          _key: Packages.long,
        ): boolean;
        public findKey(
          _value: any,
          _identity: boolean,
          _notFound: Packages.long,
        ): Packages.long;
        public constructor(
          _map: Packages.arc.struct.LongMap<any>,
        );
        public constructor(
          _initialCapacity: number,
          _loadFactor: number,
        );
        public constructor(_initialCapacity: number);
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace freetype {
      declare class FreeType extends java.lang.Object {
        public static Library = class
          extends Packages.arc.freetype.FreeType.Pointer
          implements Packages.arc.util.Disposable
        {
          fontData: Packages.arc.struct.LongMap<Packages.java.nio.ByteBuffer>;
          public dispose(): void;
          private static doneFreeType(
            _library: Packages.long,
          ): void;
          public newMemoryFace(
            _data: string[],
            _dataSize: number,
            _faceIndex: number,
          ): Packages.arc.freetype.FreeType.Face;
          public newMemoryFace(
            _buffer: Packages.java.nio.ByteBuffer,
            _faceIndex: number,
          ): Packages.arc.freetype.FreeType.Face;
          private static newMemoryFace(
            _library: Packages.long,
            _data: Packages.java.nio.ByteBuffer,
            _dataSize: number,
            _faceIndex: number,
          ): Packages.long;
          private static strokerNew(
            _library: Packages.long,
          ): Packages.long;
          public newFace(
            _font: Packages.arc.files.Fi,
            _faceIndex: number,
          ): Packages.arc.freetype.FreeType.Face;
          public createStroker(): Packages.arc.freetype.FreeType.Stroker;
        };
        public static Stroker = class
          extends Packages.arc.freetype.FreeType.Pointer
          implements Packages.arc.util.Disposable
        {
          private static set(
            _stroker: Packages.long,
            _radius: number,
            _lineCap: number,
            _lineJoin: number,
            _miterLimit: number,
          ): void;
          public set(
            _radius: number,
            _lineCap: number,
            _lineJoin: number,
            _miterLimit: number,
          ): void;
          private static done(
            _stroker: Packages.long,
          ): void;
          public dispose(): void;
        };
        public static GlyphMetrics = class extends Packages
          .arc.freetype.FreeType.Pointer {
          public getWidth(): number;
          private static getWidth(
            _metrics: Packages.long,
          ): number;
          public getHeight(): number;
          private static getHeight(
            _metrics: Packages.long,
          ): number;
          private static getHoriBearingX(
            _metrics: Packages.long,
          ): number;
          public getHoriBearingX(): number;
          private static getHoriBearingY(
            _metrics: Packages.long,
          ): number;
          public getHoriBearingY(): number;
          private static getHoriAdvance(
            _metrics: Packages.long,
          ): number;
          public getHoriAdvance(): number;
          private static getVertBearingX(
            _metrics: Packages.long,
          ): number;
          public getVertBearingX(): number;
          public getVertBearingY(): number;
          private static getVertBearingY(
            _metrics: Packages.long,
          ): number;
          public getVertAdvance(): number;
          private static getVertAdvance(
            _metrics: Packages.long,
          ): number;
        };
        public static Bitmap = class extends Packages.arc
          .freetype.FreeType.Pointer {
          private static getBuffer(
            _bitmap: Packages.long,
          ): Packages.java.nio.ByteBuffer;
          public getBuffer(): Packages.java.nio.ByteBuffer;
          public getWidth(): number;
          private static getWidth(
            _bitmap: Packages.long,
          ): number;
          public getPixmap(
            _color: Packages.arc.graphics.Color,
            _gamma: number,
          ): Packages.arc.graphics.Pixmap;
          public getRows(): number;
          private static getRows(
            _bitmap: Packages.long,
          ): number;
          private static getPitch(
            _bitmap: Packages.long,
          ): number;
          public getPitch(): number;
          public getPixelMode(): number;
          private static getPixelMode(
            _bitmap: Packages.long,
          ): number;
          public getNumGray(): number;
          private static getNumGray(
            _bitmap: Packages.long,
          ): number;
        };
        public static Glyph = class
          extends Packages.arc.freetype.FreeType.Pointer
          implements Packages.arc.util.Disposable
        {
          private rendered: boolean;
          private static done(_glyph: Packages.long): void;
          public dispose(): void;
          private static getTop(
            _glyph: Packages.long,
          ): number;
          public getTop(): number;
          private static toBitmap(
            _glyph: Packages.long,
            _renderMode: number,
          ): Packages.long;
          public toBitmap(_renderMode: number): void;
          public getBitmap(): Packages.arc.freetype.FreeType.Bitmap;
          private static getBitmap(
            _glyph: Packages.long,
          ): Packages.long;
          public getLeft(): number;
          private static getLeft(
            _glyph: Packages.long,
          ): number;
          public strokeBorder(
            _stroker: Packages.arc.freetype.FreeType.Stroker,
            _inside: boolean,
          ): void;
          private static strokeBorder(
            _glyph: Packages.long,
            _stroker: Packages.long,
            _inside: boolean,
          ): Packages.long;
        };
        public static GlyphSlot = class extends Packages.arc
          .freetype.FreeType.Pointer {
          private static getFormat(
            _slot: Packages.long,
          ): number;
          public getFormat(): number;
          private static getGlyph(
            _glyphSlot: Packages.long,
          ): Packages.long;
          public getGlyph(): Packages.arc.freetype.FreeType.Glyph;
          public getBitmap(): Packages.arc.freetype.FreeType.Bitmap;
          private static getBitmap(
            _slot: Packages.long,
          ): Packages.long;
          public getMetrics(): Packages.arc.freetype.FreeType.GlyphMetrics;
          private static getMetrics(
            _slot: Packages.long,
          ): Packages.long;
          private static getLinearHoriAdvance(
            _slot: Packages.long,
          ): number;
          public getLinearHoriAdvance(): number;
          public getLinearVertAdvance(): number;
          private static getLinearVertAdvance(
            _slot: Packages.long,
          ): number;
          public getAdvanceX(): number;
          private static getAdvanceX(
            _slot: Packages.long,
          ): number;
          public getAdvanceY(): number;
          private static getAdvanceY(
            _slot: Packages.long,
          ): number;
          public getBitmapLeft(): number;
          private static getBitmapLeft(
            _slot: Packages.long,
          ): number;
          private static getBitmapTop(
            _slot: Packages.long,
          ): number;
          public getBitmapTop(): number;
          public renderGlyph(_renderMode: number): boolean;
          private static renderGlyph(
            _slot: Packages.long,
            _renderMode: number,
          ): boolean;
        };
        public static SizeMetrics = class extends Packages
          .arc.freetype.FreeType.Pointer {
          public getHeight(): number;
          private static getHeight(
            _metrics: Packages.long,
          ): number;
          public getXppem(): number;
          private static getXppem(
            _metrics: Packages.long,
          ): number;
          private static getYppem(
            _metrics: Packages.long,
          ): number;
          public getYppem(): number;
          private static getXscale(
            _metrics: Packages.long,
          ): number;
          public getYscale(): number;
          private static getYscale(
            _metrics: Packages.long,
          ): number;
          public getAscender(): number;
          private static getAscender(
            _metrics: Packages.long,
          ): number;
          public getDescender(): number;
          private static getDescender(
            _metrics: Packages.long,
          ): number;
          public getMaxAdvance(): number;
          private static getMaxAdvance(
            _metrics: Packages.long,
          ): number;
          public getXScale(): number;
        };
        public static Size = class extends Packages.arc
          .freetype.FreeType.Pointer {
          private static getMetrics(
            _address: Packages.long,
          ): Packages.long;
          public getMetrics(): Packages.arc.freetype.FreeType.SizeMetrics;
        };
        public static Face = class
          extends Packages.arc.freetype.FreeType.Pointer
          implements Packages.arc.util.Disposable
        {
          library: Packages.arc.freetype.FreeType.Library;
          public getSize(): Packages.arc.freetype.FreeType.Size;
          private static getSize(
            _face: Packages.long,
          ): Packages.long;
          public dispose(): void;
          public getHeight(): number;
          private static getHeight(
            _face: Packages.long,
          ): number;
          private static getKerning(
            _face: Packages.long,
            _leftGlyph: number,
            _rightGlyph: number,
            _kernMode: number,
          ): number;
          public getKerning(
            _leftGlyph: number,
            _rightGlyph: number,
            _kernMode: number,
          ): number;
          private static getGlyph(
            _face: Packages.long,
          ): Packages.long;
          public getGlyph(): Packages.arc.freetype.FreeType.GlyphSlot;
          public getNumGlyphs(): number;
          private static getNumGlyphs(
            _face: Packages.long,
          ): number;
          private static getMaxAdvanceWidth(
            _face: Packages.long,
          ): number;
          public getMaxAdvanceWidth(): number;
          private static getMaxAdvanceHeight(
            _face: Packages.long,
          ): number;
          public getMaxAdvanceHeight(): number;
          public getUnderlinePosition(): number;
          private static getUnderlinePosition(
            _face: Packages.long,
          ): number;
          public getUnderlineThickness(): number;
          private static getUnderlineThickness(
            _face: Packages.long,
          ): number;
          public selectSize(_strikeIndex: number): boolean;
          private static selectSize(
            _face: Packages.long,
            _strike_index: number,
          ): boolean;
          public setCharSize(
            _charWidth: number,
            _charHeight: number,
            _horzResolution: number,
            _vertResolution: number,
          ): boolean;
          private static setCharSize(
            _face: Packages.long,
            _charWidth: number,
            _charHeight: number,
            _horzResolution: number,
            _vertResolution: number,
          ): boolean;
          public setPixelSizes(
            _pixelWidth: number,
            _pixelHeight: number,
          ): boolean;
          private static setPixelSizes(
            _face: Packages.long,
            _pixelWidth: number,
            _pixelHeight: number,
          ): boolean;
          private static loadGlyph(
            _face: Packages.long,
            _glyphIndex: number,
            _loadFlags: number,
          ): boolean;
          public loadGlyph(
            _glyphIndex: number,
            _loadFlags: number,
          ): boolean;
          private static loadChar(
            _face: Packages.long,
            _charCode: number,
            _loadFlags: number,
          ): boolean;
          public loadChar(
            _charCode: number,
            _loadFlags: number,
          ): boolean;
          public hasKerning(): boolean;
          private static hasKerning(
            _face: Packages.long,
          ): boolean;
          public getCharIndex(_charCode: number): number;
          private static getCharIndex(
            _face: Packages.long,
            _charCode: number,
          ): number;
          private static getAscender(
            _face: Packages.long,
          ): number;
          public getAscender(): number;
          private static getDescender(
            _face: Packages.long,
          ): number;
          public getDescender(): number;
          private static doneFace(
            _face: Packages.long,
          ): void;
          private static getFaceFlags(
            _face: Packages.long,
          ): number;
          public getFaceFlags(): number;
          public getStyleFlags(): number;
          private static getStyleFlags(
            _face: Packages.long,
          ): number;
          public constructor(
            _address: Packages.long,
            _library: Packages.arc.freetype.FreeType.Library,
          );
        };
        private static Pointer = class extends java.lang
          .Object {
          address: Packages.long;
        };
        public static FT_PIXEL_MODE_NONE: number;
        public static FT_PIXEL_MODE_MONO: number;
        public static FT_PIXEL_MODE_GRAY: number;
        public static FT_PIXEL_MODE_GRAY2: number;
        public static FT_PIXEL_MODE_GRAY4: number;
        public static FT_PIXEL_MODE_LCD: number;
        public static FT_PIXEL_MODE_LCD_V: number;
        public static FT_ENCODING_NONE: number;
        public static FT_ENCODING_MS_SYMBOL: number;
        public static FT_ENCODING_UNICODE: number;
        public static FT_ENCODING_SJIS: number;
        public static FT_ENCODING_GB2312: number;
        public static FT_ENCODING_BIG5: number;
        public static FT_ENCODING_WANSUNG: number;
        public static FT_ENCODING_JOHAB: number;
        public static FT_ENCODING_ADOBE_STANDARD: number;
        public static FT_ENCODING_ADOBE_EXPERT: number;
        public static FT_ENCODING_ADOBE_CUSTOM: number;
        public static FT_ENCODING_ADOBE_LATIN_1: number;
        public static FT_ENCODING_OLD_LATIN_2: number;
        public static FT_ENCODING_APPLE_ROMAN: number;
        public static FT_FACE_FLAG_SCALABLE: number;
        public static FT_FACE_FLAG_FIXED_SIZES: number;
        public static FT_FACE_FLAG_FIXED_WIDTH: number;
        public static FT_FACE_FLAG_SFNT: number;
        public static FT_FACE_FLAG_HORIZONTAL: number;
        public static FT_FACE_FLAG_VERTICAL: number;
        public static FT_FACE_FLAG_KERNING: number;
        public static FT_FACE_FLAG_FAST_GLYPHS: number;
        public static FT_FACE_FLAG_MULTIPLE_MASTERS: number;
        public static FT_FACE_FLAG_GLYPH_NAMES: number;
        public static FT_FACE_FLAG_EXTERNAL_STREAM: number;
        public static FT_FACE_FLAG_HINTER: number;
        public static FT_FACE_FLAG_CID_KEYED: number;
        public static FT_FACE_FLAG_TRICKY: number;
        public static FT_STYLE_FLAG_ITALIC: number;
        public static FT_STYLE_FLAG_BOLD: number;
        public static FT_LOAD_DEFAULT: number;
        public static FT_LOAD_NO_SCALE: number;
        public static FT_LOAD_NO_HINTING: number;
        public static FT_LOAD_RENDER: number;
        public static FT_LOAD_NO_BITMAP: number;
        public static FT_LOAD_VERTICAL_LAYOUT: number;
        public static FT_LOAD_FORCE_AUTOHINT: number;
        public static FT_LOAD_CROP_BITMAP: number;
        public static FT_LOAD_PEDANTIC: number;
        public static FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH: number;
        public static FT_LOAD_NO_RECURSE: number;
        public static FT_LOAD_IGNORE_TRANSFORM: number;
        public static FT_LOAD_MONOCHROME: number;
        public static FT_LOAD_LINEAR_DESIGN: number;
        public static FT_LOAD_NO_AUTOHINT: number;
        public static FT_LOAD_TARGET_NORMAL: number;
        public static FT_LOAD_TARGET_LIGHT: number;
        public static FT_LOAD_TARGET_MONO: number;
        public static FT_LOAD_TARGET_LCD: number;
        public static FT_LOAD_TARGET_LCD_V: number;
        public static FT_RENDER_MODE_NORMAL: number;
        public static FT_RENDER_MODE_LIGHT: number;
        public static FT_RENDER_MODE_MONO: number;
        public static FT_RENDER_MODE_LCD: number;
        public static FT_RENDER_MODE_LCD_V: number;
        public static FT_RENDER_MODE_MAX: number;
        public static FT_KERNING_DEFAULT: number;
        public static FT_KERNING_UNFITTED: number;
        public static FT_KERNING_UNSCALED: number;
        public static FT_STROKER_LINECAP_BUTT: number;
        public static FT_STROKER_LINECAP_ROUND: number;
        public static FT_STROKER_LINECAP_SQUARE: number;
        public static FT_STROKER_LINEJOIN_ROUND: number;
        public static FT_STROKER_LINEJOIN_BEVEL: number;
        public static FT_STROKER_LINEJOIN_MITER_VARIABLE: number;
        public static FT_STROKER_LINEJOIN_MITER: number;
        public static FT_STROKER_LINEJOIN_MITER_FIXED: number;
        private static encode(
          _a: string,
          _b: string,
          _c: string,
          _d: string,
        ): number;
        private static initFreeTypeJni(): Packages.long;
        static getLastErrorCode(): number;
        public static initFreeType(): Packages.arc.freetype.FreeType.Library;
        public static toInt(_value: number): number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace g2d {
        declare class PixmapPacker
          extends java.lang.Object
          implements Packages.arc.util.Disposable
        {
          public static GuillotineStrategy = class
            extends java.lang.Object
            implements
              Packages.arc.graphics.g2d.PixmapPacker
                .PackStrategy
          {
            public static GuillotinePage = class extends Packages
              .arc.graphics.g2d.PixmapPacker.Page {
              root: Packages.arc.graphics.g2d.PixmapPacker.GuillotineStrategy.Node;
              public constructor(
                _packer: Packages.arc.graphics.g2d.PixmapPacker,
              );
              public constructor(
                _packer: Packages.arc.graphics.g2d.PixmapPacker,
                _base: Packages.arc.graphics.Pixmap,
              );
            };
            static Node = class extends java.lang.Object {
              public rect: Packages.arc.math.geom.Rect;
              public leftChild: Packages.arc.graphics.g2d.PixmapPacker.GuillotineStrategy.Node;
              public rightChild: Packages.arc.graphics.g2d.PixmapPacker.GuillotineStrategy.Node;
              public full: boolean;
            };
            private insert(
              _node: Packages.arc.graphics.g2d.PixmapPacker.GuillotineStrategy.Node,
              _rect: Packages.arc.math.geom.Rect,
            ): Packages.arc.graphics.g2d.PixmapPacker.GuillotineStrategy.Node;
            public sort(
              _pixmaps: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.PixmapRegion>,
            ): void;
            public pack(
              _packer: Packages.arc.graphics.g2d.PixmapPacker,
              _name: string,
              _rect: Packages.arc.math.geom.Rect,
            ): Packages.arc.graphics.g2d.PixmapPacker.Page;
            public constructor();
          };
          public static PackStrategy = class {
            public sort(
              _images: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.PixmapRegion>,
            ): void;
            public pack(
              _packer: Packages.arc.graphics.g2d.PixmapPacker,
              _name: string,
              _rect: Packages.arc.math.geom.Rect,
            ): Packages.arc.graphics.g2d.PixmapPacker.Page;
          };
          public static PixmapPackerRect = class extends Packages
            .arc.math.geom.Rect {
            public splits: number[];
            public pads: number[];
            offsetX: number;
            offsetY: number;
            originalWidth: number;
            originalHeight: number;
            public constructor(
              _x: number,
              _y: number,
              _width: number,
              _height: number,
            );
            public constructor(
              _x: number,
              _y: number,
              _width: number,
              _height: number,
              _left: number,
              _top: number,
              _originalWidth: number,
              _originalHeight: number,
            );
          };
          public static Page = class extends java.lang
            .Object {
            addedRects: Packages.arc.struct.Seq<string>;
            rects: Packages.arc.struct.OrderedMap<
              string,
              Packages.arc.graphics.g2d.PixmapPacker.PixmapPackerRect
            >;
            image: Packages.arc.graphics.Pixmap;
            texture: Packages.arc.graphics.Texture;
            dirty: boolean;
            public getPixmap(): Packages.arc.graphics.Pixmap;
            public getTexture(): Packages.arc.graphics.Texture;
            public setDirty(_dirty: boolean): void;
            public getRects(): Packages.arc.struct.OrderedMap<
              string,
              Packages.arc.graphics.g2d.PixmapPacker.PixmapPackerRect
            >;
            public updateTexture(
              _minFilter: Packages.arc.graphics.Texture.TextureFilter,
              _magFilter: Packages.arc.graphics.Texture.TextureFilter,
              _useMipMaps: boolean,
            ): boolean;
            public constructor(
              _packer: Packages.arc.graphics.g2d.PixmapPacker,
            );
            public constructor(
              _pixmap: Packages.arc.graphics.Pixmap,
            );
          };
          public static SkylineStrategy = class
            extends java.lang.Object
            implements
              Packages.arc.graphics.g2d.PixmapPacker
                .PackStrategy
          {
            static SkylinePage = class extends Packages.arc
              .graphics.g2d.PixmapPacker.Page {
              static Row = class extends java.lang.Object {
                x: number;
                y: number;
                height: number;
              };
              rows: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.PixmapPacker.SkylineStrategy.SkylinePage.Row>;
              public constructor(
                _packer: Packages.arc.graphics.g2d.PixmapPacker,
              );
            };
            public sort(
              _images: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.PixmapRegion>,
            ): void;
            public pack(
              _packer: Packages.arc.graphics.g2d.PixmapPacker,
              _name: string,
              _rect: Packages.arc.math.geom.Rect,
            ): Packages.arc.graphics.g2d.PixmapPacker.Page;
            public constructor();
          };
          pages: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.PixmapPacker.Page>;
          packToTexture: boolean;
          disposed: boolean;
          pageWidth: number;
          pageHeight: number;
          padding: number;
          duplicateBorder: boolean;
          stripWhitespaceX: boolean;
          stripWhitespaceY: boolean;
          transparentColor: Packages.arc.graphics.Color;
          packStrategy: Packages.arc.graphics.g2d.PixmapPacker.PackStrategy;
          public sort(
            _images: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.PixmapRegion>,
          ): void;
          public getRegion(
            _name: string,
          ): Packages.arc.graphics.g2d.PixmapRegion;
          public dispose(): void;
          public setPadding(_padding: number): void;
          public pack(
            _image: Packages.arc.graphics.Pixmap,
          ): Packages.arc.math.geom.Rect;
          public pack(
            _name: string,
            _image: Packages.arc.graphics.Pixmap,
          ): Packages.arc.math.geom.Rect;
          public pack(
            _name: string,
            _image: Packages.arc.graphics.g2d.PixmapRegion,
          ): Packages.arc.math.geom.Rect;
          public pack(
            _name: string,
            _width: number,
            _height: number,
          ): Packages.arc.math.geom.Rect;
          public pack(
            _name: string | null,
            _image: Packages.arc.graphics.g2d.PixmapRegion,
            _splits: number[],
            _pads: number[],
          ): Packages.arc.math.geom.Rect;
          public getPages(): Packages.arc.struct.Seq<Packages.arc.graphics.g2d.PixmapPacker.Page>;
          public updateTextureRegions(
            _regions: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.TextureRegion>,
            _minFilter: Packages.arc.graphics.Texture.TextureFilter,
            _magFilter: Packages.arc.graphics.Texture.TextureFilter,
            _useMipMaps: boolean,
          ): void;
          public setTransparentColor(
            _color: Packages.arc.graphics.Color,
          ): void;
          public getTransparentColor(): Packages.arc.graphics.Color;
          public setPackToTexture(
            _packToTexture: boolean,
          ): void;
          public getRect(
            _name: string,
          ): Packages.arc.math.geom.Rect;
          public getPage(
            _name: string,
          ): Packages.arc.graphics.g2d.PixmapPacker.Page;
          private getSplits(
            _raster: Packages.arc.graphics.g2d.PixmapRegion,
          ): number[] | null;
          private getPads(
            _raster: Packages.arc.graphics.g2d.PixmapRegion,
            _splits: number[],
          ): number[] | null;
          public updateTextureAtlas(
            _atlas: Packages.arc.graphics.g2d.TextureAtlas,
            _minFilter: Packages.arc.graphics.Texture.TextureFilter,
            _magFilter: Packages.arc.graphics.Texture.TextureFilter,
            _useMipMaps: boolean,
          ): void;
          public updateTextureAtlas(
            _atlas: Packages.arc.graphics.g2d.TextureAtlas,
            _minFilter: Packages.arc.graphics.Texture.TextureFilter,
            _magFilter: Packages.arc.graphics.Texture.TextureFilter,
            _useMipMaps: boolean,
            _clearRects: boolean,
          ): void;
          public updatePageTextures(
            _minFilter: Packages.arc.graphics.Texture.TextureFilter,
            _magFilter: Packages.arc.graphics.Texture.TextureFilter,
            _useMipMaps: boolean,
          ): void;
          private getSplitPoint(
            _raster: Packages.arc.graphics.g2d.PixmapRegion,
            _startX: number,
            _startY: number,
            _startPoint: boolean,
            _xAxis: boolean,
          ): number;
          public getPageIndex(_name: string): number;
          public forceDispose(): void;
          public generateTextureAtlas(
            _minFilter: Packages.arc.graphics.Texture.TextureFilter,
            _magFilter: Packages.arc.graphics.Texture.TextureFilter,
            _useMipMaps: boolean,
          ): Packages.arc.graphics.g2d.TextureAtlas;
          public getPageWidth(): number;
          public setPageWidth(_pageWidth: number): void;
          public getPageHeight(): number;
          public setPageHeight(_pageHeight: number): void;
          public getPadding(): number;
          public getDuplicateBorder(): boolean;
          public setDuplicateBorder(
            _duplicateBorder: boolean,
          ): void;
          public getPackToTexture(): boolean;
          public constructor(
            _pageWidth: number,
            _pageHeight: number,
            _padding: number,
            _duplicateBorder: boolean,
            _stripWhitespaceX: boolean,
            _stripWhitespaceY: boolean,
            _packStrategy: Packages.arc.graphics.g2d.PixmapPacker.PackStrategy,
          );
          public constructor(
            _pageWidth: number,
            _pageHeight: number,
            _padding: number,
            _duplicateBorder: boolean,
            _packStrategy: Packages.arc.graphics.g2d.PixmapPacker.PackStrategy,
          );
          public constructor(
            _pageWidth: number,
            _pageHeight: number,
            _padding: number,
            _duplicateBorder: boolean,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace freetype {
      declare class FreeTypeFontGenerator
        extends java.lang.Object
        implements Packages.arc.util.Disposable
      {
        public static FreeTypeFontParameter = class extends java
          .lang.Object {
          public size: number;
          public mono: boolean;
          public hinting: Packages.arc.freetype.FreeTypeFontGenerator.Hinting;
          public color: Packages.arc.graphics.Color;
          public gamma: number;
          public renderCount: number;
          public borderWidth: number;
          public borderColor: Packages.arc.graphics.Color;
          public borderStraight: boolean;
          public borderGamma: number;
          public shadowOffsetX: number;
          public shadowOffsetY: number;
          public shadowColor: Packages.arc.graphics.Color;
          public spaceX: number;
          public spaceY: number;
          public padTop: number;
          public padLeft: number;
          public padBottom: number;
          public padRight: number;
          public characters: string;
          public kerning: boolean;
          public packer: Packages.arc.graphics.g2d.PixmapPacker;
          public flip: boolean;
          public genMipMaps: boolean;
          public minFilter: Packages.arc.graphics.Texture.TextureFilter;
          public magFilter: Packages.arc.graphics.Texture.TextureFilter;
          public incremental: boolean;
          public constructor();
        };
        public static Hinting = class extends Packages.java
          .lang
          .Enum<Packages.arc.freetype.FreeTypeFontGenerator.Hinting> {
          public static none: Packages.arc.freetype.FreeTypeFontGenerator.Hinting;
          public static slight: Packages.arc.freetype.FreeTypeFontGenerator.Hinting;
          public static medium: Packages.arc.freetype.FreeTypeFontGenerator.Hinting;
          public static full: Packages.arc.freetype.FreeTypeFontGenerator.Hinting;
          public static autoSlight: Packages.arc.freetype.FreeTypeFontGenerator.Hinting;
          public static autoMedium: Packages.arc.freetype.FreeTypeFontGenerator.Hinting;
          public static autoFull: Packages.arc.freetype.FreeTypeFontGenerator.Hinting;
          private static $VALUES: Packages.arc.freetype.FreeTypeFontGenerator.Hinting[];
          public static values():
            | Packages.arc.freetype.FreeTypeFontGenerator.Hinting[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.arc.freetype.FreeTypeFontGenerator.Hinting;
        };
        public static FreeTypeFontData = class
          extends Packages.arc.graphics.g2d.Font.FontData
          implements Packages.arc.util.Disposable
        {
          public static ignoreDirty: boolean;
          regions: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.TextureRegion>;
          generator: Packages.arc.freetype.FreeTypeFontGenerator;
          parameter: Packages.arc.freetype.FreeTypeFontGenerator.FreeTypeFontParameter;
          stroker: Packages.arc.freetype.FreeType.Stroker;
          packer: Packages.arc.graphics.g2d.PixmapPacker;
          glyphs: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.Font.Glyph>;
          private dirty: boolean;
          public dispose(): void;
          public getGlyphs(
            _run: Packages.arc.graphics.g2d.GlyphLayout.GlyphRun,
            _str: Packages.java.lang.CharSequence,
            _start: number,
            _end: number,
            _lastGlyph: Packages.arc.graphics.g2d.Font.Glyph,
          ): void;
          public getGlyph(
            _ch: string,
          ): Packages.arc.graphics.g2d.Font.Glyph;
          public constructor();
        };
        public GlyphAndBitmap = class extends java.lang
          .Object {
          public glyph: Packages.arc.graphics.g2d.Font.Glyph;
          public bitmap: Packages.arc.freetype.FreeType.Bitmap;
          this$0: Packages.arc.freetype.FreeTypeFontGenerator;
          public constructor(
            _this$0: Packages.arc.freetype.FreeTypeFontGenerator,
          );
        };
        public static DEFAULT_CHARS: string;
        public static NO_MAXIMUM: number;
        private static maxTextureSize: number;
        library: Packages.arc.freetype.FreeType.Library;
        face: Packages.arc.freetype.FreeType.Face;
        name: string;
        bitmapped: boolean;
        public dispose(): void;
        setPixelSizes(
          _pixelWidth: number,
          _pixelHeight: number,
        ): void;
        private loadChar(
          _c: number,
          _flags: number,
        ): boolean;
        private loadChar(_c: number): boolean;
        private checkForBitmapFont(): boolean;
        public generateFont(
          _parameter: Packages.arc.freetype.FreeTypeFontGenerator.FreeTypeFontParameter,
          _data: Packages.arc.freetype.FreeTypeFontGenerator.FreeTypeFontData,
        ): Packages.arc.graphics.g2d.Font;
        public generateFont(
          _parameter: Packages.arc.freetype.FreeTypeFontGenerator.FreeTypeFontParameter,
        ): Packages.arc.graphics.g2d.Font;
        public generateData(
          _parameter: Packages.arc.freetype.FreeTypeFontGenerator.FreeTypeFontParameter,
          _data: Packages.arc.freetype.FreeTypeFontGenerator.FreeTypeFontData,
        ): Packages.arc.freetype.FreeTypeFontGenerator.FreeTypeFontData;
        public generateData(
          _size: number,
        ): Packages.arc.freetype.FreeTypeFontGenerator.FreeTypeFontData;
        public generateData(
          _parameter: Packages.arc.freetype.FreeTypeFontGenerator.FreeTypeFontParameter,
        ): Packages.arc.freetype.FreeTypeFontGenerator.FreeTypeFontData;
        public scaleForPixelHeight(_height: number): number;
        public scaleForPixelWidth(
          _width: number,
          _numChars: number,
        ): number;
        private getLoadingFlags(
          _parameter: Packages.arc.freetype.FreeTypeFontGenerator.FreeTypeFontParameter,
        ): number;
        createGlyph(
          _c: string,
          _data: Packages.arc.freetype.FreeTypeFontGenerator.FreeTypeFontData,
          _parameter: Packages.arc.freetype.FreeTypeFontGenerator.FreeTypeFontParameter,
          _stroker: Packages.arc.freetype.FreeType.Stroker,
          _baseLine: number,
          _packer: Packages.arc.graphics.g2d.PixmapPacker,
        ): Packages.arc.graphics.g2d.Font.Glyph;
        public static getMaxTextureSize(): number;
        public static setMaxTextureSize(
          _texSize: number,
        ): void;
        public scaleToFitSquare(
          _width: number,
          _height: number,
          _numChars: number,
        ): number;
        public generateGlyphAndBitmap(
          _c: number,
          _size: number,
          _flip: boolean,
        ): Packages.arc.freetype.FreeTypeFontGenerator.GlyphAndBitmap;
        public constructor(
          _fontFile: Packages.arc.files.Fi,
        );
        public constructor(
          _fontFile: Packages.arc.files.Fi,
          _faceIndex: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace assets {
      declare namespace loaders {
        declare abstract class SynchronousAssetLoader<
          T,
          P extends
            Packages.arc.assets.AssetLoaderParameters<T>,
        > extends Packages.arc.assets.loaders.AssetLoader<
          T,
          P
        > {
          public load(
            _assetManager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: P,
          ): T | null;
          public constructor(
            _resolver: Packages.arc.assets.loaders.FileHandleResolver,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace freetype {
      declare class FreeTypeFontGeneratorLoader extends Packages
        .arc.assets.loaders.SynchronousAssetLoader<
        Packages.arc.freetype.FreeTypeFontGenerator,
        Packages.arc.freetype.FreeTypeFontGeneratorLoader.FreeTypeFontGeneratorParameters
      > {
        public static FreeTypeFontGeneratorParameters = class extends Packages
          .arc.assets
          .AssetLoaderParameters<Packages.arc.freetype.FreeTypeFontGenerator> {
          public constructor();
        };
        public load(
          _assetManager: Packages.arc.assets.AssetManager,
          _fileName: string,
          _file: Packages.arc.files.Fi,
          _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
        ): any;
        public load(
          _assetManager: Packages.arc.assets.AssetManager,
          _fileName: string,
          _file: Packages.arc.files.Fi,
          _parameter: Packages.arc.freetype.FreeTypeFontGeneratorLoader.FreeTypeFontGeneratorParameters,
        ): Packages.arc.freetype.FreeTypeFontGenerator;
        public getDependencies(
          _fileName: string,
          _file: Packages.arc.files.Fi,
          _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
        ): Packages.arc.struct.Seq<any>;
        public getDependencies(
          _fileName: string,
          _file: Packages.arc.files.Fi,
          _parameter: Packages.arc.freetype.FreeTypeFontGeneratorLoader.FreeTypeFontGeneratorParameters,
        ): Packages.arc.struct.Seq<
          Packages.arc.assets.AssetDescriptor<any>
        >;
        public constructor(
          _resolver: Packages.arc.assets.loaders.FileHandleResolver,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace assets {
      declare namespace loaders {
        declare abstract class AsynchronousAssetLoader<
          T,
          P extends
            Packages.arc.assets.AssetLoaderParameters<T>,
        > extends Packages.arc.assets.loaders.AssetLoader<
          T,
          P
        > {
          public loadSync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: P,
          ): T | null;
          public loadAsync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: P,
          ): void;
          public constructor(
            _resolver: Packages.arc.assets.loaders.FileHandleResolver,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace freetype {
      declare class FreetypeFontLoader extends Packages.arc
        .assets.loaders.AsynchronousAssetLoader<
        Packages.arc.graphics.g2d.Font,
        Packages.arc.freetype.FreetypeFontLoader.FreeTypeFontLoaderParameter
      > {
        public static FreeTypeFontLoaderParameter = class extends Packages
          .arc.assets
          .AssetLoaderParameters<Packages.arc.graphics.g2d.Font> {
          public fontFileName: string;
          public fontParameters: Packages.arc.freetype.FreeTypeFontGenerator.FreeTypeFontParameter;
          public constructor();
          public constructor(
            _fontFileName: string,
            _fontParameters: Packages.arc.freetype.FreeTypeFontGenerator.FreeTypeFontParameter,
          );
        };
        public getDependencies(
          _fileName: string,
          _file: Packages.arc.files.Fi,
          _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
        ): Packages.arc.struct.Seq<any>;
        public getDependencies(
          _fileName: string,
          _file: Packages.arc.files.Fi,
          _parameter: Packages.arc.freetype.FreetypeFontLoader.FreeTypeFontLoaderParameter,
        ): Packages.arc.struct.Seq<
          Packages.arc.assets.AssetDescriptor<any>
        >;
        public loadSync(
          _manager: Packages.arc.assets.AssetManager,
          _fileName: string,
          _file: Packages.arc.files.Fi,
          _parameter: Packages.arc.freetype.FreetypeFontLoader.FreeTypeFontLoaderParameter,
        ): Packages.arc.graphics.g2d.Font;
        public loadSync(
          _manager: Packages.arc.assets.AssetManager,
          _fileName: string,
          _file: Packages.arc.files.Fi,
          _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
        ): any;
        public loadAsync(
          _manager: Packages.arc.assets.AssetManager,
          _fileName: string,
          _file: Packages.arc.files.Fi,
          _parameter: Packages.arc.freetype.FreetypeFontLoader.FreeTypeFontLoaderParameter,
        ): void;
        public loadAsync(
          _manager: Packages.arc.assets.AssetManager,
          _fileName: string,
          _file: Packages.arc.files.Fi,
          _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
        ): void;
        public constructor(
          _resolver: Packages.arc.assets.loaders.FileHandleResolver,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class Boolf2<A, B> {
        public get(_a: A, _b: B): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class Boolf3<P1, P2, P3> {
        public get(_a: P1, _b: P2, _c: P3): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class Cons3<P1, P2, P3> {
        public get(
          _param1: P1,
          _param2: P2,
          _param3: P3,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class Cons4<P1, P2, P3, P4> {
        public get(
          _param1: P1,
          _param2: P2,
          _param3: P3,
          _param4: P4,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class ConsT<
        T,
        E extends Packages.java.lang.Throwable,
      > {
        public get(_t: T): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class FloatFloatf {
        public get(_f: number): number;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class Floatc4 {
        public get(
          _x: number,
          _y: number,
          _x2: number,
          _y2: number,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class Floatp {
        public get(): number;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class Func3<P1, P2, P3, R> {
        public get(
          _param1: P1,
          _param2: P2,
          _param3: P3,
        ): R | null;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class Intc4 {
        public get(
          _x: number,
          _y: number,
          _x2: number,
          _y2: number,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class Intp {
        public get(): number;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace func {
      declare abstract class Longf<T> {
        public get(_t: T): Packages.long;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare abstract class CubemapData {
        public prepare(): void;
        public getWidth(): number;
        public getHeight(): number;
        public isPrepared(): boolean;
        public consumeCubemapData(): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare class Cubemap extends Packages.arc.graphics
        .GLTexture {
        public static CubemapSide = class extends Packages
          .java.lang
          .Enum<Packages.arc.graphics.Cubemap.CubemapSide> {
          public static positiveX: Packages.arc.graphics.Cubemap.CubemapSide;
          public static negativeX: Packages.arc.graphics.Cubemap.CubemapSide;
          public static positiveY: Packages.arc.graphics.Cubemap.CubemapSide;
          public static negativeY: Packages.arc.graphics.Cubemap.CubemapSide;
          public static positiveZ: Packages.arc.graphics.Cubemap.CubemapSide;
          public static negativeZ: Packages.arc.graphics.Cubemap.CubemapSide;
          public index: number;
          public glEnum: number;
          public up: Packages.arc.math.geom.Vec3;
          public direction: Packages.arc.math.geom.Vec3;
          private static $VALUES: Packages.arc.graphics.Cubemap.CubemapSide[];
          public static values():
            | Packages.arc.graphics.Cubemap.CubemapSide[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.arc.graphics.Cubemap.CubemapSide;
          public getGLEnum(): number;
          public getUp(
            _out: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public getDirection(
            _out: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
        };
        protected data: Packages.arc.graphics.CubemapData;
        public load(
          _data: Packages.arc.graphics.CubemapData,
        ): void;
        public getDepth(): number;
        public getCubemapData(): Packages.arc.graphics.CubemapData;
        public constructor(
          _positiveX: Packages.arc.graphics.Pixmap,
          _negativeX: Packages.arc.graphics.Pixmap,
          _positiveY: Packages.arc.graphics.Pixmap,
          _negativeY: Packages.arc.graphics.Pixmap,
          _positiveZ: Packages.arc.graphics.Pixmap,
          _negativeZ: Packages.arc.graphics.Pixmap,
        );
        public constructor(
          _positiveX: Packages.arc.graphics.Pixmap,
          _negativeX: Packages.arc.graphics.Pixmap,
          _positiveY: Packages.arc.graphics.Pixmap,
          _negativeY: Packages.arc.graphics.Pixmap,
          _positiveZ: Packages.arc.graphics.Pixmap,
          _negativeZ: Packages.arc.graphics.Pixmap,
          _useMipMaps: boolean,
        );
        public constructor(
          _width: number,
          _height: number,
          _depth: number,
        );
        public constructor(
          _positiveX: Packages.arc.graphics.TextureData,
          _negativeX: Packages.arc.graphics.TextureData,
          _positiveY: Packages.arc.graphics.TextureData,
          _negativeY: Packages.arc.graphics.TextureData,
          _positiveZ: Packages.arc.graphics.TextureData,
          _negativeZ: Packages.arc.graphics.TextureData,
        );
        public constructor(
          _data: Packages.arc.graphics.CubemapData,
        );
        public constructor(_base: string);
        public constructor(
          _positiveX: Packages.arc.files.Fi,
          _negativeX: Packages.arc.files.Fi,
          _positiveY: Packages.arc.files.Fi,
          _negativeY: Packages.arc.files.Fi,
          _positiveZ: Packages.arc.files.Fi,
          _negativeZ: Packages.arc.files.Fi,
        );
        public constructor(
          _positiveX: Packages.arc.files.Fi,
          _negativeX: Packages.arc.files.Fi,
          _positiveY: Packages.arc.files.Fi,
          _negativeY: Packages.arc.files.Fi,
          _positiveZ: Packages.arc.files.Fi,
          _negativeZ: Packages.arc.files.Fi,
          _useMipMaps: boolean,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace gl {
        declare class FrameBufferCubemap extends Packages
          .arc.graphics.gl
          .GLFrameBuffer<Packages.arc.graphics.Cubemap> {
          private static cubemapSides: Packages.arc.graphics.Cubemap.CubemapSide[];
          private currentSide: number;
          public bind(): void;
          protected attachFrameBufferColorTexture(
            _texture: Packages.arc.graphics.GLTexture,
          ): void;
          protected attachFrameBufferColorTexture(
            _texture: Packages.arc.graphics.Cubemap,
          ): void;
          protected disposeColorTexture(
            _colorTexture: Packages.arc.graphics.Cubemap,
          ): void;
          protected disposeColorTexture(
            _colorTexture: Packages.arc.graphics.GLTexture,
          ): void;
          protected createTexture(
            _attachmentSpec: Packages.arc.graphics.gl.GLFrameBuffer.FrameBufferTextureAttachmentSpec,
          ): Packages.arc.graphics.Cubemap;
          protected createTexture(
            _attachmentSpec: Packages.arc.graphics.gl.GLFrameBuffer.FrameBufferTextureAttachmentSpec,
          ): Packages.arc.graphics.GLTexture;
          public getSide(): Packages.arc.graphics.Cubemap.CubemapSide;
          protected bindSide(
            _side: Packages.arc.graphics.Cubemap.CubemapSide,
          ): void;
          public nextSide(): boolean;
          public constructor(
            _format: Packages.arc.graphics.Pixmap.Format,
            _width: number,
            _height: number,
            _hasDepth: boolean,
            _hasStencil: boolean,
          );
          public constructor(
            _format: Packages.arc.graphics.Pixmap.Format,
            _width: number,
            _height: number,
            _hasDepth: boolean,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace gl {
        declare class FloatFrameBuffer extends Packages.arc
          .graphics.gl.FrameBuffer {
          protected create(
            _format: Packages.arc.graphics.Pixmap.Format,
            _width: number,
            _height: number,
            _hasDepth: boolean,
            _hasStencil: boolean,
          ): void;
          public resize(
            _width: number,
            _height: number,
          ): void;
          protected createTexture(
            _attachmentSpec: Packages.arc.graphics.gl.GLFrameBuffer.FrameBufferTextureAttachmentSpec,
          ): Packages.arc.graphics.Texture;
          protected createTexture(
            _attachmentSpec: Packages.arc.graphics.gl.GLFrameBuffer.FrameBufferTextureAttachmentSpec,
          ): Packages.arc.graphics.GLTexture;
          public constructor(
            _width: number,
            _height: number,
            _hasDepth: boolean,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace gl {
        declare abstract class GLFrameBuffer<
            T extends Packages.arc.graphics.GLTexture,
          >
          extends java.lang.Object
          implements Packages.arc.util.Disposable
        {
          protected static GLFrameBufferBuilder = class<
            U extends
              Packages.arc.graphics.gl.GLFrameBuffer<any>,
          > extends java.lang.Object {
            protected width: number;
            protected height: number;
            protected textureAttachmentSpecs: Packages.arc.struct.Seq<Packages.arc.graphics.gl.GLFrameBuffer.FrameBufferTextureAttachmentSpec>;
            protected stencilRenderBufferSpec: Packages.arc.graphics.gl.GLFrameBuffer.FrameBufferRenderBufferAttachmentSpec;
            protected depthRenderBufferSpec: Packages.arc.graphics.gl.GLFrameBuffer.FrameBufferRenderBufferAttachmentSpec;
            protected packedStencilDepthRenderBufferSpec: Packages.arc.graphics.gl.GLFrameBuffer.FrameBufferRenderBufferAttachmentSpec;
            protected hasStencilRenderBuffer: boolean;
            protected hasDepthRenderBuffer: boolean;
            protected hasPackedStencilDepthRenderBuffer: boolean;
            public build(): U | null;
            public addBasicColorTextureAttachment(
              _format: Packages.arc.graphics.Pixmap.Format,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<U>;
            public addBasicDepthRenderBuffer(): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<U>;
            public addBasicStencilRenderBuffer(): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<U>;
            public addColorTextureAttachment(
              _internalFormat: number,
              _format: number,
              _type: number,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<U>;
            public addDepthRenderBuffer(
              _internalFormat: number,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<U>;
            public addStencilRenderBuffer(
              _internalFormat: number,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<U>;
            public addStencilDepthPackedRenderBuffer(
              _internalFormat: number,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<U>;
            public addFloatAttachment(
              _internalFormat: number,
              _format: number,
              _type: number,
              _gpuOnly: boolean,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<U>;
            public addDepthTextureAttachment(
              _internalFormat: number,
              _type: number,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<U>;
            public addStencilTextureAttachment(
              _internalFormat: number,
              _type: number,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<U>;
            public addBasicStencilDepthPackedRenderBuffer(): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<U>;
            public constructor(
              _width: number,
              _height: number,
            );
          };
          protected static FrameBufferRenderBufferAttachmentSpec = class extends java
            .lang.Object {
            internalFormat: number;
            public constructor(_internalFormat: number);
          };
          protected static FrameBufferTextureAttachmentSpec = class extends java
            .lang.Object {
            internalFormat: number;
            format: number;
            type: number;
            isFloat: boolean;
            isGpuOnly: boolean;
            isDepth: boolean;
            isStencil: boolean;
            public isColorTexture(): boolean;
            public constructor(
              _internalformat: number,
              _format: number,
              _type: number,
            );
          };
          public static FrameBufferCubemapBuilder = class extends Packages
            .arc.graphics.gl.GLFrameBuffer
            .GLFrameBufferBuilder<Packages.arc.graphics.gl.FrameBufferCubemap> {
            public build(): Packages.arc.graphics.gl.GLFrameBuffer<any>;
            public build(): Packages.arc.graphics.gl.FrameBufferCubemap;
            public addBasicColorTextureAttachment(
              _format: Packages.arc.graphics.Pixmap.Format,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addBasicDepthRenderBuffer(): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addBasicStencilRenderBuffer(): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addColorTextureAttachment(
              _internalFormat: number,
              _format: number,
              _type: number,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addDepthRenderBuffer(
              _internalFormat: number,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addStencilRenderBuffer(
              _internalFormat: number,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addStencilDepthPackedRenderBuffer(
              _internalFormat: number,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addFloatAttachment(
              _internalFormat: number,
              _format: number,
              _type: number,
              _gpuOnly: boolean,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addDepthTextureAttachment(
              _internalFormat: number,
              _type: number,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addStencilTextureAttachment(
              _internalFormat: number,
              _type: number,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addBasicStencilDepthPackedRenderBuffer(): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public constructor(
              _width: number,
              _height: number,
            );
          };
          public static FloatFrameBufferBuilder = class extends Packages
            .arc.graphics.gl.GLFrameBuffer
            .GLFrameBufferBuilder<Packages.arc.graphics.gl.FloatFrameBuffer> {
            public build(): Packages.arc.graphics.gl.GLFrameBuffer<any>;
            public build(): Packages.arc.graphics.gl.FloatFrameBuffer;
            public addBasicColorTextureAttachment(
              _format: Packages.arc.graphics.Pixmap.Format,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addBasicDepthRenderBuffer(): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addBasicStencilRenderBuffer(): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addColorTextureAttachment(
              _internalFormat: number,
              _format: number,
              _type: number,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addDepthRenderBuffer(
              _internalFormat: number,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addStencilRenderBuffer(
              _internalFormat: number,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addStencilDepthPackedRenderBuffer(
              _internalFormat: number,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addFloatAttachment(
              _internalFormat: number,
              _format: number,
              _type: number,
              _gpuOnly: boolean,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addDepthTextureAttachment(
              _internalFormat: number,
              _type: number,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addStencilTextureAttachment(
              _internalFormat: number,
              _type: number,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addBasicStencilDepthPackedRenderBuffer(): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public constructor(
              _width: number,
              _height: number,
            );
          };
          public static FrameBufferBuilder = class extends Packages
            .arc.graphics.gl.GLFrameBuffer
            .GLFrameBufferBuilder<Packages.arc.graphics.gl.FrameBuffer> {
            public build(): Packages.arc.graphics.gl.GLFrameBuffer<any>;
            public build(): Packages.arc.graphics.gl.FrameBuffer;
            public addBasicColorTextureAttachment(
              _format: Packages.arc.graphics.Pixmap.Format,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addBasicDepthRenderBuffer(): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addBasicStencilRenderBuffer(): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addColorTextureAttachment(
              _internalFormat: number,
              _format: number,
              _type: number,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addDepthRenderBuffer(
              _internalFormat: number,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addStencilRenderBuffer(
              _internalFormat: number,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addStencilDepthPackedRenderBuffer(
              _internalFormat: number,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addFloatAttachment(
              _internalFormat: number,
              _format: number,
              _type: number,
              _gpuOnly: boolean,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addDepthTextureAttachment(
              _internalFormat: number,
              _type: number,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addStencilTextureAttachment(
              _internalFormat: number,
              _type: number,
            ): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public addBasicStencilDepthPackedRenderBuffer(): Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
            public constructor(
              _width: number,
              _height: number,
            );
          };
          protected static GL_DEPTH24_STENCIL8_OES: number;
          protected static currentBoundFramebuffer: Packages.arc.graphics.gl.GLFrameBuffer<any>;
          protected static defaultFramebufferHandle: number;
          protected static bufferNesting: number;
          protected static defaultFramebufferHandleInitialized: boolean;
          protected textureAttachments: Packages.arc.struct.Seq<T>;
          protected lastBoundFramebuffer: Packages.arc.graphics.gl.GLFrameBuffer<any>;
          protected framebufferHandle: number;
          protected depthbufferHandle: number;
          protected stencilbufferHandle: number;
          protected depthStencilPackedBufferHandle: number;
          protected hasDepthStencilPackedBuffer: boolean;
          protected isMRT: boolean;
          protected bufferBuilder: Packages.arc.graphics.gl.GLFrameBuffer.GLFrameBufferBuilder<any>;
          public end(): void;
          public begin(): void;
          public begin(
            _clearColor: Packages.arc.graphics.Color,
          ): void;
          public bind(): void;
          protected build(): void;
          public dispose(): void;
          public getWidth(): number;
          public getHeight(): number;
          public getTexture(): T | null;
          public static unbind(): void;
          protected attachFrameBufferColorTexture(
            _texture: T,
          ): void;
          protected disposeColorTexture(
            _colorTexture: T,
          ): void;
          protected createTexture(
            _attachmentSpec: Packages.arc.graphics.gl.GLFrameBuffer.FrameBufferTextureAttachmentSpec,
          ): T | null;
          public isBound(): boolean;
          private checkValidBuilder(): void;
          public beginBind(): void;
          protected setFrameBufferViewport(): void;
          public static getBufferNesting(): number;
          public getTextureAttachments(): Packages.arc.struct.Seq<T>;
          public endBind(): void;
          public getFramebufferHandle(): number;
          public getDepthBufferHandle(): number;
          public getStencilBufferHandle(): number;
          protected getDepthStencilPackedBuffer(): number;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace gl {
        declare class FrameBuffer extends Packages.arc
          .graphics.gl
          .GLFrameBuffer<Packages.arc.graphics.Texture> {
          private format: Packages.arc.graphics.Pixmap.Format;
          protected create(
            _format: Packages.arc.graphics.Pixmap.Format,
            _width: number,
            _height: number,
            _hasDepth: boolean,
            _hasStencil: boolean,
          ): void;
          public resize(
            _width: number,
            _height: number,
          ): void;
          public static unbind(): void;
          protected attachFrameBufferColorTexture(
            _texture: Packages.arc.graphics.GLTexture,
          ): void;
          protected attachFrameBufferColorTexture(
            _texture: Packages.arc.graphics.Texture,
          ): void;
          protected disposeColorTexture(
            _colorTexture: Packages.arc.graphics.Texture,
          ): void;
          protected disposeColorTexture(
            _colorTexture: Packages.arc.graphics.GLTexture,
          ): void;
          protected createTexture(
            _attachmentSpec: Packages.arc.graphics.gl.GLFrameBuffer.FrameBufferTextureAttachmentSpec,
          ): Packages.arc.graphics.Texture;
          protected createTexture(
            _attachmentSpec: Packages.arc.graphics.gl.GLFrameBuffer.FrameBufferTextureAttachmentSpec,
          ): Packages.arc.graphics.GLTexture;
          public resizeCheck(
            _width: number,
            _height: number,
          ): boolean;
          public blit(
            _shader: Packages.arc.graphics.gl.Shader,
          ): void;
          public constructor(
            _format: Packages.arc.graphics.Pixmap.Format,
            _width: number,
            _height: number,
          );
          public constructor(
            _format: Packages.arc.graphics.Pixmap.Format,
            _width: number,
            _height: number,
            _hasDepth: boolean,
          );
          public constructor(
            _width: number,
            _height: number,
            _hasDepth: boolean,
          );
          public constructor(
            _format: Packages.arc.graphics.Pixmap.Format,
            _width: number,
            _height: number,
            _hasDepth: boolean,
            _hasStencil: boolean,
          );
          public constructor();
          public constructor(
            _width: number,
            _height: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare abstract class FxFilter
        extends java.lang.Object
        implements Packages.arc.util.Disposable
      {
        protected static u_texture0: number;
        protected static u_texture1: number;
        protected static u_texture2: number;
        protected static u_texture3: number;
        protected shader: Packages.arc.graphics.gl.Shader;
        protected inputTexture: Packages.arc.graphics.Texture;
        protected outputBuffer: Packages.arc.graphics.gl.FrameBuffer;
        protected disabled: boolean;
        protected autobind: boolean;
        public time: number;
        public update(): void;
        public rebind(): void;
        public resize(
          _width: number,
          _height: number,
        ): void;
        public dispose(): void;
        public setInput(
          _input: Packages.arc.graphics.gl.FrameBuffer,
        ): Packages.arc.fx.FxFilter;
        public setInput(
          _input: Packages.arc.graphics.Texture,
        ): Packages.arc.fx.FxFilter;
        public static compileShader(
          _vertexFile: Packages.arc.files.Fi,
          _fragmentFile: Packages.arc.files.Fi,
          _defines: string,
        ): Packages.arc.graphics.gl.Shader;
        public static compileShader(
          _vertexFile: Packages.arc.files.Fi,
          _fragmentFile: Packages.arc.files.Fi,
        ): Packages.arc.graphics.gl.Shader;
        public isDisabled(): boolean;
        public setDisabled(_enabled: boolean): void;
        protected setParams(): void;
        protected onBeforeRender(): void;
        public setOutput(
          _output: Packages.arc.graphics.gl.FrameBuffer,
        ): Packages.arc.fx.FxFilter;
        public render(): void;
        public render(
          _src: Packages.arc.graphics.gl.FrameBuffer,
          _dst: Packages.arc.graphics.gl.FrameBuffer,
        ): void;
        public constructor(
          _shader: Packages.arc.graphics.gl.Shader,
        );
        public constructor(_vert: string, _frag: string);
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace util {
        declare class FxBufferRenderer
          extends java.lang.Object
          implements Packages.arc.util.Disposable
        {
          private shader: Packages.arc.graphics.gl.Shader;
          public rebind(): void;
          public dispose(): void;
          public renderToScreen(
            _input: Packages.arc.graphics.gl.FrameBuffer,
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          ): void;
          public renderToScreen(
            _input: Packages.arc.graphics.gl.FrameBuffer,
          ): void;
          public renderToFbo(
            _input: Packages.arc.graphics.gl.FrameBuffer,
            _output: Packages.arc.graphics.gl.FrameBuffer,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace util {
        declare class PingPongBuffer extends java.lang
          .Object {
          private buffer1: Packages.arc.graphics.gl.FrameBuffer;
          private buffer2: Packages.arc.graphics.gl.FrameBuffer;
          private bufDst: Packages.arc.graphics.gl.FrameBuffer;
          private bufSrc: Packages.arc.graphics.gl.FrameBuffer;
          private writeState: boolean;
          private capturing: boolean;
          private wrapU: Packages.arc.graphics.Texture.TextureWrap;
          private wrapV: Packages.arc.graphics.Texture.TextureWrap;
          private filterMin: Packages.arc.graphics.Texture.TextureFilter;
          private filterMag: Packages.arc.graphics.Texture.TextureFilter;
          public clear(
            _clearColor: Packages.arc.graphics.Color,
          ): void;
          public clear(
            _r: number,
            _g: number,
            _b: number,
            _a: number,
          ): void;
          public end(): void;
          public begin(): void;
          public rebind(): void;
          public resize(
            _width: number,
            _height: number,
          ): void;
          public swap(): void;
          public dispose(): void;
          public getDstBuffer(): Packages.arc.graphics.gl.FrameBuffer;
          public getSrcBuffer(): Packages.arc.graphics.gl.FrameBuffer;
          public setTextureParams(
            _u: Packages.arc.graphics.Texture.TextureWrap,
            _v: Packages.arc.graphics.Texture.TextureWrap,
            _min: Packages.arc.graphics.Texture.TextureFilter,
            _mag: Packages.arc.graphics.Texture.TextureFilter,
          ): void;
          public getSrcTexture(): Packages.arc.graphics.Texture;
          public getDstTexture(): Packages.arc.graphics.Texture;
          public constructor(
            _fbFormat: Packages.arc.graphics.Pixmap.Format,
            _width: number,
            _height: number,
            _depth: boolean,
            _stencil: boolean,
          );
          public constructor(
            _fbFormat: Packages.arc.graphics.Pixmap.Format,
            _width: number,
            _height: number,
          );
          public constructor(
            _fbFormat: Packages.arc.graphics.Pixmap.Format,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare class FxProcessor
        extends java.lang.Object
        implements Packages.arc.util.Disposable
      {
        private priorities: Packages.arc.struct.ObjectIntMap<Packages.arc.fx.FxFilter>;
        private effectsAll: Packages.arc.struct.Seq<Packages.arc.fx.FxFilter>;
        private effectsEnabled: Packages.arc.struct.Seq<Packages.arc.fx.FxFilter>;
        private bufferRenderer: Packages.arc.fx.util.FxBufferRenderer;
        private fboFormat: Packages.arc.graphics.Pixmap.Format;
        private pingPongBuffer: Packages.arc.fx.util.PingPongBuffer;
        private disabled: boolean;
        private capturing: boolean;
        private hasCaptured: boolean;
        private applyingEffects: boolean;
        private blendingEnabled: boolean;
        private width: number;
        private height: number;
        public clear(): void;
        public clear(
          _color: Packages.arc.graphics.Color,
        ): void;
        public end(): boolean;
        public begin(): boolean;
        public rebind(): void;
        public resize(
          _width: number,
          _height: number,
        ): void;
        public dispose(): void;
        public getWidth(): number;
        public getHeight(): number;
        public isDisabled(): boolean;
        public setDisabled(_disabled: boolean): void;
        public render(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
        ): void;
        public render(
          _output: Packages.arc.graphics.gl.FrameBuffer,
        ): void;
        public render(): void;
        public addEffect(
          _effect: Packages.arc.fx.FxFilter,
        ): void;
        public addEffect(
          _effect: Packages.arc.fx.FxFilter,
          _priority: number,
        ): void;
        public isBlendingEnabled(): boolean;
        public setBlendingEnabled(
          _blendingEnabled: boolean,
        ): void;
        public getFramebufferFormat(): Packages.arc.graphics.Pixmap.Format;
        public setTextureFilter(
          _filter: Packages.arc.graphics.Texture.TextureFilter,
        ): void;
        public isCapturing(): boolean;
        public isApplyingEffects(): boolean;
        public hasResult(): boolean;
        public getResultBuffer(): Packages.arc.graphics.gl.FrameBuffer;
        public getPingPongBuffer(): Packages.arc.fx.util.PingPongBuffer;
        public hasEnabledEffects(): boolean;
        public removeEffect(
          _effect: Packages.arc.fx.FxFilter,
        ): void;
        public removeAllEffects(): void;
        public setEffectPriority(
          _effect: Packages.arc.fx.FxFilter,
          _priority: number,
        ): void;
        public applyEffects(): void;
        public setBufferTextureParams(
          _u: Packages.arc.graphics.Texture.TextureWrap,
          _v: Packages.arc.graphics.Texture.TextureWrap,
          _min: Packages.arc.graphics.Texture.TextureFilter,
          _mag: Packages.arc.graphics.Texture.TextureFilter,
        ): void;
        public constructor(
          _fboFormat: Packages.arc.graphics.Pixmap.Format,
          _bufferWidth: number,
          _bufferHeight: number,
          _depth: boolean,
          _stencil: boolean,
        );
        public constructor(
          _fboFormat: Packages.arc.graphics.Pixmap.Format,
          _bufferWidth: number,
          _bufferHeight: number,
        );
        public constructor(_w: number, _h: number);
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare class Colors extends java.lang.Object {
        private static map: Packages.arc.struct.OrderedMap<
          string,
          Packages.arc.graphics.Color
        >;
        public static get(
          _name: string,
        ): Packages.arc.graphics.Color;
        public static put(
          _name: string,
          _color: Packages.arc.graphics.Color,
        ): Packages.arc.graphics.Color;
        public static reset(): void;
        public static getColors(): Packages.arc.struct.OrderedMap<
          string,
          Packages.arc.graphics.Color
        >;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class Bits extends java.lang.Object {
        bits: Packages.long[];
        public get(_index: number): boolean;
        public equals(_obj: any): boolean;
        public length(): number;
        public hashCode(): number;
        public clear(_index: number): void;
        public clear(): void;
        public isEmpty(): boolean;
        public set(_index: number, _value: boolean): void;
        public set(_index: number): void;
        public set(_from: number, _to: number): void;
        public set(_other: Packages.arc.struct.Bits): void;
        public getAndSet(_index: number): boolean;
        public containsAll(
          _other: Packages.arc.struct.Bits,
        ): boolean;
        public flip(_index: number): void;
        public nextClearBit(_fromIndex: number): number;
        public or(_other: Packages.arc.struct.Bits): void;
        public numBits(): number;
        public and(_other: Packages.arc.struct.Bits): void;
        public xor(_other: Packages.arc.struct.Bits): void;
        public andNot(
          _other: Packages.arc.struct.Bits,
        ): void;
        private checkCapacity(_len: number): void;
        public getAndClear(_index: number): boolean;
        public nextSetBit(_fromIndex: number): number;
        public intersects(
          _other: Packages.arc.struct.Bits,
        ): boolean;
        public constructor();
        public constructor(_nbits: number);
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare class Gl extends java.lang.Object {
        private static optimize: boolean;
        public static esVersion20: number;
        public static depthBufferBit: number;
        public static stencilBufferBit: number;
        public static colorBufferBit: number;
        public static falseV: number;
        public static trueV: number;
        public static points: number;
        public static lines: number;
        public static lineLoop: number;
        public static lineStrip: number;
        public static triangles: number;
        public static triangleStrip: number;
        public static triangleFan: number;
        public static zero: number;
        public static one: number;
        public static srcColor: number;
        public static oneMinusSrcColor: number;
        public static srcAlpha: number;
        public static oneMinusSrcAlpha: number;
        public static dstAlpha: number;
        public static oneMinusDstAlpha: number;
        public static dstColor: number;
        public static oneMinusDstColor: number;
        public static srcAlphaSaturate: number;
        public static funcAdd: number;
        public static blendEquationRgb: number;
        public static blendEquationAlpha: number;
        public static funcSubtract: number;
        public static funcReverseSubtract: number;
        public static min: number;
        public static max: number;
        public static blendDstRgb: number;
        public static blendSrcRgb: number;
        public static blendDstAlpha: number;
        public static blendSrcAlpha: number;
        public static constantColor: number;
        public static oneMinusConstantColor: number;
        public static constantAlpha: number;
        public static oneMinusConstantAlpha: number;
        public static arrayBuffer: number;
        public static elementArrayBuffer: number;
        public static arrayBufferBinding: number;
        public static elementArrayBufferBinding: number;
        public static streamDraw: number;
        public static staticDraw: number;
        public static dynamicDraw: number;
        public static bufferSize: number;
        public static bufferUsage: number;
        public static currentVertexAttrib: number;
        public static front: number;
        public static back: number;
        public static frontAndBack: number;
        public static texture2d: number;
        public static blend: number;
        public static dither: number;
        public static stencilTest: number;
        public static depthTest: number;
        public static scissorTest: number;
        public static polygonOffsetFill: number;
        public static sampleAlphaToCoverage: number;
        public static noError: number;
        public static invalidEnum: number;
        public static invalidValue: number;
        public static invalidOperation: number;
        public static outOfMemory: number;
        public static cw: number;
        public static ccw: number;
        public static lineWidth: number;
        public static aliasedPointSizeRange: number;
        public static aliasedLineWidthRange: number;
        public static cullFaceMode: number;
        public static depthRange: number;
        public static depthWritemask: number;
        public static depthClearValue: number;
        public static stencilClearValue: number;
        public static stencilFail: number;
        public static stencilPassDepthFail: number;
        public static stencilPassDepthPass: number;
        public static stencilRef: number;
        public static stencilValueMask: number;
        public static stencilWritemask: number;
        public static stencilBackFunc: number;
        public static stencilBackFail: number;
        public static stencilBackPassDepthFail: number;
        public static stencilBackPassDepthPass: number;
        public static stencilBackRef: number;
        public static stencilBackValueMask: number;
        public static stencilBackWritemask: number;
        public static scissorBox: number;
        public static colorClearValue: number;
        public static colorWritemask: number;
        public static unpackAlignment: number;
        public static packAlignment: number;
        public static maxTextureSize: number;
        public static maxTextureUnits: number;
        public static maxViewportDims: number;
        public static subpixelBits: number;
        public static redBits: number;
        public static greenBits: number;
        public static blueBits: number;
        public static alphaBits: number;
        public static depthBits: number;
        public static stencilBits: number;
        public static polygonOffsetUnits: number;
        public static polygonOffsetFactor: number;
        public static textureBinding2d: number;
        public static sampleBuffers: number;
        public static samples: number;
        public static sampleCoverageValue: number;
        public static sampleCoverageInvert: number;
        public static numCompressedTextureFormats: number;
        public static compressedTextureFormats: number;
        public static dontCare: number;
        public static fastest: number;
        public static nicest: number;
        public static generateMipmapHint: number;
        public static byteV: number;
        public static unsignedByte: number;
        public static shortV: number;
        public static unsignedShort: number;
        public static intV: number;
        public static unsignedInt: number;
        public static floatV: number;
        public static fixed: number;
        public static depthComponent: number;
        public static alpha: number;
        public static rgb: number;
        public static rgba: number;
        public static luminance: number;
        public static luminanceAlpha: number;
        public static unsignedShort4444: number;
        public static unsignedShort5551: number;
        public static unsignedShort565: number;
        public static fragmentShader: number;
        public static vertexShader: number;
        public static maxVertexAttribs: number;
        public static maxVertexUniformVectors: number;
        public static maxVaryingVectors: number;
        public static maxCombinedTextureImageUnits: number;
        public static maxVertexTextureImageUnits: number;
        public static maxTextureImageUnits: number;
        public static maxFragmentUniformVectors: number;
        public static shaderType: number;
        public static deleteStatus: number;
        public static linkStatus: number;
        public static validateStatus: number;
        public static attachedShaders: number;
        public static activeUniforms: number;
        public static activeUniformMaxLength: number;
        public static activeAttributes: number;
        public static activeAttributeMaxLength: number;
        public static shadingLanguageVersion: number;
        public static currentProgram: number;
        public static never: number;
        public static less: number;
        public static equal: number;
        public static lequal: number;
        public static greater: number;
        public static notequal: number;
        public static gequal: number;
        public static always: number;
        public static keep: number;
        public static replace: number;
        public static incr: number;
        public static decr: number;
        public static invert: number;
        public static incrWrap: number;
        public static decrWrap: number;
        public static vendor: number;
        public static renderer: number;
        public static version: number;
        public static extensions: number;
        public static nearest: number;
        public static linear: number;
        public static nearestMipmapNearest: number;
        public static linearMipmapNearest: number;
        public static nearestMipmapLinear: number;
        public static linearMipmapLinear: number;
        public static textureMagFilter: number;
        public static textureMinFilter: number;
        public static textureWrapS: number;
        public static textureWrapT: number;
        public static texture: number;
        public static textureCubeMap: number;
        public static textureBindingCubeMap: number;
        public static textureCubeMapPositiveX: number;
        public static textureCubeMapNegativeX: number;
        public static textureCubeMapPositiveY: number;
        public static textureCubeMapNegativeY: number;
        public static textureCubeMapPositiveZ: number;
        public static textureCubeMapNegativeZ: number;
        public static maxCubeMapTextureSize: number;
        public static texture0: number;
        public static texture1: number;
        public static texture2: number;
        public static texture3: number;
        public static texture4: number;
        public static texture5: number;
        public static texture6: number;
        public static texture7: number;
        public static texture8: number;
        public static texture9: number;
        public static texture10: number;
        public static texture11: number;
        public static texture12: number;
        public static texture13: number;
        public static texture14: number;
        public static texture15: number;
        public static texture16: number;
        public static texture17: number;
        public static texture18: number;
        public static texture19: number;
        public static texture20: number;
        public static texture21: number;
        public static texture22: number;
        public static texture23: number;
        public static texture24: number;
        public static texture25: number;
        public static texture26: number;
        public static texture27: number;
        public static texture28: number;
        public static texture29: number;
        public static texture30: number;
        public static texture31: number;
        public static repeat: number;
        public static clampToEdge: number;
        public static mirroredRepeat: number;
        public static floatVec2: number;
        public static floatVec3: number;
        public static floatVec4: number;
        public static intVec2: number;
        public static intVec3: number;
        public static intVec4: number;
        public static bool: number;
        public static boolVec2: number;
        public static boolVec3: number;
        public static boolVec4: number;
        public static floatMat2: number;
        public static floatMat3: number;
        public static floatMat4: number;
        public static sampler2d: number;
        public static samplerCube: number;
        public static vertexAttribArrayEnabled: number;
        public static vertexAttribArraySize: number;
        public static vertexAttribArrayStride: number;
        public static vertexAttribArrayType: number;
        public static vertexAttribArrayNormalized: number;
        public static vertexAttribArrayPointer: number;
        public static vertexAttribArrayBufferBinding: number;
        public static implementationColorReadType: number;
        public static implementationColorReadFormat: number;
        public static compileStatus: number;
        public static infoLogLength: number;
        public static shaderSourceLength: number;
        public static shaderCompiler: number;
        public static shaderBinaryFormats: number;
        public static numShaderBinaryFormats: number;
        public static lowFloat: number;
        public static mediumFloat: number;
        public static highFloat: number;
        public static lowInt: number;
        public static mediumInt: number;
        public static highInt: number;
        public static framebuffer: number;
        public static renderbuffer: number;
        public static rgba4: number;
        public static rgb5A1: number;
        public static rgb565: number;
        public static depthComponent16: number;
        public static stencilIndex: number;
        public static stencilIndex8: number;
        public static renderbufferWidth: number;
        public static renderbufferHeight: number;
        public static renderbufferInternalFormat: number;
        public static renderbufferRedSize: number;
        public static renderbufferGreenSize: number;
        public static renderbufferBlueSize: number;
        public static renderbufferAlphaSize: number;
        public static renderbufferDepthSize: number;
        public static renderbufferStencilSize: number;
        public static framebufferAttachmentObjectType: number;
        public static framebufferAttachmentObjectName: number;
        public static framebufferAttachmentTextureLevel: number;
        public static framebufferAttachmentTextureCubeMapFace: number;
        public static colorAttachment0: number;
        public static depthAttachment: number;
        public static stencilAttachment: number;
        public static none: number;
        public static framebufferComplete: number;
        public static framebufferIncompleteAttachment: number;
        public static framebufferIncompleteMissingAttachment: number;
        public static framebufferIncompleteDimensions: number;
        public static framebufferUnsupported: number;
        public static framebufferBinding: number;
        public static renderbufferBinding: number;
        public static maxRenderbufferSize: number;
        public static invalidFramebufferOperation: number;
        public static vertexProgramPointSize: number;
        private static ibuf: Packages.java.nio.IntBuffer;
        private static lastActiveTexture: number;
        private static lastBoundTextures: number[];
        private static lastUsedProgram: number;
        private static enabled: Packages.arc.struct.Bits;
        private static wasDepthMask: boolean;
        private static lastBlendSrc: number;
        private static lastBlendDst: number;
        private static lastBlendSrcAlpha: number;
        private static lastBlendDstAlpha: number;
        public static getInt(_name: number): number;
        public static clear(_mask: number): void;
        public static flush(): void;
        public static reset(): void;
        public static finish(): void;
        public static getString(_name: number): string;
        public static hint(
          _target: number,
          _mode: number,
        ): void;
        public static enable(_cap: number): void;
        public static isEnabled(_cap: number): boolean;
        public static clearColor(
          _red: number,
          _green: number,
          _blue: number,
          _alpha: number,
        ): void;
        public static viewport(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
        ): void;
        public static createProgram(): number;
        public static linkProgram(_program: number): void;
        public static createShader(_type: number): number;
        public static shaderSource(
          _shader: number,
          _string: string,
        ): void;
        public static compileShader(_shader: number): void;
        public static getShaderiv(
          _shader: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public static getShaderInfoLog(
          _shader: number,
        ): string;
        public static attachShader(
          _program: number,
          _shader: number,
        ): void;
        public static getProgramiv(
          _program: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public static getProgramInfoLog(
          _program: number,
        ): string;
        public static getAttribLocation(
          _program: number,
          _name: string,
        ): number;
        public static bindTexture(
          _target: number,
          _texture: number,
        ): void;
        public static texSubImage2D(
          _target: number,
          _level: number,
          _xoffset: number,
          _yoffset: number,
          _width: number,
          _height: number,
          _format: number,
          _type: number,
          _pixels: Packages.java.nio.Buffer,
        ): void;
        public static texImage2D(
          _target: number,
          _level: number,
          _internalformat: number,
          _width: number,
          _height: number,
          _border: number,
          _format: number,
          _type: number,
          _pixels: Packages.java.nio.Buffer,
        ): void;
        public static activeTexture(_texture: number): void;
        public static texParameteri(
          _target: number,
          _pname: number,
          _param: number,
        ): void;
        public static deleteTexture(_texture: number): void;
        public static blendFuncSeparate(
          _srcRGB: number,
          _dstRGB: number,
          _srcAlpha: number,
          _dstAlpha: number,
        ): void;
        public static genTexture(): number;
        public static getUniformLocation(
          _program: number,
          _name: string,
        ): number;
        public static uniform1i(
          _location: number,
          _x: number,
        ): void;
        public static uniform2i(
          _location: number,
          _x: number,
          _y: number,
        ): void;
        public static uniform3i(
          _location: number,
          _x: number,
          _y: number,
          _z: number,
        ): void;
        public static uniform4i(
          _location: number,
          _x: number,
          _y: number,
          _z: number,
          _w: number,
        ): void;
        public static uniform1f(
          _location: number,
          _x: number,
        ): void;
        public static uniform2f(
          _location: number,
          _x: number,
          _y: number,
        ): void;
        public static uniform3f(
          _location: number,
          _x: number,
          _y: number,
          _z: number,
        ): void;
        public static uniform4f(
          _location: number,
          _x: number,
          _y: number,
          _z: number,
          _w: number,
        ): void;
        public static uniform1fv(
          _location: number,
          _count: number,
          _v: Packages.java.nio.FloatBuffer,
        ): void;
        public static uniform1fv(
          _location: number,
          _count: number,
          _v: number[],
          _offset: number,
        ): void;
        public static uniform2fv(
          _location: number,
          _count: number,
          _v: Packages.java.nio.FloatBuffer,
        ): void;
        public static uniform2fv(
          _location: number,
          _count: number,
          _v: number[],
          _offset: number,
        ): void;
        public static uniform3fv(
          _location: number,
          _count: number,
          _v: Packages.java.nio.FloatBuffer,
        ): void;
        public static uniform3fv(
          _location: number,
          _count: number,
          _v: number[],
          _offset: number,
        ): void;
        public static uniform4fv(
          _location: number,
          _count: number,
          _v: number[],
          _offset: number,
        ): void;
        public static uniform4fv(
          _location: number,
          _count: number,
          _v: Packages.java.nio.FloatBuffer,
        ): void;
        public static uniformMatrix3fv(
          _location: number,
          _count: number,
          _transpose: boolean,
          _value: Packages.java.nio.FloatBuffer,
        ): void;
        public static uniformMatrix3fv(
          _location: number,
          _count: number,
          _transpose: boolean,
          _value: number[],
          _offset: number,
        ): void;
        public static uniformMatrix4fv(
          _location: number,
          _count: number,
          _transpose: boolean,
          _value: number[],
          _offset: number,
        ): void;
        public static uniformMatrix4fv(
          _location: number,
          _count: number,
          _transpose: boolean,
          _value: Packages.java.nio.FloatBuffer,
        ): void;
        public static useProgram(_program: number): void;
        public static deleteShader(_shader: number): void;
        public static deleteProgram(_program: number): void;
        public static disableVertexAttribArray(
          _index: number,
        ): void;
        public static getActiveUniform(
          _program: number,
          _index: number,
          _size: Packages.java.nio.IntBuffer,
          _type: Packages.java.nio.IntBuffer,
        ): string;
        public static getActiveAttrib(
          _program: number,
          _index: number,
          _size: Packages.java.nio.IntBuffer,
          _type: Packages.java.nio.IntBuffer,
        ): string;
        public static disable(_cap: number): void;
        public static scissor(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
        ): void;
        public static framebufferTexture2D(
          _target: number,
          _attachment: number,
          _textarget: number,
          _texture: number,
          _level: number,
        ): void;
        public static bindFramebuffer(
          _target: number,
          _framebuffer: number,
        ): void;
        public static getIntegerv(
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public static genFramebuffer(): number;
        public static genRenderbuffer(): number;
        public static bindRenderbuffer(
          _target: number,
          _renderbuffer: number,
        ): void;
        public static renderbufferStorage(
          _target: number,
          _internalformat: number,
          _width: number,
          _height: number,
        ): void;
        public static framebufferRenderbuffer(
          _target: number,
          _attachment: number,
          _renderbuffertarget: number,
          _renderbuffer: number,
        ): void;
        public static checkFramebufferStatus(
          _target: number,
        ): number;
        public static deleteRenderbuffer(
          _renderbuffer: number,
        ): void;
        public static deleteBuffer(_buffer: number): void;
        public static deleteFramebuffer(
          _framebuffer: number,
        ): void;
        public static blendEquation(_mode: number): void;
        public static blendColor(
          _red: number,
          _green: number,
          _blue: number,
          _alpha: number,
        ): void;
        public static cullFace(_mode: number): void;
        public static sampleCoverage(
          _value: number,
          _invert: boolean,
        ): void;
        public static frontFace(_mode: number): void;
        public static depthFunc(_func: number): void;
        public static stencilFunc(
          _func: number,
          _ref: number,
          _mask: number,
        ): void;
        public static generateMipmap(_target: number): void;
        public static blendFunc(
          _sfactor: number,
          _dfactor: number,
        ): void;
        public static clearDepthf(_depth: number): void;
        public static clearStencil(_s: number): void;
        public static colorMask(
          _red: boolean,
          _green: boolean,
          _blue: boolean,
          _alpha: boolean,
        ): void;
        public static compressedTexImage2D(
          _target: number,
          _level: number,
          _internalformat: number,
          _width: number,
          _height: number,
          _border: number,
          _imageSize: number,
          _data: Packages.java.nio.Buffer,
        ): void;
        public static compressedTexSubImage2D(
          _target: number,
          _level: number,
          _xoffset: number,
          _yoffset: number,
          _width: number,
          _height: number,
          _format: number,
          _imageSize: number,
          _data: Packages.java.nio.Buffer,
        ): void;
        public static copyTexImage2D(
          _target: number,
          _level: number,
          _internalformat: number,
          _x: number,
          _y: number,
          _width: number,
          _height: number,
          _border: number,
        ): void;
        public static copyTexSubImage2D(
          _target: number,
          _level: number,
          _xoffset: number,
          _yoffset: number,
          _x: number,
          _y: number,
          _width: number,
          _height: number,
        ): void;
        public static depthMask(_flag: boolean): void;
        public static depthRangef(
          _zNear: number,
          _zFar: number,
        ): void;
        public static drawArrays(
          _mode: number,
          _first: number,
          _count: number,
        ): void;
        public static drawElements(
          _mode: number,
          _count: number,
          _type: number,
          _indices: number,
        ): void;
        public static drawElements(
          _mode: number,
          _count: number,
          _type: number,
          _indices: Packages.java.nio.Buffer,
        ): void;
        public static getError(): number;
        public static pixelStorei(
          _pname: number,
          _param: number,
        ): void;
        public static polygonOffset(
          _factor: number,
          _units: number,
        ): void;
        public static readPixels(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
          _format: number,
          _type: number,
          _pixels: Packages.java.nio.Buffer,
        ): void;
        public static stencilMask(_mask: number): void;
        public static stencilOp(
          _fail: number,
          _zfail: number,
          _zpass: number,
        ): void;
        public static texParameterf(
          _target: number,
          _pname: number,
          _param: number,
        ): void;
        public static bindAttribLocation(
          _program: number,
          _index: number,
          _name: string,
        ): void;
        public static bindBuffer(
          _target: number,
          _buffer: number,
        ): void;
        public static blendEquationSeparate(
          _modeRGB: number,
          _modeAlpha: number,
        ): void;
        public static bufferData(
          _target: number,
          _size: number,
          _data: Packages.java.nio.Buffer,
          _usage: number,
        ): void;
        public static bufferSubData(
          _target: number,
          _offset: number,
          _size: number,
          _data: Packages.java.nio.Buffer,
        ): void;
        public static detachShader(
          _program: number,
          _shader: number,
        ): void;
        public static enableVertexAttribArray(
          _index: number,
        ): void;
        public static genBuffer(): number;
        public static getBooleanv(
          _pname: number,
          _params: Packages.java.nio.Buffer,
        ): void;
        public static getBufferParameteriv(
          _target: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public static getFloatv(
          _pname: number,
          _params: Packages.java.nio.FloatBuffer,
        ): void;
        public static getFramebufferAttachmentParameteriv(
          _target: number,
          _attachment: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public static getRenderbufferParameteriv(
          _target: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public static getShaderPrecisionFormat(
          _shadertype: number,
          _precisiontype: number,
          _range: Packages.java.nio.IntBuffer,
          _precision: Packages.java.nio.IntBuffer,
        ): void;
        public static getTexParameterfv(
          _target: number,
          _pname: number,
          _params: Packages.java.nio.FloatBuffer,
        ): void;
        public static getTexParameteriv(
          _target: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public static getUniformfv(
          _program: number,
          _location: number,
          _params: Packages.java.nio.FloatBuffer,
        ): void;
        public static getUniformiv(
          _program: number,
          _location: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public static getVertexAttribfv(
          _index: number,
          _pname: number,
          _params: Packages.java.nio.FloatBuffer,
        ): void;
        public static getVertexAttribiv(
          _index: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public static isBuffer(_buffer: number): boolean;
        public static isFramebuffer(
          _framebuffer: number,
        ): boolean;
        public static isProgram(_program: number): boolean;
        public static isRenderbuffer(
          _renderbuffer: number,
        ): boolean;
        public static isShader(_shader: number): boolean;
        public static isTexture(_texture: number): boolean;
        public static releaseShaderCompiler(): void;
        public static stencilFuncSeparate(
          _face: number,
          _func: number,
          _ref: number,
          _mask: number,
        ): void;
        public static stencilMaskSeparate(
          _face: number,
          _mask: number,
        ): void;
        public static stencilOpSeparate(
          _face: number,
          _fail: number,
          _zfail: number,
          _zpass: number,
        ): void;
        public static texParameterfv(
          _target: number,
          _pname: number,
          _params: Packages.java.nio.FloatBuffer,
        ): void;
        public static texParameteriv(
          _target: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public static uniform1iv(
          _location: number,
          _count: number,
          _v: number[],
          _offset: number,
        ): void;
        public static uniform1iv(
          _location: number,
          _count: number,
          _v: Packages.java.nio.IntBuffer,
        ): void;
        public static uniform2iv(
          _location: number,
          _count: number,
          _v: number[],
          _offset: number,
        ): void;
        public static uniform2iv(
          _location: number,
          _count: number,
          _v: Packages.java.nio.IntBuffer,
        ): void;
        public static uniform3iv(
          _location: number,
          _count: number,
          _v: Packages.java.nio.IntBuffer,
        ): void;
        public static uniform3iv(
          _location: number,
          _count: number,
          _v: number[],
          _offset: number,
        ): void;
        public static uniform4iv(
          _location: number,
          _count: number,
          _v: number[],
          _offset: number,
        ): void;
        public static uniform4iv(
          _location: number,
          _count: number,
          _v: Packages.java.nio.IntBuffer,
        ): void;
        public static uniformMatrix2fv(
          _location: number,
          _count: number,
          _transpose: boolean,
          _value: Packages.java.nio.FloatBuffer,
        ): void;
        public static uniformMatrix2fv(
          _location: number,
          _count: number,
          _transpose: boolean,
          _value: number[],
          _offset: number,
        ): void;
        public static validateProgram(
          _program: number,
        ): void;
        public static vertexAttrib1f(
          _indx: number,
          _x: number,
        ): void;
        public static vertexAttrib1fv(
          _indx: number,
          _values: Packages.java.nio.FloatBuffer,
        ): void;
        public static vertexAttrib2f(
          _indx: number,
          _x: number,
          _y: number,
        ): void;
        public static vertexAttrib2fv(
          _indx: number,
          _values: Packages.java.nio.FloatBuffer,
        ): void;
        public static vertexAttrib3f(
          _indx: number,
          _x: number,
          _y: number,
          _z: number,
        ): void;
        public static vertexAttrib3fv(
          _indx: number,
          _values: Packages.java.nio.FloatBuffer,
        ): void;
        public static vertexAttrib4f(
          _indx: number,
          _x: number,
          _y: number,
          _z: number,
          _w: number,
        ): void;
        public static vertexAttrib4fv(
          _indx: number,
          _values: Packages.java.nio.FloatBuffer,
        ): void;
        public static vertexAttribPointer(
          _indx: number,
          _size: number,
          _type: number,
          _normalized: boolean,
          _stride: number,
          _ptr: Packages.java.nio.Buffer,
        ): void;
        public static vertexAttribPointer(
          _indx: number,
          _size: number,
          _type: number,
          _normalized: boolean,
          _stride: number,
          _ptr: number,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare class VertexAttribute extends java.lang
        .Object {
        public static position: Packages.arc.graphics.VertexAttribute;
        public static position3: Packages.arc.graphics.VertexAttribute;
        public static texCoords: Packages.arc.graphics.VertexAttribute;
        public static normal: Packages.arc.graphics.VertexAttribute;
        public static color: Packages.arc.graphics.VertexAttribute;
        public static mixColor: Packages.arc.graphics.VertexAttribute;
        public components: number;
        public normalized: boolean;
        public type: number;
        public alias: string;
        public size: number;
        public constructor(
          _components: number,
          _alias: string,
        );
        public constructor(
          _components: number,
          _type: number,
          _normalized: boolean,
          _alias: string,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace nio {
      declare abstract class ShortBuffer {}
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace gl {
        declare abstract class IndexData
          implements Packages.arc.util.Disposable
        {
          public max(): number;
          public update(
            _targetOffset: number,
            _indices: Packages.short[],
            _offset: number,
            _count: number,
          ): void;
          public size(): number;
          public buffer(): Packages.java.nio.ShortBuffer;
          public set(
            _indices: Packages.java.nio.ShortBuffer,
          ): void;
          public set(
            _indices: Packages.short[],
            _offset: number,
            _count: number,
          ): void;
          public bind(): void;
          public dispose(): void;
          public unbind(): void;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace gl {
        declare abstract class VertexData
          implements Packages.arc.util.Disposable
        {
          public max(): number;
          public update(
            _targetOffset: number,
            _vertices: number[],
            _sourceOffset: number,
            _count: number,
          ): void;
          public size(): number;
          public buffer(): Packages.java.nio.FloatBuffer;
          public set(
            _vertices: number[],
            _offset: number,
            _count: number,
          ): void;
          public bind(
            _shader: Packages.arc.graphics.gl.Shader,
          ): void;
          public unbind(
            _shader: Packages.arc.graphics.gl.Shader,
          ): void;
          public render(
            _indices: Packages.arc.graphics.gl.IndexData,
            _primitiveType: number,
            _offset: number,
            _count: number,
          ): void;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare class Mesh
        extends java.lang.Object
        implements Packages.arc.util.Disposable
      {
        public vertexSize: number;
        public attributes: Packages.arc.graphics.VertexAttribute[];
        public vertices: Packages.arc.graphics.gl.VertexData;
        public indices: Packages.arc.graphics.gl.IndexData;
        autoBind: boolean;
        public bind(
          _shader: Packages.arc.graphics.gl.Shader,
        ): void;
        public dispose(): void;
        public unbind(
          _shader: Packages.arc.graphics.gl.Shader,
        ): void;
        public render(
          _shader: Packages.arc.graphics.gl.Shader,
          _primitiveType: number,
        ): void;
        public render(
          _shader: Packages.arc.graphics.gl.Shader,
          _primitiveType: number,
          _offset: number,
          _count: number,
        ): void;
        public render(
          _shader: Packages.arc.graphics.gl.Shader,
          _primitiveType: number,
          _offset: number,
          _count: number,
          _autoBind: boolean,
        ): void;
        public updateVertices(
          _targetOffset: number,
          _source: number[],
        ): Packages.arc.graphics.Mesh;
        public updateVertices(
          _targetOffset: number,
          _source: number[],
          _sourceOffset: number,
          _count: number,
        ): Packages.arc.graphics.Mesh;
        public getIndices(
          _indices: Packages.short[],
          _destOffset: number,
        ): void;
        public getIndices(
          _srcOffset: number,
          _count: number,
          _indices: Packages.short[],
          _destOffset: number,
        ): void;
        public getIndices(
          _srcOffset: number,
          _indices: Packages.short[],
          _destOffset: number,
        ): void;
        public getIndices(_indices: Packages.short[]): void;
        public getNumIndices(): number;
        public getIndicesBuffer(): Packages.java.nio.ShortBuffer;
        public getNumVertices(): number;
        public setVertices(
          _vertices: number[],
        ): Packages.arc.graphics.Mesh;
        public setVertices(
          _vertices: number[],
          _offset: number,
          _count: number,
        ): Packages.arc.graphics.Mesh;
        public setIndices(
          _indices: Packages.short[],
          _offset: number,
          _count: number,
        ): Packages.arc.graphics.Mesh;
        public setIndices(
          _indices: Packages.short[],
        ): Packages.arc.graphics.Mesh;
        public getMaxVertices(): number;
        public getMaxIndices(): number;
        public getVertexSize(): number;
        public setAutoBind(_autoBind: boolean): void;
        public getVerticesBuffer(): Packages.java.nio.FloatBuffer;
        public constructor(
          _isStatic: boolean,
          _maxVertices: number,
          _maxIndices: number,
          ..._attributes: Packages.arc.graphics.VertexAttribute[]
        );
        public constructor(
          _useVertexArray: boolean,
          _isStatic: boolean,
          _maxVertices: number,
          _maxIndices: number,
          ..._attributes: Packages.arc.graphics.VertexAttribute[]
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace io {
      declare class FilterOutputStream extends Packages.java
        .io.OutputStream {
        protected out: Packages.java.io.OutputStream;
        private closed: boolean;
        private closeLock: any;
        public flush(): void;
        public write(
          _arg0: string[],
          _arg1: number,
          _arg2: number,
        ): void;
        public write(_arg0: string[]): void;
        public write(_arg0: number): void;
        public close(): void;
        public constructor(
          _arg0: Packages.java.io.OutputStream,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace io {
      declare class DataOutputStream
        extends Packages.java.io.FilterOutputStream
        implements Packages.java.io.DataOutput
      {
        protected written: number;
        private bytearr: string[];
        private writeBuffer: string[];
        public flush(): void;
        public size(): number;
        public write(
          _arg0: string[],
          _arg1: number,
          _arg2: number,
        ): void;
        public write(_arg0: number): void;
        public writeInt(_arg0: number): void;
        public writeUTF(_arg0: string): void;
        static writeUTF(
          _arg0: string,
          _arg1: Packages.java.io.DataOutput,
        ): number;
        public writeBytes(_arg0: string): void;
        public writeChar(_arg0: number): void;
        public writeFloat(_arg0: number): void;
        public writeBoolean(_arg0: boolean): void;
        public writeByte(_arg0: number): void;
        public writeShort(_arg0: number): void;
        public writeLong(_arg0: Packages.long): void;
        public writeDouble(_arg0: number): void;
        public writeChars(_arg0: string): void;
        private incCount(_arg0: number): void;
        private static tooLongMsg(
          _arg0: string,
          _arg1: number,
        ): string;
        public constructor(
          _arg0: Packages.java.io.OutputStream,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare namespace zip {
        declare class CRC32 {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare namespace zip {
        declare class Deflater {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare class PixmapIO extends java.lang.Object {
        public static PngWriter = class
          extends java.lang.Object
          implements Packages.arc.util.Disposable
        {
          static ChunkBuffer = class extends Packages.java
            .io.DataOutputStream {
            buffer: Packages.java.io.ByteArrayOutputStream;
            crc: Packages.java.util.zip.CRC32;
            public endChunk(
              _target: Packages.java.io.DataOutputStream,
            ): void;
          };
          private static SIGNATURE: string[];
          private static IHDR: number;
          private static IDAT: number;
          private static IEND: number;
          private static COLOR_ARGB: string;
          private static COMPRESSION_DEFLATE: string;
          private static FILTER_NONE: string;
          private static INTERLACE_NONE: string;
          private buffer: Packages.arc.graphics.PixmapIO.PngWriter.ChunkBuffer;
          private deflater: Packages.java.util.zip.Deflater;
          private flipY: boolean;
          public write(
            _file: Packages.arc.files.Fi,
            _pixmap: Packages.arc.graphics.Pixmap,
          ): void;
          public write(
            _output: Packages.java.io.OutputStream,
            _pixmap: Packages.arc.graphics.Pixmap,
          ): void;
          public dispose(): void;
          public setFlipY(_flipY: boolean): void;
          public setCompression(_level: number): void;
          public constructor();
          public constructor(_initialBufferSize: number);
        };
        public static PngReader = class extends java.lang
          .Object {
          private static ctypeRgba: number;
          private static ctypePalette: number;
          private static ctypeRgb: number;
          public width: number;
          public height: number;
          public bitDepth: string;
          public colorType: string;
          public compression: string;
          public filter: string;
          public interlace: string;
          private dataLen: number;
          private cs: number;
          private imgData: string[];
          private buf: Packages.java.nio.ByteBuffer;
          private palette: number[];
          public read(
            _in: Packages.java.io.InputStream,
          ): Packages.java.nio.ByteBuffer;
          private getImage(
            _bb: Packages.java.nio.ByteBuffer,
          ): void;
          private readChunks(
            _in: Packages.java.io.DataInputStream,
          ): void;
          private static paeth(
            _a: number,
            _b: number,
            _c: number,
          ): number;
          private static ab(_a: number): number;
          public constructor();
        };
        public static writePng(
          _file: Packages.arc.files.Fi,
          _pixmap: Packages.arc.graphics.Pixmap,
        ): void;
        public static readApix(
          _file: Packages.arc.files.Fi,
        ): Packages.arc.graphics.Pixmap;
        public static writeApix(
          _file: Packages.arc.files.Fi,
          _pixmap: Packages.arc.graphics.Pixmap,
        ): void;
        public static readPNG(
          _file: Packages.arc.files.Fi,
        ): Packages.arc.graphics.Pixmap;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare class Pixmaps extends java.lang.Object {
        private static offsets: number[];
        private static drawPixmap: Packages.arc.graphics.Pixmap;
        private static tmpArray: Packages.arc.struct.IntSeq;
        public static blend(
          _source: Packages.arc.graphics.g2d.PixmapRegion,
          _over: Packages.arc.graphics.g2d.PixmapRegion,
          _alpha: number,
        ): Packages.arc.graphics.Pixmap;
        public static scale(
          _input: Packages.arc.graphics.Pixmap,
          _scalex: number,
          _scaley: number,
        ): Packages.arc.graphics.Pixmap;
        public static scale(
          _pixmap: Packages.arc.graphics.Pixmap,
          _width: number,
          _height: number,
          _filter: boolean,
        ): Packages.arc.graphics.Pixmap;
        public static scale(
          _input: Packages.arc.graphics.Pixmap,
          _scale: number,
        ): Packages.arc.graphics.Pixmap;
        public static empty(_i: number): boolean;
        public static flip(
          _pixmap: Packages.arc.graphics.Pixmap,
        ): void;
        public static resize(
          _input: Packages.arc.graphics.Pixmap,
          _width: number,
          _height: number,
          _backgroundColor: number,
        ): Packages.arc.graphics.Pixmap;
        public static resize(
          _input: Packages.arc.graphics.Pixmap,
          _width: number,
          _height: number,
        ): Packages.arc.graphics.Pixmap;
        public static rotate(
          _input: Packages.arc.graphics.Pixmap,
          _angle: number,
        ): Packages.arc.graphics.Pixmap;
        public static outline(
          _region: Packages.arc.graphics.g2d.PixmapRegion,
          _color: Packages.arc.graphics.Color,
          _radius: number,
        ): Packages.arc.graphics.Pixmap;
        public static outline(
          _input: Packages.arc.graphics.Pixmap,
          _color: Packages.arc.graphics.Color,
        ): Packages.arc.graphics.Pixmap;
        public static crop(
          _input: Packages.arc.graphics.Pixmap,
          _x: number,
          _y: number,
          _width: number,
          _height: number,
        ): Packages.arc.graphics.Pixmap;
        public static blankTextureRegion(): Packages.arc.graphics.g2d.TextureRegion;
        public static zoom(
          _input: Packages.arc.graphics.Pixmap,
          _scale: number,
        ): Packages.arc.graphics.Pixmap;
        public static noise(
          _w: number,
          _h: number,
        ): Packages.arc.graphics.Pixmap;
        public static median(
          _input: Packages.arc.graphics.Pixmap,
          _radius: number,
          _percentile: number,
          _tmp: Packages.arc.struct.IntSeq,
        ): Packages.arc.graphics.Pixmap;
        public static median(
          _input: Packages.arc.graphics.Pixmap,
          _radius: number,
          _percentile: number,
        ): Packages.arc.graphics.Pixmap;
        public static huePixmap(
          _width: number,
          _height: number,
        ): Packages.arc.graphics.Pixmap;
        public static blankPixmap(): Packages.arc.graphics.Pixmap;
        public static blankTexture(): Packages.arc.graphics.Texture;
        public static noiseTex(
          _w: number,
          _h: number,
        ): Packages.arc.graphics.Texture;
        public static hueTexture(
          _width: number,
          _height: number,
        ): Packages.arc.graphics.Texture;
        public static drawPixel(
          _texture: Packages.arc.graphics.Texture,
          _x: number,
          _y: number,
          _color: number,
        ): void;
        public static bleed(
          _image: Packages.arc.graphics.Pixmap,
          _maxIterations: number,
        ): Packages.arc.graphics.Pixmap;
        public static bleed(
          _image: Packages.arc.graphics.Pixmap,
        ): Packages.arc.graphics.Pixmap;
        public static antialias(
          _pixmap: Packages.arc.graphics.Pixmap,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare abstract class TextureArrayData {
        public prepare(): void;
        public getWidth(): number;
        public getHeight(): number;
        public getGLType(): number;
        public isPrepared(): boolean;
        public getDepth(): number;
        public getInternalFormat(): number;
        public consumeTextureArrayData(): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare class TextureArray extends Packages.arc
        .graphics.GLTexture {
        private data: Packages.arc.graphics.TextureArrayData;
        private load(
          _data: Packages.arc.graphics.TextureArrayData,
        ): void;
        public getDepth(): number;
        private static getInternalHandles(
          ..._internalPaths: string[]
        ): Packages.arc.files.Fi[] | null;
        public constructor(
          _data: Packages.arc.graphics.TextureArrayData,
        );
        public constructor(
          _useMipMaps: boolean,
          ..._files: Packages.arc.files.Fi[]
        );
        public constructor(
          ..._files: Packages.arc.files.Fi[]
        );
        public constructor(..._internalPaths: string[]);
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace input {
      declare abstract class Controller extends Packages.arc
        .input.InputDevice {
        public index(): number;
        public type(): Packages.arc.input.InputDevice.DeviceType;
        public accelerometer(): Packages.arc.math.geom.Vec3;
        public postUpdate(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace input {
      declare class InputEventQueue
        extends java.lang.Object
        implements Packages.arc.input.InputProcessor
      {
        private static SKIP: number;
        private static KEY_DOWN: number;
        private static KEY_UP: number;
        private static KEY_TYPED: number;
        private static TOUCH_DOWN: number;
        private static TOUCH_UP: number;
        private static TOUCH_DRAGGED: number;
        private static MOUSE_MOVED: number;
        private static SCROLLED: number;
        private queue: Packages.arc.struct.IntSeq;
        private processingQueue: Packages.arc.struct.IntSeq;
        private processor: Packages.arc.input.InputProcessor;
        private currentEventTime: Packages.long;
        private next(_nextType: number, _i: number): number;
        public keyDown(
          _key: Packages.arc.input.KeyCode,
        ): boolean;
        public getCurrentEventTime(): Packages.long;
        public touchDown(
          _screenX: number,
          _screenY: number,
          _pointer: number,
          _button: Packages.arc.input.KeyCode,
        ): boolean;
        public touchDragged(
          _screenX: number,
          _screenY: number,
          _pointer: number,
        ): boolean;
        public touchUp(
          _screenX: number,
          _screenY: number,
          _pointer: number,
          _button: Packages.arc.input.KeyCode,
        ): boolean;
        public mouseMoved(
          _screenX: number,
          _screenY: number,
        ): boolean;
        public scrolled(
          _amountX: number,
          _amountY: number,
        ): boolean;
        public keyUp(
          _key: Packages.arc.input.KeyCode,
        ): boolean;
        public keyTyped(_character: string): boolean;
        private queueTime(): void;
        public getProcessor(): Packages.arc.input.InputProcessor;
        public setProcessor(
          _processor: Packages.arc.input.InputProcessor,
        ): void;
        public drain(): void;
        public constructor();
        public constructor(
          _processor: Packages.arc.input.InputProcessor,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare class Angles extends java.lang.Object {
        public static ParticleConsumer = class {
          public accept(
            _x: number,
            _y: number,
            _fin: number,
            _fout: number,
          ): void;
        };
        private static rand: Packages.arc.math.Rand;
        private static rv: Packages.arc.math.geom.Vec2;
        public static angle(_x: number, _y: number): number;
        public static angle(
          _x: number,
          _y: number,
          _x2: number,
          _y2: number,
        ): number;
        public static moveToward(
          _angle: number,
          _to: number,
          _speed: number,
        ): number;
        public static angleRad(
          _x: number,
          _y: number,
          _x2: number,
          _y2: number,
        ): number;
        public static within(
          _a: number,
          _b: number,
          _margin: number,
        ): boolean;
        public static near(
          _a: number,
          _b: number,
          _range: number,
        ): boolean;
        public static angleDist(
          _a: number,
          _b: number,
        ): number;
        public static backwardDistance(
          _angle1: number,
          _angle2: number,
        ): number;
        public static forwardDistance(
          _angle1: number,
          _angle2: number,
        ): number;
        public static trnsx(
          _angle: number,
          _x: number,
          _y: number,
        ): number;
        public static trnsx(
          _angle: number,
          _len: number,
        ): number;
        public static trnsy(
          _angle: number,
          _x: number,
          _y: number,
        ): number;
        public static trnsy(
          _angle: number,
          _len: number,
        ): number;
        public static clampRange(
          _angle: number,
          _dest: number,
          _range: number,
        ): number;
        public static mouseAngle(
          _cx: number,
          _cy: number,
        ): number;
        public static circleVectors(
          _points: number,
          _length: number,
          _offset: number,
          _pos: Packages.arc.func.Floatc2,
        ): void;
        public static circleVectors(
          _points: number,
          _length: number,
          _pos: Packages.arc.func.Floatc2,
        ): void;
        public static randVectors(
          _seed: Packages.long,
          _amount: number,
          _length: number,
          _cons: Packages.arc.func.Floatc2,
        ): void;
        public static randLenVectors(
          _seed: Packages.long,
          _fin: number,
          _amount: number,
          _length: number,
          _cons: Packages.arc.math.Angles.ParticleConsumer,
        ): void;
        public static randLenVectors(
          _seed: Packages.long,
          _fin: number,
          _amount: number,
          _length: number,
          _angle: number,
          _range: number,
          _cons: Packages.arc.math.Angles.ParticleConsumer,
        ): void;
        public static randLenVectors(
          _seed: Packages.long,
          _amount: number,
          _length: number,
          _cons: Packages.arc.func.Floatc2,
        ): void;
        public static randLenVectors(
          _seed: Packages.long,
          _amount: number,
          _length: number,
          _angle: number,
          _range: number,
          _spread: number,
          _cons: Packages.arc.func.Floatc2,
        ): void;
        public static randLenVectors(
          _seed: Packages.long,
          _amount: number,
          _length: number,
          _angle: number,
          _range: number,
          _cons: Packages.arc.func.Floatc2,
        ): void;
        public static randLenVectors(
          _seed: Packages.long,
          _amount: number,
          _minLength: number,
          _length: number,
          _cons: Packages.arc.func.Floatc2,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare class CumulativeDistribution<T> extends java
        .lang.Object {
        public CumulativeValue = class extends java.lang
          .Object {
          public value: T;
          public frequency: number;
          public interval: number;
          this$0: Packages.arc.math.CumulativeDistribution<any>;
          public constructor(
            _this$0: Packages.arc.math.CumulativeDistribution<any>,
            _value: T,
            _frequency: number,
            _interval: number,
          );
        };
        private values: Packages.arc.struct.Seq<Packages.arc.math.CumulativeDistribution.CumulativeValue>;
        public add(_value: T): void;
        public add(_value: T, _intervalSize: number): void;
        public value(): T | null;
        public value(_probability: number): T | null;
        public clear(): void;
        public getValue(_index: number): T | null;
        public size(): number;
        public generate(): void;
        public generateNormalized(): void;
        public generateUniform(): void;
        public getInterval(_index: number): number;
        public setInterval(
          _obj: T,
          _intervalSize: number,
        ): void;
        public setInterval(
          _index: number,
          _intervalSize: number,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class ShortSeq extends java.lang.Object {
        public items: Packages.short[];
        public size: number;
        public ordered: boolean;
        public add(
          _value1: Packages.short,
          _value2: Packages.short,
        ): void;
        public add(
          _value1: Packages.short,
          _value2: Packages.short,
          _value3: Packages.short,
        ): void;
        public add(
          _value1: Packages.short,
          _value2: Packages.short,
          _value3: Packages.short,
          _value4: Packages.short,
        ): void;
        public add(_value: Packages.short): void;
        public add(_value: number): void;
        public get(_index: number): Packages.short;
        public equals(_object: any): boolean;
        public toString(_separator: string): string;
        public toString(): string;
        public hashCode(): number;
        public indexOf(_value: Packages.short): number;
        public insert(
          _index: number,
          _value: Packages.short,
        ): void;
        public clear(): void;
        public lastIndexOf(_value: string): number;
        public isEmpty(): boolean;
        public toArray(): Packages.short[] | null;
        public contains(_value: Packages.short): boolean;
        public addAll(
          _array: Packages.arc.struct.ShortSeq,
        ): void;
        public addAll(
          _array: Packages.short[],
          _offset: number,
          _length: number,
        ): void;
        public addAll(..._array: Packages.short[]): void;
        public addAll(
          _array: Packages.arc.struct.ShortSeq,
          _offset: number,
          _length: number,
        ): void;
        public first(): Packages.short;
        public set(
          _index: number,
          _value: Packages.short,
        ): void;
        public ensureCapacity(
          _additionalCapacity: number,
        ): Packages.short[] | null;
        public reverse(): void;
        public peek(): Packages.short;
        public sort(): void;
        public removeRange(
          _start: number,
          _end: number,
        ): void;
        public removeAll(
          _array: Packages.arc.struct.ShortSeq,
        ): boolean;
        protected resize(
          _newSize: number,
        ): Packages.short[] | null;
        public incr(
          _index: number,
          _value: Packages.short,
        ): void;
        public random(): Packages.short;
        public swap(_first: number, _second: number): void;
        public shuffle(): void;
        public pop(): Packages.short;
        public static with(
          ..._array: Packages.short[]
        ): Packages.arc.struct.ShortSeq;
        public setSize(
          _newSize: number,
        ): Packages.short[] | null;
        public mul(
          _index: number,
          _value: Packages.short,
        ): void;
        public truncate(_newSize: number): void;
        public shrink(): Packages.short[] | null;
        public removeIndex(_index: number): Packages.short;
        public removeValue(_value: Packages.short): boolean;
        public constructor(
          _ordered: boolean,
          _array: Packages.short[],
          _startIndex: number,
          _count: number,
        );
        public constructor(_array: Packages.short[]);
        public constructor(
          _array: Packages.arc.struct.ShortSeq,
        );
        public constructor();
        public constructor(_capacity: number);
        public constructor(
          _ordered: boolean,
          _capacity: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class BoolSeq extends java.lang.Object {
        public items: boolean[];
        public size: number;
        public ordered: boolean;
        public add(
          _value1: boolean,
          _value2: boolean,
        ): void;
        public add(
          _value1: boolean,
          _value2: boolean,
          _value3: boolean,
        ): void;
        public add(
          _value1: boolean,
          _value2: boolean,
          _value3: boolean,
          _value4: boolean,
        ): void;
        public add(_value: boolean): void;
        public get(_index: number): boolean;
        public equals(_object: any): boolean;
        public toString(_separator: string): string;
        public toString(): string;
        public hashCode(): number;
        public insert(
          _index: number,
          _value: boolean,
        ): void;
        public clear(): void;
        public isEmpty(): boolean;
        public toArray(): boolean[] | null;
        public addAll(
          _array: boolean[],
          _offset: number,
          _length: number,
        ): void;
        public addAll(
          _array: Packages.arc.struct.BoolSeq,
          _offset: number,
          _length: number,
        ): void;
        public addAll(
          _array: Packages.arc.struct.BoolSeq,
        ): void;
        public addAll(..._array: boolean[]): void;
        public first(): boolean;
        public set(_index: number, _value: boolean): void;
        public ensureCapacity(
          _additionalCapacity: number,
        ): boolean[] | null;
        public reverse(): void;
        public peek(): boolean;
        public removeRange(
          _start: number,
          _end: number,
        ): void;
        public removeAll(
          _array: Packages.arc.struct.BoolSeq,
        ): boolean;
        protected resize(
          _newSize: number,
        ): boolean[] | null;
        public random(): boolean;
        public swap(_first: number, _second: number): void;
        public shuffle(): void;
        public pop(): boolean;
        public static with(
          ..._array: boolean[]
        ): Packages.arc.struct.BoolSeq;
        public setSize(_newSize: number): boolean[] | null;
        public truncate(_newSize: number): void;
        public shrink(): boolean[] | null;
        public removeIndex(_index: number): boolean;
        public constructor(
          _ordered: boolean,
          _array: boolean[],
          _startIndex: number,
          _count: number,
        );
        public constructor(_array: boolean[]);
        public constructor(
          _array: Packages.arc.struct.BoolSeq,
        );
        public constructor();
        public constructor(_capacity: number);
        public constructor(
          _ordered: boolean,
          _capacity: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare class DelaunayTriangulator extends java.lang
        .Object {
        private static EPSILON: number;
        private static INSIDE: number;
        private static COMPLETE: number;
        private static INCOMPLETE: number;
        private quicksortStack: Packages.arc.struct.IntSeq;
        private triangles: Packages.arc.struct.ShortSeq;
        private originalIndices: Packages.arc.struct.ShortSeq;
        private edges: Packages.arc.struct.IntSeq;
        private complete: Packages.arc.struct.BoolSeq;
        private superTriangle: number[];
        private centroid: Packages.arc.math.geom.Vec2;
        private sortedPoints: number[];
        public trim(
          _triangles: Packages.arc.struct.ShortSeq,
          _points: number[],
          _hull: number[],
          _offset: number,
          _count: number,
        ): void;
        private sort(
          _values: number[],
          _count: number,
        ): void;
        public computeTriangles(
          _polygon: number[],
          _sorted: boolean,
        ): Packages.arc.struct.ShortSeq;
        public computeTriangles(
          _points: Packages.arc.struct.FloatSeq,
          _sorted: boolean,
        ): Packages.arc.struct.ShortSeq;
        public computeTriangles(
          _points: number[],
          _offset: number,
          _count: number,
          _sorted: boolean,
        ): Packages.arc.struct.ShortSeq;
        private circumCircle(
          _xp: number,
          _yp: number,
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
          _x3: number,
          _y3: number,
        ): number;
        private quicksortPartition(
          _values: number[],
          _lower: number,
          _upper: number,
          _originalIndices: Packages.short[],
        ): number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare class EarClippingTriangulator extends java
        .lang.Object {
        private static CONCAVE: number;
        private static CONVEX: number;
        private indicesArray: Packages.arc.struct.ShortSeq;
        private vertexTypes: Packages.arc.struct.IntSeq;
        private triangles: Packages.arc.struct.ShortSeq;
        private indices: Packages.short[];
        private vertices: number[];
        private vertexCount: number;
        private nextIndex(_index: number): number;
        private previousIndex(_index: number): number;
        public computeTriangles(
          _vertices: number[],
          _offset: number,
          _count: number,
        ): Packages.arc.struct.ShortSeq;
        public computeTriangles(
          _vertices: number[],
        ): Packages.arc.struct.ShortSeq;
        public computeTriangles(
          _vertices: Packages.arc.struct.FloatSeq,
        ): Packages.arc.struct.ShortSeq;
        private static areVerticesClockwise(
          _vertices: number[],
          _offset: number,
          _count: number,
        ): boolean;
        private classifyVertex(_index: number): number;
        private triangulate(): void;
        private findEarTip(): number;
        private cutEarTip(_earTipIndex: number): void;
        private static computeSpannedAreaSign(
          _p1x: number,
          _p1y: number,
          _p2x: number,
          _p2y: number,
          _p3x: number,
          _p3y: number,
        ): number;
        private isEarTip(_earTipIndex: number): boolean;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare class Extrapolator extends java.lang.Object {
        private snapPos: number[];
        private snapVel: number[];
        private aimPos: number[];
        private lastPacketPos: number[];
        private tmpArr: number[];
        private tmpArr2: number[];
        private snapTime: number;
        private aimTime: number;
        private lastPacketTime: number;
        private latency: number;
        private updateTime: number;
        private size: number;
        private clear(_arr: number[]): number[] | null;
        public reset(
          _packetTime: number,
          _curTime: number,
          _pos: number[],
          _vel: number[],
        ): void;
        public reset(
          _packetTime: number,
          _curTime: number,
          _pos: number[],
        ): void;
        public reset(
          _packetTime: number,
          _curTime: number,
          _pos: number,
        ): void;
        public reset(
          _packetTime: number,
          _curTime: number,
          _pos: number,
          _vel: number,
        ): void;
        public addSample(
          _packetTime: number,
          _curTime: number,
          _pos: number[],
        ): boolean;
        public addSample(
          _packetTime: number,
          _curTime: number,
          _pos: number[],
          _vel: number[],
        ): boolean;
        public addSample(
          _packetTime: number,
          _curTime: number,
          _pos: number,
        ): boolean;
        public addSample(
          _packetTime: number,
          _curTime: number,
          _pos: number,
          _vel: number,
        ): boolean;
        private estimates(
          _packet: number,
          _cur: number,
        ): boolean;
        private copyArray(
          _dest: number[],
          _src: number[],
        ): void;
        public readPosition(_forTime: number): number;
        public readPosition(
          _forTime: number,
          _outPos: number[],
        ): boolean;
        public readPosition(
          _forTime: number,
          _outPos: number[],
          _outVel: number[],
        ): boolean;
        private checkArraySizeOne(): void;
        public estimateLatency(): number;
        public estimateUpdateTime(): number;
        public constructor(_size: number);
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare class WindowedMean extends java.lang.Object {
        values: number[];
        addedValues: number;
        lastValue: number;
        dirty: boolean;
        public add(_value: number): void;
        public get(_index: number): number;
        public clear(): void;
        public fill(_value: number): void;
        public reset(): void;
        public getCount(): number;
        public mean(): number;
        public latest(): number;
        public hasEnoughData(): boolean;
        public rawMean(): number;
        public oldest(): number;
        public standardDeviation(): number;
        public lowest(): number;
        public highest(): number;
        public getWindowSize(): number;
        public getWindowValues(): number[] | null;
        public constructor(_windowSize: number);
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare class FloatCounter extends java.lang.Object {
        public mean: Packages.arc.math.WindowedMean;
        public count: number;
        public total: number;
        public min: number;
        public max: number;
        public average: number;
        public latest: number;
        public value: number;
        public put(_value: number): void;
        public reset(): void;
        public constructor(_windowSize: number);
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare class LinearRegression extends java.lang
        .Object {
        public intercept: number;
        public slope: number;
        public calculate(
          _v: Packages.arc.struct.Seq<Packages.arc.math.geom.Vec2>,
        ): void;
        public predict(_x: number): number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare class Mathf extends java.lang.Object {
        public static signs: number[];
        public static zeroOne: number[];
        public static booleans: boolean[];
        public static FLOAT_ROUNDING_ERROR: number;
        public static PI: number;
        public static pi: number;
        public static halfPi: number;
        public static PI2: number;
        public static E: number;
        public static sqrt2: number;
        public static sqrt3: number;
        public static radiansToDegrees: number;
        public static radDeg: number;
        public static degreesToRadians: number;
        public static degRad: number;
        public static doubleDegRad: number;
        public static doubleRadDeg: number;
        private static sinBits: number;
        private static sinMask: number;
        private static sinCount: number;
        private static sinTable: number[];
        private static radFull: number;
        private static degFull: number;
        private static radToIndex: number;
        private static degToIndex: number;
        private static BIG_ENOUGH_INT: number;
        private static BIG_ENOUGH_FLOOR: number;
        private static CEIL: number;
        private static BIG_ENOUGH_ROUND: number;
        private static seedr: Packages.arc.math.Rand;
        private static v1: Packages.arc.math.geom.Vec2;
        private static v2: Packages.arc.math.geom.Vec2;
        private static v3: Packages.arc.math.geom.Vec2;
        public static rand: Packages.arc.math.Rand;
        public static sin(
          _radians: number,
          _scl: number,
          _mag: number,
        ): number;
        public static sin(
          _scl: number,
          _mag: number,
        ): number;
        public static sin(_radians: number): number;
        public static cos(_radians: number): number;
        public static cos(
          _radians: number,
          _scl: number,
          _mag: number,
        ): number;
        public static tan(
          _radians: number,
          _scl: number,
          _mag: number,
        ): number;
        public static atan2(_x: number, _y: number): number;
        public static sqrt(_x: number): number;
        public static log(
          _a: number,
          _value: number,
        ): number;
        public static pow(_a: number, _b: number): number;
        public static pow(_a: number, _b: number): number;
        public static floor(_value: number): number;
        public static ceil(_value: number): number;
        public static map(
          _value: number,
          _froma: number,
          _toa: number,
          _fromb: number,
          _tob: number,
        ): number;
        public static map(
          _value: number,
          _from: number,
          _to: number,
        ): number;
        public static dst(
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
        ): number;
        public static dst(_x1: number, _y1: number): number;
        public static len(_x: number, _y: number): number;
        public static dot(
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
        ): number;
        public static mod(_f: number, _n: number): number;
        public static mod(_x: number, _n: number): number;
        public static zero(_value: number): boolean;
        public static zero(_value: number): boolean;
        public static zero(
          _value: number,
          _tolerance: number,
        ): boolean;
        public static num(_b: boolean): number;
        public static equal(
          _a: number,
          _b: number,
        ): boolean;
        public static equal(
          _a: number,
          _b: number,
          _tolerance: number,
        ): boolean;
        public static digits(_n: number): number;
        public static digits(_n: Packages.long): number;
        public static len2(_x: number, _y: number): number;
        public static round(_value: number): number;
        public static round(
          _value: number,
          _step: number,
        ): number;
        public static round(
          _value: number,
          _step: number,
        ): number;
        public static round(
          _value: number,
          _step: number,
        ): number;
        public static random(_range: number): number;
        public static random(
          _start: number,
          _end: number,
        ): number;
        public static random(): number;
        public static random(
          _start: number,
          _end: number,
        ): number;
        public static random(
          _range: Packages.long,
        ): Packages.long;
        public static random(
          _start: Packages.long,
          _end: Packages.long,
        ): Packages.long;
        public static random(_range: number): number;
        public static sign(_f: number): number;
        public static sign(_b: boolean): number;
        public static range(_range: number): number;
        public static range(
          _min: number,
          _max: number,
        ): number;
        public static range(_range: number): number;
        public static clamp(
          _value: Packages.long,
          _min: Packages.long,
          _max: Packages.long,
        ): Packages.long;
        public static clamp(
          _value: number,
          _min: number,
          _max: number,
        ): number;
        public static clamp(
          _value: number,
          _min: number,
          _max: number,
        ): number;
        public static clamp(_value: number): number;
        public static clamp(
          _value: number,
          _min: number,
          _max: number,
        ): number;
        public static chance(_d: number): boolean;
        public static nextPowerOfTwo(
          _value: number,
        ): number;
        public static angle(_x: number, _y: number): number;
        public static approach(
          _from: number,
          _to: number,
          _speed: number,
        ): number;
        public static lerp(
          _fromValue: number,
          _toValue: number,
          _progress: number,
        ): number;
        public static dst2(
          _x1: number,
          _y1: number,
        ): number;
        public static dst2(
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
        ): number;
        public static approachDelta(
          _from: number,
          _to: number,
          _speed: number,
        ): number;
        public static lerpDelta(
          _fromValue: number,
          _toValue: number,
          _progress: number,
        ): number;
        public static slope(_fin: number): number;
        public static within(
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
          _dst: number,
        ): boolean;
        public static within(
          _x1: number,
          _y1: number,
          _dst: number,
        ): boolean;
        public static cosDeg(_degrees: number): number;
        public static sinDeg(_degrees: number): number;
        public static slerp(
          _fromDegrees: number,
          _toDegrees: number,
          _progress: number,
        ): number;
        public static isPowerOfTwo(_value: number): boolean;
        public static absin(
          _scl: number,
          _mag: number,
        ): number;
        public static absin(
          _in: number,
          _scl: number,
          _mag: number,
        ): number;
        private static atn(_i: number): number;
        public static randomTriangular(
          _min: number,
          _max: number,
        ): number;
        public static randomTriangular(
          _max: number,
        ): number;
        public static randomTriangular(
          _min: number,
          _max: number,
          _mode: number,
        ): number;
        public static randomTriangular(): number;
        public static curveMargin(
          _f: number,
          _marginLeft: number,
          _marginRight: number,
        ): number;
        public static curveMargin(
          _f: number,
          _margin: number,
        ): number;
        public static arrive(
          _x: number,
          _y: number,
          _destX: number,
          _destY: number,
          _curVel: Packages.arc.math.geom.Vec2,
          _radius: number,
          _tolerance: number,
          _speed: number,
          _accel: number,
        ): Packages.arc.math.geom.Vec2;
        public static arrive(
          _pos: Packages.arc.math.geom.Position,
          _target: Packages.arc.math.geom.Position,
          _curVel: Packages.arc.math.geom.Vec2,
          _radius: number,
          _tolerance: number,
          _speed: number,
          _smoothTime: number,
        ): Packages.arc.math.geom.Vec2;
        public static angleExact(
          _x: number,
          _y: number,
        ): number;
        public static wrapAngleAroundZero(
          _a: number,
        ): number;
        public static sqr(_x: number): number;
        public static chanceDelta(_d: number): boolean;
        public static randomBoolean(): boolean;
        public static randomBoolean(
          _chance: number,
        ): boolean;
        public static randomSign(): number;
        public static randomSeed(
          _seed: Packages.long,
          _max: number,
        ): number;
        public static randomSeed(
          _seed: Packages.long,
        ): number;
        public static randomSeed(
          _seed: Packages.long,
          _min: number,
          _max: number,
        ): number;
        public static randomSeed(
          _seed: Packages.long,
          _min: number,
          _max: number,
        ): number;
        public static randomSeedRange(
          _seed: Packages.long,
          _range: number,
        ): number;
        public static maxZero(_val: number): number;
        public static slerpRad(
          _fromRadians: number,
          _toRadians: number,
          _progress: number,
        ): number;
        public static slerpDelta(
          _fromDegrees: number,
          _toDegrees: number,
          _progress: number,
        ): number;
        public static floorPositive(_value: number): number;
        public static ceilPositive(_value: number): number;
        public static roundPositive(_value: number): number;
        public static log2(_value: number): number;
        public static log2(_value: number): number;
        public static sample(
          _values: number[],
          _time: number,
        ): number;
        public static curve(
          _f: number,
          _from: number,
          _to: number,
        ): number;
        public static curve(
          _f: number,
          _offset: number,
        ): number;
        public static dstm(
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
        ): number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare abstract class Scaled {
        public fout(_i: Packages.arc.math.Interp): number;
        public fout(): number;
        public fout(_margin: number): number;
        public fin(_i: Packages.arc.math.Interp): number;
        public fin(): number;
        public finpow(): number;
        public foutpow(): number;
        public finpowdown(): number;
        public foutpowdown(): number;
        public fslope(): number;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace mock {
      declare class MockApplication
        extends java.lang.Object
        implements Packages.arc.Application
      {
        public exit(): void;
        public getType(): Packages.arc.Application.ApplicationType;
        public post(
          _runnable: Packages.java.lang.Runnable,
        ): void;
        public getListeners(): Packages.arc.struct.Seq<Packages.arc.ApplicationListener>;
        public getClipboardText(): string;
        public setClipboardText(_text: string): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace mock {
      declare class MockAudio extends Packages.arc.audio
        .Audio {
        protected initialize(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace mock {
      declare class MockFiles
        extends java.lang.Object
        implements Packages.arc.Files
      {
        public get(
          _fileName: string,
          _type: Packages.arc.Files.FileType,
        ): Packages.arc.files.Fi;
        public getExternalStoragePath(): string;
        public isExternalStorageAvailable(): boolean;
        public getLocalStoragePath(): string;
        public isLocalStorageAvailable(): boolean;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace mock {
      declare class MockGL20
        extends java.lang.Object
        implements Packages.arc.graphics.GL20
      {
        public glActiveTexture(_texture: number): void;
        public glBindTexture(
          _target: number,
          _texture: number,
        ): void;
        public glBlendFunc(
          _sfactor: number,
          _dfactor: number,
        ): void;
        public glClear(_mask: number): void;
        public glClearColor(
          _red: number,
          _green: number,
          _blue: number,
          _alpha: number,
        ): void;
        public glClearDepthf(_depth: number): void;
        public glClearStencil(_s: number): void;
        public glColorMask(
          _red: boolean,
          _green: boolean,
          _blue: boolean,
          _alpha: boolean,
        ): void;
        public glCompressedTexImage2D(
          _target: number,
          _level: number,
          _internalformat: number,
          _width: number,
          _height: number,
          _border: number,
          _imageSize: number,
          _data: Packages.java.nio.Buffer,
        ): void;
        public glCompressedTexSubImage2D(
          _target: number,
          _level: number,
          _xoffset: number,
          _yoffset: number,
          _width: number,
          _height: number,
          _format: number,
          _imageSize: number,
          _data: Packages.java.nio.Buffer,
        ): void;
        public glCopyTexImage2D(
          _target: number,
          _level: number,
          _internalformat: number,
          _x: number,
          _y: number,
          _width: number,
          _height: number,
          _border: number,
        ): void;
        public glCopyTexSubImage2D(
          _target: number,
          _level: number,
          _xoffset: number,
          _yoffset: number,
          _x: number,
          _y: number,
          _width: number,
          _height: number,
        ): void;
        public glCullFace(_mode: number): void;
        public glDeleteTexture(_texture: number): void;
        public glDepthFunc(_func: number): void;
        public glDepthMask(_flag: boolean): void;
        public glDepthRangef(
          _zNear: number,
          _zFar: number,
        ): void;
        public glDisable(_cap: number): void;
        public glDrawArrays(
          _mode: number,
          _first: number,
          _count: number,
        ): void;
        public glDrawElements(
          _mode: number,
          _count: number,
          _type: number,
          _indices: number,
        ): void;
        public glDrawElements(
          _mode: number,
          _count: number,
          _type: number,
          _indices: Packages.java.nio.Buffer,
        ): void;
        public glEnable(_cap: number): void;
        public glFinish(): void;
        public glFlush(): void;
        public glFrontFace(_mode: number): void;
        public glGenTexture(): number;
        public glGetError(): number;
        public glGetIntegerv(
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glGetString(_name: number): string;
        public glHint(_target: number, _mode: number): void;
        public glLineWidth(_width: number): void;
        public glPixelStorei(
          _pname: number,
          _param: number,
        ): void;
        public glPolygonOffset(
          _factor: number,
          _units: number,
        ): void;
        public glReadPixels(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
          _format: number,
          _type: number,
          _pixels: Packages.java.nio.Buffer,
        ): void;
        public glScissor(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
        ): void;
        public glStencilFunc(
          _func: number,
          _ref: number,
          _mask: number,
        ): void;
        public glStencilMask(_mask: number): void;
        public glStencilOp(
          _fail: number,
          _zfail: number,
          _zpass: number,
        ): void;
        public glTexImage2D(
          _target: number,
          _level: number,
          _internalformat: number,
          _width: number,
          _height: number,
          _border: number,
          _format: number,
          _type: number,
          _pixels: Packages.java.nio.Buffer,
        ): void;
        public glTexParameterf(
          _target: number,
          _pname: number,
          _param: number,
        ): void;
        public glTexSubImage2D(
          _target: number,
          _level: number,
          _xoffset: number,
          _yoffset: number,
          _width: number,
          _height: number,
          _format: number,
          _type: number,
          _pixels: Packages.java.nio.Buffer,
        ): void;
        public glViewport(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
        ): void;
        public glAttachShader(
          _program: number,
          _shader: number,
        ): void;
        public glBindAttribLocation(
          _program: number,
          _index: number,
          _name: string,
        ): void;
        public glBindBuffer(
          _target: number,
          _buffer: number,
        ): void;
        public glBindFramebuffer(
          _target: number,
          _framebuffer: number,
        ): void;
        public glBindRenderbuffer(
          _target: number,
          _renderbuffer: number,
        ): void;
        public glBlendColor(
          _red: number,
          _green: number,
          _blue: number,
          _alpha: number,
        ): void;
        public glBlendEquation(_mode: number): void;
        public glBlendEquationSeparate(
          _modeRGB: number,
          _modeAlpha: number,
        ): void;
        public glBlendFuncSeparate(
          _srcRGB: number,
          _dstRGB: number,
          _srcAlpha: number,
          _dstAlpha: number,
        ): void;
        public glBufferData(
          _target: number,
          _size: number,
          _data: Packages.java.nio.Buffer,
          _usage: number,
        ): void;
        public glBufferSubData(
          _target: number,
          _offset: number,
          _size: number,
          _data: Packages.java.nio.Buffer,
        ): void;
        public glCheckFramebufferStatus(
          _target: number,
        ): number;
        public glCompileShader(_shader: number): void;
        public glCreateProgram(): number;
        public glCreateShader(_type: number): number;
        public glDeleteBuffer(_buffer: number): void;
        public glDeleteFramebuffer(
          _framebuffer: number,
        ): void;
        public glDeleteProgram(_program: number): void;
        public glDeleteRenderbuffer(
          _renderbuffer: number,
        ): void;
        public glDeleteShader(_shader: number): void;
        public glDetachShader(
          _program: number,
          _shader: number,
        ): void;
        public glDisableVertexAttribArray(
          _index: number,
        ): void;
        public glEnableVertexAttribArray(
          _index: number,
        ): void;
        public glFramebufferRenderbuffer(
          _target: number,
          _attachment: number,
          _renderbuffertarget: number,
          _renderbuffer: number,
        ): void;
        public glFramebufferTexture2D(
          _target: number,
          _attachment: number,
          _textarget: number,
          _texture: number,
          _level: number,
        ): void;
        public glGenBuffer(): number;
        public glGenerateMipmap(_target: number): void;
        public glGenFramebuffer(): number;
        public glGenRenderbuffer(): number;
        public glGetActiveAttrib(
          _program: number,
          _index: number,
          _size: Packages.java.nio.IntBuffer,
          _type: Packages.java.nio.IntBuffer,
        ): string;
        public glGetActiveUniform(
          _program: number,
          _index: number,
          _size: Packages.java.nio.IntBuffer,
          _type: Packages.java.nio.IntBuffer,
        ): string;
        public glGetAttribLocation(
          _program: number,
          _name: string,
        ): number;
        public glGetBooleanv(
          _pname: number,
          _params: Packages.java.nio.Buffer,
        ): void;
        public glGetBufferParameteriv(
          _target: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glGetFloatv(
          _pname: number,
          _params: Packages.java.nio.FloatBuffer,
        ): void;
        public glGetFramebufferAttachmentParameteriv(
          _target: number,
          _attachment: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glGetProgramiv(
          _program: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glGetProgramInfoLog(
          _program: number,
        ): string;
        public glGetRenderbufferParameteriv(
          _target: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glGetShaderiv(
          _shader: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glGetShaderInfoLog(_shader: number): string;
        public glGetShaderPrecisionFormat(
          _shadertype: number,
          _precisiontype: number,
          _range: Packages.java.nio.IntBuffer,
          _precision: Packages.java.nio.IntBuffer,
        ): void;
        public glGetTexParameterfv(
          _target: number,
          _pname: number,
          _params: Packages.java.nio.FloatBuffer,
        ): void;
        public glGetTexParameteriv(
          _target: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glGetUniformfv(
          _program: number,
          _location: number,
          _params: Packages.java.nio.FloatBuffer,
        ): void;
        public glGetUniformiv(
          _program: number,
          _location: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glGetUniformLocation(
          _program: number,
          _name: string,
        ): number;
        public glGetVertexAttribfv(
          _index: number,
          _pname: number,
          _params: Packages.java.nio.FloatBuffer,
        ): void;
        public glGetVertexAttribiv(
          _index: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glIsBuffer(_buffer: number): boolean;
        public glIsEnabled(_cap: number): boolean;
        public glIsFramebuffer(
          _framebuffer: number,
        ): boolean;
        public glIsProgram(_program: number): boolean;
        public glIsRenderbuffer(
          _renderbuffer: number,
        ): boolean;
        public glIsShader(_shader: number): boolean;
        public glIsTexture(_texture: number): boolean;
        public glLinkProgram(_program: number): void;
        public glReleaseShaderCompiler(): void;
        public glRenderbufferStorage(
          _target: number,
          _internalformat: number,
          _width: number,
          _height: number,
        ): void;
        public glSampleCoverage(
          _value: number,
          _invert: boolean,
        ): void;
        public glShaderSource(
          _shader: number,
          _string: string,
        ): void;
        public glStencilFuncSeparate(
          _face: number,
          _func: number,
          _ref: number,
          _mask: number,
        ): void;
        public glStencilMaskSeparate(
          _face: number,
          _mask: number,
        ): void;
        public glStencilOpSeparate(
          _face: number,
          _fail: number,
          _zfail: number,
          _zpass: number,
        ): void;
        public glTexParameterfv(
          _target: number,
          _pname: number,
          _params: Packages.java.nio.FloatBuffer,
        ): void;
        public glTexParameteri(
          _target: number,
          _pname: number,
          _param: number,
        ): void;
        public glTexParameteriv(
          _target: number,
          _pname: number,
          _params: Packages.java.nio.IntBuffer,
        ): void;
        public glUniform1f(
          _location: number,
          _x: number,
        ): void;
        public glUniform1fv(
          _location: number,
          _count: number,
          _v: number[],
          _offset: number,
        ): void;
        public glUniform1fv(
          _location: number,
          _count: number,
          _v: Packages.java.nio.FloatBuffer,
        ): void;
        public glUniform1i(
          _location: number,
          _x: number,
        ): void;
        public glUniform1iv(
          _location: number,
          _count: number,
          _v: number[],
          _offset: number,
        ): void;
        public glUniform1iv(
          _location: number,
          _count: number,
          _v: Packages.java.nio.IntBuffer,
        ): void;
        public glUniform2f(
          _location: number,
          _x: number,
          _y: number,
        ): void;
        public glUniform2fv(
          _location: number,
          _count: number,
          _v: number[],
          _offset: number,
        ): void;
        public glUniform2fv(
          _location: number,
          _count: number,
          _v: Packages.java.nio.FloatBuffer,
        ): void;
        public glUniform2i(
          _location: number,
          _x: number,
          _y: number,
        ): void;
        public glUniform2iv(
          _location: number,
          _count: number,
          _v: Packages.java.nio.IntBuffer,
        ): void;
        public glUniform2iv(
          _location: number,
          _count: number,
          _v: number[],
          _offset: number,
        ): void;
        public glUniform3f(
          _location: number,
          _x: number,
          _y: number,
          _z: number,
        ): void;
        public glUniform3fv(
          _location: number,
          _count: number,
          _v: number[],
          _offset: number,
        ): void;
        public glUniform3fv(
          _location: number,
          _count: number,
          _v: Packages.java.nio.FloatBuffer,
        ): void;
        public glUniform3i(
          _location: number,
          _x: number,
          _y: number,
          _z: number,
        ): void;
        public glUniform3iv(
          _location: number,
          _count: number,
          _v: number[],
          _offset: number,
        ): void;
        public glUniform3iv(
          _location: number,
          _count: number,
          _v: Packages.java.nio.IntBuffer,
        ): void;
        public glUniform4f(
          _location: number,
          _x: number,
          _y: number,
          _z: number,
          _w: number,
        ): void;
        public glUniform4fv(
          _location: number,
          _count: number,
          _v: Packages.java.nio.FloatBuffer,
        ): void;
        public glUniform4fv(
          _location: number,
          _count: number,
          _v: number[],
          _offset: number,
        ): void;
        public glUniform4i(
          _location: number,
          _x: number,
          _y: number,
          _z: number,
          _w: number,
        ): void;
        public glUniform4iv(
          _location: number,
          _count: number,
          _v: number[],
          _offset: number,
        ): void;
        public glUniform4iv(
          _location: number,
          _count: number,
          _v: Packages.java.nio.IntBuffer,
        ): void;
        public glUniformMatrix2fv(
          _location: number,
          _count: number,
          _transpose: boolean,
          _value: number[],
          _offset: number,
        ): void;
        public glUniformMatrix2fv(
          _location: number,
          _count: number,
          _transpose: boolean,
          _value: Packages.java.nio.FloatBuffer,
        ): void;
        public glUniformMatrix3fv(
          _location: number,
          _count: number,
          _transpose: boolean,
          _value: number[],
          _offset: number,
        ): void;
        public glUniformMatrix3fv(
          _location: number,
          _count: number,
          _transpose: boolean,
          _value: Packages.java.nio.FloatBuffer,
        ): void;
        public glUniformMatrix4fv(
          _location: number,
          _count: number,
          _transpose: boolean,
          _value: number[],
          _offset: number,
        ): void;
        public glUniformMatrix4fv(
          _location: number,
          _count: number,
          _transpose: boolean,
          _value: Packages.java.nio.FloatBuffer,
        ): void;
        public glUseProgram(_program: number): void;
        public glValidateProgram(_program: number): void;
        public glVertexAttrib1f(
          _indx: number,
          _x: number,
        ): void;
        public glVertexAttrib1fv(
          _indx: number,
          _values: Packages.java.nio.FloatBuffer,
        ): void;
        public glVertexAttrib2f(
          _indx: number,
          _x: number,
          _y: number,
        ): void;
        public glVertexAttrib2fv(
          _indx: number,
          _values: Packages.java.nio.FloatBuffer,
        ): void;
        public glVertexAttrib3f(
          _indx: number,
          _x: number,
          _y: number,
          _z: number,
        ): void;
        public glVertexAttrib3fv(
          _indx: number,
          _values: Packages.java.nio.FloatBuffer,
        ): void;
        public glVertexAttrib4f(
          _indx: number,
          _x: number,
          _y: number,
          _z: number,
          _w: number,
        ): void;
        public glVertexAttrib4fv(
          _indx: number,
          _values: Packages.java.nio.FloatBuffer,
        ): void;
        public glVertexAttribPointer(
          _indx: number,
          _size: number,
          _type: number,
          _normalized: boolean,
          _stride: number,
          _ptr: number,
        ): void;
        public glVertexAttribPointer(
          _indx: number,
          _size: number,
          _type: number,
          _normalized: boolean,
          _stride: number,
          _ptr: Packages.java.nio.Buffer,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace mock {
      declare class MockGraphics extends Packages.arc
        .Graphics {
        frameId: Packages.long;
        deltaTime: number;
        frameStart: Packages.long;
        frames: number;
        fps: number;
        lastTime: Packages.long;
        glVersion: Packages.arc.graphics.gl.GLVersion;
        public updateTime(): void;
        public getWidth(): number;
        public getHeight(): number;
        public newCursor(
          _pixmap: Packages.arc.graphics.Pixmap,
          _xHotspot: number,
          _yHotspot: number,
        ): Packages.arc.Graphics.Cursor;
        public setCursor(
          _cursor: Packages.arc.Graphics.Cursor,
        ): void;
        public setSystemCursor(
          _systemCursor: Packages.arc.Graphics.Cursor.SystemCursor,
        ): void;
        public isGL30Available(): boolean;
        public getGL20(): Packages.arc.graphics.GL20;
        public setGL20(
          _gl20: Packages.arc.graphics.GL20,
        ): void;
        public getGL30(): Packages.arc.graphics.GL30;
        public setGL30(
          _gl30: Packages.arc.graphics.GL30,
        ): void;
        public getBackBufferWidth(): number;
        public getBackBufferHeight(): number;
        public getFrameId(): Packages.long;
        public getDeltaTime(): number;
        public getFramesPerSecond(): number;
        public getGLVersion(): Packages.arc.graphics.gl.GLVersion;
        public getPpiX(): number;
        public getPpiY(): number;
        public getPpcX(): number;
        public getPpcY(): number;
        public getDensity(): number;
        public setFullscreen(): boolean;
        public setWindowedMode(
          _width: number,
          _height: number,
        ): boolean;
        public setTitle(_title: string): void;
        public setBorderless(_undecorated: boolean): void;
        public setResizable(_resizable: boolean): void;
        public setVSync(_vsync: boolean): void;
        public getBufferFormat(): Packages.arc.Graphics.BufferFormat;
        public supportsExtension(
          _extension: string,
        ): boolean;
        public isContinuousRendering(): boolean;
        public setContinuousRendering(
          _isContinuous: boolean,
        ): void;
        public requestRendering(): void;
        public isFullscreen(): boolean;
        public incrementFrameId(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace mock {
      declare class MockInput extends Packages.arc.Input {
        public mouseX(_pointer: number): number;
        public mouseX(): number;
        public mouseY(_pointer: number): number;
        public mouseY(): number;
        public isTouched(): boolean;
        public isTouched(_pointer: number): boolean;
        public deltaX(_pointer: number): number;
        public deltaX(): number;
        public deltaY(): number;
        public deltaY(_pointer: number): number;
        public justTouched(): boolean;
        public getCurrentEventTime(): Packages.long;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace mock {
      declare class MockSettings extends Packages.arc
        .Settings {
        public load(): void;
        public forceSave(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace net {
      declare class ArcNet extends java.lang.Object {
        public static errorHandler: Packages.arc.func.Cons<Packages.java.lang.Throwable>;
        public static handleError(
          _e: Packages.java.lang.Throwable,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace net {
      declare class ArcNetException extends Packages.java
        .lang.RuntimeException {
        public constructor(
          _cause: Packages.java.lang.Throwable,
        );
        public constructor(_message: string);
        public constructor(
          _message: string,
          _cause: Packages.java.lang.Throwable,
        );
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace net {
      declare class DcReason extends Packages.java.lang
        .Enum<Packages.arc.net.DcReason> {
        public static timeout: Packages.arc.net.DcReason;
        public static closed: Packages.arc.net.DcReason;
        public static error: Packages.arc.net.DcReason;
        private static $VALUES: Packages.arc.net.DcReason[];
        public static values():
          | Packages.arc.net.DcReason[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.arc.net.DcReason;
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare namespace concurrent {
        declare abstract class ScheduledExecutorService {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare class LinkedList<E> {}
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace net {
      declare abstract class NetListener {
        public static LagListener = class extends Packages
          .arc.net.NetListener.QueuedListener {
          private threadPool: Packages.java.util.concurrent.ScheduledExecutorService;
          private lagMillisMin: number;
          private lagMillisMax: number;
          runnables: Packages.java.util.LinkedList<Packages.java.lang.Runnable>;
          public queue(
            _runnable: Packages.java.lang.Runnable,
          ): void;
          public constructor(
            _lagMillisMin: number,
            _lagMillisMax: number,
            _listener: Packages.arc.net.NetListener,
          );
        };
        public static ThreadedListener = class extends Packages
          .arc.net.NetListener.QueuedListener {
          protected threadPool: Packages.java.util.concurrent.ExecutorService;
          public queue(
            _runnable: Packages.java.lang.Runnable,
          ): void;
          public constructor(
            _listener: Packages.arc.net.NetListener,
          );
          public constructor(
            _listener: Packages.arc.net.NetListener,
            _threadPool: Packages.java.util.concurrent.ExecutorService,
          );
        };
        public static QueuedListener = class
          extends java.lang.Object
          implements Packages.arc.net.NetListener
        {
          listener: Packages.arc.net.NetListener;
          protected queue(
            _runnable: Packages.java.lang.Runnable,
          ): void;
          public connected(
            _connection: Packages.arc.net.Connection,
          ): void;
          public disconnected(
            _connection: Packages.arc.net.Connection,
            _reason: Packages.arc.net.DcReason,
          ): void;
          public idle(
            _connection: Packages.arc.net.Connection,
          ): void;
          public received(
            _connection: Packages.arc.net.Connection,
            _object: any,
          ): void;
          public constructor(
            _listener: Packages.arc.net.NetListener,
          );
        };
        public connected(
          _connection: Packages.arc.net.Connection,
        ): void;
        public disconnected(
          _connection: Packages.arc.net.Connection,
          _reason: Packages.arc.net.DcReason,
        ): void;
        public idle(
          _connection: Packages.arc.net.Connection,
        ): void;
        public received(
          _connection: Packages.arc.net.Connection,
          _object: any,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare class Thread {}
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace net {
      declare abstract class EndPoint
        implements Packages.java.lang.Runnable
      {
        public run(): void;
        public update(_timeout: number): void;
        public start(): void;
        public stop(): void;
        public close(): void;
        public addListener(
          _listener: Packages.arc.net.NetListener,
        ): void;
        public removeListener(
          _listener: Packages.arc.net.NetListener,
        ): void;
        public getUpdateThread(): Packages.java.lang.Thread;
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace nio {
      declare namespace channels {
        declare abstract class SocketChannel {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace net {
      declare abstract class NetSerializer {
        public write(
          _buffer: Packages.java.nio.ByteBuffer,
          _object: any,
        ): void;
        public read(
          _buffer: Packages.java.nio.ByteBuffer,
        ): any;
        public getLengthLength(): number;
        public readLength(
          _buffer: Packages.java.nio.ByteBuffer,
        ): number;
        public writeLength(
          _buffer: Packages.java.nio.ByteBuffer,
          _length: number,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace nio {
      declare namespace channels {
        declare abstract class SelectionKey {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace nio {
      declare namespace channels {
        declare abstract class Selector {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace net {
      declare abstract class SocketAddress {}
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace net {
      declare class TcpConnection extends java.lang.Object {
        socketChannel: Packages.java.nio.channels.SocketChannel;
        keepAliveMillis: number;
        readBuffer: Packages.java.nio.ByteBuffer;
        writeBuffer: Packages.java.nio.ByteBuffer;
        timeoutMillis: number;
        idleThreshold: number;
        serialization: Packages.arc.net.NetSerializer;
        private selectionKey: Packages.java.nio.channels.SelectionKey;
        private lastWriteTime: Packages.long;
        private lastReadTime: Packages.long;
        private currentObjectLength: number;
        private writeLock: any;
        public readObject(): any;
        public connect(
          _selector: Packages.java.nio.channels.Selector,
          _remoteAddress: Packages.java.net.SocketAddress,
          _timeout: number,
        ): void;
        public accept(
          _selector: Packages.java.nio.channels.Selector,
          _socketChannel: Packages.java.nio.channels.SocketChannel,
        ): Packages.java.nio.channels.SelectionKey;
        public close(): void;
        public send(_object: any): number;
        public writeOperation(): void;
        public isTimedOut(_time: Packages.long): boolean;
        public needsKeepAlive(
          _time: Packages.long,
        ): boolean;
        private writeToSocket(): boolean;
        public constructor(
          _serialization: Packages.arc.net.NetSerializer,
          _writeBufferSize: number,
          _objectBufferSize: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace nio {
      declare namespace channels {
        declare abstract class DatagramChannel {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace net {
      declare class UdpConnection extends java.lang.Object {
        connectedAddress: Packages.java.net.InetSocketAddress;
        datagramChannel: Packages.java.nio.channels.DatagramChannel;
        keepAliveMillis: number;
        readBuffer: Packages.java.nio.ByteBuffer;
        writeBuffer: Packages.java.nio.ByteBuffer;
        private serialization: Packages.arc.net.NetSerializer;
        private selectionKey: Packages.java.nio.channels.SelectionKey;
        private writeLock: any;
        private lastCommunicationTime: Packages.long;
        public readObject(): any;
        public connect(
          _selector: Packages.java.nio.channels.Selector,
          _remoteAddress: Packages.java.net.InetSocketAddress,
        ): void;
        public close(): void;
        public bind(
          _selector: Packages.java.nio.channels.Selector,
          _localPort: Packages.java.net.InetSocketAddress,
        ): void;
        public send(
          _object: any,
          _address: Packages.java.net.SocketAddress,
        ): number;
        public readFromAddress(): Packages.java.net.InetSocketAddress;
        public needsKeepAlive(
          _time: Packages.long,
        ): boolean;
        public constructor(
          _serialization: Packages.arc.net.NetSerializer,
          _bufferSize: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace net {
      declare class Connection extends java.lang.Object {
        id: number;
        private name: string;
        endPoint: Packages.arc.net.EndPoint;
        tcp: Packages.arc.net.TcpConnection;
        udp: Packages.arc.net.UdpConnection;
        udpRemoteAddress: Packages.java.net.InetSocketAddress;
        private listeners: Packages.arc.net.NetListener[];
        private listenerLock: any;
        private lastPingID: number;
        private lastPingSendTime: Packages.long;
        private returnTripTime: number;
        lastProtocolError: Packages.arc.net.ArcNetException;
        private arbitraryData: any;
        public toString(): string;
        initialize(
          _serialization: Packages.arc.net.NetSerializer,
          _writeBufferSize: number,
          _objectBufferSize: number,
        ): void;
        public setName(_name: string): void;
        public close(
          _reason: Packages.arc.net.DcReason,
        ): void;
        public getID(): number;
        public addListener(
          _listener: Packages.arc.net.NetListener,
        ): void;
        public removeListener(
          _listener: Packages.arc.net.NetListener,
        ): void;
        setConnected(_isConnected: boolean): void;
        notifyConnected(): void;
        public isConnected(): boolean;
        notifyReceived(_object: any): void;
        public isIdle(): boolean;
        notifyIdle(): void;
        public sendTCP(_object: any): number;
        public sendUDP(_object: any): number;
        notifyDisconnected(
          _reason: Packages.arc.net.DcReason,
        ): void;
        public getLastProtocolError(): Packages.arc.net.ArcNetException;
        public updateReturnTripTime(): void;
        public getReturnTripTime(): number;
        public setKeepAliveTCP(
          _keepAliveMillis: number,
        ): void;
        public setTimeout(_timeoutMillis: number): void;
        public getEndPoint(): Packages.arc.net.EndPoint;
        public getRemoteAddressTCP(): Packages.java.net.InetSocketAddress;
        public getRemoteAddressUDP(): Packages.java.net.InetSocketAddress;
        public getTcpWriteBufferSize(): number;
        public setIdleThreshold(
          _idleThreshold: number,
        ): void;
        public getArbitraryData(): any;
        public setArbitraryData(_arbitraryData: any): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace net {
      declare class InetAddress {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace net {
      declare class DatagramPacket {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace net {
      declare class DatagramSocket {}
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace net {
      declare class Client
        extends Packages.arc.net.Connection
        implements Packages.arc.net.EndPoint
      {
        private serialization: Packages.arc.net.NetSerializer;
        private selector: Packages.java.nio.channels.Selector;
        private emptySelects: number;
        private tcpRegistered: boolean;
        private udpRegistered: boolean;
        private tcpRegistrationLock: any;
        private udpRegistrationLock: any;
        private shutdown: boolean;
        private updateLock: any;
        private updateThread: Packages.java.lang.Thread;
        private connectTimeout: number;
        private connectHost: Packages.java.net.InetAddress;
        private connectTcpPort: number;
        private connectUdpPort: number;
        private isClosed: boolean;
        private discoverExecutor: Packages.java.util.concurrent.ExecutorService;
        private discoveryPacket: Packages.arc.func.Prov<Packages.java.net.DatagramPacket>;
        public run(): void;
        public update(_timeout: number): void;
        public start(): void;
        public connect(
          _timeout: number,
          _host: string,
          _tcpPort: number,
          _udpPort: number,
        ): void;
        public connect(
          _timeout: number,
          _host: string,
          _tcpPort: number,
        ): void;
        public connect(
          _timeout: number,
          _host: Packages.java.net.InetAddress,
          _tcpPort: number,
        ): void;
        public connect(
          _timeout: number,
          _host: Packages.java.net.InetAddress,
          _tcpPort: number,
          _udpPort: number,
        ): void;
        public stop(): void;
        public close(): void;
        private broadcast(
          _udpPort: number,
          _socket: Packages.java.net.DatagramSocket,
        ): void;
        keepAlive(): void;
        public dispose(): void;
        public getUpdateThread(): Packages.java.lang.Thread;
        public reconnect(_timeout: number): void;
        public reconnect(): void;
        public setDiscoveryPacket(
          _discoveryPacket: Packages.arc.func.Prov<Packages.java.net.DatagramPacket>,
        ): void;
        public setKeepAliveUDP(
          _keepAliveMillis: number,
        ): void;
        public getSerialization(): Packages.arc.net.NetSerializer;
        public discoverHosts(
          _udpPort: number,
          _multicastGroup: string,
          _multicastPort: number,
          _timeoutMillis: number,
          _handler: Packages.arc.func.Cons<Packages.java.net.DatagramPacket>,
          _done: Packages.java.lang.Runnable,
        ): void;
        public constructor(
          _writeBufferSize: number,
          _objectBufferSize: number,
          _serialization: Packages.arc.net.NetSerializer,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace net {
      declare abstract class ClientDiscoveryHandler {
        public finish(): void;
        public newDatagramPacket(): Packages.java.net.DatagramPacket;
        public discoveredHost(
          _datagramPacket: Packages.java.net.DatagramPacket,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace net {
      declare abstract class FrameworkMessage {
        public static KeepAlive = class
          extends java.lang.Object
          implements Packages.arc.net.FrameworkMessage
        {
          public constructor();
        };
        public static DiscoverHost = class
          extends java.lang.Object
          implements Packages.arc.net.FrameworkMessage
        {
          public constructor();
        };
        public static Ping = class
          extends java.lang.Object
          implements Packages.arc.net.FrameworkMessage
        {
          public id: number;
          public isReply: boolean;
          public constructor();
        };
        public static RegisterUDP = class
          extends java.lang.Object
          implements Packages.arc.net.FrameworkMessage
        {
          public connectionID: number;
          public constructor();
        };
        public static RegisterTCP = class
          extends java.lang.Object
          implements Packages.arc.net.FrameworkMessage
        {
          public connectionID: number;
          public constructor();
        };
        public static keepAlive: Packages.arc.net.FrameworkMessage.KeepAlive;
        public static discoverHost: Packages.arc.net.FrameworkMessage.DiscoverHost;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace net {
      declare abstract class TcpIdleSender
        extends java.lang.Object
        implements Packages.arc.net.NetListener
      {
        started: boolean;
        protected next(): any;
        protected start(): void;
        public idle(
          _connection: Packages.arc.net.Connection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace net {
      declare abstract class InputStreamSender extends Packages
        .arc.net.TcpIdleSender {
        private input: Packages.java.io.InputStream;
        private chunk: string[];
        protected next(): any;
        protected next(_chunk: string[]): any;
        public constructor(
          _input: Packages.java.io.InputStream,
          _chunkSize: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace net {
      declare class MulticastSocket {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace nio {
      declare namespace channels {
        declare abstract class ServerSocketChannel {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class IntMap<V>
        extends java.lang.Object
        implements
          Packages.java.lang.Iterable<
            Packages.arc.struct.IntMap.Entry<V>
          >
      {
        public static Entries = class<V>
          extends Packages.arc.struct.IntMap.MapIterator<V>
          implements
            Packages.java.lang.Iterable<
              Packages.arc.struct.IntMap.Entry<V>
            >,
            Packages.java.util.Iterator<
              Packages.arc.struct.IntMap.Entry<V>
            >
        {
          private entry: Packages.arc.struct.IntMap.Entry<V>;
          public remove(): void;
          public iterator(): Packages.java.util.Iterator<
            Packages.arc.struct.IntMap.Entry<V>
          >;
          public hasNext(): boolean;
          public next(): any;
          public next(): Packages.arc.struct.IntMap.Entry<V>;
          public reset(): void;
          public constructor(
            _map: Packages.arc.struct.IntMap<any>,
          );
        };
        public static Entry = class<V> extends java.lang
          .Object {
          public key: number;
          public value: V;
          public toString(): string;
          public constructor();
        };
        public static Values = class<V>
          extends Packages.arc.struct.IntMap.MapIterator<V>
          implements
            Packages.java.util.Iterator<V>,
            Packages.java.lang.Iterable<V>
        {
          public remove(): void;
          public toArray(): Packages.arc.struct.Seq<V>;
          public iterator(): Packages.java.util.Iterator<V>;
          public hasNext(): boolean;
          public next(): V | null;
          public reset(): void;
          public constructor(
            _map: Packages.arc.struct.IntMap<V>,
          );
        };
        public static Keys = class extends Packages.arc
          .struct.IntMap.MapIterator<any> {
          public remove(): void;
          public toArray(): Packages.arc.struct.IntSeq;
          public next(): number;
          public reset(): void;
          public constructor(
            _map: Packages.arc.struct.IntMap<any>,
          );
        };
        private static MapIterator = class<V> extends java
          .lang.Object {
          static INDEX_ILLEGAL: number;
          static INDEX_ZERO: number;
          map: Packages.arc.struct.IntMap<V>;
          public hasNext: boolean;
          nextIndex: number;
          currentIndex: number;
          valid: boolean;
          public remove(): void;
          public reset(): void;
          findNextIndex(): void;
          public constructor(
            _map: Packages.arc.struct.IntMap<V>,
          );
        };
        private static PRIME1: number;
        private static PRIME2: number;
        private static PRIME3: number;
        private static EMPTY: number;
        public size: number;
        keyTable: number[];
        valueTable: V[];
        capacity: number;
        stashSize: number;
        zeroValue: V;
        hasZeroValue: boolean;
        private loadFactor: number;
        private hashShift: number;
        private mask: number;
        private threshold: number;
        private stashCapacity: number;
        private pushIterations: number;
        private entries1: Packages.arc.struct.IntMap.Entries<any>;
        private entries2: Packages.arc.struct.IntMap.Entries<any>;
        private values1: Packages.arc.struct.IntMap.Values<any>;
        private values2: Packages.arc.struct.IntMap.Values<any>;
        private keys1: Packages.arc.struct.IntMap.Keys;
        private keys2: Packages.arc.struct.IntMap.Keys;
        public remove(_key: number): V | null;
        public get(
          _key: number,
          _defaultValue: Packages.arc.func.Prov<V>,
        ): V | null;
        public get(
          _key: number,
          _defaultValue: V,
        ): V | null;
        public get(_key: number): V | null;
        public put(_key: number, _value: V): V | null;
        public equals(_obj: any): boolean;
        public toString(): string;
        public values(): Packages.arc.struct.IntMap.Values<V>;
        public hashCode(): number;
        public clear(): void;
        public clear(_maximumCapacity: number): void;
        public isEmpty(): boolean;
        public iterator(): Packages.java.util.Iterator<
          Packages.arc.struct.IntMap.Entry<V>
        >;
        public static of<V>(
          ..._values: any[]
        ): Packages.arc.struct.IntMap<V>;
        public putAll(
          _map: Packages.arc.struct.IntMap<any>,
        ): void;
        public containsKey(_key: number): boolean;
        public keys(): Packages.arc.struct.IntMap.Keys;
        public containsValue(
          _value: any,
          _identity: boolean,
        ): boolean;
        public entries(): Packages.arc.struct.IntMap.Entries<V>;
        public ensureCapacity(
          _additionalCapacity: number,
        ): void;
        private resize(_newSize: number): void;
        private push(
          _insertKey: number,
          _insertValue: V,
          _index1: number,
          _key1: number,
          _index2: number,
          _key2: number,
          _index3: number,
          _key3: number,
        ): void;
        public shrink(_maximumCapacity: number): void;
        private hash2(_h: number): number;
        private hash3(_h: number): number;
        private putStash(_key: number, _value: V): void;
        private putResize(_key: number, _value: V): void;
        private getStash(
          _key: number,
          _defaultValue: V,
        ): V | null;
        removeStash(_key: number): V | null;
        removeStashIndex(_index: number): void;
        private containsKeyStash(_key: number): boolean;
        public findKey(
          _value: any,
          _identity: boolean,
          _notFound: number,
        ): number;
        public constructor(
          _initialCapacity: number,
          _loadFactor: number,
        );
        public constructor(_initialCapacity: number);
        public constructor();
        public constructor(
          _map: Packages.arc.struct.IntMap<any>,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace net {
      declare abstract class ServerDiscoveryHandler {
        public static ReponseHandler = class {
          public respond(
            _buffer: Packages.java.nio.ByteBuffer,
          ): void;
        };
        public onDiscoverReceived(
          _address: Packages.java.net.InetAddress,
          _handler: Packages.arc.net.ServerDiscoveryHandler.ReponseHandler,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace net {
      declare class Server
        extends java.lang.Object
        implements Packages.arc.net.EndPoint
      {
        public static ServerConnectFilter = class {
          public accept(_address: string): boolean;
        };
        DiscoveryReceiver = class extends java.lang.Object {
          socket: Packages.java.net.MulticastSocket;
          multicastThread: Packages.java.lang.Thread;
          multicastPort: number;
          this$0: Packages.arc.net.Server;
          start(): void;
          close(): void;
        };
        private serializer: Packages.arc.net.NetSerializer;
        private writeBufferSize: number;
        private objectBufferSize: number;
        private selector: Packages.java.nio.channels.Selector;
        private emptySelects: number;
        private serverChannel: Packages.java.nio.channels.ServerSocketChannel;
        private udp: Packages.arc.net.UdpConnection;
        private connections: Packages.arc.net.Connection[];
        private udpAddressToConnection: Packages.arc.struct.ObjectMap<
          Packages.java.net.InetSocketAddress,
          Packages.arc.net.Connection
        >;
        private pendingConnections: Packages.arc.struct.IntMap<Packages.arc.net.Connection>;
        listeners: Packages.arc.net.NetListener[];
        private listenerLock: any;
        private shutdown: boolean;
        private updateLock: any;
        private updateThread: Packages.java.lang.Thread;
        private multicastPort: number;
        protected multicastGroup: Packages.java.net.InetAddress;
        protected discoveryReceiver: Packages.arc.net.Server.DiscoveryReceiver;
        protected discoveryHandler: Packages.arc.net.ServerDiscoveryHandler;
        private connectFilter: Packages.arc.net.Server.ServerConnectFilter;
        private dispatchListener: Packages.arc.net.NetListener;
        public run(): void;
        public update(_timeout: number): void;
        public start(): void;
        public stop(): void;
        public close(): void;
        public bind(
          _tcpPort: Packages.java.net.InetSocketAddress,
          _udpPort: Packages.java.net.InetSocketAddress,
        ): void;
        public bind(_tcpPort: number): void;
        public bind(
          _tcpPort: number,
          _udpPort: number,
        ): void;
        private keepAlive(): void;
        public dispose(): void;
        public addListener(
          _listener: Packages.arc.net.NetListener,
        ): void;
        public removeListener(
          _listener: Packages.arc.net.NetListener,
        ): void;
        public getUpdateThread(): Packages.java.lang.Thread;
        private acceptOperation(
          _socketChannel: Packages.java.nio.channels.SocketChannel,
        ): void;
        private addConnection(
          _connection: Packages.arc.net.Connection,
        ): void;
        protected newConnection(): Packages.arc.net.Connection;
        private generateId(): number;
        public setMulticast(
          _group: string,
          _multicastPort: number,
        ): void;
        public setDiscoveryHandler(
          _newDiscoveryHandler: Packages.arc.net.ServerDiscoveryHandler,
        ): void;
        public setConnectFilter(
          _connectFilter: Packages.arc.net.Server.ServerConnectFilter,
        ): void;
        public getConnectFilter(): Packages.arc.net.Server.ServerConnectFilter;
        removeConnection(
          _connection: Packages.arc.net.Connection,
        ): void;
        public sendToAllTCP(_object: any): void;
        public sendToAllExceptTCP(
          _connectionID: number,
          _object: any,
        ): void;
        public sendToTCP(
          _connectionID: number,
          _object: any,
        ): void;
        public sendToAllUDP(_object: any): void;
        public sendToAllExceptUDP(
          _connectionID: number,
          _object: any,
        ): void;
        public sendToUDP(
          _connectionID: number,
          _object: any,
        ): void;
        public getConnections():
          | Packages.arc.net.Connection[]
          | null;
        public constructor(
          _writeBufferSize: number,
          _objectBufferSize: number,
          _serializer: Packages.arc.net.NetSerializer,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class ArrayMap<K, V>
        extends java.lang.Object
        implements
          Packages.java.lang.Iterable<
            Packages.arc.struct.ObjectMap.Entry<K, V>
          >
      {
        public static Entries = class<K, V>
          extends java.lang.Object
          implements
            Packages.java.util.Iterator<
              Packages.arc.struct.ObjectMap.Entry<K, V>
            >,
            Packages.java.lang.Iterable<
              Packages.arc.struct.ObjectMap.Entry<K, V>
            >
        {
          private map: Packages.arc.struct.ArrayMap<K, V>;
          entry: Packages.arc.struct.ObjectMap.Entry<K, V>;
          index: number;
          valid: boolean;
          public remove(): void;
          public iterator(): Packages.java.util.Iterator<
            Packages.arc.struct.ObjectMap.Entry<K, V>
          >;
          public hasNext(): boolean;
          public next(): any;
          public next(): Packages.arc.struct.ObjectMap.Entry<
            K,
            V
          >;
          public reset(): void;
          public constructor(
            _map: Packages.arc.struct.ArrayMap<K, V>,
          );
        };
        public static Values = class<V>
          extends java.lang.Object
          implements
            Packages.java.lang.Iterable<V>,
            Packages.java.util.Iterator<V>
        {
          private map: Packages.arc.struct.ArrayMap<any, V>;
          index: number;
          valid: boolean;
          public remove(): void;
          public toArray(
            _array: Packages.arc.struct.Seq<any>,
          ): Packages.arc.struct.Seq<V>;
          public toArray(): Packages.arc.struct.Seq<V>;
          public iterator(): Packages.java.util.Iterator<V>;
          public hasNext(): boolean;
          public next(): V | null;
          public reset(): void;
          public constructor(
            _map: Packages.arc.struct.ArrayMap<any, V>,
          );
        };
        public static Keys = class<K>
          extends java.lang.Object
          implements
            Packages.java.util.Iterator<K>,
            Packages.java.lang.Iterable<K>
        {
          private map: Packages.arc.struct.ArrayMap<K, any>;
          index: number;
          valid: boolean;
          public remove(): void;
          public toArray(
            _array: Packages.arc.struct.Seq<any>,
          ): Packages.arc.struct.Seq<K>;
          public toArray(): Packages.arc.struct.Seq<K>;
          public iterator(): Packages.java.util.Iterator<K>;
          public hasNext(): boolean;
          public next(): K | null;
          public reset(): void;
          public constructor(
            _map: Packages.arc.struct.ArrayMap<K, any>,
          );
        };
        public size: number;
        public ordered: boolean;
        private entries1: Packages.arc.struct.ArrayMap.Entries<anyany>;
        private entries2: Packages.arc.struct.ArrayMap.Entries<anyany>;
        private valuesIter1: Packages.arc.struct.ArrayMap.Values<any>;
        private valuesIter2: Packages.arc.struct.ArrayMap.Values<any>;
        private keysIter1: Packages.arc.struct.ArrayMap.Keys<any>;
        private keysIter2: Packages.arc.struct.ArrayMap.Keys<any>;
        public get(_key: K): V | null;
        public put(
          _key: K,
          _value: V,
          _index: number,
        ): number;
        public put(_key: K, _value: V): number;
        public equals(_obj: any): boolean;
        public toString(): string;
        public values(): Packages.arc.struct.ArrayMap.Values<V>;
        public hashCode(): number;
        public insert(
          _index: number,
          _key: K,
          _value: V,
        ): void;
        public clear(): void;
        public clear(_maximumCapacity: number): void;
        public isEmpty(): boolean;
        public iterator(): Packages.java.util.Iterator<
          Packages.arc.struct.ObjectMap.Entry<K, V>
        >;
        public getKey(
          _value: V,
          _identity: boolean,
        ): K | null;
        public putAll(
          _map: Packages.arc.struct.ArrayMap<any, any>,
        ): void;
        public putAll(
          _map: Packages.arc.struct.ArrayMap<any, any>,
          _offset: number,
          _length: number,
        ): void;
        public containsKey(_key: K): boolean;
        public keys(): Packages.arc.struct.ArrayMap.Keys<K>;
        public containsValue(
          _value: V,
          _identity: boolean,
        ): boolean;
        public setValue(_index: number, _value: V): void;
        public entries(): Packages.arc.struct.ArrayMap.Entries<
          K,
          V
        >;
        public ensureCapacity(
          _additionalCapacity: number,
        ): void;
        public reverse(): void;
        protected resize(_newSize: number): void;
        public firstValue(): V | null;
        public shuffle(): void;
        public firstKey(): K | null;
        public truncate(_newSize: number): void;
        public shrink(): void;
        public removeIndex(_index: number): void;
        public removeValue(
          _value: V,
          _identity: boolean,
        ): boolean;
        public getKeyAt(_index: number): K | null;
        public getValueAt(_index: number): V | null;
        public setKey(_index: number, _key: K): void;
        public indexOfValue(
          _value: V,
          _identity: boolean,
        ): number;
        public peekKey(): K | null;
        public peekValue(): V | null;
        public indexOfKey(_key: K): number;
        public removeKey(_key: K): V | null;
        public constructor(
          _array: Packages.arc.struct.ArrayMap<anyany>,
        );
        public constructor(
          _keyArrayType:
            | Class
            | Packages.java.lang.Class<any>,
          _valueArrayType:
            | Class
            | Packages.java.lang.Class<any>,
        );
        public constructor(
          _ordered: boolean,
          _capacity: number,
          _keyArrayType:
            | Class
            | Packages.java.lang.Class<any>,
          _valueArrayType:
            | Class
            | Packages.java.lang.Class<any>,
        );
        public constructor();
        public constructor(_capacity: number);
        public constructor(
          _ordered: boolean,
          _capacity: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class BinaryHeap<
        T extends Packages.arc.struct.BinaryHeap.Node,
      > extends java.lang.Object {
        public static Node = class extends java.lang
          .Object {
          value: number;
          index: number;
          public toString(): string;
          public getValue(): number;
          public constructor(_value: number);
        };
        private isMaxHeap: boolean;
        public size: number;
        private nodes: Packages.arc.struct.BinaryHeap.Node[];
        public add(_node: T, _value: number): T | null;
        public add(_node: T): T | null;
        private remove(_index: number): T | null;
        public remove(_node: T): T | null;
        public equals(_obj: any): boolean;
        public toString(): string;
        public hashCode(): number;
        public clear(): void;
        public isEmpty(): boolean;
        public contains(
          _node: T,
          _identity: boolean,
        ): boolean;
        public setValue(_node: T, _value: number): void;
        public peek(): T | null;
        public pop(): T | null;
        private up(_index: number): void;
        private down(_index: number): void;
        public constructor();
        public constructor(
          _capacity: number,
          _isMaxHeap: boolean,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class ByteSeq extends java.lang.Object {
        public items: string[];
        public size: number;
        public ordered: boolean;
        public add(_value1: string, _value2: string): void;
        public add(
          _value1: string,
          _value2: string,
          _value3: string,
        ): void;
        public add(
          _value1: string,
          _value2: string,
          _value3: string,
          _value4: string,
        ): void;
        public add(_value: string): void;
        public get(_index: number): string;
        public equals(_object: any): boolean;
        public toString(_separator: string): string;
        public toString(): string;
        public hashCode(): number;
        public indexOf(_value: string): number;
        public insert(_index: number, _value: string): void;
        public clear(): void;
        public lastIndexOf(_value: string): number;
        public isEmpty(): boolean;
        public toArray(): string[] | null;
        public contains(_value: string): boolean;
        public addAll(
          _array: Packages.arc.struct.ByteSeq,
        ): void;
        public addAll(
          _array: string[],
          _offset: number,
          _length: number,
        ): void;
        public addAll(..._array: string[]): void;
        public addAll(
          _array: Packages.arc.struct.ByteSeq,
          _offset: number,
          _length: number,
        ): void;
        public first(): string;
        public set(_index: number, _value: string): void;
        public ensureCapacity(
          _additionalCapacity: number,
        ): string[] | null;
        public reverse(): void;
        public peek(): string;
        public sort(): void;
        public removeRange(
          _start: number,
          _end: number,
        ): void;
        public removeAll(
          _array: Packages.arc.struct.ByteSeq,
        ): boolean;
        protected resize(_newSize: number): string[] | null;
        public incr(_index: number, _value: string): void;
        public random(): string;
        public swap(_first: number, _second: number): void;
        public shuffle(): void;
        public pop(): string;
        public static with(
          ..._array: string[]
        ): Packages.arc.struct.ByteSeq;
        public setSize(_newSize: number): string[] | null;
        public mul(_index: number, _value: string): void;
        public truncate(_newSize: number): void;
        public shrink(): string[] | null;
        public removeIndex(_index: number): number;
        public removeValue(_value: string): boolean;
        public constructor(
          _ordered: boolean,
          _array: string[],
          _startIndex: number,
          _count: number,
        );
        public constructor(_array: string[]);
        public constructor(
          _array: Packages.arc.struct.ByteSeq,
        );
        public constructor();
        public constructor(_capacity: number);
        public constructor(
          _ordered: boolean,
          _capacity: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class EnumSet<
        T extends Packages.java.lang.Enum<T>,
      > extends java.lang.Object {
        private mask: number;
        public array: T[];
        public size: number;
        public static of<
          T extends Packages.java.lang.Enum<T>,
        >(..._arr: T[]): Packages.arc.struct.EnumSet<T>;
        public contains(_t: T): boolean;
        public containsAll(
          _other: Packages.arc.struct.EnumSet<T>,
        ): boolean;
        public with(
          _add: T,
        ): Packages.arc.struct.EnumSet<T>;
        public containsAny(
          _other: Packages.arc.struct.EnumSet<T>,
        ): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class GridBits extends java.lang.Object {
        private bits: Packages.arc.struct.Bits;
        public get(_x: number, _y: number): boolean;
        public clear(): void;
        public set(
          _x: number,
          _y: number,
          _b: boolean,
        ): void;
        public set(_x: number, _y: number): void;
        public set(
          _other: Packages.arc.struct.GridBits,
        ): void;
        public width(): number;
        public height(): number;
        public constructor(_width: number, _height: number);
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class GridMap<T> extends java.lang.Object {
        protected map: Packages.arc.struct.LongMap<T>;
        public remove(_x: number, _y: number): void;
        public get(
          _x: number,
          _y: number,
          _defaultValue: T,
        ): T | null;
        public get(_x: number, _y: number): T | null;
        public put(_x: number, _y: number, _t: T): void;
        public values(): Packages.arc.struct.LongMap.Values<T>;
        public clear(): void;
        public size(): number;
        public containsKey(_x: number, _y: number): boolean;
        public keys(): Packages.arc.struct.LongMap.Keys;
        private static getHash(
          _x: number,
          _y: number,
        ): Packages.long;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class IntIntMap
        extends java.lang.Object
        implements
          Packages.java.lang
            .Iterable<Packages.arc.struct.IntIntMap.Entry>
      {
        public static Entries = class
          extends Packages.arc.struct.IntIntMap.MapIterator
          implements
            Packages.java.lang
              .Iterable<Packages.arc.struct.IntIntMap.Entry>,
            Packages.java.util
              .Iterator<Packages.arc.struct.IntIntMap.Entry>
        {
          private entry: Packages.arc.struct.IntIntMap.Entry;
          public remove(): void;
          public iterator(): Packages.java.util.Iterator<Packages.arc.struct.IntIntMap.Entry>;
          public hasNext(): boolean;
          public next(): any;
          public next(): Packages.arc.struct.IntIntMap.Entry;
          public reset(): void;
          public constructor(
            _map: Packages.arc.struct.IntIntMap,
          );
        };
        public static Entry = class extends java.lang
          .Object {
          public key: number;
          public value: number;
          public toString(): string;
          public constructor();
        };
        public static Values = class extends Packages.arc
          .struct.IntIntMap.MapIterator {
          public remove(): void;
          public toArray(): Packages.arc.struct.IntSeq;
          public hasNext(): boolean;
          public next(): number;
          public reset(): void;
          public constructor(
            _map: Packages.arc.struct.IntIntMap,
          );
        };
        public static Keys = class extends Packages.arc
          .struct.IntIntMap.MapIterator {
          public remove(): void;
          public toArray(): Packages.arc.struct.IntSeq;
          public hasNext(): boolean;
          public next(): number;
          public reset(): void;
          public constructor(
            _map: Packages.arc.struct.IntIntMap,
          );
        };
        private static MapIterator = class extends java.lang
          .Object {
          static INDEX_ILLEGAL: number;
          static INDEX_ZERO: number;
          map: Packages.arc.struct.IntIntMap;
          public hasNext: boolean;
          nextIndex: number;
          currentIndex: number;
          valid: boolean;
          public remove(): void;
          public reset(): void;
          findNextIndex(): void;
          public constructor(
            _map: Packages.arc.struct.IntIntMap,
          );
        };
        private static PRIME1: number;
        private static PRIME2: number;
        private static PRIME3: number;
        private static EMPTY: number;
        public size: number;
        keyTable: number[];
        valueTable: number[];
        capacity: number;
        stashSize: number;
        zeroValue: number;
        hasZeroValue: boolean;
        private loadFactor: number;
        private hashShift: number;
        private mask: number;
        private threshold: number;
        private stashCapacity: number;
        private pushIterations: number;
        private entries1: Packages.arc.struct.IntIntMap.Entries;
        private entries2: Packages.arc.struct.IntIntMap.Entries;
        private values1: Packages.arc.struct.IntIntMap.Values;
        private values2: Packages.arc.struct.IntIntMap.Values;
        private keys1: Packages.arc.struct.IntIntMap.Keys;
        private keys2: Packages.arc.struct.IntIntMap.Keys;
        public remove(_key: number): number;
        public remove(
          _key: number,
          _defaultValue: number,
        ): number;
        public get(
          _key: number,
          _defaultValue: number,
        ): number;
        public get(_key: number): number;
        public put(_key: number, _value: number): void;
        public equals(_obj: any): boolean;
        public toString(): string;
        public values(): Packages.arc.struct.IntIntMap.Values;
        public hashCode(): number;
        public clear(_maximumCapacity: number): void;
        public clear(): void;
        public isEmpty(): boolean;
        public iterator(): Packages.java.util.Iterator<Packages.arc.struct.IntIntMap.Entry>;
        public static of(
          ..._values: number[]
        ): Packages.arc.struct.IntIntMap;
        public putAll(
          _map: Packages.arc.struct.IntIntMap,
        ): void;
        public increment(
          _key: number,
          _amount: number,
        ): number;
        public increment(_key: number): number;
        public increment(
          _key: number,
          _defaultValue: number,
          _increment: number,
        ): number;
        public containsKey(_key: number): boolean;
        public keys(): Packages.arc.struct.IntIntMap.Keys;
        public containsValue(_value: number): boolean;
        public entries(): Packages.arc.struct.IntIntMap.Entries;
        public ensureCapacity(
          _additionalCapacity: number,
        ): void;
        private resize(_newSize: number): void;
        private push(
          _insertKey: number,
          _insertValue: number,
          _index1: number,
          _key1: number,
          _index2: number,
          _key2: number,
          _index3: number,
          _key3: number,
        ): void;
        public shrink(_maximumCapacity: number): void;
        private hash2(_h: number): number;
        private hash3(_h: number): number;
        private putStash(
          _key: number,
          _value: number,
        ): void;
        private putResize(
          _key: number,
          _value: number,
        ): void;
        private getStash(
          _key: number,
          _defaultValue: number,
        ): number;
        removeStash(
          _key: number,
          _defaultValue: number,
        ): number;
        removeStashIndex(_index: number): void;
        private containsKeyStash(_key: number): boolean;
        public findKey(
          _value: number,
          _notFound: number,
        ): number;
        private getAndIncrementStash(
          _key: number,
          _defaultValue: number,
          _increment: number,
        ): number;
        public getOrPut(
          _key: number,
          _value: number,
        ): number;
        public constructor(
          _map: Packages.arc.struct.IntIntMap,
        );
        public constructor(
          _initialCapacity: number,
          _loadFactor: number,
        );
        public constructor(_initialCapacity: number);
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class IntQueue extends java.lang.Object {
        public size: number;
        public values: number[];
        protected head: number;
        protected tail: number;
        public get(_index: number): number;
        public toString(): string;
        public indexOf(_value: number): number;
        public clear(): void;
        public isEmpty(): boolean;
        public last(): number;
        public first(): number;
        public set(_index: number, _value: number): void;
        public ensureCapacity(_additional: number): void;
        protected resize(_newSize: number): void;
        public addFirst(_object: number): void;
        public addLast(_object: number): void;
        public removeFirst(): number;
        public removeLast(): number;
        public shrink(): number[] | null;
        public removeIndex(_index: number): number;
        public removeValue(_value: number): boolean;
        public constructor();
        public constructor(_initialSize: number);
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class LongQueue extends java.lang.Object {
        public size: number;
        public values: Packages.long[];
        protected head: number;
        protected tail: number;
        public get(_index: number): Packages.long;
        public toString(): string;
        public indexOf(
          _value: Packages.long,
          _identity: boolean,
        ): number;
        public clear(): void;
        public isEmpty(): boolean;
        public toArray(): Packages.long[] | null;
        public last(): Packages.long;
        public first(): Packages.long;
        public set(
          _index: number,
          _value: Packages.long,
        ): void;
        public ensureCapacity(_additional: number): void;
        protected resize(_newSize: number): void;
        public addFirst(_object: Packages.long): void;
        public addLast(_object: Packages.long): void;
        public removeFirst(): Packages.long;
        public removeLast(): Packages.long;
        public shrink(): Packages.long[] | null;
        public removeIndex(_index: number): Packages.long;
        public removeValue(
          _value: Packages.long,
          _identity: boolean,
        ): boolean;
        public constructor(_array: Packages.long[]);
        public constructor(_initialSize: number);
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class OrderedSet<T> extends Packages.arc
        .struct.ObjectSet<T> {
        public OrderedSetIterator = class extends Packages
          .arc.struct.ObjectSet.ObjectSetIterator {
          this$0: Packages.arc.struct.OrderedSet<any>;
          public remove(): void;
          public next(): T | null;
          public reset(): void;
          public constructor(
            _this$0: Packages.arc.struct.OrderedSet<any>,
          );
        };
        items: Packages.arc.struct.Seq<T>;
        iterator1: Packages.arc.struct.OrderedSet.OrderedSetIterator;
        iterator2: Packages.arc.struct.OrderedSet.OrderedSetIterator;
        public add(_key: T): boolean;
        public add(_key: T, _index: number): boolean;
        public remove(_key: T): boolean;
        public toString(_separator: string): string;
        public toString(): string;
        public clear(): void;
        public clear(_maximumCapacity: number): void;
        public iterator(): Packages.arc.struct.OrderedSet.OrderedSetIterator;
        public iterator(): Packages.arc.struct.ObjectSet.ObjectSetIterator;
        public iterator(): Packages.java.util.Iterator<any>;
        public first(): T | null;
        public removeIndex(_index: number): T | null;
        public orderedItems(): Packages.arc.struct.Seq<T>;
        public constructor(
          _set: Packages.arc.struct.OrderedSet<any>,
        );
        public constructor(_initialCapacity: number);
        public constructor(
          _initialCapacity: number,
          _loadFactor: number,
        );
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class PQueue<E> extends java.lang.Object {
        private static CAPACITY_RATIO_LOW: number;
        private static CAPACITY_RATIO_HI: number;
        public queue: any[];
        public comparator: Packages.java.util.Comparator<E>;
        public add(_e: E): boolean;
        public get(_index: number): E | null;
        private compare(_a: E, _b: E): number;
        public clear(): void;
        public size(): number;
        public empty(): boolean;
        public poll(): E | null;
        public peek(): E | null;
        private growToSize(_minCapacity: number): void;
        private siftUp(_k: number, _x: E): void;
        private siftDown(_k: number, _x: E): void;
        public constructor();
        public constructor(
          _initialCapacity: number,
          _comparator: Packages.java.util.Comparator<E>,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class Queue<T>
        extends java.lang.Object
        implements
          Packages.java.lang.Iterable<T>,
          Packages.arc.util.Eachable<T>
      {
        public static QueueIterable = class<T>
          extends java.lang.Object
          implements Packages.java.lang.Iterable<T>
        {
          private QueueIterator = class
            extends java.lang.Object
            implements
              Packages.java.util.Iterator<T>,
              Packages.java.lang.Iterable<T>
          {
            index: number;
            done: boolean;
            this$0: Packages.arc.struct.Queue.QueueIterable<any>;
            public remove(): void;
            public iterator(): Packages.java.util.Iterator<T>;
            public hasNext(): boolean;
            public next(): T | null;
            public reset(): void;
          };
          queue: Packages.arc.struct.Queue<T>;
          allowRemove: boolean;
          private iterator1: Packages.arc.struct.Queue.QueueIterable.QueueIterator;
          private iterator2: Packages.arc.struct.Queue.QueueIterable.QueueIterator;
          public iterator(): Packages.java.util.Iterator<T>;
          public constructor(
            _queue: Packages.arc.struct.Queue<T>,
          );
          public constructor(
            _queue: Packages.arc.struct.Queue<T>,
            _allowRemove: boolean,
          );
        };
        public size: number;
        public values: T[];
        protected head: number;
        protected tail: number;
        private iterable?: Packages.arc.struct.Queue.QueueIterable<T>;
        public add(_object: T): void;
        public remove(_value: T): boolean;
        public remove(
          _value: Packages.arc.func.Boolf<T>,
        ): boolean;
        public remove(
          _value: T,
          _identity: boolean,
        ): boolean;
        public get(_index: number): T | null;
        public equals(_o: any): boolean;
        public toString(): string;
        public hashCode(): number;
        public indexOf(
          _value: T,
          _identity: boolean,
        ): number;
        public indexOf(
          _value: Packages.arc.func.Boolf<T>,
        ): number;
        public clear(): void;
        public isEmpty(): boolean;
        public toArray(
          _type: Class<T> | Packages.java.lang.Class<T>,
        ): T[] | null;
        public iterator(): Packages.java.util.Iterator<T>;
        public contains(_value: T): boolean;
        public contains(
          _value: T,
          _identity: boolean,
        ): boolean;
        public last(): T | null;
        public first(): T | null;
        public ensureCapacity(_additional: number): void;
        public each(_c: Packages.arc.func.Cons<any>): void;
        protected resize(_newSize: number): void;
        public addFirst(_object: T): void;
        public addLast(_object: T): void;
        public removeFirst(): T | null;
        public removeLast(): T | null;
        public shrink(): T[] | null;
        public removeIndex(_index: number): T | null;
        public constructor(
          _initialSize: number,
          _type: Class<T> | Packages.java.lang.Class<T>,
        );
        public constructor(_initialSize: number);
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare class ThreadLocal<T> {}
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class TimSort<T> extends java.lang.Object {
        private static MIN_MERGE: number;
        private static MIN_GALLOP: number;
        private static INITIAL_TMP_STORAGE_LENGTH: number;
        private static DEBUG: boolean;
        private runBase: number[];
        private runLen: number[];
        private a: T[];
        private c: Packages.java.util.Comparator<any>;
        private minGallop: number;
        private tmp: T[];
        private tmpCount: number;
        private stackSize: number;
        private static rangeCheck(
          _arrayLen: number,
          _fromIndex: number,
          _toIndex: number,
        ): void;
        private ensureCapacity(
          _minCapacity: number,
        ): T[] | null;
        static sort<T>(
          _a: T[],
          _c: Packages.java.util.Comparator<any>,
        ): void;
        static sort<T>(
          _a: T[],
          _lo: number,
          _hi: number,
          _c: Packages.java.util.Comparator<any>,
        ): void;
        private static countRunAndMakeAscending<T>(
          _a: T[],
          _lo: number,
          _hi: number,
          _c: Packages.java.util.Comparator<any>,
        ): number;
        private static binarySort<T>(
          _a: T[],
          _lo: number,
          _hi: number,
          _start: number,
          _c: Packages.java.util.Comparator<any>,
        ): void;
        private static minRunLength(_n: number): number;
        private pushRun(
          _runBase: number,
          _runLen: number,
        ): void;
        private mergeCollapse(): void;
        private mergeForceCollapse(): void;
        private static reverseRange(
          _a: any[],
          _lo: number,
          _hi: number,
        ): void;
        private mergeAt(_i: number): void;
        private static gallopRight<T>(
          _key: T,
          _a: T[],
          _base: number,
          _len: number,
          _hint: number,
          _c: Packages.java.util.Comparator<any>,
        ): number;
        private static gallopLeft<T>(
          _key: T,
          _a: T[],
          _base: number,
          _len: number,
          _hint: number,
          _c: Packages.java.util.Comparator<any>,
        ): number;
        private mergeLo(
          _base1: number,
          _len1: number,
          _base2: number,
          _len2: number,
        ): void;
        private mergeHi(
          _base1: number,
          _len1: number,
          _base2: number,
          _len2: number,
        ): void;
        public doSort(
          _a: T[],
          _c: Packages.java.util.Comparator<T>,
          _lo: number,
          _hi: number,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class ComparableTimSort extends java.lang
        .Object {
        private static MIN_MERGE: number;
        private static MIN_GALLOP: number;
        private static INITIAL_TMP_STORAGE_LENGTH: number;
        private static DEBUG: boolean;
        private runBase: number[];
        private runLen: number[];
        private a: any[];
        private minGallop: number;
        private tmp: any[];
        private tmpCount: number;
        private stackSize: number;
        private static rangeCheck(
          _arrayLen: number,
          _fromIndex: number,
          _toIndex: number,
        ): void;
        private ensureCapacity(
          _minCapacity: number,
        ): any[] | null;
        static sort(_a: any[]): void;
        static sort(
          _a: any[],
          _lo: number,
          _hi: number,
        ): void;
        private static countRunAndMakeAscending(
          _a: any[],
          _lo: number,
          _hi: number,
        ): number;
        private static binarySort(
          _a: any[],
          _lo: number,
          _hi: number,
          _start: number,
        ): void;
        private static minRunLength(_n: number): number;
        private pushRun(
          _runBase: number,
          _runLen: number,
        ): void;
        private mergeCollapse(): void;
        private mergeForceCollapse(): void;
        private static reverseRange(
          _a: any[],
          _lo: number,
          _hi: number,
        ): void;
        private mergeAt(_i: number): void;
        private static gallopRight(
          _key: Packages.java.lang.Comparable<any>,
          _a: any[],
          _base: number,
          _len: number,
          _hint: number,
        ): number;
        private static gallopLeft(
          _key: Packages.java.lang.Comparable<any>,
          _a: any[],
          _base: number,
          _len: number,
          _hint: number,
        ): number;
        private mergeLo(
          _base1: number,
          _len1: number,
          _base2: number,
          _len2: number,
        ): void;
        private mergeHi(
          _base1: number,
          _len1: number,
          _base2: number,
          _len2: number,
        ): void;
        public doSort(
          _a: any[],
          _lo: number,
          _hi: number,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class Sort extends java.lang.Object {
        private timSort: Packages.arc.struct.TimSort<any>;
        private comparableTimSort: Packages.arc.struct.ComparableTimSort;
        public sort<T>(
          _a: Packages.arc.struct.Seq<T>,
          _c: Packages.java.util.Comparator<any>,
        ): void;
        public sort<T>(
          _a: T[],
          _c: Packages.java.util.Comparator<any>,
        ): void;
        public sort<T>(
          _a: T[],
          _c: Packages.java.util.Comparator<any>,
          _fromIndex: number,
          _toIndex: number,
        ): void;
        public sort<T>(
          _a: T[],
          _fromIndex: number,
          _toIndex: number,
        ): void;
        public sort<T>(_a: T[]): void;
        public sort<T>(
          _a: Packages.arc.struct.Seq<T>,
        ): void;
        public static instance(): Packages.arc.struct.Sort;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace struct {
      declare class StringMap extends Packages.arc.struct
        .ObjectMap<string, string> {
        public getInt(_name: string): number;
        public getInt(_name: string, _def: number): number;
        public getLong(_name: string): Packages.long;
        public getLong(
          _name: string,
          _def: Packages.long,
        ): Packages.long;
        public getFloat(
          _name: string,
          _def: number,
        ): number;
        public getFloat(_name: string): number;
        public static of(
          ..._values: any[]
        ): Packages.arc.struct.StringMap;
        public getBool(_name: string): boolean;
        public constructor(
          _map: Packages.arc.struct.ObjectMap<any, any>,
        );
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class Align extends java.lang.Object {
        public static center: number;
        public static top: number;
        public static bottom: number;
        public static left: number;
        public static right: number;
        public static topLeft: number;
        public static topRight: number;
        public static bottomLeft: number;
        public static bottomRight: number;
        public static toString(_align: number): string;
        public static isLeft(_align: number): boolean;
        public static isRight(_align: number): boolean;
        public static isTop(_align: number): boolean;
        public static isBottom(_align: number): boolean;
        public static isCenterVertical(
          _align: number,
        ): boolean;
        public static isCenterHorizontal(
          _align: number,
        ): boolean;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class ArcNativesLoader extends java.lang
        .Object {
        public static disableNativesLoading: boolean;
        public static loaded: boolean;
        public static load(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class ArcRuntimeException extends Packages
        .java.lang.RuntimeException {
        private static serialVersionUID: Packages.long;
        public constructor(_message: string);
        public constructor(
          _t: Packages.java.lang.Throwable,
        );
        public constructor(
          _message: string,
          _t: Packages.java.lang.Throwable,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class Bench extends java.lang.Object {
        private static totalStart: Packages.long;
        private static lastName: string;
        private static times: Packages.arc.struct.ObjectMap<
          string,
          Packages.java.lang.Long
        >;
        private static last: Packages.long;
        public static end(): void;
        public static begin(_name: string): void;
        private static endi(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class Buffers extends java.lang.Object {
        static unsafeBuffers: Packages.arc.struct.Seq<Packages.java.nio.ByteBuffer>;
        static allocatedUnsafe: number;
        private static clear(
          _buffer: Packages.java.nio.ByteBuffer,
          _numBytes: number,
        ): void;
        public static copy(
          _src: number[],
          _srcOffset: number,
          _dst: Packages.java.nio.Buffer,
          _numElements: number,
        ): void;
        public static copy(
          _src: Packages.java.nio.Buffer,
          _dst: Packages.java.nio.Buffer,
          _numElements: number,
        ): void;
        public static copy(
          _src: number[],
          _dst: Packages.java.nio.Buffer,
          _numFloats: number,
          _offset: number,
        ): void;
        public static copy(
          _src: string[],
          _srcOffset: number,
          _dst: Packages.java.nio.Buffer,
          _numElements: number,
        ): void;
        public static copy(
          _src: Packages.short[],
          _srcOffset: number,
          _dst: Packages.java.nio.Buffer,
          _numElements: number,
        ): void;
        public static copy(
          _src: number[],
          _srcOffset: number,
          _numElements: number,
          _dst: Packages.java.nio.Buffer,
        ): void;
        public static copy(
          _src: number[],
          _srcOffset: number,
          _dst: Packages.java.nio.Buffer,
          _numElements: number,
        ): void;
        private static freeMemory(
          _buffer: Packages.java.nio.ByteBuffer,
        ): void;
        private static getBufferAddress(
          _buffer: Packages.java.nio.Buffer,
        ): Packages.long;
        public static newIntBuffer(
          _numInts: number,
        ): Packages.java.nio.IntBuffer;
        public static newFloatBuffer(
          _numFloats: number,
        ): Packages.java.nio.FloatBuffer;
        public static newShortBuffer(
          _numShorts: number,
        ): Packages.java.nio.ShortBuffer;
        public static getUnsafeBufferAddress(
          _buffer: Packages.java.nio.Buffer,
        ): Packages.long;
        public static getAllocatedBytesUnsafe(): number;
        private static copyJni(
          _src: number[],
          _srcOffset: number,
          _dst: Packages.java.nio.Buffer,
          _dstOffset: number,
          _numBytes: number,
        ): void;
        private static copyJni(
          _src: Packages.short[],
          _srcOffset: number,
          _dst: Packages.java.nio.Buffer,
          _dstOffset: number,
          _numBytes: number,
        ): void;
        private static copyJni(
          _src: number[],
          _dst: Packages.java.nio.Buffer,
          _numFloats: number,
          _offset: number,
        ): void;
        private static copyJni(
          _src: string[],
          _srcOffset: number,
          _dst: Packages.java.nio.Buffer,
          _dstOffset: number,
          _numBytes: number,
        ): void;
        private static copyJni(
          _src: number[],
          _srcOffset: number,
          _dst: Packages.java.nio.Buffer,
          _dstOffset: number,
          _numBytes: number,
        ): void;
        private static copyJni(
          _src: Packages.java.nio.Buffer,
          _srcOffset: number,
          _dst: Packages.java.nio.Buffer,
          _dstOffset: number,
          _numBytes: number,
        ): void;
        private static bytesToElements(
          _dst: Packages.java.nio.Buffer,
          _bytes: number,
        ): number;
        private static positionInBytes(
          _dst: Packages.java.nio.Buffer,
        ): number;
        private static elementsToBytes(
          _dst: Packages.java.nio.Buffer,
          _elements: number,
        ): number;
        private static elementShift(
          _dst: Packages.java.nio.Buffer,
        ): number;
        private static newDisposableByteBuffer(
          _numBytes: number,
        ): Packages.java.nio.ByteBuffer;
        public static newByteBuffer(
          _numBytes: number,
        ): Packages.java.nio.ByteBuffer;
        public static isUnsafeByteBuffer(
          _buffer: Packages.java.nio.ByteBuffer,
        ): boolean;
        public static disposeUnsafeByteBuffer(
          _buffer: Packages.java.nio.ByteBuffer,
        ): void;
        public static newUnsafeByteBuffer(
          _numBytes: number,
        ): Packages.java.nio.ByteBuffer;
        public static newUnsafeByteBuffer(
          _buffer: Packages.java.nio.ByteBuffer,
        ): Packages.java.nio.ByteBuffer;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class ColorCodes extends java.lang.Object {
        public static flush: string;
        public static reset: string;
        public static bold: string;
        public static italic: string;
        public static underline: string;
        public static black: string;
        public static red: string;
        public static green: string;
        public static yellow: string;
        public static blue: string;
        public static purple: string;
        public static cyan: string;
        public static lightBlack: string;
        public static lightRed: string;
        public static lightGreen: string;
        public static lightYellow: string;
        public static lightBlue: string;
        public static lightMagenta: string;
        public static lightCyan: string;
        public static lightWhite: string;
        public static white: string;
        public static backDefault: string;
        public static backRed: string;
        public static backGreen: string;
        public static backYellow: string;
        public static backBlue: string;
        public static codes: string[];
        public static values: string[];
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class CommandHandler extends java.lang
        .Object {
        public static CommandResponse = class extends java
          .lang.Object {
          public type: Packages.arc.util.CommandHandler.ResponseType;
          public command: Packages.arc.util.CommandHandler.Command;
          public runCommand: string;
          public constructor(
            _type: Packages.arc.util.CommandHandler.ResponseType,
            _command: Packages.arc.util.CommandHandler.Command,
            _runCommand: string,
          );
        };
        public static ResponseType = class extends Packages
          .java.lang
          .Enum<Packages.arc.util.CommandHandler.ResponseType> {
          public static noCommand: Packages.arc.util.CommandHandler.ResponseType;
          public static unknownCommand: Packages.arc.util.CommandHandler.ResponseType;
          public static fewArguments: Packages.arc.util.CommandHandler.ResponseType;
          public static manyArguments: Packages.arc.util.CommandHandler.ResponseType;
          public static valid: Packages.arc.util.CommandHandler.ResponseType;
          private static $VALUES: Packages.arc.util.CommandHandler.ResponseType[];
          public static values():
            | Packages.arc.util.CommandHandler.ResponseType[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.arc.util.CommandHandler.ResponseType;
        };
        public static Command = class extends java.lang
          .Object {
          public text: string;
          public paramText: string;
          public description: string;
          public params: Packages.arc.util.CommandHandler.CommandParam[];
          runner: Packages.arc.util.CommandHandler.CommandRunner<any>;
          public constructor(
            _text: string,
            _paramText: string,
            _description: string,
            _runner: Packages.arc.util.CommandHandler.CommandRunner<any>,
          );
        };
        public static CommandParam = class extends java.lang
          .Object {
          public name: string;
          public optional: boolean;
          public variadic: boolean;
          public constructor(
            _name: string,
            _optional: boolean,
            _variadic: boolean,
          );
        };
        public static CommandRunner = class<T> {
          public accept(
            _args: string[],
            _parameter: T,
          ): void;
        };
        public prefix: string;
        private commands: Packages.arc.struct.ObjectMap<
          string,
          Packages.arc.util.CommandHandler.Command
        >;
        private orderedCommands: Packages.arc.struct.Seq<Packages.arc.util.CommandHandler.Command>;
        public register<T>(
          _text: string,
          _description: string,
          _runner: Packages.arc.util.CommandHandler.CommandRunner<T>,
        ): Packages.arc.util.CommandHandler.Command;
        public register<T>(
          _text: string,
          _params: string,
          _description: string,
          _runner: Packages.arc.util.CommandHandler.CommandRunner<T>,
        ): Packages.arc.util.CommandHandler.Command;
        public register(
          _text: string,
          _description: string,
          _runner: Packages.arc.func.Cons<string[]>,
        ): Packages.arc.util.CommandHandler.Command;
        public register(
          _text: string,
          _params: string,
          _description: string,
          _runner: Packages.arc.func.Cons<string[]>,
        ): Packages.arc.util.CommandHandler.Command;
        public handleMessage(
          _message: string,
        ): Packages.arc.util.CommandHandler.CommandResponse;
        public handleMessage(
          _message: string,
          _params: any,
        ): Packages.arc.util.CommandHandler.CommandResponse;
        public setPrefix(_prefix: string): void;
        public getPrefix(): string;
        public removeCommand(_text: string): void;
        public getCommandList(): Packages.arc.struct.Seq<Packages.arc.util.CommandHandler.Command>;
        public constructor(_prefix: string);
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace net {
      declare abstract class HttpURLConnection {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare class Exception {}
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class Http extends java.lang.Object {
        public static HttpRequest = class extends java.lang
          .Object {
          public method: Packages.arc.util.Http.HttpMethod;
          public url: string;
          public headers: Packages.arc.struct.ObjectMap<
            string,
            string
          >;
          public timeout: number;
          public content: string;
          public contentStream: Packages.java.io.InputStream;
          public followRedirects: boolean;
          public includeCredentials: boolean;
          public errorHandler: Packages.arc.func.Cons<Packages.java.lang.Throwable>;
          public method(
            _method: Packages.arc.util.Http.HttpMethod,
          ): Packages.arc.util.Http.HttpRequest;
          public url(
            _url: string,
          ): Packages.arc.util.Http.HttpRequest;
          public block(
            _success: Packages.arc.func.ConsT<
              Packages.arc.util.Http.HttpResponse,
              Packages.java.lang.Exception
            >,
          ): void;
          public timeout(
            _timeout: number,
          ): Packages.arc.util.Http.HttpRequest;
          public error(
            _failed: Packages.arc.func.Cons<Packages.java.lang.Throwable>,
          ): Packages.arc.util.Http.HttpRequest;
          public header(
            _name: string,
            _value: string,
          ): Packages.arc.util.Http.HttpRequest;
          public content(
            _content: string,
          ): Packages.arc.util.Http.HttpRequest;
          public content(
            _contentStream: Packages.java.io.InputStream,
          ): Packages.arc.util.Http.HttpRequest;
          public submit(
            _success: Packages.arc.func.ConsT<
              Packages.arc.util.Http.HttpResponse,
              Packages.java.lang.Exception
            >,
          ): void;
          public redirects(
            _followRedirects: boolean,
          ): Packages.arc.util.Http.HttpRequest;
          public credentials(
            _includeCredentials: boolean,
          ): Packages.arc.util.Http.HttpRequest;
        };
        public static HttpMethod = class extends Packages
          .java.lang
          .Enum<Packages.arc.util.Http.HttpMethod> {
          public static GET: Packages.arc.util.Http.HttpMethod;
          public static POST: Packages.arc.util.Http.HttpMethod;
          public static PUT: Packages.arc.util.Http.HttpMethod;
          public static DELETE: Packages.arc.util.Http.HttpMethod;
          public static HEAD: Packages.arc.util.Http.HttpMethod;
          public static CONNECT: Packages.arc.util.Http.HttpMethod;
          public static OPTIONS: Packages.arc.util.Http.HttpMethod;
          public static TRACE: Packages.arc.util.Http.HttpMethod;
          private static $VALUES: Packages.arc.util.Http.HttpMethod[];
          public static values():
            | Packages.arc.util.Http.HttpMethod[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.arc.util.Http.HttpMethod;
        };
        public static HttpStatus = class extends Packages
          .java.lang
          .Enum<Packages.arc.util.Http.HttpStatus> {
          public static UNKNOWN_STATUS: Packages.arc.util.Http.HttpStatus;
          public static CONTINUE: Packages.arc.util.Http.HttpStatus;
          public static SWITCHING_PROTOCOLS: Packages.arc.util.Http.HttpStatus;
          public static PROCESSING: Packages.arc.util.Http.HttpStatus;
          public static OK: Packages.arc.util.Http.HttpStatus;
          public static CREATED: Packages.arc.util.Http.HttpStatus;
          public static ACCEPTED: Packages.arc.util.Http.HttpStatus;
          public static NON_AUTHORITATIVE_INFORMATION: Packages.arc.util.Http.HttpStatus;
          public static NO_CONTENT: Packages.arc.util.Http.HttpStatus;
          public static RESET_CONTENT: Packages.arc.util.Http.HttpStatus;
          public static PARTIAL_CONTENT: Packages.arc.util.Http.HttpStatus;
          public static MULTI_STATUS: Packages.arc.util.Http.HttpStatus;
          public static MULTIPLE_CHOICES: Packages.arc.util.Http.HttpStatus;
          public static MOVED_PERMANENTLY: Packages.arc.util.Http.HttpStatus;
          public static MOVED_TEMPORARILY: Packages.arc.util.Http.HttpStatus;
          public static SEE_OTHER: Packages.arc.util.Http.HttpStatus;
          public static NOT_MODIFIED: Packages.arc.util.Http.HttpStatus;
          public static USE_PROXY: Packages.arc.util.Http.HttpStatus;
          public static TEMPORARY_REDIRECT: Packages.arc.util.Http.HttpStatus;
          public static BAD_REQUEST: Packages.arc.util.Http.HttpStatus;
          public static UNAUTHORIZED: Packages.arc.util.Http.HttpStatus;
          public static PAYMENT_REQUIRED: Packages.arc.util.Http.HttpStatus;
          public static FORBIDDEN: Packages.arc.util.Http.HttpStatus;
          public static NOT_FOUND: Packages.arc.util.Http.HttpStatus;
          public static METHOD_NOT_ALLOWED: Packages.arc.util.Http.HttpStatus;
          public static NOT_ACCEPTABLE: Packages.arc.util.Http.HttpStatus;
          public static PROXY_AUTHENTICATION_REQUIRED: Packages.arc.util.Http.HttpStatus;
          public static REQUEST_TIMEOUT: Packages.arc.util.Http.HttpStatus;
          public static CONFLICT: Packages.arc.util.Http.HttpStatus;
          public static GONE: Packages.arc.util.Http.HttpStatus;
          public static LENGTH_REQUIRED: Packages.arc.util.Http.HttpStatus;
          public static PRECONDITION_FAILED: Packages.arc.util.Http.HttpStatus;
          public static REQUEST_TOO_LONG: Packages.arc.util.Http.HttpStatus;
          public static REQUEST_URI_TOO_LONG: Packages.arc.util.Http.HttpStatus;
          public static UNSUPPORTED_MEDIA_TYPE: Packages.arc.util.Http.HttpStatus;
          public static REQUESTED_RANGE_NOT_SATISFIABLE: Packages.arc.util.Http.HttpStatus;
          public static EXPECTATION_FAILED: Packages.arc.util.Http.HttpStatus;
          public static IM_A_TEAPOT: Packages.arc.util.Http.HttpStatus;
          public static INSUFFICIENT_SPACE_ON_RESOURCE: Packages.arc.util.Http.HttpStatus;
          public static METHOD_FAILURE: Packages.arc.util.Http.HttpStatus;
          public static UNPROCESSABLE_ENTITY: Packages.arc.util.Http.HttpStatus;
          public static LOCKED: Packages.arc.util.Http.HttpStatus;
          public static FAILED_DEPENDENCY: Packages.arc.util.Http.HttpStatus;
          public static INTERNAL_SERVER_ERROR: Packages.arc.util.Http.HttpStatus;
          public static NOT_IMPLEMENTED: Packages.arc.util.Http.HttpStatus;
          public static BAD_GATEWAY: Packages.arc.util.Http.HttpStatus;
          public static SERVICE_UNAVAILABLE: Packages.arc.util.Http.HttpStatus;
          public static GATEWAY_TIMEOUT: Packages.arc.util.Http.HttpStatus;
          public static HTTP_VERSION_NOT_SUPPORTED: Packages.arc.util.Http.HttpStatus;
          public static INSUFFICIENT_STORAGE: Packages.arc.util.Http.HttpStatus;
          private static byCode: Packages.arc.struct.IntMap<Packages.arc.util.Http.HttpStatus>;
          public code: number;
          private static $VALUES: Packages.arc.util.Http.HttpStatus[];
          public static values():
            | Packages.arc.util.Http.HttpStatus[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.arc.util.Http.HttpStatus;
          public static byCode(
            _code: number,
          ): Packages.arc.util.Http.HttpStatus;
        };
        public static HttpStatusException = class extends Packages
          .java.lang.RuntimeException {
          public status: Packages.arc.util.Http.HttpStatus;
          public response: Packages.arc.util.Http.HttpResponse;
          public constructor(
            _message: string,
            _status: Packages.arc.util.Http.HttpStatus,
            _response: Packages.arc.util.Http.HttpResponse,
          );
        };
        public static HttpResponse = class extends java.lang
          .Object {
          private connection: Packages.java.net.HttpURLConnection;
          private status: Packages.arc.util.Http.HttpStatus;
          public getHeader(_name: string): string;
          public getContentLength(): Packages.long;
          public getResult(): string[] | null;
          public getStatus(): Packages.arc.util.Http.HttpStatus;
          public getResultAsStream(): Packages.java.io.InputStream;
          public getResultAsString(): string;
          public getHeaders(): Packages.arc.struct.ObjectMap<
            string,
            Packages.arc.struct.Seq<string>
          >;
        };
        protected static exec: Packages.java.util.concurrent.ExecutorService;
        public static get(
          _url: string,
          _callback: Packages.arc.func.ConsT<
            Packages.arc.util.Http.HttpResponse,
            Packages.java.lang.Exception
          >,
          _error: Packages.arc.func.Cons<Packages.java.lang.Throwable>,
        ): void;
        public static get(
          _url: string,
          _callback: Packages.arc.func.ConsT<
            Packages.arc.util.Http.HttpResponse,
            Packages.java.lang.Exception
          >,
        ): void;
        public static get(
          _url: string,
        ): Packages.arc.util.Http.HttpRequest;
        public static post(
          _url: string,
          _content: string,
        ): Packages.arc.util.Http.HttpRequest;
        public static post(
          _url: string,
        ): Packages.arc.util.Http.HttpRequest;
        public static post(
          _url: string,
          _callback: Packages.arc.func.ConsT<
            Packages.arc.util.Http.HttpResponse,
            Packages.java.lang.Exception
          >,
        ): void;
        public static request(
          _method: Packages.arc.util.Http.HttpMethod,
          _url: string,
        ): Packages.arc.util.Http.HttpRequest;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class Interval extends java.lang.Object {
        times: number[];
        public get(_id: number, _time: number): boolean;
        public get(_time: number): boolean;
        public clear(): void;
        public reset(_id: number, _time: number): void;
        public check(_id: number, _time: number): boolean;
        public getTime(_id: number): number;
        public getTimes(): number[] | null;
        public constructor(_capacity: number);
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class Log extends java.lang.Object {
        public static LogLevel = class extends Packages.java
          .lang.Enum<Packages.arc.util.Log.LogLevel> {
          public static debug: Packages.arc.util.Log.LogLevel;
          public static info: Packages.arc.util.Log.LogLevel;
          public static warn: Packages.arc.util.Log.LogLevel;
          public static err: Packages.arc.util.Log.LogLevel;
          public static none: Packages.arc.util.Log.LogLevel;
          private static $VALUES: Packages.arc.util.Log.LogLevel[];
          public static values():
            | Packages.arc.util.Log.LogLevel[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.arc.util.Log.LogLevel;
        };
        public static LogHandler = class {
          public log(
            _level: Packages.arc.util.Log.LogLevel,
            _text: string,
          ): void;
        };
        public static LogFormatter = class {
          public format(
            _text: string,
            _useColors: boolean,
            ..._args: any[]
          ): string;
        };
        public static DefaultLogHandler = class
          extends java.lang.Object
          implements Packages.arc.util.Log.LogHandler
        {
          public log(
            _level: Packages.arc.util.Log.LogLevel,
            _text: string,
          ): void;
          public constructor();
        };
        public static DefaultLogFormatter = class
          extends java.lang.Object
          implements Packages.arc.util.Log.LogFormatter
        {
          public format(
            _text: string,
            _useColors: boolean,
            ..._args: any[]
          ): string;
          public constructor();
        };
        public static NoopLogHandler = class
          extends java.lang.Object
          implements Packages.arc.util.Log.LogHandler
        {
          public log(
            _level: Packages.arc.util.Log.LogLevel,
            _text: string,
          ): void;
          public constructor();
        };
        private static empty: any[];
        public static useColors: boolean;
        public static level: Packages.arc.util.Log.LogLevel;
        public static logger: Packages.arc.util.Log.LogHandler;
        public static formatter: Packages.arc.util.Log.LogFormatter;
        public static log(
          _level: Packages.arc.util.Log.LogLevel,
          _text: string,
          ..._args: any[]
        ): void;
        public static format(
          _text: string,
          ..._args: any[]
        ): string;
        public static info(
          _text: string,
          ..._args: any[]
        ): void;
        public static info(_object: any): void;
        public static err(
          _text: string,
          ..._args: any[]
        ): void;
        public static err(
          _text: string,
          _th: Packages.java.lang.Throwable,
        ): void;
        public static err(
          _th: Packages.java.lang.Throwable,
        ): void;
        public static debug(
          _text: string,
          ..._args: any[]
        ): void;
        public static debug(_object: any): void;
        public static warn(
          _text: string,
          ..._args: any[]
        ): void;
        public static infoTag(
          _tag: string,
          _text: string,
        ): void;
        public static formatColors(
          _text: string,
          _useColors: boolean,
          ..._args: any[]
        ): string;
        public static infoList(..._args: any[]): void;
        public static errTag(
          _tag: string,
          _text: string,
        ): void;
        public static removeColors(_text: string): string;
        public static addColors(_text: string): string;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare abstract class Nullable
        implements
          Packages.java.lang.annotation.Annotation {}
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class OS extends java.lang.Object {
        public static cores: number;
        public static username: string;
        public static userHome: string;
        public static osName: string;
        public static osVersion: string;
        public static osArch: string;
        public static osArchBits: string;
        public static javaVersion: string;
        public static isWindows: boolean;
        public static isLinux: boolean;
        public static isMac: boolean;
        public static isIos: boolean;
        public static isAndroid: boolean;
        public static isARM: boolean;
        public static is64Bit: boolean;
        public static prop(_name: string): string;
        public static exec(
          _logErr: boolean,
          ..._args: string[]
        ): string;
        public static exec(..._args: string[]): string;
        public static env(_name: string): string;
        public static getAppDataDirectoryString(
          _appname: string,
        ): string;
        public static hasEnv(_name: string): boolean;
        public static propNoNull(_name: string): string;
        public static getWindowsTmpDir(): string;
        public static execSafe(
          ..._command: string[]
        ): boolean;
        public static execSafe(_command: string): boolean;
        public static getAppDataDirectory(
          _appname: string,
        ): Packages.arc.files.Fi;
        public static hasProp(_name: string): boolean;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class Pack extends java.lang.Object {
        public static byteValue(_b: boolean): string;
        public static bytes(
          _i: number,
          _result: string[],
        ): string[] | null;
        public static u(_b: Packages.short): number;
        public static u(_b: string): number;
        public static u(_b: number): Packages.long;
        public static leftByte(_value: string): string;
        public static leftByte(
          _field: Packages.short,
        ): string;
        public static rightByte(
          _field: Packages.short,
        ): string;
        public static rightByte(_value: string): string;
        public static shortInt(
          _left: Packages.short,
          _right: Packages.short,
        ): number;
        public static longInt(
          _x: number,
          _y: number,
        ): Packages.long;
        public static byteByte(
          _left: string,
          _right: string,
        ): string;
        public static leftShort(
          _field: number,
        ): Packages.short;
        public static rightShort(
          _field: number,
        ): Packages.short;
        public static leftInt(
          _field: Packages.long,
        ): number;
        public static rightInt(
          _field: Packages.long,
        ): number;
        public static shortByte(
          _left: string,
          _right: string,
        ): Packages.short;
        public static shorts(
          _i: Packages.long,
          _resultShort: Packages.short[],
        ): Packages.short[] | null;
        public static longShorts(
          _s: Packages.short[],
        ): Packages.long;
        public static intBytes(
          _b1: string,
          _b2: string,
          _b3: string,
          _b4: string,
        ): number;
        public static intBytes(_array: string[]): number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class PerformanceCounter extends java.lang
        .Object {
        private static nano2seconds: number;
        public time: Packages.arc.math.FloatCounter;
        public load: Packages.arc.math.FloatCounter;
        public name: string;
        public current: number;
        public valid: boolean;
        private startTime: Packages.long;
        private lastTick: Packages.long;
        public toString(): string;
        public toString(
          _sb: Packages.java.lang.StringBuilder,
        ): Packages.java.lang.StringBuilder;
        public start(): void;
        public stop(): void;
        public reset(): void;
        public tick(): void;
        public tick(_delta: number): void;
        private commas(
          _builder: Packages.java.lang.StringBuilder,
          _number: number,
        ): void;
        public constructor(_name: string);
        public constructor(
          _name: string,
          _windowSize: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class PerformanceCounters extends java.lang
        .Object {
        private static nano2seconds: number;
        public counters: Packages.arc.struct.Seq<Packages.arc.util.PerformanceCounter>;
        private lastTick: Packages.long;
        public add(
          _name: string,
        ): Packages.arc.util.PerformanceCounter;
        public add(
          _name: string,
          _windowSize: number,
        ): Packages.arc.util.PerformanceCounter;
        public toString(): string;
        public tick(_deltaTime: number): void;
        public tick(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class QuickSelect<T> extends java.lang
        .Object {
        private array: T[];
        private comp: Packages.java.util.Comparator<any>;
        private swap(_left: number, _right: number): void;
        public select(
          _items: T[],
          _comp: Packages.java.util.Comparator<T>,
          _n: number,
          _size: number,
        ): number;
        private recursiveSelect(
          _left: number,
          _right: number,
          _k: number,
        ): number;
        private medianOfThreePivot(
          _leftIdx: number,
          _rightIdx: number,
        ): number;
        private partition(
          _left: number,
          _right: number,
          _pivot: number,
        ): number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class Ratekeeper extends java.lang.Object {
        public occurences: number;
        public lastTime: Packages.long;
        public allow(
          _spacing: Packages.long,
          _cap: number,
        ): boolean;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class Reflect extends java.lang.Object {
        public static invoke<T>(
          _object: any,
          _name: string,
        ): T | null;
        public static invoke<T>(
          _object: any,
          _name: string,
          _args: any[],
          ..._parameterTypes: Packages.java.lang.Class<any>[]
        ): T | null;
        public static invoke<T>(
          _type: Class<any> | Packages.java.lang.Class<any>,
          _name: string,
        ): T | null;
        public static invoke<T>(
          _type: Class<any> | Packages.java.lang.Class<any>,
          _name: string,
          _args: any[],
          ..._parameterTypes: Packages.java.lang.Class<any>[]
        ): T | null;
        public static invoke<T>(
          _type: Class<any> | Packages.java.lang.Class<any>,
          _object: any,
          _name: string,
          _args: any[],
          ..._parameterTypes: Packages.java.lang.Class<any>[]
        ): T | null;
        public static get<T>(
          _type: Class<any> | Packages.java.lang.Class<any>,
          _object: any,
          _name: string,
        ): T | null;
        public static get<T>(
          _type: Class<any> | Packages.java.lang.Class<any>,
          _name: string,
        ): T | null;
        public static get<T>(
          _object: any,
          _name: string,
        ): T | null;
        public static get<T>(
          _field: Packages.java.lang.reflect.Field,
        ): T | null;
        public static get<T>(
          _object: any,
          _field: Packages.java.lang.reflect.Field,
        ): T | null;
        public static newArray<T>(
          _type: Class<T> | Packages.java.lang.Class<T>,
          _length: number,
        ): T[] | null;
        public static newArray<T>(
          _oldType: T[],
          _length: number,
        ): T[] | null;
        public static make<T>(_type: string): T | null;
        public static set(
          _type: Class<any> | Packages.java.lang.Class<any>,
          _object: any,
          _name: string,
          _value: any,
        ): void;
        public static set(
          _object: any,
          _field: Packages.java.lang.reflect.Field,
          _value: any,
        ): void;
        public static set(
          _object: any,
          _name: string,
          _value: any,
        ): void;
        public static set(
          _type: Class<any> | Packages.java.lang.Class<any>,
          _name: string,
          _value: any,
        ): void;
        public static cons<T>(
          _type: Class<T> | Packages.java.lang.Class<T>,
        ): Packages.arc.func.Prov<T>;
        public static isWrapper(
          _type: Class<any> | Packages.java.lang.Class<any>,
        ): boolean;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class ScreenRecorder extends java.lang
        .Object {
        public static record(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class ScreenUtils extends java.lang.Object {
        public static saveScreenshot(
          _file: Packages.arc.files.Fi,
          _x: number,
          _y: number,
          _width: number,
          _height: number,
        ): void;
        public static saveScreenshot(
          _file: Packages.arc.files.Fi,
        ): void;
        public static getFrameBufferPixmap(
          _x: number,
          _y: number,
          _w: number,
          _h: number,
          _flip: boolean,
        ): Packages.arc.graphics.Pixmap;
        public static getFrameBufferPixmap(
          _x: number,
          _y: number,
          _w: number,
          _h: number,
        ): Packages.arc.graphics.Pixmap;
        public static getFrameBufferTexture(
          _x: number,
          _y: number,
          _w: number,
          _h: number,
        ): Packages.arc.graphics.g2d.TextureRegion;
        public static getFrameBufferTexture(): Packages.arc.graphics.g2d.TextureRegion;
        public static getFrameBufferPixels(
          _x: number,
          _y: number,
          _w: number,
          _h: number,
          _flipY: boolean,
        ): string[] | null;
        public static getFrameBufferPixels(
          _flipY: boolean,
        ): string[] | null;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class Select extends java.lang.Object {
        private quickSelect: Packages.arc.util.QuickSelect<any>;
        public static instance(): Packages.arc.util.Select;
        public select<T>(
          _items: T[],
          _comp: Packages.java.util.Comparator<T>,
          _kthLowest: number,
          _size: number,
        ): T | null;
        public selectIndex<T>(
          _items: T[],
          _comp: Packages.java.util.Comparator<T>,
          _kthLowest: number,
          _size: number,
        ): number;
        private fastMin<T>(
          _items: T[],
          _comp: Packages.java.util.Comparator<T>,
          _size: number,
        ): number;
        private fastMax<T>(
          _items: T[],
          _comp: Packages.java.util.Comparator<T>,
          _size: number,
        ): number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare class HashSet<E> {}
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class SharedLibraryLoader extends java.lang
        .Object {
        private static loadedLibraries: Packages.java.util.HashSet<string>;
        private nativesJar: string;
        public load(_libraryName: string): void;
        public mapLibraryName(_libraryName: string): string;
        public static isLoaded(
          _libraryName: string,
        ): boolean;
        private canWrite(
          _file: Packages.java.io.File,
        ): boolean;
        private canExecute(
          _file: Packages.java.io.File,
        ): boolean;
        public crc(
          _input: Packages.java.io.InputStream,
        ): string;
        protected loadFile(
          _sourcePath: string,
          _sourceCrc: string,
          _extractedFile: Packages.java.io.File,
        ): Packages.java.lang.Throwable;
        private loadFile(_sourcePath: string): void;
        public static setLoaded(_libraryName: string): void;
        protected readFile(
          _path: string,
        ): Packages.java.io.InputStream;
        private getExtractedFile(
          _dirName: string,
          _fileName: string,
        ): Packages.java.io.File;
        public extractFile(
          _sourcePath: string,
          _dirName: string,
        ): Packages.java.io.File;
        protected extractFile(
          _sourcePath: string,
          _sourceCrc: string,
          _extractedFile: Packages.java.io.File,
        ): Packages.java.io.File;
        public extractFileTo(
          _sourcePath: string,
          _dir: Packages.java.io.File,
        ): void;
        public constructor();
        public constructor(_nativesJar: string);
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace nio {
      declare namespace charset {
        declare abstract class Charset {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class Strings extends java.lang.Object {
        private static tmp1: Packages.java.lang.StringBuilder;
        private static tmp2: Packages.java.lang.StringBuilder;
        private static filenamePattern: Packages.java.util.regex.Pattern;
        private static reservedFilenamePattern: Packages.java.util.regex.Pattern;
        public static utf8: Packages.java.nio.charset.Charset;
        public static getStackTrace(
          _e: Packages.java.lang.Throwable,
        ): string;
        private static append(
          _tgt: Packages.java.lang.StringBuilder,
          _pfx: string,
          _dgt: number,
          _val: Packages.long,
        ): void;
        public static encode(_str: string): string;
        public static replace(
          _builder: Packages.java.lang.StringBuilder,
          _find: string,
          _replace: string,
        ): Packages.java.lang.StringBuilder;
        public static replace(
          _builder: Packages.java.lang.StringBuilder,
          _find: string,
          _replace: string,
        ): Packages.java.lang.StringBuilder;
        public static matches(
          _query: string,
          _name: string,
        ): boolean;
        public static join(
          _separator: string,
          _strings: Packages.java.lang.Iterable<string>,
        ): string;
        public static join(
          _separator: string,
          ..._strings: string[]
        ): string;
        public static format(
          _text: string,
          ..._args: any[]
        ): string;
        public static count(
          _str: string,
          _substring: string,
        ): number;
        public static count(
          _s: Packages.java.lang.CharSequence,
          _c: string,
        ): number;
        public static fixed(
          _d: number,
          _decimalPlaces: number,
        ): string;
        public static parseInt(
          _s: string,
          _radix: number,
          _defaultValue: number,
          _start: number,
          _end: number,
        ): number;
        public static parseInt(
          _s: string,
          _radix: number,
          _defaultValue: number,
        ): number;
        public static parseInt(
          _s: string,
          _defaultValue: number,
        ): number;
        public static parseInt(_s: string): number;
        public static parseFloat(_s: string): number;
        public static parseFloat(
          _s: string,
          _defaultValue: number,
        ): number;
        public static parseDouble(
          _value: string,
          _defaultValue: number,
        ): number;
        public static parseLong(
          _s: string,
          _radix: number,
          _defaultValue: Packages.long,
        ): Packages.long;
        public static parseLong(
          _s: string,
          _radix: number,
          _start: number,
          _end: number,
          _defaultValue: Packages.long,
        ): Packages.long;
        public static parseLong(
          _s: string,
          _defaultValue: Packages.long,
        ): Packages.long;
        public static capitalize(_s: string): string;
        public static truncate(
          _s: string,
          _length: number,
        ): string;
        public static truncate(
          _s: string,
          _length: number,
          _ellipsis: string,
        ): string;
        public static animated(
          _time: number,
          _length: number,
          _scale: number,
          _replacement: string,
        ): string;
        private static parseColorMarkup(
          _str: Packages.java.lang.CharSequence,
          _start: number,
          _end: number,
        ): number;
        public static getFinalCause(
          _e: Packages.java.lang.Throwable,
        ): Packages.java.lang.Throwable;
        public static neatError(
          _e: Packages.java.lang.Throwable,
          _stacktrace: boolean,
        ): string;
        public static neatError(
          _e: Packages.java.lang.Throwable,
        ): string;
        public static fixedBuilder(
          _d: number,
          _decimalPlaces: number,
        ): Packages.java.lang.StringBuilder;
        public static getCauses(
          _e: Packages.java.lang.Throwable,
        ): Packages.arc.struct.Seq<Packages.java.lang.Throwable>;
        public static getSimpleMessage(
          _e: Packages.java.lang.Throwable,
        ): string;
        public static getFinalMessage(
          _e: Packages.java.lang.Throwable,
        ): string;
        public static stripColors(
          _str: Packages.java.lang.CharSequence,
        ): string;
        public static stripGlyphs(
          _str: Packages.java.lang.CharSequence,
        ): string;
        public static sanitizeFilename(
          _str: string,
        ): string;
        public static levenshtein(
          _x: string,
          _y: string,
        ): number;
        public static kebabToCamel(_s: string): string;
        public static camelToKebab(_s: string): string;
        public static insertSpaces(_s: string): string;
        public static camelize(_s: string): string;
        public static canParseInt(_s: string): boolean;
        public static canParsePositiveInt(
          _s: string,
        ): boolean;
        public static canParseFloat(_s: string): boolean;
        public static canParsePositiveFloat(
          _s: string,
        ): boolean;
        public static autoFixed(
          _value: number,
          _max: number,
        ): string;
        public static formatMillis(
          _val: Packages.long,
        ): string;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class Structs extends java.lang.Object {
        public static add<T>(
          _array: T[],
          _item: T,
        ): T[] | null;
        public static remove<T>(
          _array: T[],
          _value: T,
        ): T[] | null;
        public static remove<T>(
          _array: T[],
          _index: number,
        ): T[] | null;
        public static indexOf<T>(
          _array: T[],
          _value: Packages.arc.func.Boolf<T>,
        ): number;
        public static indexOf<T>(
          _array: Packages.java.lang.Iterable<T>,
          _value: Packages.arc.func.Boolf<T>,
        ): number;
        public static indexOf<T>(
          _array: T[],
          _value: T,
        ): number;
        public static count<T>(
          _array: T[],
          _value: Packages.arc.func.Boolf<T>,
        ): number;
        public static contains<T>(
          _array: T[],
          _value: Packages.arc.func.Boolf<T>,
        ): boolean;
        public static contains<T>(
          _array: T[],
          _value: T,
        ): boolean;
        public static filter<T>(
          _it: Packages.java.util.Iterator<T>,
          _removal: Packages.arc.func.Boolf<T>,
        ): void;
        public static filter<T>(
          _iterable: Packages.java.lang.Iterable<T>,
          _removal: Packages.arc.func.Boolf<T>,
        ): void;
        public static filter<T>(
          _type: Class<T> | Packages.java.lang.Class<T>,
          _array: T[],
          _value: Packages.arc.func.Boolf<T>,
        ): T[] | null;
        public static find<T>(
          _array: T[],
          _value: Packages.arc.func.Boolf<T>,
        ): T | null;
        public static forEach<T>(
          _i: Packages.java.lang.Iterable<T>,
          _cons: Packages.arc.func.Cons<T>,
        ): void;
        public static eq(_a: any, _b: any): boolean;
        public static each<T>(
          _cons: Packages.arc.func.Cons<T>,
          ..._objects: T[]
        ): void;
        public static comparing<T, U>(
          _keyExtractor: Packages.arc.func.Func<any, any>,
          _keyComparator: Packages.java.util.Comparator<any>,
        ): Packages.java.util.Comparator<T>;
        public static comparing<
          T,
          U extends Packages.java.lang.Comparable<any>,
        >(
          _keyExtractor: Packages.arc.func.Func<any, any>,
        ): Packages.java.util.Comparator<T>;
        public static comparingInt<T>(
          _keyExtractor: Packages.arc.func.Intf<any>,
        ): Packages.java.util.Comparator<T>;
        public static comparingLong<T>(
          _keyExtractor: Packages.arc.func.Longf<any>,
        ): Packages.java.util.Comparator<T>;
        public static random<T>(
          _rand: Packages.arc.math.Rand,
          ..._array: T[]
        ): T | null;
        public static random<T>(..._array: T[]): T | null;
        public static swap<T>(
          _array: T[],
          _a: number,
          _b: number,
        ): void;
        public static arr<T>(..._array: T[]): T[] | null;
        public static comparingFloat<T>(
          _keyExtractor: Packages.arc.func.Floatf<any>,
        ): Packages.java.util.Comparator<T>;
        public static inBounds<T>(
          _x: number,
          _y: number,
          _z: number,
          _array: T[][][],
        ): boolean;
        public static inBounds(
          _x: number,
          _y: number,
          _array: boolean[][],
        ): boolean;
        public static inBounds<T>(
          _x: number,
          _y: number,
          _array: T[][],
        ): boolean;
        public static inBounds(
          _x: number,
          _y: number,
          _array: number[][],
        ): boolean;
        public static inBounds(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
        ): boolean;
        public static inBounds(
          _x: number,
          _y: number,
          _array: number[][],
        ): boolean;
        public static inBounds(
          _x: number,
          _y: number,
          _z: number,
          _size: number,
          _padding: number,
        ): boolean;
        public static inBounds(
          _x: number,
          _y: number,
          _z: number,
          _array: number[][][],
        ): boolean;
        public static comps<T>(
          _first: Packages.java.util.Comparator<T>,
          _second: Packages.java.util.Comparator<T>,
        ): Packages.java.util.Comparator<T>;
        public static comparingBool<T>(
          _keyExtractor: Packages.arc.func.Boolf<any>,
        ): Packages.java.util.Comparator<T>;
        public static findMin<T>(
          _arr: T[],
          _proc: Packages.arc.func.Floatf<T>,
        ): T | null;
        public static findMin<T>(
          _arr: T[],
          _comp: Packages.java.util.Comparator<T>,
        ): T | null;
        public static findMin<T>(
          _arr: Packages.java.lang.Iterable<T>,
          _comp: Packages.java.util.Comparator<T>,
        ): T | null;
        public static findMin<T>(
          _arr: Packages.java.lang.Iterable<T>,
          _allow: Packages.arc.func.Boolf<T>,
          _comp: Packages.java.util.Comparator<T>,
        ): T | null;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class TaskQueue extends java.lang.Object {
        private runnables: Packages.arc.struct.Seq<Packages.java.lang.Runnable>;
        private executedRunnables: Packages.arc.struct.Seq<Packages.java.lang.Runnable>;
        public run(): void;
        public clear(): void;
        public size(): number;
        public post(
          _runnable: Packages.java.lang.Runnable,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class Threads extends java.lang.Object {
        public static daemon(
          _runnable: Packages.java.lang.Runnable,
        ): Packages.java.lang.Thread;
        public static daemon(
          _name: string | null,
          _runnable: Packages.java.lang.Runnable,
        ): Packages.java.lang.Thread;
        public static sleep(
          _ms: Packages.long,
          _ns: number,
        ): void;
        public static sleep(_ms: Packages.long): void;
        public static thread(
          _name: string | null,
          _runnable: Packages.java.lang.Runnable,
        ): Packages.java.lang.Thread;
        public static thread(
          _runnable: Packages.java.lang.Runnable,
        ): Packages.java.lang.Thread;
        public static local<T>(
          _prov: Packages.arc.func.Prov<T>,
        ): Packages.java.lang.ThreadLocal<T>;
        public static executor(
          _name: string | null,
          _threads: number,
        ): Packages.java.util.concurrent.ExecutorService;
        public static executor(
          _threads: number,
        ): Packages.java.util.concurrent.ExecutorService;
        public static executor(): Packages.java.util.concurrent.ExecutorService;
        public static executor(
          _name: string | null,
        ): Packages.java.util.concurrent.ExecutorService;
        private static newThread(
          _r: Packages.java.lang.Runnable,
          _name: string | null,
          _daemon: boolean,
        ): Packages.java.lang.Thread;
        public static await<T>(
          _future: Packages.java.util.concurrent.Future<T>,
        ): T | null;
        public static await(
          _exec: Packages.java.util.concurrent.ExecutorService,
        ): void;
        public static unboundedExecutor(): Packages.java.util.concurrent.ExecutorService;
        public static unboundedExecutor(
          _name: string | null,
          _min: number,
        ): Packages.java.util.concurrent.ExecutorService;
        public static unboundedExecutor(
          _name: string | null,
        ): Packages.java.util.concurrent.ExecutorService;
        public static awaitAll(
          _futures: Packages.arc.struct.Seq<
            Packages.java.util.concurrent.Future<any>
          >,
        ): void;
        public static boundedExecutor(
          _name: string | null,
          _max: number,
        ): Packages.java.util.concurrent.ExecutorService;
        public static throwAppException(
          _t: Packages.java.lang.Throwable,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class Time extends java.lang.Object {
        public static DelayRun = class
          extends java.lang.Object
          implements Packages.arc.util.pooling.Pool.Poolable
        {
          delay: number;
          finish: Packages.java.lang.Runnable;
          public reset(): void;
          public constructor();
        };
        public static toSeconds: number;
        public static toMinutes: number;
        public static toHours: number;
        public static delta: number;
        public static time: number;
        public static globalTime: number;
        public static nanosPerMilli: Packages.long;
        private static timeRaw: number;
        private static globalTimeRaw: number;
        private static runs: Packages.arc.struct.Seq<Packages.arc.util.Time.DelayRun>;
        private static removal: Packages.arc.struct.Seq<Packages.arc.util.Time.DelayRun>;
        private static marks: Packages.arc.struct.LongSeq;
        private static deltaimpl: Packages.arc.func.Floatp;
        public static run(
          _delay: number,
          _r: Packages.java.lang.Runnable,
        ): void;
        public static update(): void;
        public static clear(): void;
        public static nanos(): Packages.long;
        public static millis(): Packages.long;
        public static mark(): void;
        public static elapsed(): number;
        public static updateGlobal(): void;
        public static timeSinceMillis(
          _prevTime: Packages.long,
        ): Packages.long;
        public static timeSinceNanos(
          _prevTime: Packages.long,
        ): Packages.long;
        public static runTask(
          _delay: number,
          _r: Packages.java.lang.Runnable,
        ): Packages.arc.util.Timer.Task;
        public static setDeltaProvider(
          _impl: Packages.arc.func.Floatp,
        ): void;
        public static nanosToMillis(
          _nanos: Packages.long,
        ): Packages.long;
        public static millisToNanos(
          _millis: Packages.long,
        ): Packages.long;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class Timekeeper extends java.lang.Object {
        private intervalms: Packages.long;
        private time: Packages.long;
        public get(): boolean;
        public reset(): void;
        public constructor(_seconds: number);
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class Point2 extends java.lang.Object {
          public add(
            _x: number,
            _y: number,
          ): Packages.arc.math.geom.Point2;
          public add(
            _other: Packages.arc.math.geom.Point2,
          ): Packages.arc.math.geom.Point2;
          public equals(_x: number, _y: number): boolean;
          public static equals(
            _x: number,
            _y: number,
            _ox: number,
            _oy: number,
          ): boolean;
          public equals(_o: any): boolean;
          public toString(): string;
          public hashCode(): number;
          public dst(_x: number, _y: number): number;
          public dst(
            _other: Packages.arc.math.geom.Point2,
          ): number;
          public static x(_pos: number): Packages.short;
          public set(
            _x: number,
            _y: number,
          ): Packages.arc.math.geom.Point2;
          public set(
            _point: Packages.arc.math.geom.Point2,
          ): Packages.arc.math.geom.Point2;
          public static y(_pos: number): Packages.short;
          public rotate(
            _steps: number,
          ): Packages.arc.math.geom.Point2;
          public sub(
            _x: number,
            _y: number,
          ): Packages.arc.math.geom.Point2;
          public sub(
            _other: Packages.arc.math.geom.Point2,
          ): Packages.arc.math.geom.Point2;
          public dst2(
            _other: Packages.arc.math.geom.Point2,
          ): number;
          public dst2(_x: number, _y: number): number;
          public cpy(): Packages.arc.math.geom.Point2;
          public pack(): number;
          public static pack(
            _x: number,
            _y: number,
          ): number;
          public static unpack(
            _pos: number,
          ): Packages.arc.math.geom.Point2;
          public constructor(
            _point: Packages.arc.math.geom.Point2,
          );
          public constructor(_x: number, _y: number);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare abstract class Path<T> {
          public approximate(_v: T): number;
          public valueAt(_out: T, _t: number): T | null;
          public locate(_v: T): number;
          public derivativeAt(
            _out: T,
            _t: number,
          ): T | null;
          public approxLength(_samples: number): number;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class Bezier<
            T extends Packages.arc.math.geom.Vector<T>,
          >
          extends java.lang.Object
          implements Packages.arc.math.geom.Path<T>
        {
          public points: Packages.arc.struct.Seq<T>;
          private tmp: T;
          private tmp2: T;
          private tmp3: T;
          public set(
            _points: T[],
            _offset: number,
            _length: number,
          ): Packages.arc.math.geom.Bezier<T>;
          public set(
            _p1: T,
            _p2: T,
            _p3: T,
          ): Packages.arc.math.geom.Bezier<T>;
          public set(
            ..._points: T[]
          ): Packages.arc.math.geom.Bezier<T>;
          public set(
            _points: Packages.arc.struct.Seq<T>,
          ): Packages.arc.math.geom.Bezier<T>;
          public set(
            _points: Packages.arc.struct.Seq<T>,
            _offset: number,
            _length: number,
          ): Packages.arc.math.geom.Bezier<T>;
          public static linear<
            T extends Packages.arc.math.geom.Vector<T>,
          >(
            _out: T,
            _t: number,
            _p0: T,
            _p1: T,
            _tmp: T,
          ): T | null;
          public static quadratic<
            T extends Packages.arc.math.geom.Vector<T>,
          >(
            _out: T,
            _t: number,
            _p0: T,
            _p1: T,
            _p2: T,
            _tmp: T,
          ): T | null;
          public static cubic<
            T extends Packages.arc.math.geom.Vector<T>,
          >(
            _out: T,
            _t: number,
            _p0: T,
            _p1: T,
            _p2: T,
            _p3: T,
            _tmp: T,
          ): T | null;
          public static linearDerivative<
            T extends Packages.arc.math.geom.Vector<T>,
          >(
            _out: T,
            _t: number,
            _p0: T,
            _p1: T,
            _tmp: T,
          ): T | null;
          public static quadraticDerivative<
            T extends Packages.arc.math.geom.Vector<T>,
          >(
            _out: T,
            _t: number,
            _p0: T,
            _p1: T,
            _p2: T,
            _tmp: T,
          ): T | null;
          public static cubicDerivative<
            T extends Packages.arc.math.geom.Vector<T>,
          >(
            _out: T,
            _t: number,
            _p0: T,
            _p1: T,
            _p2: T,
            _p3: T,
            _tmp: T,
          ): T | null;
          public approximate(_v: T): number;
          public approximate(_v: any): number;
          public valueAt(_out: T, _t: number): T | null;
          public valueAt(_out: any, _t: number): any;
          public locate(_v: any): number;
          public locate(_v: T): number;
          public derivativeAt(_out: any, _t: number): any;
          public derivativeAt(
            _out: T,
            _t: number,
          ): T | null;
          public approxLength(_samples: number): number;
          public constructor(
            _points: Packages.arc.struct.Seq<T>,
            _offset: number,
            _length: number,
          );
          public constructor(
            _points: T[],
            _offset: number,
            _length: number,
          );
          public constructor(..._points: T[]);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare class Tmp extends java.lang.Object {
        public static v1: Packages.arc.math.geom.Vec2;
        public static v2: Packages.arc.math.geom.Vec2;
        public static v3: Packages.arc.math.geom.Vec2;
        public static v4: Packages.arc.math.geom.Vec2;
        public static v5: Packages.arc.math.geom.Vec2;
        public static v6: Packages.arc.math.geom.Vec2;
        public static v31: Packages.arc.math.geom.Vec3;
        public static v32: Packages.arc.math.geom.Vec3;
        public static v33: Packages.arc.math.geom.Vec3;
        public static v34: Packages.arc.math.geom.Vec3;
        public static r1: Packages.arc.math.geom.Rect;
        public static r2: Packages.arc.math.geom.Rect;
        public static r3: Packages.arc.math.geom.Rect;
        public static cr1: Packages.arc.math.geom.Circle;
        public static cr2: Packages.arc.math.geom.Circle;
        public static cr3: Packages.arc.math.geom.Circle;
        public static t1: Packages.arc.math.geom.Vec2;
        public static c1: Packages.arc.graphics.Color;
        public static c2: Packages.arc.graphics.Color;
        public static c3: Packages.arc.graphics.Color;
        public static c4: Packages.arc.graphics.Color;
        public static p1: Packages.arc.math.geom.Point2;
        public static p2: Packages.arc.math.geom.Point2;
        public static p3: Packages.arc.math.geom.Point2;
        public static tr1: Packages.arc.graphics.g2d.TextureRegion;
        public static tr2: Packages.arc.graphics.g2d.TextureRegion;
        public static m1: Packages.arc.math.Mat;
        public static m2: Packages.arc.math.Mat;
        public static m3: Packages.arc.math.Mat;
        public static bz2: Packages.arc.math.geom.Bezier<Packages.arc.math.geom.Vec2>;
        public static bz3: Packages.arc.math.geom.Bezier<Packages.arc.math.geom.Vec3>;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare abstract class UnsafeRunnable {
        public run(): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace assets {
      declare namespace loaders {
        declare class CubemapLoader extends Packages.arc
          .assets.loaders.AsynchronousAssetLoader<
          Packages.arc.graphics.Cubemap,
          Packages.arc.assets.loaders.CubemapLoader.CubemapParameter
        > {
          public static CubemapLoaderInfo = class extends java
            .lang.Object {
            filename: string;
            data: Packages.arc.graphics.CubemapData;
            cubemap: Packages.arc.graphics.Cubemap;
            public constructor();
          };
          public static CubemapParameter = class extends Packages
            .arc.assets
            .AssetLoaderParameters<Packages.arc.graphics.Cubemap> {
            public format: Packages.arc.graphics.Pixmap.Format;
            public cubemap: Packages.arc.graphics.Cubemap;
            public cubemapData: Packages.arc.graphics.CubemapData;
            public minFilter: Packages.arc.graphics.Texture.TextureFilter;
            public magFilter: Packages.arc.graphics.Texture.TextureFilter;
            public wrapU: Packages.arc.graphics.Texture.TextureWrap;
            public wrapV: Packages.arc.graphics.Texture.TextureWrap;
            public constructor();
          };
          info: Packages.arc.assets.loaders.CubemapLoader.CubemapLoaderInfo;
          public getDependencies(
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): Packages.arc.struct.Seq<any>;
          public getDependencies(
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.loaders.CubemapLoader.CubemapParameter,
          ): Packages.arc.struct.Seq<
            Packages.arc.assets.AssetDescriptor<any>
          >;
          public loadSync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.loaders.CubemapLoader.CubemapParameter,
          ): Packages.arc.graphics.Cubemap;
          public loadSync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): any;
          public loadAsync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.loaders.CubemapLoader.CubemapParameter,
          ): void;
          public loadAsync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): void;
          public constructor(
            _resolver: Packages.arc.assets.loaders.FileHandleResolver,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace assets {
      declare namespace loaders {
        declare abstract class CustomLoader extends Packages
          .arc.assets.loaders
          .AsynchronousAssetLoader<anyany> {
          public loaded: Packages.java.lang.Runnable;
          public getDependencies(
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): Packages.arc.struct.Seq<
            Packages.arc.assets.AssetDescriptor<any>
          >;
          public loadSync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): any;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace assets {
      declare namespace loaders {
        declare class FontLoader extends Packages.arc.assets
          .loaders.AsynchronousAssetLoader<
          Packages.arc.graphics.g2d.Font,
          Packages.arc.assets.loaders.FontLoader.FontParameter
        > {
          public static FontParameter = class extends Packages
            .arc.assets
            .AssetLoaderParameters<Packages.arc.graphics.g2d.Font> {
            public flip: boolean;
            public genMipMaps: boolean;
            public minFilter: Packages.arc.graphics.Texture.TextureFilter;
            public magFilter: Packages.arc.graphics.Texture.TextureFilter;
            public fontData: Packages.arc.graphics.g2d.Font.FontData;
            public atlasName: string;
            public constructor();
          };
          data: Packages.arc.graphics.g2d.Font.FontData;
          public getDependencies(
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): Packages.arc.struct.Seq<any>;
          public getDependencies(
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.loaders.FontLoader.FontParameter,
          ): Packages.arc.struct.Seq<
            Packages.arc.assets.AssetDescriptor<any>
          >;
          public loadSync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.loaders.FontLoader.FontParameter,
          ): Packages.arc.graphics.g2d.Font;
          public loadSync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): any;
          public loadAsync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): void;
          public loadAsync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.loaders.FontLoader.FontParameter,
          ): void;
          public constructor(
            _resolver: Packages.arc.assets.loaders.FileHandleResolver,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace assets {
      declare namespace loaders {
        declare class I18NBundleLoader extends Packages.arc
          .assets.loaders.AsynchronousAssetLoader<
          Packages.arc.util.I18NBundle,
          Packages.arc.assets.loaders.I18NBundleLoader.I18NBundleParameter
        > {
          public static I18NBundleParameter = class extends Packages
            .arc.assets
            .AssetLoaderParameters<Packages.arc.util.I18NBundle> {
            public locale: Packages.java.util.Locale;
            public encoding: string;
            public constructor();
            public constructor(
              _locale: Packages.java.util.Locale,
            );
            public constructor(
              _locale: Packages.java.util.Locale,
              _encoding: string,
            );
          };
          bundle: Packages.arc.util.I18NBundle;
          public getDependencies(
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): Packages.arc.struct.Seq<any>;
          public getDependencies(
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.loaders.I18NBundleLoader.I18NBundleParameter,
          ): Packages.arc.struct.Seq<
            Packages.arc.assets.AssetDescriptor<any>
          >;
          public loadSync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.loaders.I18NBundleLoader.I18NBundleParameter,
          ): Packages.arc.util.I18NBundle;
          public loadSync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): any;
          public loadAsync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.loaders.I18NBundleLoader.I18NBundleParameter,
          ): void;
          public loadAsync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): void;
          public constructor(
            _resolver: Packages.arc.assets.loaders.FileHandleResolver,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace assets {
      declare namespace loaders {
        declare class MusicLoader extends Packages.arc
          .assets.loaders.AsynchronousAssetLoader<
          Packages.arc.audio.Music,
          Packages.arc.assets.loaders.MusicLoader.MusicParameter
        > {
          public static MusicParameter = class extends Packages
            .arc.assets
            .AssetLoaderParameters<Packages.arc.audio.Music> {
            public music?: Packages.arc.audio.Music;
            public constructor();
            public constructor(
              _music: Packages.arc.audio.Music | null,
            );
            public constructor(
              _loadedCallback: Packages.arc.assets.AssetLoaderParameters.LoadedCallback,
            );
          };
          private music: Packages.arc.audio.Music;
          public getDependencies(
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): Packages.arc.struct.Seq<any>;
          public getDependencies(
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.loaders.MusicLoader.MusicParameter,
          ): Packages.arc.struct.Seq<
            Packages.arc.assets.AssetDescriptor<any>
          >;
          public loadSync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): any;
          public loadSync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.loaders.MusicLoader.MusicParameter,
          ): Packages.arc.audio.Music;
          public loadAsync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): void;
          public loadAsync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.loaders.MusicLoader.MusicParameter,
          ): void;
          protected getLoadedMusic(): Packages.arc.audio.Music;
          public constructor(
            _resolver: Packages.arc.assets.loaders.FileHandleResolver,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace assets {
      declare namespace loaders {
        declare class PixmapLoader extends Packages.arc
          .assets.loaders.AsynchronousAssetLoader<
          Packages.arc.graphics.Pixmap,
          Packages.arc.assets.loaders.PixmapLoader.PixmapParameter
        > {
          public static PixmapParameter = class extends Packages
            .arc.assets
            .AssetLoaderParameters<Packages.arc.graphics.Pixmap> {
            public constructor();
          };
          pixmap: Packages.arc.graphics.Pixmap;
          public getDependencies(
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): Packages.arc.struct.Seq<any>;
          public getDependencies(
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.loaders.PixmapLoader.PixmapParameter,
          ): Packages.arc.struct.Seq<
            Packages.arc.assets.AssetDescriptor<any>
          >;
          public loadSync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.loaders.PixmapLoader.PixmapParameter,
          ): Packages.arc.graphics.Pixmap;
          public loadSync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): any;
          public loadAsync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.loaders.PixmapLoader.PixmapParameter,
          ): void;
          public loadAsync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): void;
          public constructor(
            _resolver: Packages.arc.assets.loaders.FileHandleResolver,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace assets {
      declare namespace loaders {
        declare class ShaderProgramLoader extends Packages
          .arc.assets.loaders.AsynchronousAssetLoader<
          Packages.arc.graphics.gl.Shader,
          Packages.arc.assets.loaders.ShaderProgramLoader.ShaderProgramParameter
        > {
          public static ShaderProgramParameter = class extends Packages
            .arc.assets
            .AssetLoaderParameters<Packages.arc.graphics.gl.Shader> {
            public vertexFile: string;
            public fragmentFile: string;
            public logOnCompileFailure: boolean;
            public prependVertexCode: string;
            public prependFragmentCode: string;
            public constructor();
          };
          private vertexFileSuffix: string;
          private fragmentFileSuffix: string;
          public getDependencies(
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): Packages.arc.struct.Seq<any>;
          public getDependencies(
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.loaders.ShaderProgramLoader.ShaderProgramParameter,
          ): Packages.arc.struct.Seq<
            Packages.arc.assets.AssetDescriptor<any>
          >;
          public loadSync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.loaders.ShaderProgramLoader.ShaderProgramParameter,
          ): Packages.arc.graphics.gl.Shader;
          public loadSync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): any;
          public loadAsync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): void;
          public loadAsync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.loaders.ShaderProgramLoader.ShaderProgramParameter,
          ): void;
          public constructor(
            _resolver: Packages.arc.assets.loaders.FileHandleResolver,
          );
          public constructor(
            _resolver: Packages.arc.assets.loaders.FileHandleResolver,
            _vertexFileSuffix: string,
            _fragmentFileSuffix: string,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace assets {
      declare namespace loaders {
        declare class SoundLoader extends Packages.arc
          .assets.loaders.AsynchronousAssetLoader<
          Packages.arc.audio.Sound,
          Packages.arc.assets.loaders.SoundLoader.SoundParameter
        > {
          public static SoundParameter = class extends Packages
            .arc.assets
            .AssetLoaderParameters<Packages.arc.audio.Sound> {
            public sound?: Packages.arc.audio.Sound;
            public constructor();
            public constructor(
              _sound: Packages.arc.audio.Sound | null,
            );
            public constructor(
              _loadedCallback: Packages.arc.assets.AssetLoaderParameters.LoadedCallback,
            );
          };
          private sound: Packages.arc.audio.Sound;
          public getDependencies(
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): Packages.arc.struct.Seq<any>;
          public getDependencies(
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.loaders.SoundLoader.SoundParameter,
          ): Packages.arc.struct.Seq<
            Packages.arc.assets.AssetDescriptor<any>
          >;
          public loadSync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): any;
          public loadSync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.loaders.SoundLoader.SoundParameter,
          ): Packages.arc.audio.Sound;
          public loadAsync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): void;
          public loadAsync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.loaders.SoundLoader.SoundParameter,
          ): void;
          protected getLoadedSound(): Packages.arc.audio.Sound;
          public constructor(
            _resolver: Packages.arc.assets.loaders.FileHandleResolver,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace assets {
      declare namespace loaders {
        declare class TextureAtlasLoader extends Packages
          .arc.assets.loaders.SynchronousAssetLoader<
          Packages.arc.graphics.g2d.TextureAtlas,
          Packages.arc.assets.loaders.TextureAtlasLoader.TextureAtlasParameter
        > {
          public static TextureAtlasParameter = class extends Packages
            .arc.assets
            .AssetLoaderParameters<Packages.arc.graphics.g2d.TextureAtlas> {
            public flip: boolean;
            public constructor();
            public constructor(_flip: boolean);
            public constructor(
              _loadedCallback: Packages.arc.assets.AssetLoaderParameters.LoadedCallback,
            );
          };
          data: Packages.arc.graphics.g2d.TextureAtlas.TextureAtlasData;
          public load(
            _assetManager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): any;
          public load(
            _assetManager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.loaders.TextureAtlasLoader.TextureAtlasParameter,
          ): Packages.arc.graphics.g2d.TextureAtlas;
          public getDependencies(
            _fileName: string,
            _atlasFile: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): Packages.arc.struct.Seq<any>;
          public getDependencies(
            _fileName: string,
            _atlasFile: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.loaders.TextureAtlasLoader.TextureAtlasParameter,
          ): Packages.arc.struct.Seq<
            Packages.arc.assets.AssetDescriptor<any>
          >;
          public constructor(
            _resolver: Packages.arc.assets.loaders.FileHandleResolver,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace assets {
      declare namespace loaders {
        declare class TextureLoader extends Packages.arc
          .assets.loaders.AsynchronousAssetLoader<
          Packages.arc.graphics.Texture,
          Packages.arc.assets.loaders.TextureLoader.TextureParameter
        > {
          public static TextureLoaderInfo = class extends java
            .lang.Object {
            filename: string;
            data: Packages.arc.graphics.TextureData;
            texture: Packages.arc.graphics.Texture;
            public constructor();
          };
          public static TextureParameter = class extends Packages
            .arc.assets
            .AssetLoaderParameters<Packages.arc.graphics.Texture> {
            public genMipMaps: boolean;
            public texture: Packages.arc.graphics.Texture;
            public textureData: Packages.arc.graphics.TextureData;
            public minFilter: Packages.arc.graphics.Texture.TextureFilter;
            public magFilter: Packages.arc.graphics.Texture.TextureFilter;
            public wrapU: Packages.arc.graphics.Texture.TextureWrap;
            public wrapV: Packages.arc.graphics.Texture.TextureWrap;
            public constructor();
          };
          info: Packages.arc.assets.loaders.TextureLoader.TextureLoaderInfo;
          public getDependencies(
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): Packages.arc.struct.Seq<any>;
          public getDependencies(
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.loaders.TextureLoader.TextureParameter,
          ): Packages.arc.struct.Seq<
            Packages.arc.assets.AssetDescriptor<any>
          >;
          public loadSync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.loaders.TextureLoader.TextureParameter,
          ): Packages.arc.graphics.Texture;
          public loadSync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): any;
          public loadAsync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.loaders.TextureLoader.TextureParameter,
          ): void;
          public loadAsync(
            _manager: Packages.arc.assets.AssetManager,
            _fileName: string,
            _file: Packages.arc.files.Fi,
            _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
          ): void;
          public constructor(
            _resolver: Packages.arc.assets.loaders.FileHandleResolver,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace flabel {
      declare namespace effects {
        declare class BlinkEffect extends Packages.arc
          .flabel.FEffect {
          private static defaultFrequency: number;
          public color1: Packages.arc.graphics.Color;
          public color2: Packages.arc.graphics.Color;
          public frequency: number;
          public threshold: number;
          protected onApply(
            _label: Packages.arc.flabel.FLabel,
            _glyph: Packages.arc.flabel.FGlyph,
            _localIndex: number,
            _delta: number,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace flabel {
      declare namespace effects {
        declare class EaseEffect extends Packages.arc.flabel
          .FEffect {
          private static defaultDistance: number;
          private static defaultIntensity: number;
          public distance: number;
          public intensity: number;
          public elastic: boolean;
          private timePassedByGlyphIndex: Packages.arc.struct.IntFloatMap;
          protected onApply(
            _label: Packages.arc.flabel.FLabel,
            _glyph: Packages.arc.flabel.FGlyph,
            _localIndex: number,
            _delta: number,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace flabel {
      declare namespace effects {
        declare class FadeEffect extends Packages.arc.flabel
          .FEffect {
          private color1: Packages.arc.graphics.Color;
          private color2: Packages.arc.graphics.Color;
          public alpha1: number;
          public alpha2: number;
          public fadeDuration: number;
          private timePassedByGlyphIndex: Packages.arc.struct.IntFloatMap;
          protected onApply(
            _label: Packages.arc.flabel.FLabel,
            _glyph: Packages.arc.flabel.FGlyph,
            _localIndex: number,
            _delta: number,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace flabel {
      declare namespace effects {
        declare class GradientEffect extends Packages.arc
          .flabel.FEffect {
          private static defaultDistance: number;
          private static defaultFrequency: number;
          public color1: Packages.arc.graphics.Color;
          public color2: Packages.arc.graphics.Color;
          public distance: number;
          public frequency: number;
          protected onApply(
            _label: Packages.arc.flabel.FLabel,
            _glyph: Packages.arc.flabel.FGlyph,
            _localIndex: number,
            _delta: number,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace flabel {
      declare namespace effects {
        declare class JumpEffect extends Packages.arc.flabel
          .FEffect {
          private static defaultFrequency: number;
          private static defaultDistance: number;
          private static defaultIntensity: number;
          public distance: number;
          public frequency: number;
          public intensity: number;
          protected onApply(
            _label: Packages.arc.flabel.FLabel,
            _glyph: Packages.arc.flabel.FGlyph,
            _localIndex: number,
            _delta: number,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace flabel {
      declare namespace effects {
        declare class RainbowEffect extends Packages.arc
          .flabel.FEffect {
          private static defaultDistance: number;
          private static defaultFrequency: number;
          public distance: number;
          public frequency: number;
          public saturation: number;
          public brightness: number;
          protected onApply(
            _label: Packages.arc.flabel.FLabel,
            _glyph: Packages.arc.flabel.FGlyph,
            _localIndex: number,
            _delta: number,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace flabel {
      declare namespace effects {
        declare class ShakeEffect extends Packages.arc
          .flabel.FEffect {
          private static defaultDistance: number;
          private static defaultIntensity: number;
          private lastOffsets: Packages.arc.struct.FloatSeq;
          public distance: number;
          public intensity: number;
          protected onApply(
            _label: Packages.arc.flabel.FLabel,
            _glyph: Packages.arc.flabel.FGlyph,
            _localIndex: number,
            _delta: number,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace flabel {
      declare namespace effects {
        declare class SickEffect extends Packages.arc.flabel
          .FEffect {
          private static defaultFrequency: number;
          private static defaultDistance: number;
          private static defaultIntensity: number;
          public distance: number;
          public intensity: number;
          private indices: Packages.arc.struct.IntSeq;
          protected onApply(
            _label: Packages.arc.flabel.FLabel,
            _glyph: Packages.arc.flabel.FGlyph,
            _localIndex: number,
            _delta: number,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace flabel {
      declare namespace effects {
        declare class WaveEffect extends Packages.arc.flabel
          .FEffect {
          private static defaultFrequency: number;
          private static defaultDistance: number;
          private static defaultIntensity: number;
          public distance: number;
          public frequency: number;
          public intensity: number;
          protected onApply(
            _label: Packages.arc.flabel.FLabel,
            _glyph: Packages.arc.flabel.FGlyph,
            _localIndex: number,
            _delta: number,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace flabel {
      declare namespace effects {
        declare class WindEffect extends Packages.arc.flabel
          .FEffect {
          private static defaultSpacing: number;
          private static defaultDistance: number;
          private static defaultIntensity: number;
          private static distanceXRatio: number;
          private static distanceYRatio: number;
          private noiseCursorX: number;
          private noiseCursorY: number;
          public distanceX: number;
          public distanceY: number;
          public spacing: number;
          public intensity: number;
          public update(_delta: number): void;
          protected onApply(
            _label: Packages.arc.flabel.FLabel,
            _glyph: Packages.arc.flabel.FGlyph,
            _localIndex: number,
            _delta: number,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class BiasFilter extends Packages.arc.fx
          .FxFilter {
          public bias: number;
          public setParams(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare abstract class MultipassVfxFilter
          extends java.lang.Object
          implements Packages.arc.util.Disposable
        {
          public resize(
            _width: number,
            _height: number,
          ): void;
          public setParams(): void;
          public render(
            _pingPongBuffer: Packages.arc.fx.util.PingPongBuffer,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class Convolve1dFilter extends Packages.arc
          .fx.FxFilter {
          public length: number;
          public weights: number[];
          public offsets: number[];
          public dispose(): void;
          public setParams(): void;
          public setWeights(
            _length: number,
            _weights: number[],
            _offsets: number[],
          ): void;
          public constructor(
            _length: number,
            _weights_data: number[],
            _offsets: number[],
          );
          public constructor(
            _length: number,
            _weights_data: number[],
          );
          public constructor(_length: number);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class Convolve2dFilter extends Packages.arc
          .fx.filters.MultipassVfxFilter {
          public radius: number;
          public length: number;
          public weights: number[];
          public offsetsHor: number[];
          public offsetsVert: number[];
          public hor: Packages.arc.fx.filters.Convolve1dFilter;
          public vert: Packages.arc.fx.filters.Convolve1dFilter;
          public dispose(): void;
          public setParams(): void;
          public render(
            _buffer: Packages.arc.fx.util.PingPongBuffer,
          ): void;
          public constructor(_radius: number);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class GaussianBlurFilter extends Packages
          .arc.fx.filters.MultipassVfxFilter {
          public static BlurType = class extends Packages
            .java.lang
            .Enum<Packages.arc.fx.filters.GaussianBlurFilter.BlurType> {
            public static gaussian3x3: Packages.arc.fx.filters.GaussianBlurFilter.BlurType;
            public static gaussian3x3b: Packages.arc.fx.filters.GaussianBlurFilter.BlurType;
            public static gaussian5x5: Packages.arc.fx.filters.GaussianBlurFilter.BlurType;
            public static gaussian5x5b: Packages.arc.fx.filters.GaussianBlurFilter.BlurType;
            public tap: Packages.arc.fx.filters.GaussianBlurFilter.Tap;
            private static $VALUES: Packages.arc.fx.filters.GaussianBlurFilter.BlurType[];
            public static values():
              | Packages.arc.fx.filters.GaussianBlurFilter.BlurType[]
              | null;
            public static valueOf(
              _name: string,
            ): Packages.arc.fx.filters.GaussianBlurFilter.BlurType;
          };
          private static Tap = class extends Packages.java
            .lang
            .Enum<Packages.arc.fx.filters.GaussianBlurFilter.Tap> {
            public static tap3x3: Packages.arc.fx.filters.GaussianBlurFilter.Tap;
            public static tap5x5: Packages.arc.fx.filters.GaussianBlurFilter.Tap;
            public radius: number;
            private static $VALUES: Packages.arc.fx.filters.GaussianBlurFilter.Tap[];
            public static values():
              | Packages.arc.fx.filters.GaussianBlurFilter.Tap[]
              | null;
            public static valueOf(
              _name: string,
            ): Packages.arc.fx.filters.GaussianBlurFilter.Tap;
          };
          private type: Packages.arc.fx.filters.GaussianBlurFilter.BlurType;
          private amount: number;
          private passes: number;
          private invWidth: number;
          private invHeight: number;
          private convolve: Packages.arc.fx.filters.Convolve2dFilter;
          public getType(): Packages.arc.fx.filters.GaussianBlurFilter.BlurType;
          public resize(
            _width: number,
            _height: number,
          ): void;
          public dispose(): void;
          public setParams(): void;
          public render(
            _buffer: Packages.arc.fx.util.PingPongBuffer,
          ): void;
          private computeBlurWeightings(): void;
          private computeKernel(
            _blurRadius: number,
            _blurAmount: number,
            _outKernel: number[],
          ): void;
          private computeOffsets(
            _blurRadius: number,
            _dx: number,
            _dy: number,
            _outOffsetH: number[],
            _outOffsetV: number[],
          ): void;
          public getAmount(): number;
          public getPasses(): number;
          public setPasses(_passes: number): void;
          public setAmount(_amount: number): void;
          public setType(
            _type: Packages.arc.fx.filters.GaussianBlurFilter.BlurType,
          ): void;
          public constructor();
          public constructor(
            _blurType: Packages.arc.fx.filters.GaussianBlurFilter.BlurType,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class ThresholdFilter extends Packages.arc
          .fx.FxFilter {
          public gamma: number;
          public setParams(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class CombineFilter extends Packages.arc.fx
          .FxFilter {
          public src1int: number;
          public src1sat: number;
          public src2int: number;
          public src2sat: number;
          public inputTexture2: Packages.arc.graphics.Texture;
          public setInput(
            _texture1: Packages.arc.graphics.Texture,
            _texture2: Packages.arc.graphics.Texture,
          ): Packages.arc.fx.filters.CombineFilter;
          public setInput(
            _buffer1: Packages.arc.graphics.gl.FrameBuffer,
            _buffer2: Packages.arc.graphics.gl.FrameBuffer,
          ): Packages.arc.fx.filters.CombineFilter;
          public setParams(): void;
          protected onBeforeRender(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class BloomFilter extends Packages.arc.fx
          .FxFilter {
          public buffer: Packages.arc.fx.util.PingPongBuffer;
          public blur: Packages.arc.fx.filters.GaussianBlurFilter;
          public threshold: Packages.arc.fx.filters.ThresholdFilter;
          public combine: Packages.arc.fx.filters.CombineFilter;
          public blending: Packages.arc.graphics.Blending;
          public scaling: number;
          public rebind(): void;
          public resize(
            _width: number,
            _height: number,
          ): void;
          public dispose(): void;
          public render(
            _src: Packages.arc.graphics.gl.FrameBuffer,
            _dst: Packages.arc.graphics.gl.FrameBuffer,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class CopyFilter extends Packages.arc.fx
          .FxFilter {
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class BlurFilter extends Packages.arc.fx
          .FxFilter {
          public blur: Packages.arc.fx.filters.GaussianBlurFilter;
          private pingPongBuffer: Packages.arc.fx.util.PingPongBuffer;
          private copy: Packages.arc.fx.filters.CopyFilter;
          public blending: Packages.arc.graphics.Blending;
          private firstRender: boolean;
          public rebind(): void;
          public resize(
            _width: number,
            _height: number,
          ): void;
          public dispose(): void;
          public render(
            _src: Packages.arc.graphics.gl.FrameBuffer,
            _dst: Packages.arc.graphics.gl.FrameBuffer,
          ): void;
          public constructor();
          public constructor(
            _blurPasses: number,
            _blurType: Packages.arc.fx.filters.GaussianBlurFilter.BlurType,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class ChromaticAberrationFilter extends Packages
          .arc.fx.FxFilter {
          public maxDistortion: number;
          public setParams(): void;
          public constructor(_passes: number);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class CrtFilter extends Packages.arc.fx
          .FxFilter {
          public static LineStyle = class extends Packages
            .java.lang
            .Enum<Packages.arc.fx.filters.CrtFilter.LineStyle> {
            public static CROSSLINE_HARD: Packages.arc.fx.filters.CrtFilter.LineStyle;
            public static VERTICAL_HARD: Packages.arc.fx.filters.CrtFilter.LineStyle;
            public static HORIZONTAL_HARD: Packages.arc.fx.filters.CrtFilter.LineStyle;
            public static VERTICAL_SMOOTH: Packages.arc.fx.filters.CrtFilter.LineStyle;
            public static HORIZONTAL_SMOOTH: Packages.arc.fx.filters.CrtFilter.LineStyle;
            private static $VALUES: Packages.arc.fx.filters.CrtFilter.LineStyle[];
            public static values():
              | Packages.arc.fx.filters.CrtFilter.LineStyle[]
              | null;
            public static valueOf(
              _name: string,
            ): Packages.arc.fx.filters.CrtFilter.LineStyle;
          };
          public static SizeSource = class extends Packages
            .java.lang
            .Enum<Packages.arc.fx.filters.CrtFilter.SizeSource> {
            public static VIEWPORT: Packages.arc.fx.filters.CrtFilter.SizeSource;
            public static SCREEN: Packages.arc.fx.filters.CrtFilter.SizeSource;
            private static $VALUES: Packages.arc.fx.filters.CrtFilter.SizeSource[];
            public static values():
              | Packages.arc.fx.filters.CrtFilter.SizeSource[]
              | null;
            public static valueOf(
              _name: string,
            ): Packages.arc.fx.filters.CrtFilter.SizeSource;
          };
          public viewportSize: Packages.arc.math.geom.Vec2;
          public sizeSource: Packages.arc.fx.filters.CrtFilter.SizeSource;
          public resize(
            _width: number,
            _height: number,
          ): void;
          public setParams(): void;
          public constructor();
          public constructor(
            _lineStyle: Packages.arc.fx.filters.CrtFilter.LineStyle,
            _brightnessMin: number,
            _brightnessMax: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class FilmGrainFilter extends Packages.arc
          .fx.FxFilter {
          public seed: number;
          public update(): void;
          public setSeed(_seed: number): void;
          public setParams(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class FisheyeDistortionFilter extends Packages
          .arc.fx.FxFilter {
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class FxaaFilter extends Packages.arc.fx
          .FxFilter {
          public viewportInverse: Packages.arc.math.geom.Vec2;
          public fxaaReduceMin: number;
          public fxaaReduceMul: number;
          public fxaaSpanMax: number;
          public resize(
            _width: number,
            _height: number,
          ): void;
          public setParams(): void;
          public constructor();
          public constructor(
            _fxaaReduceMin: number,
            _fxaaReduceMul: number,
            _fxaaSpanMax: number,
            _supportAlpha: boolean,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class HdrFilter extends Packages.arc.fx
          .FxFilter {
          public exposure: number;
          public gamma: number;
          public setParams(): void;
          public constructor();
          public constructor(
            _exposure: number,
            _gamma: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class LensFlareFilter extends Packages.arc
          .fx.FxFilter {
          private viewport: Packages.arc.math.geom.Vec2;
          public lightPosition: Packages.arc.math.geom.Vec2;
          public color: Packages.arc.graphics.Color;
          public intensity: number;
          public resize(
            _width: number,
            _height: number,
          ): void;
          public setParams(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class LevelsFilter extends Packages.arc.fx
          .FxFilter {
          public brightness: number;
          public contrast: number;
          public saturation: number;
          public hue: number;
          public gamma: number;
          public setParams(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class MixFilter extends Packages.arc.fx
          .FxFilter {
          private inputTexture2: Packages.arc.graphics.Texture;
          public mix: number;
          public resize(
            _width: number,
            _height: number,
          ): void;
          public setInput(
            _input: Packages.arc.graphics.gl.FrameBuffer,
          ): Packages.arc.fx.FxFilter;
          public setInput(
            _input: Packages.arc.graphics.Texture,
          ): Packages.arc.fx.FxFilter;
          public setInput(
            _buffer1: Packages.arc.graphics.gl.FrameBuffer,
            _buffer2: Packages.arc.graphics.gl.FrameBuffer,
          ): Packages.arc.fx.filters.MixFilter;
          public setInput(
            _input: Packages.arc.graphics.Texture,
          ): Packages.arc.fx.filters.MixFilter;
          public setInput(
            _input: Packages.arc.graphics.gl.FrameBuffer,
          ): Packages.arc.fx.filters.MixFilter;
          public setInput(
            _texture1: Packages.arc.graphics.Texture,
            _texture2: Packages.arc.graphics.Texture,
          ): Packages.arc.fx.filters.MixFilter;
          public setParams(): void;
          protected onBeforeRender(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace util {
        declare class FxBufferQueue
          extends java.lang.Object
          implements Packages.arc.util.Disposable
        {
          private buffers: Packages.arc.struct.Seq<Packages.arc.graphics.gl.FrameBuffer>;
          private currentIdx: number;
          private wrapU: Packages.arc.graphics.Texture.TextureWrap;
          private wrapV: Packages.arc.graphics.Texture.TextureWrap;
          private filterMin: Packages.arc.graphics.Texture.TextureFilter;
          private filterMag: Packages.arc.graphics.Texture.TextureFilter;
          public rebind(): void;
          public resize(
            _width: number,
            _height: number,
          ): void;
          public dispose(): void;
          public setTextureParams(
            _u: Packages.arc.graphics.Texture.TextureWrap,
            _v: Packages.arc.graphics.Texture.TextureWrap,
            _min: Packages.arc.graphics.Texture.TextureFilter,
            _mag: Packages.arc.graphics.Texture.TextureFilter,
          ): void;
          public getCurrent(): Packages.arc.graphics.gl.FrameBuffer;
          public changeToNext(): Packages.arc.graphics.gl.FrameBuffer;
          public constructor(
            _pixelFormat: Packages.arc.graphics.Pixmap.Format,
            _fboAmount: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class MotionBlurFilter extends Packages.arc
          .fx.FxFilter {
          public static BlurFunction = class extends Packages
            .java.lang
            .Enum<Packages.arc.fx.filters.MotionBlurFilter.BlurFunction> {
            public static MAX: Packages.arc.fx.filters.MotionBlurFilter.BlurFunction;
            public static MIX: Packages.arc.fx.filters.MotionBlurFilter.BlurFunction;
            fragmentShaderName: string;
            private static $VALUES: Packages.arc.fx.filters.MotionBlurFilter.BlurFunction[];
            public static values():
              | Packages.arc.fx.filters.MotionBlurFilter.BlurFunction[]
              | null;
            public static valueOf(
              _name: string,
            ): Packages.arc.fx.filters.MotionBlurFilter.BlurFunction;
          };
          private copyFilter: Packages.arc.fx.filters.CopyFilter;
          private localBuffer: Packages.arc.fx.util.FxBufferQueue;
          public blurOpacity: number;
          public lastFrameTex: Packages.arc.graphics.Texture;
          public rebind(): void;
          public resize(
            _width: number,
            _height: number,
          ): void;
          public dispose(): void;
          public setParams(): void;
          protected onBeforeRender(): void;
          public render(
            _src: Packages.arc.graphics.gl.FrameBuffer,
            _dst: Packages.arc.graphics.gl.FrameBuffer,
          ): void;
          public constructor(
            _blurFunction: Packages.arc.fx.filters.MotionBlurFilter.BlurFunction,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class NfaaFilter extends Packages.arc.fx
          .FxFilter {
          private viewportInverse: Packages.arc.math.geom.Vec2;
          public resize(
            _width: number,
            _height: number,
          ): void;
          public setParams(): void;
          public constructor();
          public constructor(_supportAlpha: boolean);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class NoiseFilter extends Packages.arc.fx
          .FxFilter {
          public amount: number;
          public speed: number;
          public setParams(): void;
          public constructor(
            _amount: number,
            _speed: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class OldTvFilter extends Packages.arc.fx
          .FxFilter {
          private resolution: Packages.arc.math.geom.Vec2;
          public resize(
            _width: number,
            _height: number,
          ): void;
          public setParams(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class RadialBlurFilter extends Packages.arc
          .fx.FxFilter {
          public passes: number;
          public strength: number;
          public originX: number;
          public originY: number;
          public zoom: number;
          public setOrigin(
            _originX: number,
            _originY: number,
          ): void;
          public setOrigin(_align: number): void;
          public setParams(): void;
          public getOriginX(): number;
          public getOriginY(): number;
          public constructor(_passes: number);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class RadialDistortionFilter extends Packages
          .arc.fx.FxFilter {
          public zoom: number;
          public distortion: number;
          public setParams(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class RippleFilter extends Packages.arc.fx
          .FxFilter {
          public amount: number;
          public speed: number;
          public setParams(): void;
          public constructor(
            _amount: number,
            _speed: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class VignettingFilter extends Packages.arc
          .fx.FxFilter {
          private lutTexture: Packages.arc.graphics.Texture;
          public vignetteX: number;
          public vignetteY: number;
          public centerX: number;
          public centerY: number;
          public intensity: number;
          public saturation: number;
          public saturationMul: number;
          public saturationEnabled: boolean;
          public lutEnabled: boolean;
          public lutIntensity: number;
          public lutIndex1: number;
          public lutIndex2: number;
          public lutStep: number;
          public lutStepOffset: number;
          public lutIndexOffset: number;
          public setParams(): void;
          protected onBeforeRender(): void;
          public setLut(
            _texture: Packages.arc.graphics.Texture,
          ): void;
          public constructor(_controlSaturation: boolean);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace filters {
        declare class ZoomFilter extends Packages.arc.fx
          .FxFilter {
          public originX: number;
          public originY: number;
          public zoom: number;
          public setOrigin(_align: number): void;
          public setParams(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace fx {
      declare namespace util {
        declare class FxWidgetGroup extends Packages.arc
          .scene.ui.layout.WidgetGroup {
          private fxProcessor: Packages.arc.fx.FxProcessor;
          private initialized: boolean;
          private resizePending: boolean;
          private matchWidgetSize: boolean;
          private initialize(): void;
          private reset(): void;
          public draw(): void;
          protected setScene(
            _stage: Packages.arc.scene.Scene,
          ): void;
          public setTransform(_transform: boolean): void;
          protected sizeChanged(): void;
          protected drawChildren(): void;
          public setCullingArea(
            _cullingArea: Packages.arc.math.geom.Rect,
          ): void;
          private performPendingResize(): void;
          public getFxProcessor(): Packages.arc.fx.FxProcessor;
          public isMatchWidgetSize(): boolean;
          public setMatchWidgetSize(
            _matchWidgetSize: boolean,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace g2d {
        declare class Animation<T> extends java.lang
          .Object {
          public static PlayMode = class extends Packages
            .java.lang
            .Enum<Packages.arc.graphics.g2d.Animation.PlayMode> {
            public static normal: Packages.arc.graphics.g2d.Animation.PlayMode;
            public static reversed: Packages.arc.graphics.g2d.Animation.PlayMode;
            public static loop: Packages.arc.graphics.g2d.Animation.PlayMode;
            public static loopReversed: Packages.arc.graphics.g2d.Animation.PlayMode;
            public static loopPingPong: Packages.arc.graphics.g2d.Animation.PlayMode;
            public static loopRandom: Packages.arc.graphics.g2d.Animation.PlayMode;
            private static $VALUES: Packages.arc.graphics.g2d.Animation.PlayMode[];
            public static values():
              | Packages.arc.graphics.g2d.Animation.PlayMode[]
              | null;
            public static valueOf(
              _name: string,
            ): Packages.arc.graphics.g2d.Animation.PlayMode;
          };
          keyFrames: T[];
          private frameDuration: number;
          private animationDuration: number;
          private lastFrameNumber: number;
          private lastStateTime: number;
          private playMode: Packages.arc.graphics.g2d.Animation.PlayMode;
          protected setKeyFrames(..._keyFrames: T[]): void;
          public setPlayMode(
            _playMode: Packages.arc.graphics.g2d.Animation.PlayMode,
          ): void;
          public getKeyFrame(_stateTime: number): T | null;
          public getKeyFrame(
            _stateTime: number,
            _looping: boolean,
          ): T | null;
          public getKeyFrameIndex(
            _stateTime: number,
          ): number;
          public getKeyFrames(): T[] | null;
          public getPlayMode(): Packages.arc.graphics.g2d.Animation.PlayMode;
          public isAnimationFinished(
            _stateTime: number,
          ): boolean;
          public getFrameDuration(): number;
          public setFrameDuration(
            _frameDuration: number,
          ): void;
          public getAnimationDuration(): number;
          public constructor(
            _frameDuration: number,
            ..._keyFrames: T[]
          );
          public constructor(
            _frameDuration: number,
            _keyFrames: Packages.arc.struct.Seq<any>,
            _playMode: Packages.arc.graphics.g2d.Animation.PlayMode,
          );
          public constructor(
            _frameDuration: number,
            _keyFrames: Packages.arc.struct.Seq<any>,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace g2d {
        declare class Bloom extends java.lang.Object {
          public blurPasses: number;
          public blending: boolean;
          private thresholdShader: Packages.arc.graphics.gl.Shader;
          private bloomShader: Packages.arc.graphics.gl.Shader;
          private blurShader: Packages.arc.graphics.gl.Shader;
          private pingPong1: Packages.arc.graphics.gl.FrameBuffer;
          private pingPong2: Packages.arc.graphics.gl.FrameBuffer;
          private bloomIntensity: number;
          private originalIntensity: number;
          private threshold: number;
          private capturing: boolean;
          private r: number;
          private g: number;
          private b: number;
          private a: number;
          public buffer(): Packages.arc.graphics.gl.FrameBuffer;
          private init(
            _width: number,
            _height: number,
            _hasDepth: boolean,
            _useBlending: boolean,
          ): void;
          public resume(): void;
          public resize(
            _width: number,
            _height: number,
          ): void;
          public resize(
            _width: number,
            _height: number,
            _scaling: number,
          ): void;
          public setThreshold(_threshold: number): void;
          private setSize(
            _width: number,
            _height: number,
          ): void;
          public dispose(): void;
          public capture(): void;
          private static createShader(
            _vertexName: string,
            _fragmentName: string,
          ): Packages.arc.graphics.gl.Shader;
          public render(): void;
          public setBloomIntensity(
            _intensity: number,
          ): void;
          public setOriginalIntensity(
            _intensity: number,
          ): void;
          public setClearColor(
            _r: number,
            _g: number,
            _b: number,
            _a: number,
          ): void;
          public capturePause(): void;
          public captureContinue(): void;
          public constructor(_useBlending: boolean);
          public constructor();
          public constructor(
            _width: number,
            _height: number,
            _hasDepth: boolean,
            _useBlending: boolean,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace g2d {
        declare class SpriteCache
          extends java.lang.Object
          implements Packages.arc.util.Disposable
        {
          private static Cache = class extends java.lang
            .Object {
            id: number;
            offset: number;
            maxCount: number;
            textureCount: number;
            textures: Packages.arc.graphics.Texture[];
            counts: number[];
            public constructor(
              _id: number,
              _offset: number,
            );
          };
          static VERTEX_SIZE: number;
          private static tempVertices: number[];
          private mesh: Packages.arc.graphics.Mesh;
          private transformMatrix: Packages.arc.math.Mat;
          private projectionMatrix: Packages.arc.math.Mat;
          private combinedMatrix: Packages.arc.math.Mat;
          private shader: Packages.arc.graphics.gl.Shader;
          private textures: Packages.arc.struct.Seq<Packages.arc.graphics.Texture>;
          private counts: Packages.arc.struct.IntSeq;
          private color: Packages.arc.graphics.Color;
          public renderCalls: number;
          public totalRenderCalls: number;
          private drawing: boolean;
          private caches: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.SpriteCache.Cache>;
          private currentCache: Packages.arc.graphics.g2d.SpriteCache.Cache;
          private colorPacked: number;
          private customShader: Packages.arc.graphics.gl.Shader;
          public add(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _x: number,
            _y: number,
            _originX: number,
            _originY: number,
            _width: number,
            _height: number,
            _scaleX: number,
            _scaleY: number,
            _rotation: number,
          ): void;
          public add(
            _texture: Packages.arc.graphics.Texture,
            _vertices: number[],
            _offset: number,
            _length: number,
          ): void;
          public add(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _x: number,
            _y: number,
          ): void;
          public add(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          ): void;
          public clear(): void;
          public end(): void;
          public begin(): void;
          public setColor(
            _tint: Packages.arc.graphics.Color,
          ): void;
          public setColor(
            _r: number,
            _g: number,
            _b: number,
            _a: number,
          ): void;
          public dispose(): void;
          public draw(_cacheID: number): void;
          public draw(
            _cacheID: number,
            _offset: number,
            _length: number,
          ): void;
          public setShader(
            _shader: Packages.arc.graphics.gl.Shader,
          ): void;
          public setPackedColor(_packedColor: number): void;
          public getPackedColor(): number;
          public getColor(): Packages.arc.graphics.Color;
          public setProjectionMatrix(
            _projection: Packages.arc.math.Mat,
          ): void;
          public beginCache(_cacheID: number): void;
          public beginCache(): void;
          public endCache(): number;
          public isDrawing(): boolean;
          public static createDefaultShader(): Packages.arc.graphics.gl.Shader;
          public getCaches(): Packages.arc.struct.Seq<Packages.arc.graphics.g2d.SpriteCache.Cache>;
          public reserve(_sprites: number): number;
          public getProjectionMatrix(): Packages.arc.math.Mat;
          public getTransformMatrix(): Packages.arc.math.Mat;
          public setTransformMatrix(
            _transform: Packages.arc.math.Mat,
          ): void;
          public constructor(
            _size: number,
            _cacheSize: number,
            _shader: Packages.arc.graphics.gl.Shader,
            _useIndices: boolean,
          );
          public constructor(
            _size: number,
            _cacheSize: number,
            _useIndices: boolean,
          );
          public constructor(
            _size: number,
            _useIndices: boolean,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace g2d {
        declare class CacheBatch extends Packages.arc
          .graphics.g2d.Batch {
          cache: Packages.arc.graphics.g2d.SpriteCache;
          tmpVertices: number[];
          public flush(): void;
          public dispose(): void;
          protected draw(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _x: number,
            _y: number,
            _originX: number,
            _originY: number,
            _width: number,
            _height: number,
            _rotation: number,
          ): void;
          protected draw(
            _texture: Packages.arc.graphics.Texture,
            _spriteVertices: number[],
            _offset: number,
            _count: number,
          ): void;
          public setShader(
            _shader: Packages.arc.graphics.gl.Shader,
          ): void;
          public setShader(
            _shader: Packages.arc.graphics.gl.Shader,
            _apply: boolean,
          ): void;
          public setPackedColor(_color: number): void;
          public getPackedColor(): number;
          public setProjection(
            _projection: Packages.arc.math.Mat,
          ): void;
          public beginCache(): void;
          public endCache(): number;
          public beginDraw(): void;
          public endDraw(): void;
          public drawCache(_id: number): void;
          public constructor(_size: number);
          public constructor(
            _cache: Packages.arc.graphics.g2d.SpriteCache,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace g2d {
        declare class DistanceFieldFont extends Packages.arc
          .graphics.g2d.Font {
          private static DistanceFieldFontCache = class extends Packages
            .arc.graphics.g2d.FontCache {
            public draw(_start: number, _end: number): void;
            public draw(): void;
            private getSmoothingFactor(): number;
            private setSmoothingUniform(
              _smoothing: number,
            ): void;
            public constructor(
              _font: Packages.arc.graphics.g2d.DistanceFieldFont,
            );
            public constructor(
              _font: Packages.arc.graphics.g2d.DistanceFieldFont,
              _integer: boolean,
            );
          };
          private distanceFieldSmoothing: number;
          protected load(
            _data: Packages.arc.graphics.g2d.Font.FontData,
          ): void;
          public newFontCache(): Packages.arc.graphics.g2d.FontCache;
          public static createDistanceFieldShader(): Packages.arc.graphics.gl.Shader;
          public getDistanceFieldSmoothing(): number;
          public setDistanceFieldSmoothing(
            _distanceFieldSmoothing: number,
          ): void;
          public constructor(
            _fontFile: Packages.arc.files.Fi,
            _imageFile: Packages.arc.files.Fi,
            _flip: boolean,
          );
          public constructor(
            _fontFile: Packages.arc.files.Fi,
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _flip: boolean,
          );
          public constructor(
            _fontFile: Packages.arc.files.Fi,
            _region: Packages.arc.graphics.g2d.TextureRegion,
          );
          public constructor(
            _fontFile: Packages.arc.files.Fi,
          );
          public constructor(
            _data: Packages.arc.graphics.g2d.Font.FontData,
            _pageRegions: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.TextureRegion>,
            _integer: boolean,
          );
          public constructor(
            _data: Packages.arc.graphics.g2d.Font.FontData,
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _integer: boolean,
          );
          public constructor(
            _fontFile: Packages.arc.files.Fi,
            _flip: boolean,
          );
          public constructor(
            _fontFile: Packages.arc.files.Fi,
            _imageFile: Packages.arc.files.Fi,
            _flip: boolean,
            _integer: boolean,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace g2d {
        declare class ScreenQuad
          extends java.lang.Object
          implements Packages.arc.util.Disposable
        {
          public mesh: Packages.arc.graphics.Mesh;
          public dispose(): void;
          public render(
            _shader: Packages.arc.graphics.gl.Shader,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace g2d {
        declare class Draw extends java.lang.Object {
          private static squad: Packages.arc.graphics.g2d.ScreenQuad;
          private static carr: Packages.arc.graphics.Color[];
          private static vertices: number[];
          private static zTransformer?: Packages.arc.func.FloatFloatf;
          private static actualZ: number;
          private static retColor: Packages.arc.graphics.Color;
          private static retPackedColor: Packages.arc.graphics.Color;
          public static xscl: number;
          public static yscl: number;
          public static blend(): void;
          public static blend(
            _blending: Packages.arc.graphics.Blending,
          ): void;
          public static wrap(
            _texture: Packages.arc.graphics.Texture,
          ): Packages.arc.graphics.g2d.TextureRegion;
          public static flush(): void;
          public static scl(): void;
          public static scl(
            _nxscl: number,
            _nyscl: number,
          ): void;
          public static scl(_nscl: number): void;
          public static z(_z: number): void;
          public static z(): number;
          public static reset(): void;
          public static sort(_sort: boolean): void;
          public static color(
            _color: Packages.arc.graphics.Color,
          ): void;
          public static color(
            _a: Packages.arc.graphics.Color,
            _b: Packages.arc.graphics.Color,
            _c: Packages.arc.graphics.Color,
            _progress: number,
          ): void;
          public static color(_color: number): void;
          public static color(_color: number): void;
          public static color(
            _color: Packages.arc.graphics.Color,
            _alpha: number,
          ): void;
          public static color(
            _r: number,
            _g: number,
            _b: number,
          ): void;
          public static color(): void;
          public static color(
            _a: Packages.arc.graphics.Color,
            _b: Packages.arc.graphics.Color,
            _s: number,
          ): void;
          public static color(
            _r: number,
            _g: number,
            _b: number,
            _a: number,
          ): void;
          public static trans(
            _trans: Packages.arc.math.Mat,
          ): void;
          public static trans(): Packages.arc.math.Mat;
          public static batch(
            _nextBatch: Packages.arc.graphics.g2d.Batch,
          ): void;
          public static batch(
            _nextBatch: Packages.arc.graphics.g2d.Batch,
            _run: Packages.java.lang.Runnable,
          ): void;
          public static alpha(_alpha: number): void;
          public static draw(
            _z: number,
            _run: Packages.java.lang.Runnable,
          ): void;
          public static shader(
            _shader: Packages.arc.graphics.gl.Shader,
          ): void;
          public static shader(
            _shader: Packages.arc.graphics.gl.Shader,
            _apply: boolean,
          ): void;
          public static shader(): void;
          public static getShader(): Packages.arc.graphics.gl.Shader;
          public static discard(): void;
          public static proj(): Packages.arc.math.Mat;
          public static proj(
            _proj: Packages.arc.graphics.Camera,
          ): void;
          public static proj(
            _proj: Packages.arc.math.Mat,
          ): void;
          public static proj(
            _x: number,
            _y: number,
            _w: number,
            _h: number,
          ): void;
          public static stencil(
            _stencil: Packages.java.lang.Runnable,
            _contents: Packages.java.lang.Runnable,
          ): void;
          public static rect(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _x: number,
            _y: number,
            _w: number,
            _h: number,
            _originX: number,
            _originY: number,
            _rotation: number,
          ): void;
          public static rect(
            _region: string,
            _x: number,
            _y: number,
            _w: number,
            _h: number,
            _originX: number,
            _originY: number,
            _rotation: number,
          ): void;
          public static rect(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _x: number,
            _y: number,
          ): void;
          public static rect(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _x: number,
            _y: number,
            _w: number,
            _h: number,
          ): void;
          public static rect(
            _region: string,
            _x: number,
            _y: number,
            _w: number,
            _h: number,
          ): void;
          public static rect(): void;
          public static rect(
            _region: string,
            _x: number,
            _y: number,
          ): void;
          public static rect(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _pos: Packages.arc.math.geom.Position,
            _w: number,
            _h: number,
          ): void;
          public static rect(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _pos: Packages.arc.math.geom.Position,
            _w: number,
            _h: number,
            _rotation: number,
          ): void;
          public static rect(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _pos: Packages.arc.math.geom.Position,
            _rotation: number,
          ): void;
          public static rect(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _x: number,
            _y: number,
            _rotation: number,
          ): void;
          public static rect(
            _region: string,
            _x: number,
            _y: number,
            _rotation: number,
          ): void;
          public static rect(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _x: number,
            _y: number,
            _w: number,
            _h: number,
            _rotation: number,
          ): void;
          public static rect(
            _region: string,
            _x: number,
            _y: number,
            _w: number,
            _h: number,
            _rotation: number,
          ): void;
          public static tint(
            _a: Packages.arc.graphics.Color,
            _b: Packages.arc.graphics.Color,
            _s: number,
          ): void;
          public static tint(
            _color: Packages.arc.graphics.Color,
          ): void;
          public static getColor(): Packages.arc.graphics.Color;
          public static vert(
            _texture: Packages.arc.graphics.Texture,
            _vertices: number[],
            _offset: number,
            _length: number,
          ): void;
          public static blit(
            _buffer: Packages.arc.graphics.gl.FrameBuffer,
            _shader: Packages.arc.graphics.gl.Shader,
          ): void;
          public static blit(
            _texture: Packages.arc.graphics.Texture,
            _shader: Packages.arc.graphics.gl.Shader,
          ): void;
          public static blit(
            _shader: Packages.arc.graphics.gl.Shader,
          ): void;
          private static getQuad(): Packages.arc.graphics.g2d.ScreenQuad;
          public static beginStencil(): void;
          public static beginStenciled(): void;
          public static endStencil(): void;
          public static zTransform(): void;
          public static zTransform(
            _f: Packages.arc.func.FloatFloatf,
          ): void;
          public static getColorAlpha(): number;
          public static mixcol(
            _color: Packages.arc.graphics.Color,
            _a: number,
          ): void;
          public static mixcol(
            _a: Packages.arc.graphics.Color,
            _b: Packages.arc.graphics.Color,
            _prog: number,
          ): void;
          public static mixcol(): void;
          public static mixcol(_color: number): void;
          public static fbo(
            _buffer: Packages.arc.graphics.gl.FrameBuffer,
            _worldWidth: number,
            _worldHeight: number,
            _tilesize: number,
          ): void;
          public static fbo(
            _texture: Packages.arc.graphics.Texture,
            _worldWidth: number,
            _worldHeight: number,
            _tilesize: number,
          ): void;
          public static fbo(
            _texture: Packages.arc.graphics.Texture,
            _worldWidth: number,
            _worldHeight: number,
            _tilesize: number,
            _offset: number,
          ): void;
          public static drawRange(
            _z: number,
            _begin: Packages.java.lang.Runnable,
            _end: Packages.java.lang.Runnable,
          ): void;
          public static drawRange(
            _z: number,
            _range: number,
            _begin: Packages.java.lang.Runnable,
            _end: Packages.java.lang.Runnable,
          ): void;
          public static rectv(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _x: number,
            _y: number,
            _width: number,
            _height: number,
            _originX: number,
            _originY: number,
            _rotation: number,
            _tweaker: Packages.arc.func.Cons<Packages.arc.math.geom.Vec2>,
          ): void;
          public static rectv(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _x: number,
            _y: number,
            _width: number,
            _height: number,
            _tweaker: Packages.arc.func.Cons<Packages.arc.math.geom.Vec2>,
          ): void;
          public static rectv(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _x: number,
            _y: number,
            _width: number,
            _height: number,
            _rotation: number,
            _tweaker: Packages.arc.func.Cons<Packages.arc.math.geom.Vec2>,
          ): void;
          public static getColorPacked(): number;
          public static getMixColorPacked(): number;
          public static getMixColor(): Packages.arc.graphics.Color;
          public static colorMul(
            _color: Packages.arc.graphics.Color,
            _mul: number,
          ): void;
          public static colorl(_l: number): void;
          public static colorl(
            _l: number,
            _a: number,
          ): void;
          public static getBlend(): Packages.arc.graphics.Blending;
          public static quad(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _x1: number,
            _y1: number,
            _c1: number,
            _x2: number,
            _y2: number,
            _c2: number,
            _x3: number,
            _y3: number,
            _c3: number,
            _x4: number,
            _y4: number,
            _c4: number,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class Polygon
          extends java.lang.Object
          implements Packages.arc.math.geom.Shape2D
        {
          private localVertices: number[];
          private worldVertices: number[];
          private x: number;
          private y: number;
          private originX: number;
          private originY: number;
          private rotation: number;
          private scaleX: number;
          private scaleY: number;
          private bounds: Packages.arc.math.geom.Rect;
          public scale(_amount: number): void;
          public contains(_x: number, _y: number): boolean;
          public contains(
            _point: Packages.arc.math.geom.Vec2,
          ): boolean;
          public rotate(_degrees: number): void;
          public setScale(
            _scaleX: number,
            _scaleY: number,
          ): void;
          public dirty(): void;
          public getX(): number;
          public getY(): number;
          public translate(_x: number, _y: number): void;
          public getRotation(): number;
          public setPosition(_x: number, _y: number): void;
          public area(): number;
          public setOrigin(
            _originX: number,
            _originY: number,
          ): void;
          public setRotation(_degrees: number): void;
          public getScaleX(): number;
          public getScaleY(): number;
          public getVertices(): number[] | null;
          public setVertices(_vertices: number[]): void;
          public getOriginX(): number;
          public getOriginY(): number;
          public getTransformedVertices(): number[] | null;
          public getBoundingRectangle(): Packages.arc.math.geom.Rect;
          public constructor();
          public constructor(_vertices: number[]);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace g2d {
        declare class Fill extends java.lang.Object {
          private static vertices: number[];
          private static circleRegion: Packages.arc.graphics.g2d.TextureRegion;
          private static polyFloats: Packages.arc.struct.FloatSeq;
          public static square(
            _x: number,
            _y: number,
            _radius: number,
            _rotation: number,
          ): void;
          public static square(
            _x: number,
            _y: number,
            _radius: number,
          ): void;
          public static arc(
            _x: number,
            _y: number,
            _radius: number,
            _fraction: number,
            _rotation: number,
            _sides: number,
          ): void;
          public static arc(
            _x: number,
            _y: number,
            _radius: number,
            _fraction: number,
          ): void;
          public static arc(
            _x: number,
            _y: number,
            _radius: number,
            _fraction: number,
            _rotation: number,
          ): void;
          public static circle(
            _c: Packages.arc.math.geom.Circle,
          ): void;
          public static circle(
            _x: number,
            _y: number,
            _radius: number,
          ): void;
          public static rect(
            _x: number,
            _y: number,
            _w: number,
            _h: number,
            _rot: number,
          ): void;
          public static rect(
            _x: number,
            _y: number,
            _w: number,
            _h: number,
          ): void;
          public static rect(
            _r: Packages.arc.math.geom.Rect,
          ): void;
          public static rects(
            _x: number,
            _y: number,
            _w: number,
            _h: number,
            _skew: number,
          ): void;
          public static quad(
            _texture: Packages.arc.graphics.Texture,
            _x1: number,
            _y1: number,
            _c1: number,
            _u1: number,
            _v1: number,
            _x2: number,
            _y2: number,
            _c2: number,
            _u2: number,
            _v2: number,
            _x3: number,
            _y3: number,
            _c3: number,
            _u3: number,
            _v3: number,
            _x4: number,
            _y4: number,
            _c4: number,
            _u4: number,
            _v4: number,
          ): void;
          public static quad(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _x1: number,
            _y1: number,
            _c1: number,
            _x2: number,
            _y2: number,
            _c2: number,
            _x3: number,
            _y3: number,
            _c3: number,
            _x4: number,
            _y4: number,
            _c4: number,
          ): void;
          public static quad(
            _x1: number,
            _y1: number,
            _x2: number,
            _y2: number,
            _x3: number,
            _y3: number,
            _x4: number,
            _y4: number,
          ): void;
          public static quad(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _x1: number,
            _y1: number,
            _x2: number,
            _y2: number,
            _x3: number,
            _y3: number,
            _x4: number,
            _y4: number,
          ): void;
          public static quad(
            _x1: number,
            _y1: number,
            _c1: number,
            _x2: number,
            _y2: number,
            _c2: number,
            _x3: number,
            _y3: number,
            _c3: number,
            _x4: number,
            _y4: number,
            _c4: number,
          ): void;
          public static dropShadow(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
            _blur: number,
            _opacity: number,
          ): void;
          public static light(
            _x: number,
            _y: number,
            _sides: number,
            _radius: number,
            _rotation: number,
            _center: Packages.arc.graphics.Color,
            _edge: Packages.arc.graphics.Color,
          ): void;
          public static light(
            _x: number,
            _y: number,
            _sides: number,
            _radius: number,
            _center: Packages.arc.graphics.Color,
            _edge: Packages.arc.graphics.Color,
          ): void;
          public static poly(
            _vertices: number[],
            _length: number,
          ): void;
          public static poly(
            _p: Packages.arc.math.geom.Polygon,
          ): void;
          public static poly(
            _vertices: Packages.arc.struct.FloatSeq,
          ): void;
          public static poly(
            _x: number,
            _y: number,
            _sides: number,
            _radius: number,
          ): void;
          public static poly(
            _x: number,
            _y: number,
            _sides: number,
            _radius: number,
            _rotation: number,
          ): void;
          public static tri(
            _x1: number,
            _y1: number,
            _x2: number,
            _y2: number,
            _x3: number,
            _y3: number,
          ): void;
          public static polyBegin(): void;
          public static polyPoint(
            _x: number,
            _y: number,
          ): void;
          public static polyEnd(): void;
          public static crect(
            _x: number,
            _y: number,
            _w: number,
            _h: number,
          ): void;
          public static dropShadowRect(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
            _blur: number,
            _opacity: number,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare namespace concurrent {
        declare class ForkJoinPool {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare namespace concurrent {
        declare class TimeUnit {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare namespace concurrent {
        declare abstract class Future<V> {
          public get(
            _arg0: Packages.long,
            _arg1: Packages.java.util.concurrent.TimeUnit,
          ): V | null;
          public get(): V | null;
          public isDone(): boolean;
          public cancel(_arg0: boolean): boolean;
          public isCancelled(): boolean;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare namespace invoke {
        declare abstract class VarHandle {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare namespace concurrent {
        declare abstract class ForkJoinTask<V>
          extends java.lang.Object
          implements
            Packages.java.io.Serializable,
            Packages.java.util.concurrent.Future<V>
        {
          static Aux = class {};
          static AdaptedRunnableAction = class {};
          static AdaptedRunnable = class<T> {};
          static AdaptedCallable = class<T> {};
          static AdaptedInterruptibleCallable = class<T> {};
          static RunnableExecuteAction = class {};
          private static DONE: number;
          private static ABNORMAL: number;
          private static THROWN: number;
          private static SMASK: number;
          private static UNCOMPENSATE: number;
          status: number;
          private aux: Packages.java.util.concurrent.ForkJoinTask.Aux;
          private static STATUS: Packages.java.lang.invoke.VarHandle;
          private static AUX: Packages.java.lang.invoke.VarHandle;
          private static serialVersionUID: Packages.long;
          public invoke(): V | null;
          public get(): V | null;
          public get(
            _arg0: Packages.long,
            _arg1: Packages.java.util.concurrent.TimeUnit,
          ): V | null;
          public join(): V | null;
          private readObject(
            _arg0: Packages.java.io.ObjectInputStream,
          ): void;
          private writeObject(
            _arg0: Packages.java.io.ObjectOutputStream,
          ): void;
          public getException(): Packages.java.lang.Throwable;
          private getException(
            _arg0: number,
          ): Packages.java.lang.Throwable;
          protected exec(): boolean;
          public reinitialize(): void;
          public static getPool(): Packages.java.util.concurrent.ForkJoinPool;
          public complete(_arg0: V): void;
          static uncheckedThrow<
            T extends Packages.java.lang.Throwable,
          >(_arg0: Packages.java.lang.Throwable): void;
          public isDone(): boolean;
          public cancel(_arg0: boolean): boolean;
          public static invokeAll(
            _arg0: Packages.java.util.concurrent.ForkJoinTask<any>,
            _arg1: Packages.java.util.concurrent.ForkJoinTask<any>,
          ): void;
          public static invokeAll<
            T extends
              Packages.java.util.concurrent.ForkJoinTask<any>,
          >(
            _arg0: Packages.java.util.Collection<T>,
          ): Packages.java.util.Collection<T>;
          public static invokeAll(
            ..._arg0: Packages.java.util.concurrent.ForkJoinTask<any>[]
          ): void;
          public quietlyComplete(): void;
          protected setRawResult(_arg0: V): void;
          trySetThrown(
            _arg0: Packages.java.lang.Throwable,
          ): number;
          static isExceptionalStatus(
            _arg0: number,
          ): boolean;
          trySetException(
            _arg0: Packages.java.lang.Throwable,
          ): number;
          public getRawResult(): V | null;
          private casAux(
            _arg0: Packages.java.util.concurrent.ForkJoinTask.Aux,
            _arg1: Packages.java.util.concurrent.ForkJoinTask.Aux,
          ): boolean;
          private getAndBitwiseOrStatus(
            _arg0: number,
          ): number;
          private signalWaiters(): void;
          private casStatus(
            _arg0: number,
            _arg1: number,
          ): boolean;
          private setDone(): number;
          doExec(): number;
          private getThrowableException(): Packages.java.lang.Throwable;
          private awaitDone(
            _arg0: Packages.java.util.concurrent.ForkJoinPool,
            _arg1: boolean,
            _arg2: boolean,
            _arg3: boolean,
            _arg4: Packages.long,
          ): number;
          private reportException(_arg0: number): void;
          public fork(): Packages.java.util.concurrent.ForkJoinTask<V>;
          static cancelIgnoringExceptions(
            _arg0: Packages.java.util.concurrent.Future<any>,
          ): void;
          static rethrow(
            _arg0: Packages.java.lang.Throwable,
          ): void;
          private trySetCancelled(): number;
          private reportExecutionException(
            _arg0: number,
          ): void;
          public static getSurplusQueuedTaskCount(): number;
          protected static pollSubmission(): Packages.java.util.concurrent.ForkJoinTask<any>;
          public isCancelled(): boolean;
          public isCompletedAbnormally(): boolean;
          public isCompletedNormally(): boolean;
          public completeExceptionally(
            _arg0: Packages.java.lang.Throwable,
          ): void;
          public quietlyJoin(): void;
          public quietlyInvoke(): void;
          awaitPoolInvoke(
            _arg0: Packages.java.util.concurrent.ForkJoinPool,
            _arg1: Packages.long,
          ): void;
          awaitPoolInvoke(
            _arg0: Packages.java.util.concurrent.ForkJoinPool,
          ): void;
          joinForPoolInvoke(
            _arg0: Packages.java.util.concurrent.ForkJoinPool,
          ): V | null;
          getForPoolInvoke(
            _arg0: Packages.java.util.concurrent.ForkJoinPool,
          ): V | null;
          getForPoolInvoke(
            _arg0: Packages.java.util.concurrent.ForkJoinPool,
            _arg1: Packages.long,
          ): V | null;
          public static helpQuiesce(): void;
          public static inForkJoinPool(): boolean;
          public tryUnfork(): boolean;
          public static getQueuedTaskCount(): number;
          protected static peekNextLocalTask(): Packages.java.util.concurrent.ForkJoinTask<any>;
          protected static pollNextLocalTask(): Packages.java.util.concurrent.ForkJoinTask<any>;
          protected static pollTask(): Packages.java.util.concurrent.ForkJoinTask<any>;
          public getForkJoinTaskTag(): Packages.short;
          public setForkJoinTaskTag(
            _arg0: Packages.short,
          ): Packages.short;
          public compareAndSetForkJoinTaskTag(
            _arg0: Packages.short,
            _arg1: Packages.short,
          ): boolean;
          public static adapt(
            _arg0: Packages.java.lang.Runnable,
          ): Packages.java.util.concurrent.ForkJoinTask<any>;
          public static adapt<T>(
            _arg0: Packages.java.util.concurrent.Callable<any>,
          ): Packages.java.util.concurrent.ForkJoinTask<T>;
          public static adapt<T>(
            _arg0: Packages.java.lang.Runnable,
            _arg1: T,
          ): Packages.java.util.concurrent.ForkJoinTask<T>;
          private static adaptInterruptible<T>(
            _arg0: Packages.java.util.concurrent.Callable<any>,
          ): Packages.java.util.concurrent.ForkJoinTask<T>;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare namespace concurrent {
        declare abstract class RecursiveAction extends Packages
          .java.util.concurrent.ForkJoinTask<void> {
          private static serialVersionUID: Packages.long;
          protected compute(): void;
          protected exec(): boolean;
          protected setRawResult(_arg0: any): void;
          protected setRawResult(_arg0: void): void;
          public getRawResult(): void;
          public getRawResult(): any;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace g2d {
        declare class ForkJoinHolder extends java.lang
          .Object {
          public pool: Packages.java.util.concurrent.ForkJoinPool;
          public populateTask: Packages.arc.graphics.g2d.SpriteBatch.PopulateTask;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace g2d {
        declare class Lines extends java.lang.Object {
          public static useLegacyLine: boolean;
          private static vector: Packages.arc.math.geom.Vec2;
          private static u: Packages.arc.math.geom.Vec2;
          private static v: Packages.arc.math.geom.Vec2;
          private static floats: Packages.arc.struct.FloatSeq;
          private static floatBuilder: Packages.arc.struct.FloatSeq;
          private static building: boolean;
          private static circlePrecision: number;
          private static AB: Packages.arc.math.geom.Vec2;
          private static BC: Packages.arc.math.geom.Vec2;
          private static A: Packages.arc.math.geom.Vec2;
          private static B: Packages.arc.math.geom.Vec2;
          private static C: Packages.arc.math.geom.Vec2;
          private static E: Packages.arc.math.geom.Vec2;
          private static D: Packages.arc.math.geom.Vec2;
          private static vec1: Packages.arc.math.geom.Vec2;
          private static D0: Packages.arc.math.geom.Vec2;
          private static E0: Packages.arc.math.geom.Vec2;
          private static q1: Packages.arc.math.geom.Vec2;
          private static q2: Packages.arc.math.geom.Vec2;
          private static q3: Packages.arc.math.geom.Vec2;
          private static q4: Packages.arc.math.geom.Vec2;
          public static line(
            _x: number,
            _y: number,
            _x2: number,
            _y2: number,
            _cap: boolean,
          ): void;
          public static line(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _x: number,
            _y: number,
            _c: Packages.arc.graphics.Color,
            _x2: number,
            _y2: number,
            _c2: Packages.arc.graphics.Color,
            _cap: boolean,
          ): void;
          public static line(
            _x: number,
            _y: number,
            _x2: number,
            _y2: number,
          ): void;
          public static line(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _x: number,
            _y: number,
            _x2: number,
            _y2: number,
            _cap: boolean,
          ): void;
          public static line(
            _x: number,
            _y: number,
            _c: Packages.arc.graphics.Color,
            _x2: number,
            _y2: number,
            _c2: Packages.arc.graphics.Color,
          ): void;
          public static line(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _x: number,
            _y: number,
            _color1: number,
            _x2: number,
            _y2: number,
            _color2: number,
            _cap: boolean,
          ): void;
          public static square(
            _x: number,
            _y: number,
            _rad: number,
            _rot: number,
          ): void;
          public static square(
            _x: number,
            _y: number,
            _rad: number,
          ): void;
          public static arc(
            _x: number,
            _y: number,
            _radius: number,
            _fraction: number,
          ): void;
          public static arc(
            _x: number,
            _y: number,
            _radius: number,
            _fraction: number,
            _rotation: number,
          ): void;
          public static arc(
            _x: number,
            _y: number,
            _radius: number,
            _fraction: number,
            _rotation: number,
            _sides: number,
          ): void;
          public static circle(
            _x: number,
            _y: number,
            _rad: number,
          ): void;
          private static angleRad(
            _v: Packages.arc.math.geom.Vec2,
            _reference: Packages.arc.math.geom.Vec2,
          ): number;
          public static rect(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
            _xspace: number,
            _yspace: number,
          ): void;
          public static rect(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
            _space: number,
          ): void;
          public static rect(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          ): void;
          public static rect(
            _rect: Packages.arc.math.geom.Rect,
          ): void;
          public static curve(
            _x1: number,
            _y1: number,
            _cx1: number,
            _cy1: number,
            _cx2: number,
            _cy2: number,
            _x2: number,
            _y2: number,
            _segments: number,
          ): void;
          public static stroke(
            _thick: number,
            _color: Packages.arc.graphics.Color,
          ): void;
          public static stroke(_thick: number): void;
          public static quad(
            _x1: number,
            _y1: number,
            _x2: number,
            _y2: number,
            _x3: number,
            _y3: number,
            _x4: number,
            _y4: number,
          ): void;
          public static poly(
            _x: number,
            _y: number,
            _sides: number,
            _radius: number,
          ): void;
          public static poly(
            _x: number,
            _y: number,
            _sides: number,
            _radius: number,
            _startAngle: number,
            _endAngle: number,
          ): void;
          public static poly(
            _vertices: Packages.arc.math.geom.Vec2[],
            _offsetx: number,
            _offsety: number,
            _scl: number,
          ): void;
          public static poly(
            _x: number,
            _y: number,
            _sides: number,
            _radius: number,
            _angle: number,
          ): void;
          public static linePoint(
            _x: number,
            _y: number,
          ): void;
          public static linePoint(
            _p: Packages.arc.math.geom.Position,
          ): void;
          public static endLine(): void;
          public static endLine(_wrap: boolean): void;
          public static polyline(
            _points: number[],
            _length: number,
            _wrap: boolean,
          ): void;
          public static polyline(
            _points: Packages.arc.struct.FloatSeq,
            _wrap: boolean,
          ): void;
          private static preparePointyJoin(
            _A: Packages.arc.math.geom.Vec2,
            _B: Packages.arc.math.geom.Vec2,
            _C: Packages.arc.math.geom.Vec2,
            _D: Packages.arc.math.geom.Vec2,
            _E: Packages.arc.math.geom.Vec2,
            _halfLineWidth: number,
          ): void;
          private static prepareFlatEndpoint(
            _pathPointX: number,
            _pathPointY: number,
            _endPointX: number,
            _endPointY: number,
            _D: Packages.arc.math.geom.Vec2,
            _E: Packages.arc.math.geom.Vec2,
            _halfLineWidth: number,
          ): void;
          private static prepareFlatEndpoint(
            _pathPoint: Packages.arc.math.geom.Vec2,
            _endPoint: Packages.arc.math.geom.Vec2,
            _D: Packages.arc.math.geom.Vec2,
            _E: Packages.arc.math.geom.Vec2,
            _halfLineWidth: number,
          ): void;
          private static pushQuad(): void;
          private static prepareStraightJoin(
            _B: Packages.arc.math.geom.Vec2,
            _D: Packages.arc.math.geom.Vec2,
            _E: Packages.arc.math.geom.Vec2,
            _halfLineWidth: number,
          ): void;
          public static circleVertices(
            _rad: number,
          ): number;
          public static ellipse(
            _sides: number,
            _x: number,
            _y: number,
            _width: number,
            _height: number,
            _rot: number,
          ): void;
          public static ellipse(
            _x: number,
            _y: number,
            _rad: number,
            _width: number,
            _height: number,
            _rot: number,
          ): void;
          public static beginLine(): void;
          public static spikes(
            _x: number,
            _y: number,
            _rad: number,
            _length: number,
            _spikes: number,
          ): void;
          public static spikes(
            _x: number,
            _y: number,
            _radius: number,
            _length: number,
            _spikes: number,
            _rot: number,
          ): void;
          public static setCirclePrecision(
            _amount: number,
          ): void;
          public static lineAngle(
            _x: number,
            _y: number,
            _angle: number,
            _length: number,
          ): void;
          public static lineAngle(
            _x: number,
            _y: number,
            _angle: number,
            _length: number,
            _cap: boolean,
          ): void;
          public static lineAngle(
            _x: number,
            _y: number,
            _angle: number,
            _length: number,
            _offset: number,
          ): void;
          public static lineAngleCenter(
            _x: number,
            _y: number,
            _angle: number,
            _length: number,
            _cap: boolean,
          ): void;
          public static lineAngleCenter(
            _x: number,
            _y: number,
            _angle: number,
            _length: number,
          ): void;
          public static dashLine(
            _x1: number,
            _y1: number,
            _x2: number,
            _y2: number,
            _divisions: number,
          ): void;
          public static dashCircle(
            _x: number,
            _y: number,
            _radius: number,
          ): void;
          public static getStroke(): number;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace g2d {
        declare class SpriteBatch extends Packages.arc
          .graphics.g2d.Batch {
          protected static DrawRequest = class extends java
            .lang.Object {
            verticesOffset: number;
            verticesLength: number;
            texture: Packages.arc.graphics.Texture;
            blending: Packages.arc.graphics.Blending;
            run: Packages.java.lang.Runnable;
          };
          static CountingSort = class extends java.lang
            .Object {
            static CountingSortTask = class
              extends java.lang.Object
              implements Packages.java.lang.Runnable
            {
              static arr: number[];
              start: number;
              end: number;
              id: number;
              public run(): void;
              public set(
                _start: number,
                _end: number,
                _id: number,
              ): void;
            };
            static CountingSortTask2 = class
              extends java.lang.Object
              implements Packages.java.lang.Runnable
            {
              static src: number[];
              static dest: number[];
              start: number;
              end: number;
              id: number;
              public run(): void;
              public set(
                _start: number,
                _end: number,
                _id: number,
              ): void;
            };
            private static processors: number;
            static locs: number[];
            static locses: number[][];
            static countses: Packages.arc.struct.IntIntMap[];
            private static entries: Packages.arc.math.geom.Point2[];
            private static entries3: number[];
            private static entries3a: number[];
            private static entriesBacking: number[];
            private static tasks: Packages.arc.graphics.g2d.SpriteBatch.CountingSort.CountingSortTask[];
            private static task2s: Packages.arc.graphics.g2d.SpriteBatch.CountingSort.CountingSortTask2[];
            private static futures: Packages.java.util.concurrent.Future<any>[];
            static countingSortMapMT(
              _arr: number[],
              _swap: number[],
              _end: number,
            ): number[] | null;
            static countingSortMap(
              _arr: number[],
              _swap: number[],
              _end: number,
            ): number[] | null;
          };
          static PopulateTask = class extends Packages.java
            .util.concurrent.RecursiveAction {
            from: number;
            to: number;
            static tasks: number[];
            static src: Packages.arc.graphics.g2d.SpriteBatch.DrawRequest[];
            static dest: Packages.arc.graphics.g2d.SpriteBatch.DrawRequest[];
            static locs: number[];
            protected compute(): void;
            public constructor();
          };
          public static VERTEX_SIZE: number;
          public static SPRITE_SIZE: number;
          private static initialSize: number;
          private static emptyVertices: number[];
          static commonPool: Packages.arc.graphics.g2d.ForkJoinHolder;
          multithreaded: boolean;
          protected mesh: Packages.arc.graphics.Mesh;
          protected buffer: Packages.java.nio.FloatBuffer;
          tmpVertices: number[];
          requestVerts: number[];
          requestVertOffset: number;
          protected sort: boolean;
          protected flushing: boolean;
          protected requests: Packages.arc.graphics.g2d.SpriteBatch.DrawRequest[];
          protected copy: Packages.arc.graphics.g2d.SpriteBatch.DrawRequest[];
          protected requestZ: number[];
          protected numRequests: number;
          protected contiguous: number[];
          protected contiguousCopy: number[];
          protected intZ: number;
          protected flush(): void;
          protected z(_z: number): void;
          protected prepare(_i: number): void;
          public dispose(): void;
          protected draw(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _x: number,
            _y: number,
            _originX: number,
            _originY: number,
            _width: number,
            _height: number,
            _rotation: number,
          ): void;
          protected draw(
            _texture: Packages.arc.graphics.Texture,
            _spriteVertices: number[],
            _offset: number,
            _count: number,
          ): void;
          protected draw(
            _request: Packages.java.lang.Runnable,
          ): void;
          protected setShader(
            _shader: Packages.arc.graphics.gl.Shader,
            _apply: boolean,
          ): void;
          protected setSort(_sort: boolean): void;
          protected discard(): void;
          protected setBlending(
            _blending: Packages.arc.graphics.Blending,
          ): void;
          public static createShader(): Packages.arc.graphics.gl.Shader;
          protected expandRequests(): void;
          protected drawSuper(
            _texture: Packages.arc.graphics.Texture,
            _spriteVertices: number[],
            _offset: number,
            _count: number,
          ): void;
          protected drawSuper(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _x: number,
            _y: number,
            _originX: number,
            _originY: number,
            _width: number,
            _height: number,
            _rotation: number,
          ): void;
          protected constructVertices(
            _vertices: number[],
            _idx: number,
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _x: number,
            _y: number,
            _originX: number,
            _originY: number,
            _width: number,
            _height: number,
            _rotation: number,
          ): void;
          protected flushRequests(): void;
          protected sortRequests(): void;
          protected sortRequestsThreaded(): void;
          protected sortRequestsStandard(): void;
          public constructor(
            _size: number,
            _defaultShader: Packages.arc.graphics.gl.Shader,
          );
          public constructor(_size: number);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class Quat extends java.lang.Object {
          private static tmp1: Packages.arc.math.geom.Quat;
          private static tmp2: Packages.arc.math.geom.Quat;
          public x: number;
          public y: number;
          public z: number;
          public w: number;
          public add(
            _qx: number,
            _qy: number,
            _qz: number,
            _qw: number,
          ): Packages.arc.math.geom.Quat;
          public add(
            _quat: Packages.arc.math.geom.Quat,
          ): Packages.arc.math.geom.Quat;
          public equals(_obj: any): boolean;
          public toString(): string;
          public hashCode(): number;
          public exp(
            _alpha: number,
          ): Packages.arc.math.geom.Quat;
          public static len(
            _x: number,
            _y: number,
            _z: number,
            _w: number,
          ): number;
          public len(): number;
          public transform(
            _v: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public static dot(
            _x1: number,
            _y1: number,
            _z1: number,
            _w1: number,
            _x2: number,
            _y2: number,
            _z2: number,
            _w2: number,
          ): number;
          public dot(
            _x: number,
            _y: number,
            _z: number,
            _w: number,
          ): number;
          public dot(
            _other: Packages.arc.math.geom.Quat,
          ): number;
          public set(
            _quat: Packages.arc.math.geom.Quat,
          ): Packages.arc.math.geom.Quat;
          public set(
            _x: number,
            _y: number,
            _z: number,
            _w: number,
          ): Packages.arc.math.geom.Quat;
          public set(
            _axis: Packages.arc.math.geom.Vec3,
            _angle: number,
          ): Packages.arc.math.geom.Quat;
          public isIdentity(): boolean;
          public isIdentity(_tolerance: number): boolean;
          public static len2(
            _x: number,
            _y: number,
            _z: number,
            _w: number,
          ): number;
          public len2(): number;
          public mul(
            _x: number,
            _y: number,
            _z: number,
            _w: number,
          ): Packages.arc.math.geom.Quat;
          public mul(
            _other: Packages.arc.math.geom.Quat,
          ): Packages.arc.math.geom.Quat;
          public mul(
            _scalar: number,
          ): Packages.arc.math.geom.Quat;
          public nor(): Packages.arc.math.geom.Quat;
          public cpy(): Packages.arc.math.geom.Quat;
          public mulLeft(
            _x: number,
            _y: number,
            _z: number,
            _w: number,
          ): Packages.arc.math.geom.Quat;
          public mulLeft(
            _other: Packages.arc.math.geom.Quat,
          ): Packages.arc.math.geom.Quat;
          public idt(): Packages.arc.math.geom.Quat;
          public slerp(
            _end: Packages.arc.math.geom.Quat,
            _alpha: number,
          ): Packages.arc.math.geom.Quat;
          public slerp(
            _q: Packages.arc.math.geom.Quat[],
            _w: number[],
          ): Packages.arc.math.geom.Quat;
          public slerp(
            _q: Packages.arc.math.geom.Quat[],
          ): Packages.arc.math.geom.Quat;
          public getPitch(): number;
          public setFromAxisRad(
            _axis: Packages.arc.math.geom.Vec3,
            _radians: number,
          ): Packages.arc.math.geom.Quat;
          public setFromAxisRad(
            _x: number,
            _y: number,
            _z: number,
            _radians: number,
          ): Packages.arc.math.geom.Quat;
          public setFromAxis(
            _axis: Packages.arc.math.geom.Vec3,
            _degrees: number,
          ): Packages.arc.math.geom.Quat;
          public setFromAxis(
            _x: number,
            _y: number,
            _z: number,
            _degrees: number,
          ): Packages.arc.math.geom.Quat;
          public setFromCross(
            _x1: number,
            _y1: number,
            _z1: number,
            _x2: number,
            _y2: number,
            _z2: number,
          ): Packages.arc.math.geom.Quat;
          public setFromCross(
            _v1: Packages.arc.math.geom.Vec3,
            _v2: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Quat;
          public setEulerAngles(
            _yaw: number,
            _pitch: number,
            _roll: number,
          ): Packages.arc.math.geom.Quat;
          public setEulerAnglesRad(
            _yaw: number,
            _pitch: number,
            _roll: number,
          ): Packages.arc.math.geom.Quat;
          public getRoll(): number;
          public getYaw(): number;
          public getAxisAngle(
            _axis: Packages.arc.math.geom.Vec3,
          ): number;
          public getAngle(): number;
          public getGimbalPole(): number;
          public getRollRad(): number;
          public getPitchRad(): number;
          public getYawRad(): number;
          public conjugate(): Packages.arc.math.geom.Quat;
          public setFromAxes(
            _xx: number,
            _xy: number,
            _xz: number,
            _yx: number,
            _yy: number,
            _yz: number,
            _zx: number,
            _zy: number,
            _zz: number,
          ): Packages.arc.math.geom.Quat;
          public setFromAxes(
            _normalizeAxes: boolean,
            _xx: number,
            _xy: number,
            _xz: number,
            _yx: number,
            _yy: number,
            _yz: number,
            _zx: number,
            _zy: number,
            _zz: number,
          ): Packages.arc.math.geom.Quat;
          public getAxisAngleRad(
            _axis: Packages.arc.math.geom.Vec3,
          ): number;
          public getAngleRad(): number;
          public getSwingTwist(
            _axis: Packages.arc.math.geom.Vec3,
            _swing: Packages.arc.math.geom.Quat,
            _twist: Packages.arc.math.geom.Quat,
          ): void;
          public getSwingTwist(
            _axisX: number,
            _axisY: number,
            _axisZ: number,
            _swing: Packages.arc.math.geom.Quat,
            _twist: Packages.arc.math.geom.Quat,
          ): void;
          public getAngleAroundRad(
            _axisX: number,
            _axisY: number,
            _axisZ: number,
          ): number;
          public getAngleAroundRad(
            _axis: Packages.arc.math.geom.Vec3,
          ): number;
          public getAngleAround(
            _axis: Packages.arc.math.geom.Vec3,
          ): number;
          public getAngleAround(
            _axisX: number,
            _axisY: number,
            _axisZ: number,
          ): number;
          public setFromMatrix(
            _matrix: Packages.arc.math.Mat,
          ): Packages.arc.math.geom.Quat;
          public setFromMatrix(
            _matrix: Packages.arc.math.geom.Mat3D,
          ): Packages.arc.math.geom.Quat;
          public setFromMatrix(
            _normalizeAxes: boolean,
            _matrix: Packages.arc.math.Mat,
          ): Packages.arc.math.geom.Quat;
          public setFromMatrix(
            _normalizeAxes: boolean,
            _matrix: Packages.arc.math.geom.Mat3D,
          ): Packages.arc.math.geom.Quat;
          public toMatrix(_matrix: number[]): void;
          public constructor(
            _axis: Packages.arc.math.geom.Vec3,
            _angle: number,
          );
          public constructor(
            _quat: Packages.arc.math.geom.Quat,
          );
          public constructor();
          public constructor(
            _x: number,
            _y: number,
            _z: number,
            _w: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class Mat3D extends java.lang.Object {
          public static M00: number;
          public static M01: number;
          public static M02: number;
          public static M03: number;
          public static M10: number;
          public static M11: number;
          public static M12: number;
          public static M13: number;
          public static M20: number;
          public static M21: number;
          public static M22: number;
          public static M23: number;
          public static M30: number;
          public static M31: number;
          public static M32: number;
          public static M33: number;
          private static tmp: number[];
          private static tmp2: number[];
          public val: number[];
          static quat: Packages.arc.math.geom.Quat;
          static quat2: Packages.arc.math.geom.Quat;
          static l_vez: Packages.arc.math.geom.Vec3;
          static l_vex: Packages.arc.math.geom.Vec3;
          static l_vey: Packages.arc.math.geom.Vec3;
          static tmpVec: Packages.arc.math.geom.Vec3;
          static tmpMat: Packages.arc.math.geom.Mat3D;
          static right: Packages.arc.math.geom.Vec3;
          static tmpForward: Packages.arc.math.geom.Vec3;
          static tmpUp: Packages.arc.math.geom.Vec3;
          public toString(): string;
          public scale(
            _vec: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Mat3D;
          public scale(
            _scaleX: number,
            _scaleY: number,
            _scaleZ: number,
          ): Packages.arc.math.geom.Mat3D;
          public scl(
            _x: number,
            _y: number,
            _z: number,
          ): Packages.arc.math.geom.Mat3D;
          public scl(
            _scale: number,
          ): Packages.arc.math.geom.Mat3D;
          public scl(
            _scale: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Mat3D;
          public set(
            _matrix: Packages.arc.math.geom.Mat3D,
          ): Packages.arc.math.geom.Mat3D;
          public set(
            _mat: Packages.arc.math.Mat,
          ): Packages.arc.math.geom.Mat3D;
          public set(
            _affine: Packages.arc.math.Affine2,
          ): Packages.arc.math.geom.Mat3D;
          public set(
            _position: Packages.arc.math.geom.Vec3,
            _orientation: Packages.arc.math.geom.Quat,
            _scale: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Mat3D;
          public set(
            _translationX: number,
            _translationY: number,
            _translationZ: number,
            _quaternionX: number,
            _quaternionY: number,
            _quaternionZ: number,
            _quaternionW: number,
          ): Packages.arc.math.geom.Mat3D;
          public set(
            _position: Packages.arc.math.geom.Vec3,
            _orientation: Packages.arc.math.geom.Quat,
          ): Packages.arc.math.geom.Mat3D;
          public set(
            _quaternionX: number,
            _quaternionY: number,
            _quaternionZ: number,
            _quaternionW: number,
          ): Packages.arc.math.geom.Mat3D;
          public set(
            _quat: Packages.arc.math.geom.Quat,
          ): Packages.arc.math.geom.Mat3D;
          public set(
            _values: number[],
          ): Packages.arc.math.geom.Mat3D;
          public set(
            _translationX: number,
            _translationY: number,
            _translationZ: number,
            _quaternionX: number,
            _quaternionY: number,
            _quaternionZ: number,
            _quaternionW: number,
            _scaleX: number,
            _scaleY: number,
            _scaleZ: number,
          ): Packages.arc.math.geom.Mat3D;
          public set(
            _xAxis: Packages.arc.math.geom.Vec3,
            _yAxis: Packages.arc.math.geom.Vec3,
            _zAxis: Packages.arc.math.geom.Vec3,
            _pos: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Mat3D;
          public static inv(_val: number[]): boolean;
          public inv(): Packages.arc.math.geom.Mat3D;
          public rotate(
            _rotation: Packages.arc.math.geom.Quat,
          ): Packages.arc.math.geom.Mat3D;
          public rotate(
            _v1: Packages.arc.math.geom.Vec3,
            _v2: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Mat3D;
          public rotate(
            _axis: Packages.arc.math.geom.Vec3,
            _degrees: number,
          ): Packages.arc.math.geom.Mat3D;
          public rotate(
            _axisX: number,
            _axisY: number,
            _axisZ: number,
            _degrees: number,
          ): Packages.arc.math.geom.Mat3D;
          public static mul(
            _mata: number[],
            _matb: number[],
          ): void;
          public mul(
            _matrix: Packages.arc.math.geom.Mat3D,
          ): Packages.arc.math.geom.Mat3D;
          public avg(
            _other: Packages.arc.math.geom.Mat3D,
            _w: number,
          ): Packages.arc.math.geom.Mat3D;
          public avg(
            _t: Packages.arc.math.geom.Mat3D[],
          ): Packages.arc.math.geom.Mat3D;
          public avg(
            _t: Packages.arc.math.geom.Mat3D[],
            _w: number[],
          ): Packages.arc.math.geom.Mat3D;
          public rotateRad(
            _axis: Packages.arc.math.geom.Vec3,
            _radians: number,
          ): Packages.arc.math.geom.Mat3D;
          public rotateRad(
            _axisX: number,
            _axisY: number,
            _axisZ: number,
            _radians: number,
          ): Packages.arc.math.geom.Mat3D;
          public lerp(
            _matrix: Packages.arc.math.geom.Mat3D,
            _alpha: number,
          ): Packages.arc.math.geom.Mat3D;
          public cpy(): Packages.arc.math.geom.Mat3D;
          public static mulVec(
            _mat: number[],
            _vec: number[],
          ): void;
          public setToRotationRad(
            _axisX: number,
            _axisY: number,
            _axisZ: number,
            _radians: number,
          ): Packages.arc.math.geom.Mat3D;
          public setToRotationRad(
            _axis: Packages.arc.math.geom.Vec3,
            _radians: number,
          ): Packages.arc.math.geom.Mat3D;
          public static det(_val: number[]): number;
          public det(): number;
          public mulLeft(
            _matrix: Packages.arc.math.geom.Mat3D,
          ): Packages.arc.math.geom.Mat3D;
          public setToTranslation(
            _vector: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Mat3D;
          public setToTranslation(
            _x: number,
            _y: number,
            _z: number,
          ): Packages.arc.math.geom.Mat3D;
          public setToScaling(
            _x: number,
            _y: number,
            _z: number,
          ): Packages.arc.math.geom.Mat3D;
          public setToScaling(
            _vector: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Mat3D;
          public trn(
            _vector: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Mat3D;
          public trn(
            _x: number,
            _y: number,
            _z: number,
          ): Packages.arc.math.geom.Mat3D;
          public translate(
            _translation: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Mat3D;
          public translate(
            _x: number,
            _y: number,
            _z: number,
          ): Packages.arc.math.geom.Mat3D;
          public getValues(): number[] | null;
          public getTranslation(
            _position: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public getScale(
            _scale: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public getRotation(
            _rotation: Packages.arc.math.geom.Quat,
          ): Packages.arc.math.geom.Quat;
          public getRotation(
            _rotation: Packages.arc.math.geom.Quat,
            _normalizeAxes: boolean,
          ): Packages.arc.math.geom.Quat;
          public setToRotation(
            _axis: Packages.arc.math.geom.Vec3,
            _degrees: number,
          ): Packages.arc.math.geom.Mat3D;
          public setToRotation(
            _x1: number,
            _y1: number,
            _z1: number,
            _x2: number,
            _y2: number,
            _z2: number,
          ): Packages.arc.math.geom.Mat3D;
          public setToRotation(
            _axisX: number,
            _axisY: number,
            _axisZ: number,
            _degrees: number,
          ): Packages.arc.math.geom.Mat3D;
          public setToRotation(
            _v1: Packages.arc.math.geom.Vec3,
            _v2: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Mat3D;
          public idt(): Packages.arc.math.geom.Mat3D;
          public setTranslation(
            _x: number,
            _y: number,
            _z: number,
          ): Packages.arc.math.geom.Mat3D;
          public setTranslation(
            _vector: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Mat3D;
          public getScaleX(): number;
          public getScaleY(): number;
          public static rot(
            _mat: number[],
            _vec: number[],
          ): void;
          public static rot(
            _v: Packages.arc.math.geom.Vec3,
            _matrix: Packages.arc.math.geom.Mat3D,
          ): Packages.arc.math.geom.Vec3;
          public setToProjection(
            _left: number,
            _right: number,
            _bottom: number,
            _top: number,
            _near: number,
            _far: number,
          ): Packages.arc.math.geom.Mat3D;
          public setToProjection(
            _near: number,
            _far: number,
            _fovy: number,
            _aspectRatio: number,
          ): Packages.arc.math.geom.Mat3D;
          public setToOrtho(
            _left: number,
            _right: number,
            _bottom: number,
            _top: number,
            _near: number,
            _far: number,
          ): Packages.arc.math.geom.Mat3D;
          public setToLookAt(
            _direction: Packages.arc.math.geom.Vec3,
            _up: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Mat3D;
          public setToLookAt(
            _position: Packages.arc.math.geom.Vec3,
            _target: Packages.arc.math.geom.Vec3,
            _up: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Mat3D;
          public static prj(
            _mat: number[],
            _vec: number[],
          ): void;
          public static prj(
            _mat: number[],
            _vecs: number[],
            _offset: number,
            _numVecs: number,
            _stride: number,
          ): void;
          public static prj(
            _v: Packages.arc.math.geom.Vec3,
            _matrix: Packages.arc.math.geom.Mat3D,
          ): Packages.arc.math.geom.Vec3;
          public getScaleXSquared(): number;
          public getScaleYSquared(): number;
          public getScaleZSquared(): number;
          public getScaleZ(): number;
          public tra(): Packages.arc.math.geom.Mat3D;
          public det3x3(): number;
          public setToOrtho2D(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          ): Packages.arc.math.geom.Mat3D;
          public setToOrtho2D(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
            _near: number,
            _far: number,
          ): Packages.arc.math.geom.Mat3D;
          public setToTranslationAndScaling(
            _translationX: number,
            _translationY: number,
            _translationZ: number,
            _scalingX: number,
            _scalingY: number,
            _scalingZ: number,
          ): Packages.arc.math.geom.Mat3D;
          public setToTranslationAndScaling(
            _translation: Packages.arc.math.geom.Vec3,
            _scaling: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Mat3D;
          public setFromEulerAngles(
            _yaw: number,
            _pitch: number,
            _roll: number,
          ): Packages.arc.math.geom.Mat3D;
          public setFromEulerAnglesRad(
            _yaw: number,
            _pitch: number,
            _roll: number,
          ): Packages.arc.math.geom.Mat3D;
          public setToWorld(
            _position: Packages.arc.math.geom.Vec3,
            _forward: Packages.arc.math.geom.Vec3,
            _up: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Mat3D;
          public setAsAffine(
            _mat: Packages.arc.math.geom.Mat3D,
          ): Packages.arc.math.geom.Mat3D;
          public setAsAffine(
            _affine: Packages.arc.math.Affine2,
          ): Packages.arc.math.geom.Mat3D;
          public toNormalMatrix(): Packages.arc.math.geom.Mat3D;
          public extract4x3Matrix(_dst: number[]): void;
          public hasRotationOrScaling(): boolean;
          public static unrotate(
            _v: Packages.arc.math.geom.Vec3,
            _matrix: Packages.arc.math.geom.Mat3D,
          ): Packages.arc.math.geom.Vec3;
          public static untransform(
            _v: Packages.arc.math.geom.Vec3,
            _matrix: Packages.arc.math.geom.Mat3D,
          ): Packages.arc.math.geom.Vec3;
          public constructor(
            _position: Packages.arc.math.geom.Vec3,
            _rotation: Packages.arc.math.geom.Quat,
            _scale: Packages.arc.math.geom.Vec3,
          );
          public constructor(
            _quat: Packages.arc.math.geom.Quat,
          );
          public constructor(_values: number[]);
          public constructor(
            _matrix: Packages.arc.math.geom.Mat3D,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class Plane extends java.lang.Object {
          public static PlaneSide = class extends Packages
            .java.lang
            .Enum<Packages.arc.math.geom.Plane.PlaneSide> {
            public static onPlane: Packages.arc.math.geom.Plane.PlaneSide;
            public static back: Packages.arc.math.geom.Plane.PlaneSide;
            public static front: Packages.arc.math.geom.Plane.PlaneSide;
            private static $VALUES: Packages.arc.math.geom.Plane.PlaneSide[];
            public static values():
              | Packages.arc.math.geom.Plane.PlaneSide[]
              | null;
            public static valueOf(
              _name: string,
            ): Packages.arc.math.geom.Plane.PlaneSide;
          };
          public normal: Packages.arc.math.geom.Vec3;
          public d: number;
          public toString(): string;
          public set(
            _point1: Packages.arc.math.geom.Vec3,
            _point2: Packages.arc.math.geom.Vec3,
            _point3: Packages.arc.math.geom.Vec3,
          ): void;
          public set(
            _plane: Packages.arc.math.geom.Plane,
          ): void;
          public set(
            _pointX: number,
            _pointY: number,
            _pointZ: number,
            _norX: number,
            _norY: number,
            _norZ: number,
          ): void;
          public set(
            _point: Packages.arc.math.geom.Vec3,
            _normal: Packages.arc.math.geom.Vec3,
          ): void;
          public set(
            _nx: number,
            _ny: number,
            _nz: number,
            _d: number,
          ): void;
          public distance(
            _point: Packages.arc.math.geom.Vec3,
          ): number;
          public project(
            _v: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public testPoint(
            _point: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Plane.PlaneSide;
          public testPoint(
            _x: number,
            _y: number,
            _z: number,
          ): Packages.arc.math.geom.Plane.PlaneSide;
          public isFrontFacing(
            _direction: Packages.arc.math.geom.Vec3,
          ): boolean;
          public getNormal(): Packages.arc.math.geom.Vec3;
          public getD(): number;
          public constructor(
            _point1: Packages.arc.math.geom.Vec3,
            _point2: Packages.arc.math.geom.Vec3,
            _point3: Packages.arc.math.geom.Vec3,
          );
          public constructor(
            _normal: Packages.arc.math.geom.Vec3,
            _point: Packages.arc.math.geom.Vec3,
          );
          public constructor(
            _normal: Packages.arc.math.geom.Vec3,
            _d: number,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class BoundingBox extends java.lang.Object {
          private cnt: Packages.arc.math.geom.Vec3;
          private dim: Packages.arc.math.geom.Vec3;
          public toString(): string;
          static min(_a: number, _b: number): number;
          static max(_a: number, _b: number): number;
          public contains(
            _b: Packages.arc.math.geom.BoundingBox,
          ): boolean;
          public contains(
            _v: Packages.arc.math.geom.Vec3,
          ): boolean;
          public set(
            _minimum: Packages.arc.math.geom.Vec3,
            _maximum: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.BoundingBox;
          public set(
            _points: Packages.arc.struct.Seq<Packages.arc.math.geom.Vec3>,
          ): Packages.arc.math.geom.BoundingBox;
          public set(
            _points: Packages.arc.math.geom.Vec3[],
          ): Packages.arc.math.geom.BoundingBox;
          public set(
            _bounds: Packages.arc.math.geom.BoundingBox,
          ): Packages.arc.math.geom.BoundingBox;
          public isValid(): boolean;
          public inf(): Packages.arc.math.geom.BoundingBox;
          public ext(
            _x: number,
            _y: number,
            _z: number,
          ): Packages.arc.math.geom.BoundingBox;
          public ext(
            _point: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.BoundingBox;
          public ext(
            _a_bounds: Packages.arc.math.geom.BoundingBox,
          ): Packages.arc.math.geom.BoundingBox;
          public ext(
            _center: Packages.arc.math.geom.Vec3,
            _radius: number,
          ): Packages.arc.math.geom.BoundingBox;
          public getDimensions(
            _out: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public getMin(
            _out: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public getMax(
            _out: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public getWidth(): number;
          public getHeight(): number;
          public getDepth(): number;
          public getCenter(
            _out: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public intersects(
            _b: Packages.arc.math.geom.BoundingBox,
          ): boolean;
          public getCorner000(
            _out: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public getCorner001(
            _out: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public getCorner010(
            _out: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public getCorner011(
            _out: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public getCorner100(
            _out: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public getCorner101(
            _out: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public getCorner110(
            _out: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public getCorner111(
            _out: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public clr(): Packages.arc.math.geom.BoundingBox;
          public getCenterX(): number;
          public getCenterY(): number;
          public getCenterZ(): number;
          public constructor(
            _minimum: Packages.arc.math.geom.Vec3,
            _maximum: Packages.arc.math.geom.Vec3,
          );
          public constructor(
            _bounds: Packages.arc.math.geom.BoundingBox,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class Frustum extends java.lang.Object {
          protected static clipSpacePlanePoints: Packages.arc.math.geom.Vec3[];
          protected static clipSpacePlanePointsArray: number[];
          private static tmpV: Packages.arc.math.geom.Vec3;
          public planes: Packages.arc.math.geom.Plane[];
          public planePoints: Packages.arc.math.geom.Vec3[];
          protected planePointsArray: number[];
          public update(
            _inverseProjectionView: Packages.arc.math.geom.Mat3D,
          ): void;
          public containsBounds(
            _x: number,
            _y: number,
            _z: number,
            _halfWidth: number,
            _halfHeight: number,
            _halfDepth: number,
          ): boolean;
          public containsBounds(
            _bounds: Packages.arc.math.geom.BoundingBox,
          ): boolean;
          public containsBounds(
            _center: Packages.arc.math.geom.Vec3,
            _dimensions: Packages.arc.math.geom.Vec3,
          ): boolean;
          public containsPoint(
            _point: Packages.arc.math.geom.Vec3,
          ): boolean;
          public containsPoint(
            _x: number,
            _y: number,
            _z: number,
          ): boolean;
          public containsSphere(
            _x: number,
            _y: number,
            _z: number,
            _radius: number,
          ): boolean;
          public containsSphere(
            _center: Packages.arc.math.geom.Vec3,
            _radius: number,
          ): boolean;
          public containsSphereWithoutNearFar(
            _center: Packages.arc.math.geom.Vec3,
            _radius: number,
          ): boolean;
          public containsSphereWithoutNearFar(
            _x: number,
            _y: number,
            _z: number,
            _radius: number,
          ): boolean;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class Ray extends java.lang.Object {
          public origin: Packages.arc.math.geom.Vec3;
          public direction: Packages.arc.math.geom.Vec3;
          public equals(_o: any): boolean;
          public toString(): string;
          public hashCode(): number;
          public set(
            _x: number,
            _y: number,
            _z: number,
            _dx: number,
            _dy: number,
            _dz: number,
          ): Packages.arc.math.geom.Ray;
          public set(
            _ray: Packages.arc.math.geom.Ray,
          ): Packages.arc.math.geom.Ray;
          public set(
            _origin: Packages.arc.math.geom.Vec3,
            _direction: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Ray;
          public cpy(): Packages.arc.math.geom.Ray;
          public getEndPoint(
            _out: Packages.arc.math.geom.Vec3,
            _distance: number,
          ): Packages.arc.math.geom.Vec3;
          public constructor();
          public constructor(
            _origin: Packages.arc.math.geom.Vec3,
            _direction: Packages.arc.math.geom.Vec3,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace g3d {
        declare class Camera3D extends java.lang.Object {
          public fov: number;
          public near: number;
          public far: number;
          public perspective: boolean;
          public width: number;
          public height: number;
          public position: Packages.arc.math.geom.Vec3;
          public direction: Packages.arc.math.geom.Vec3;
          public up: Packages.arc.math.geom.Vec3;
          public combined: Packages.arc.math.geom.Mat3D;
          public projection: Packages.arc.math.geom.Mat3D;
          public view: Packages.arc.math.geom.Mat3D;
          public invProjectionView: Packages.arc.math.geom.Mat3D;
          public frustum: Packages.arc.math.geom.Frustum;
          private tmpVec: Packages.arc.math.geom.Vec3;
          private ray: Packages.arc.math.geom.Ray;
          public update(): void;
          public resize(
            _width: number,
            _height: number,
          ): void;
          public unproject(
            _screenCoords: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public unproject(
            _screenCoords: Packages.arc.math.geom.Vec3,
            _viewportX: number,
            _viewportY: number,
            _viewportWidth: number,
            _viewportHeight: number,
          ): Packages.arc.math.geom.Vec3;
          public project(
            _worldCoords: Packages.arc.math.geom.Vec3,
            _viewportX: number,
            _viewportY: number,
            _viewportWidth: number,
            _viewportHeight: number,
          ): Packages.arc.math.geom.Vec3;
          public project(
            _worldCoords: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          public normalizeUp(): void;
          public lookAt(
            _x: number,
            _y: number,
            _z: number,
          ): void;
          public lookAt(
            _target: Packages.arc.math.geom.Vec3,
          ): void;
          public getPickRay(
            _screenX: number,
            _screenY: number,
            _viewportX: number,
            _viewportY: number,
            _viewportWidth: number,
            _viewportHeight: number,
          ): Packages.arc.math.geom.Ray;
          public getPickRay(
            _screenX: number,
            _screenY: number,
          ): Packages.arc.math.geom.Ray;
          public getMouseRay(): Packages.arc.math.geom.Ray;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace g3d {
        declare class VertexBatch3D extends java.lang
          .Object {
          private maxVertices: number;
          private mesh: Packages.arc.graphics.Mesh;
          private numTexCoords: number;
          private vertexSize: number;
          private normalOffset: number;
          private colorOffset: number;
          private texCoordOffset: number;
          private vertices: number[];
          private shaderUniformNames: string[];
          private vertexIdx: number;
          private numSetTexCoords: number;
          private numVertices: number;
          private shader: Packages.arc.graphics.gl.Shader;
          private ownsShader: boolean;
          public flush(_primitiveType: number): void;
          public flush(
            _primitiveType: number,
            _shader: Packages.arc.graphics.gl.Shader,
          ): void;
          public color(
            _r: number,
            _g: number,
            _b: number,
            _a: number,
          ): void;
          public color(
            _color: Packages.arc.graphics.Color,
          ): void;
          public color(_colorBits: number): void;
          public normal(
            _v: Packages.arc.math.geom.Vec3,
          ): void;
          public normal(
            _x: number,
            _y: number,
            _z: number,
          ): void;
          public dispose(): void;
          public setShader(
            _shader: Packages.arc.graphics.gl.Shader,
          ): void;
          public proj(): Packages.arc.math.geom.Mat3D;
          public proj(
            _projModelView: Packages.arc.math.geom.Mat3D,
          ): void;
          public getNumVertices(): number;
          public getMaxVertices(): number;
          public static createDefaultShader(
            _hasNormals: boolean,
            _hasColors: boolean,
            _numTexCoords: number,
          ): Packages.arc.graphics.gl.Shader;
          public tri(
            _x1: number,
            _y1: number,
            _z1: number,
            _x2: number,
            _y2: number,
            _z2: number,
            _x3: number,
            _y3: number,
            _z3: number,
            _color: Packages.arc.graphics.Color,
          ): void;
          public tri(
            _v1: Packages.arc.math.geom.Vec3,
            _v2: Packages.arc.math.geom.Vec3,
            _v3: Packages.arc.math.geom.Vec3,
            _color: Packages.arc.graphics.Color,
          ): void;
          public vertex(_floats: number[]): void;
          public vertex(
            _x: number,
            _y: number,
            _z: number,
          ): void;
          public vertex(
            _v: Packages.arc.math.geom.Vec3,
            _color: Packages.arc.graphics.Color,
          ): void;
          public vertex(
            _v: Packages.arc.math.geom.Vec3,
          ): void;
          private static createVertexShader(
            _hasNormals: boolean,
            _hasColors: boolean,
            _numTexCoords: number,
          ): string;
          private static createFragmentShader(
            _hasNormals: boolean,
            _hasColors: boolean,
            _numTexCoords: number,
          ): string;
          public texCoord(_u: number, _v: number): void;
          public tri2(
            _v1: Packages.arc.math.geom.Vec3,
            _v2: Packages.arc.math.geom.Vec3,
            _v3: Packages.arc.math.geom.Vec3,
            _color: Packages.arc.graphics.Color,
          ): void;
          private buildVertexAttributes(
            _hasNormals: boolean,
            _hasColor: boolean,
            _numTexCoords: number,
          ): Packages.arc.graphics.VertexAttribute[] | null;
          public constructor(
            _maxVertices: number,
            _hasNormals: boolean,
            _hasColors: boolean,
            _numTexCoords: number,
            _shader: Packages.arc.graphics.gl.Shader,
          );
          public constructor(
            _maxVertices: number,
            _hasNormals: boolean,
            _hasColors: boolean,
            _numTexCoords: number,
          );
          public constructor(
            _hasNormals: boolean,
            _hasColors: boolean,
            _numTexCoords: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace g3d {
        declare class PlaneBatch3D extends Packages.arc
          .graphics.g2d.Batch {
          protected up: Packages.arc.math.geom.Vec3;
          protected right: Packages.arc.math.geom.Vec3;
          protected origin: Packages.arc.math.geom.Vec3;
          protected vec: Packages.arc.math.geom.Vec3;
          protected batch: Packages.arc.graphics.g3d.VertexBatch3D;
          protected scaling: number;
          protected flush(): void;
          protected draw(
            _texture: Packages.arc.graphics.Texture,
            _v: number[],
            _offset: number,
            _count: number,
          ): void;
          protected draw(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _x: number,
            _y: number,
            _originX: number,
            _originY: number,
            _width: number,
            _height: number,
            _rotation: number,
          ): void;
          public proj(
            _mat: Packages.arc.math.geom.Mat3D,
          ): void;
          public setScaling(_scaling: number): void;
          private vertex(
            _x1: number,
            _y1: number,
            _c1: number,
            _u1: number,
            _v1: number,
          ): void;
          private checkFlush(): void;
          public setPlane(
            _origin: Packages.arc.math.geom.Vec3,
            _up: Packages.arc.math.geom.Vec3,
            _right: Packages.arc.math.geom.Vec3,
          ): void;
          public constructor();
          public constructor(_vertices: number);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace gl {
        declare class FacedCubemapData
          extends java.lang.Object
          implements Packages.arc.graphics.CubemapData
        {
          protected data: Packages.arc.graphics.TextureData[];
          public load(
            _side: Packages.arc.graphics.Cubemap.CubemapSide,
            _pixmap: Packages.arc.graphics.Pixmap,
          ): void;
          public load(
            _side: Packages.arc.graphics.Cubemap.CubemapSide,
            _file: Packages.arc.files.Fi,
          ): void;
          public prepare(): void;
          public getWidth(): number;
          public getHeight(): number;
          public getTextureData(
            _side: Packages.arc.graphics.Cubemap.CubemapSide,
          ): Packages.arc.graphics.TextureData;
          public isPrepared(): boolean;
          public consumeCubemapData(): void;
          public isComplete(): boolean;
          public constructor(
            _positiveX: Packages.arc.graphics.Pixmap,
            _negativeX: Packages.arc.graphics.Pixmap,
            _positiveY: Packages.arc.graphics.Pixmap,
            _negativeY: Packages.arc.graphics.Pixmap,
            _positiveZ: Packages.arc.graphics.Pixmap,
            _negativeZ: Packages.arc.graphics.Pixmap,
          );
          public constructor(
            _positiveX: Packages.arc.graphics.Pixmap,
            _negativeX: Packages.arc.graphics.Pixmap,
            _positiveY: Packages.arc.graphics.Pixmap,
            _negativeY: Packages.arc.graphics.Pixmap,
            _positiveZ: Packages.arc.graphics.Pixmap,
            _negativeZ: Packages.arc.graphics.Pixmap,
            _useMipMaps: boolean,
          );
          public constructor(
            _width: number,
            _height: number,
            _depth: number,
            _format: Packages.arc.graphics.Pixmap.Format,
          );
          public constructor(
            _positiveX: Packages.arc.graphics.TextureData,
            _negativeX: Packages.arc.graphics.TextureData,
            _positiveY: Packages.arc.graphics.TextureData,
            _negativeY: Packages.arc.graphics.TextureData,
            _positiveZ: Packages.arc.graphics.TextureData,
            _negativeZ: Packages.arc.graphics.TextureData,
          );
          public constructor();
          public constructor(
            _positiveX: Packages.arc.files.Fi,
            _negativeX: Packages.arc.files.Fi,
            _positiveY: Packages.arc.files.Fi,
            _negativeY: Packages.arc.files.Fi,
            _positiveZ: Packages.arc.files.Fi,
            _negativeZ: Packages.arc.files.Fi,
          );
          public constructor(
            _positiveX: Packages.arc.files.Fi,
            _negativeX: Packages.arc.files.Fi,
            _positiveY: Packages.arc.files.Fi,
            _negativeY: Packages.arc.files.Fi,
            _positiveZ: Packages.arc.files.Fi,
            _negativeZ: Packages.arc.files.Fi,
            _useMipMaps: boolean,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace gl {
        declare class FileTextureArrayData
          extends java.lang.Object
          implements Packages.arc.graphics.TextureArrayData
        {
          useMipMaps: boolean;
          private textureDatas: Packages.arc.graphics.TextureData[];
          private prepared: boolean;
          private depth: number;
          public prepare(): void;
          public getWidth(): number;
          public getHeight(): number;
          public getGLType(): number;
          public isPrepared(): boolean;
          public getDepth(): number;
          public getInternalFormat(): number;
          public consumeTextureArrayData(): void;
          public constructor(
            _useMipMaps: boolean,
            _files: Packages.arc.files.Fi[],
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace gl {
        declare class FileTextureData
          extends java.lang.Object
          implements Packages.arc.graphics.TextureData
        {
          file: Packages.arc.files.Fi;
          width: number;
          height: number;
          pixmap: Packages.arc.graphics.Pixmap;
          public toString(): string;
          public prepare(): void;
          public getFormat(): Packages.arc.graphics.Pixmap.Format;
          public getWidth(): number;
          public getHeight(): number;
          public useMipMaps(): boolean;
          public disposePixmap(): boolean;
          public isPrepared(): boolean;
          public isCustom(): boolean;
          public consumeCustomData(_target: number): void;
          public consumePixmap(): Packages.arc.graphics.Pixmap;
          public getFileHandle(): Packages.arc.files.Fi;
          public constructor(
            _file: Packages.arc.files.Fi,
            _preloadedPixmap: Packages.arc.graphics.Pixmap,
            _useMipMaps: boolean,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace gl {
        declare class FloatTextureData
          extends java.lang.Object
          implements Packages.arc.graphics.TextureData
        {
          width: number;
          height: number;
          internalFormat: number;
          format: number;
          type: number;
          isGpuOnly: boolean;
          buffer: Packages.java.nio.FloatBuffer;
          public prepare(): void;
          public getFormat(): Packages.arc.graphics.Pixmap.Format;
          public getBuffer(): Packages.java.nio.FloatBuffer;
          public getWidth(): number;
          public getHeight(): number;
          public useMipMaps(): boolean;
          public disposePixmap(): boolean;
          public isPrepared(): boolean;
          public isCustom(): boolean;
          public consumeCustomData(_target: number): void;
          public consumePixmap(): Packages.arc.graphics.Pixmap;
          public constructor(
            _w: number,
            _h: number,
            _internalFormat: number,
            _format: number,
            _type: number,
            _isGpuOnly: boolean,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace gl {
        declare class GLOnlyTextureData
          extends java.lang.Object
          implements Packages.arc.graphics.TextureData
        {
          width: number;
          height: number;
          mipLevel: number;
          internalFormat: number;
          format: number;
          type: number;
          public prepare(): void;
          public getFormat(): Packages.arc.graphics.Pixmap.Format;
          public getWidth(): number;
          public getHeight(): number;
          public useMipMaps(): boolean;
          public disposePixmap(): boolean;
          public isPrepared(): boolean;
          public isCustom(): boolean;
          public consumeCustomData(_target: number): void;
          public consumePixmap(): Packages.arc.graphics.Pixmap;
          public constructor(
            _width: number,
            _height: number,
            _mipMapLevel: number,
            _internalFormat: number,
            _format: number,
            _type: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace gl {
        declare class HdpiMode extends Packages.java.lang
          .Enum<Packages.arc.graphics.gl.HdpiMode> {
          public static logical: Packages.arc.graphics.gl.HdpiMode;
          public static pixels: Packages.arc.graphics.gl.HdpiMode;
          private static $VALUES: Packages.arc.graphics.gl.HdpiMode[];
          public static values():
            | Packages.arc.graphics.gl.HdpiMode[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.arc.graphics.gl.HdpiMode;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace gl {
        declare class HdpiUtils extends java.lang.Object {
          private static mode: Packages.arc.graphics.gl.HdpiMode;
          public static glScissor(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          ): void;
          public static glViewport(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          ): void;
          public static toLogicalY(
            _backBufferY: number,
          ): number;
          public static toBackBufferX(
            _logicalX: number,
          ): number;
          public static toBackBufferY(
            _logicalY: number,
          ): number;
          public static setMode(
            _mode: Packages.arc.graphics.gl.HdpiMode,
          ): void;
          public static toLogicalX(
            _backBufferX: number,
          ): number;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace gl {
        declare class IndexArray
          extends java.lang.Object
          implements Packages.arc.graphics.gl.IndexData
        {
          byteBuffer: Packages.java.nio.ByteBuffer;
          private empty: boolean;
          public max(): number;
          public update(
            _targetOffset: number,
            _indices: Packages.short[],
            _offset: number,
            _count: number,
          ): void;
          public size(): number;
          public buffer(): Packages.java.nio.ShortBuffer;
          public set(
            _indices: Packages.short[],
            _offset: number,
            _count: number,
          ): void;
          public set(
            _indices: Packages.java.nio.ShortBuffer,
          ): void;
          public bind(): void;
          public dispose(): void;
          public unbind(): void;
          public constructor(_maxIndices: number);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace gl {
        declare class IndexBufferObject
          extends java.lang.Object
          implements Packages.arc.graphics.gl.IndexData
        {
          byteBuffer: Packages.java.nio.ByteBuffer;
          isDirect: boolean;
          usage: number;
          empty: boolean;
          bufferHandle: number;
          dirty: boolean;
          bound: boolean;
          public max(): number;
          public update(
            _targetOffset: number,
            _indices: Packages.short[],
            _offset: number,
            _count: number,
          ): void;
          public size(): number;
          public buffer(): Packages.java.nio.ShortBuffer;
          public set(
            _indices: Packages.java.nio.ShortBuffer,
          ): void;
          public set(
            _indices: Packages.short[],
            _offset: number,
            _count: number,
          ): void;
          public bind(): void;
          public dispose(): void;
          public unbind(): void;
          public constructor(_maxIndices: number);
          public constructor(
            _isStatic: boolean,
            _maxIndices: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace gl {
        declare class IndexBufferObjectSubData
          extends java.lang.Object
          implements Packages.arc.graphics.gl.IndexData
        {
          byteBuffer: Packages.java.nio.ByteBuffer;
          isDirect: boolean;
          usage: number;
          bufferHandle: number;
          isDirty: boolean;
          isBound: boolean;
          public max(): number;
          public update(
            _targetOffset: number,
            _indices: Packages.short[],
            _offset: number,
            _count: number,
          ): void;
          public size(): number;
          public buffer(): Packages.java.nio.ShortBuffer;
          public set(
            _indices: Packages.java.nio.ShortBuffer,
          ): void;
          public set(
            _indices: Packages.short[],
            _offset: number,
            _count: number,
          ): void;
          public bind(): void;
          public dispose(): void;
          public unbind(): void;
          private createBufferObject(): number;
          public constructor(
            _isStatic: boolean,
            _maxIndices: number,
          );
          public constructor(_maxIndices: number);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace gl {
        declare class MipMapGenerator extends java.lang
          .Object {
          private static useHWMipMap: boolean;
          public static generateMipMap(
            _pixmap: Packages.arc.graphics.Pixmap,
            _textureWidth: number,
            _textureHeight: number,
          ): void;
          public static generateMipMap(
            _target: number,
            _pixmap: Packages.arc.graphics.Pixmap,
            _textureWidth: number,
            _textureHeight: number,
          ): void;
          private static generateMipMapCPU(
            _target: number,
            _pixmap: Packages.arc.graphics.Pixmap,
            _textureWidth: number,
            _textureHeight: number,
          ): void;
          private static generateMipMapGLES20(
            _target: number,
            _pixmap: Packages.arc.graphics.Pixmap,
          ): void;
          private static generateMipMapDesktop(
            _target: number,
            _pixmap: Packages.arc.graphics.Pixmap,
            _textureWidth: number,
            _textureHeight: number,
          ): void;
          public static setUseHardwareMipMap(
            _useHWMipMap: boolean,
          ): void;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace gl {
        declare class MipMapTextureData
          extends java.lang.Object
          implements Packages.arc.graphics.TextureData
        {
          mips: Packages.arc.graphics.TextureData[];
          public prepare(): void;
          public getFormat(): Packages.arc.graphics.Pixmap.Format;
          public getWidth(): number;
          public getHeight(): number;
          public useMipMaps(): boolean;
          public disposePixmap(): boolean;
          public isPrepared(): boolean;
          public isCustom(): boolean;
          public consumeCustomData(_target: number): void;
          public consumePixmap(): Packages.arc.graphics.Pixmap;
          public constructor(
            ..._mipMapData: Packages.arc.graphics.TextureData[]
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace gl {
        declare class PixmapTextureData
          extends java.lang.Object
          implements Packages.arc.graphics.TextureData
        {
          pixmap: Packages.arc.graphics.Pixmap;
          public prepare(): void;
          public getFormat(): Packages.arc.graphics.Pixmap.Format;
          public getWidth(): number;
          public getHeight(): number;
          public useMipMaps(): boolean;
          public disposePixmap(): boolean;
          public isPrepared(): boolean;
          public isCustom(): boolean;
          public consumeCustomData(_target: number): void;
          public consumePixmap(): Packages.arc.graphics.Pixmap;
          public constructor(
            _pixmap: Packages.arc.graphics.Pixmap,
            _useMipMaps: boolean,
            _disposePixmap: boolean,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace gl {
        declare class VertexArray
          extends java.lang.Object
          implements Packages.arc.graphics.gl.VertexData
        {
          mesh: Packages.arc.graphics.Mesh;
          byteBuffer: Packages.java.nio.ByteBuffer;
          isBound: boolean;
          public max(): number;
          public update(
            _targetOffset: number,
            _vertices: number[],
            _sourceOffset: number,
            _count: number,
          ): void;
          public size(): number;
          public buffer(): Packages.java.nio.FloatBuffer;
          public set(
            _vertices: number[],
            _offset: number,
            _count: number,
          ): void;
          public bind(
            _shader: Packages.arc.graphics.gl.Shader,
          ): void;
          public dispose(): void;
          public unbind(
            _shader: Packages.arc.graphics.gl.Shader,
          ): void;
          public render(
            _indices: Packages.arc.graphics.gl.IndexData,
            _primitiveType: number,
            _offset: number,
            _count: number,
          ): void;
          public constructor(
            _numVertices: number,
            _mesh: Packages.arc.graphics.Mesh,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace gl {
        declare class VertexBufferObject
          extends java.lang.Object
          implements Packages.arc.graphics.gl.VertexData
        {
          dirty: boolean;
          bound: boolean;
          private mesh: Packages.arc.graphics.Mesh;
          private byteBuffer: Packages.java.nio.ByteBuffer;
          private ownsBuffer: boolean;
          private bufferHandle: number;
          private usage: number;
          public max(): number;
          public update(
            _targetOffset: number,
            _vertices: number[],
            _sourceOffset: number,
            _count: number,
          ): void;
          public size(): number;
          public buffer(): Packages.java.nio.FloatBuffer;
          public set(
            _vertices: number[],
            _offset: number,
            _count: number,
          ): void;
          public bind(): void;
          public bind(
            _shader: Packages.arc.graphics.gl.Shader,
          ): void;
          public dispose(): void;
          public unbind(
            _shader: Packages.arc.graphics.gl.Shader,
          ): void;
          protected setBuffer(
            _data: Packages.java.nio.Buffer,
            _ownsBuffer: boolean,
          ): void;
          private upload(): void;
          private bufferChanged(): void;
          public constructor(
            _isStatic: boolean,
            _numVertices: number,
            _mesh: Packages.arc.graphics.Mesh,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace graphics {
      declare namespace gl {
        declare class VertexBufferObjectWithVAO
          extends java.lang.Object
          implements Packages.arc.graphics.gl.VertexData
        {
          static tmpHandle: Packages.java.nio.IntBuffer;
          mesh: Packages.arc.graphics.Mesh;
          byteBuffer: Packages.java.nio.ByteBuffer;
          isStatic: boolean;
          usage: number;
          bufferHandle: number;
          isDirty: boolean;
          isBound: boolean;
          vaoHandle: number;
          cachedLocations: Packages.arc.struct.IntSeq;
          public max(): number;
          public update(
            _targetOffset: number,
            _vertices: number[],
            _sourceOffset: number,
            _count: number,
          ): void;
          public size(): number;
          public buffer(): Packages.java.nio.FloatBuffer;
          public set(
            _vertices: number[],
            _offset: number,
            _count: number,
          ): void;
          public bind(
            _shader: Packages.arc.graphics.gl.Shader,
          ): void;
          public dispose(): void;
          public unbind(
            _shader: Packages.arc.graphics.gl.Shader,
          ): void;
          private upload(): void;
          private bufferChanged(): void;
          private createVAO(): void;
          private bindAttributes(
            _shader: Packages.arc.graphics.gl.Shader,
          ): void;
          private bindData(): void;
          private unbindAttributes(
            _shader: Packages.arc.graphics.gl.Shader,
          ): void;
          private deleteVAO(): void;
          public constructor(
            _isStatic: boolean,
            _numVertices: number,
            _mesh: Packages.arc.graphics.Mesh,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class BSpline<
            T extends Packages.arc.math.geom.Vector<T>,
          >
          extends java.lang.Object
          implements Packages.arc.math.geom.Path<T>
        {
          private static d6: number;
          public controlPoints: T[];
          public knots: Packages.arc.struct.Seq<T>;
          public degree: number;
          public continuous: boolean;
          public spanCount: number;
          private tmp: T;
          private tmp2: T;
          private tmp3: T;
          public set(
            _controlPoints: T[],
            _degree: number,
            _continuous: boolean,
          ): Packages.arc.math.geom.BSpline<any>;
          public nearest(
            _in: T,
            _start: number,
            _count: number,
          ): number;
          public nearest(_in: T): number;
          public static calculate<
            T extends Packages.arc.math.geom.Vector<T>,
          >(
            _out: T,
            _t: number,
            _points: T[],
            _degree: number,
            _continuous: boolean,
            _tmp: T,
          ): T | null;
          public static calculate<
            T extends Packages.arc.math.geom.Vector<T>,
          >(
            _out: T,
            _i: number,
            _u: number,
            _points: T[],
            _degree: number,
            _continuous: boolean,
            _tmp: T,
          ): T | null;
          public static cubic<
            T extends Packages.arc.math.geom.Vector<T>,
          >(
            _out: T,
            _i: number,
            _u: number,
            _points: T[],
            _continuous: boolean,
            _tmp: T,
          ): T | null;
          public static cubic<
            T extends Packages.arc.math.geom.Vector<T>,
          >(
            _out: T,
            _t: number,
            _points: T[],
            _continuous: boolean,
            _tmp: T,
          ): T | null;
          public approximate(_in: T, _near: number): number;
          public approximate(_v: T): number;
          public approximate(
            _in: T,
            _start: number,
            _count: number,
          ): number;
          public approximate(_v: any): number;
          public valueAt(_out: any, _t: number): any;
          public valueAt(_out: T, _t: number): T | null;
          public valueAt(
            _out: T,
            _span: number,
            _u: number,
          ): T | null;
          public locate(_v: any): number;
          public locate(_v: T): number;
          public derivativeAt(_out: any, _t: number): any;
          public derivativeAt(
            _out: T,
            _span: number,
            _u: number,
          ): T | null;
          public derivativeAt(
            _out: T,
            _t: number,
          ): T | null;
          public approxLength(_samples: number): number;
          public static derivative<
            T extends Packages.arc.math.geom.Vector<T>,
          >(
            _out: T,
            _t: number,
            _points: T[],
            _degree: number,
            _continuous: boolean,
            _tmp: T,
          ): T | null;
          public static derivative<
            T extends Packages.arc.math.geom.Vector<T>,
          >(
            _out: T,
            _i: number,
            _u: number,
            _points: T[],
            _degree: number,
            _continuous: boolean,
            _tmp: T,
          ): T | null;
          public static cubic_derivative<
            T extends Packages.arc.math.geom.Vector<T>,
          >(
            _out: T,
            _i: number,
            _u: number,
            _points: T[],
            _continuous: boolean,
            _tmp: T,
          ): T | null;
          public static cubic_derivative<
            T extends Packages.arc.math.geom.Vector<T>,
          >(
            _out: T,
            _t: number,
            _points: T[],
            _continuous: boolean,
            _tmp: T,
          ): T | null;
          public constructor();
          public constructor(
            _controlPoints: T[],
            _degree: number,
            _continuous: boolean,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class Bresenham2 extends java.lang.Object {
          private points: Packages.arc.struct.Seq<Packages.arc.math.geom.Point2>;
          private pool: Packages.arc.util.pooling.Pool<Packages.arc.math.geom.Point2>;
          public line(
            _startX: number,
            _startY: number,
            _endX: number,
            _endY: number,
            _pool: Packages.arc.util.pooling.Pool<Packages.arc.math.geom.Point2>,
            _output: Packages.arc.struct.Seq<Packages.arc.math.geom.Point2>,
          ): Packages.arc.struct.Seq<Packages.arc.math.geom.Point2>;
          public line(
            _startX: number,
            _startY: number,
            _endX: number,
            _endY: number,
          ): Packages.arc.struct.Seq<Packages.arc.math.geom.Point2>;
          public line(
            _start: Packages.arc.math.geom.Point2,
            _end: Packages.arc.math.geom.Point2,
          ): Packages.arc.struct.Seq<Packages.arc.math.geom.Point2>;
          public static line(
            _startX: number,
            _startY: number,
            _endX: number,
            _endY: number,
            _consumer: Packages.arc.func.Intc2,
          ): void;
          public lineNoDiagonal(
            _startX: number,
            _startY: number,
            _endX: number,
            _endY: number,
            _pool: Packages.arc.util.pooling.Pool<Packages.arc.math.geom.Point2>,
            _output: Packages.arc.struct.Seq<Packages.arc.math.geom.Point2>,
          ): Packages.arc.struct.Seq<Packages.arc.math.geom.Point2>;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class CatmullRomSpline<
            T extends Packages.arc.math.geom.Vector<T>,
          >
          extends java.lang.Object
          implements Packages.arc.math.geom.Path<T>
        {
          public controlPoints: T[];
          public continuous: boolean;
          public spanCount: number;
          private tmp: T;
          private tmp2: T;
          private tmp3: T;
          public set(
            _controlPoints: T[],
            _continuous: boolean,
          ): Packages.arc.math.geom.CatmullRomSpline<any>;
          public nearest(_in: T): number;
          public nearest(
            _in: T,
            _start: number,
            _count: number,
          ): number;
          public static calculate<
            T extends Packages.arc.math.geom.Vector<T>,
          >(
            _out: T,
            _i: number,
            _u: number,
            _points: T[],
            _continuous: boolean,
            _tmp: T,
          ): T | null;
          public static calculate<
            T extends Packages.arc.math.geom.Vector<T>,
          >(
            _out: T,
            _t: number,
            _points: T[],
            _continuous: boolean,
            _tmp: T,
          ): T | null;
          public approximate(_in: T, _near: number): number;
          public approximate(_v: any): number;
          public approximate(
            _in: T,
            _start: number,
            _count: number,
          ): number;
          public approximate(_v: T): number;
          public valueAt(
            _out: T,
            _span: number,
            _u: number,
          ): T | null;
          public valueAt(_out: any, _t: number): any;
          public valueAt(_out: T, _t: number): T | null;
          public locate(_v: any): number;
          public locate(_v: T): number;
          public derivativeAt(
            _out: T,
            _t: number,
          ): T | null;
          public derivativeAt(
            _out: T,
            _span: number,
            _u: number,
          ): T | null;
          public derivativeAt(_out: any, _t: number): any;
          public approxLength(_samples: number): number;
          public static derivative<
            T extends Packages.arc.math.geom.Vector<T>,
          >(
            _out: T,
            _i: number,
            _u: number,
            _points: T[],
            _continuous: boolean,
            _tmp: T,
          ): T | null;
          public static derivative<
            T extends Packages.arc.math.geom.Vector<T>,
          >(
            _out: T,
            _t: number,
            _points: T[],
            _continuous: boolean,
            _tmp: T,
          ): T | null;
          public constructor();
          public constructor(
            _controlPoints: T[],
            _continuous: boolean,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class ConvexHull extends java.lang.Object {
          private quicksortStack: Packages.arc.struct.IntSeq;
          private hull: Packages.arc.struct.FloatSeq;
          private indices: Packages.arc.struct.IntSeq;
          private originalIndices: Packages.arc.struct.ShortSeq;
          private sortedPoints: number[];
          private sort(
            _values: number[],
            _count: number,
          ): void;
          private ccw(_p3x: number, _p3y: number): number;
          private quicksortPartition(
            _values: number[],
            _lower: number,
            _upper: number,
          ): number;
          public computePolygon(
            _points: number[],
            _offset: number,
            _count: number,
            _sorted: boolean,
          ): Packages.arc.struct.FloatSeq;
          public computePolygon(
            _points: Packages.arc.struct.FloatSeq,
            _sorted: boolean,
          ): Packages.arc.struct.FloatSeq;
          public computePolygon(
            _polygon: number[],
            _sorted: boolean,
          ): Packages.arc.struct.FloatSeq;
          public computeIndices(
            _points: Packages.arc.struct.FloatSeq,
            _sorted: boolean,
            _yDown: boolean,
          ): Packages.arc.struct.IntSeq;
          public computeIndices(
            _polygon: number[],
            _sorted: boolean,
            _yDown: boolean,
          ): Packages.arc.struct.IntSeq;
          public computeIndices(
            _points: number[],
            _offset: number,
            _count: number,
            _sorted: boolean,
            _yDown: boolean,
          ): Packages.arc.struct.IntSeq;
          private sortWithIndices(
            _values: number[],
            _count: number,
            _yDown: boolean,
          ): void;
          private quicksortPartitionWithIndices(
            _values: number[],
            _lower: number,
            _upper: number,
            _yDown: boolean,
            _originalIndices: Packages.short[],
          ): number;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class Ellipse
          extends java.lang.Object
          implements Packages.arc.math.geom.Shape2D
        {
          public x: number;
          public y: number;
          public width: number;
          public height: number;
          public equals(_o: any): boolean;
          public hashCode(): number;
          public contains(_x: number, _y: number): boolean;
          public contains(
            _point: Packages.arc.math.geom.Vec2,
          ): boolean;
          public set(
            _position: Packages.arc.math.geom.Vec2,
            _size: Packages.arc.math.geom.Vec2,
          ): void;
          public set(
            _ellipse: Packages.arc.math.geom.Ellipse,
          ): void;
          public set(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          ): void;
          public set(
            _circle: Packages.arc.math.geom.Circle,
          ): void;
          public setSize(
            _width: number,
            _height: number,
          ): Packages.arc.math.geom.Ellipse;
          public setPosition(
            _x: number,
            _y: number,
          ): Packages.arc.math.geom.Ellipse;
          public setPosition(
            _position: Packages.arc.math.geom.Vec2,
          ): Packages.arc.math.geom.Ellipse;
          public area(): number;
          public circumference(): number;
          public constructor(
            _circle: Packages.arc.math.geom.Circle,
          );
          public constructor(
            _position: Packages.arc.math.geom.Vec2,
            _size: Packages.arc.math.geom.Vec2,
          );
          public constructor(
            _position: Packages.arc.math.geom.Vec2,
            _width: number,
            _height: number,
          );
          public constructor();
          public constructor(
            _ellipse: Packages.arc.math.geom.Ellipse,
          );
          public constructor(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class Geometry extends java.lang.Object {
          public static SolidChecker = class {
            public solid(
              _index: number,
              _x: number,
              _y: number,
            ): boolean;
          };
          public static Raycaster = class {
            public accept(_x: number, _y: number): boolean;
          };
          public static d4c: Packages.arc.math.geom.Point2[];
          private static tmp1: Packages.arc.math.geom.Vec2;
          private static tmp2: Packages.arc.math.geom.Vec2;
          private static tmp3: Packages.arc.math.geom.Vec2;
          public static d4(
            _i: number,
          ): Packages.arc.math.geom.Point2;
          public static circle(
            _x: number,
            _y: number,
            _radius: number,
            _cons: Packages.arc.func.Intc2,
          ): void;
          public static circle(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
            _radius: number,
            _cons: Packages.arc.func.Intc2,
          ): void;
          public static triangleCentroid(
            _x1: number,
            _y1: number,
            _x2: number,
            _y2: number,
            _x3: number,
            _y3: number,
            _centroid: Packages.arc.math.geom.Vec2,
          ): Packages.arc.math.geom.Vec2;
          public static polygonArea(
            _polygon: number[],
            _offset: number,
            _count: number,
          ): number;
          public static d4y(_i: number): number;
          public static d8(
            _i: number,
          ): Packages.arc.math.geom.Point2;
          public static d8edge(
            _i: number,
          ): Packages.arc.math.geom.Point2;
          public static pixelCircle(
            _tindex: number,
          ): Packages.arc.math.geom.Vec2[] | null;
          public static pixelCircle(
            _index: number,
            _checker: Packages.arc.math.geom.Geometry.SolidChecker,
          ): Packages.arc.math.geom.Vec2[] | null;
          public static raycastRect(
            _startx: number,
            _starty: number,
            _endx: number,
            _endy: number,
            _x: number,
            _y: number,
            _halfx: number,
            _halfy: number,
          ): Packages.arc.math.geom.Vec2;
          public static raycastRect(
            _startx: number,
            _starty: number,
            _endx: number,
            _endy: number,
            _rect: Packages.arc.math.geom.Rect,
          ): Packages.arc.math.geom.Vec2;
          public static triangleCircumradius(
            _x1: number,
            _y1: number,
            _x2: number,
            _y2: number,
            _x3: number,
            _y3: number,
          ): number;
          public static ensureCCW(
            _polygon: number[],
            _offset: number,
            _count: number,
          ): void;
          public static ensureCCW(_polygon: number[]): void;
          public static isClockwise(
            _polygon: number[],
            _offset: number,
            _count: number,
          ): boolean;
          public static vectorsToFloats(
            _result: Packages.arc.struct.Seq<Packages.arc.math.geom.Vec2>,
          ): Packages.arc.struct.FloatSeq;
          public static findClosest<
            T extends Packages.arc.math.geom.Position,
          >(_x: number, _y: number, _list: T[]): T | null;
          public static findClosest<
            T extends Packages.arc.math.geom.Position,
          >(
            _x: number,
            _y: number,
            _list: Packages.java.lang.Iterable<T>,
          ): T | null;
          public static findFurthest<
            T extends Packages.arc.math.geom.Position,
          >(
            _x: number,
            _y: number,
            _list: Packages.java.lang.Iterable<T>,
          ): T | null;
          public static regPoly(
            _amount: number,
            _size: number,
          ): number[] | null;
          public static iterateLine(
            _start: number,
            _x1: number,
            _y1: number,
            _x2: number,
            _y2: number,
            _segment: number,
            _pos: Packages.arc.func.Floatc2,
          ): number;
          public static iteratePolySegments(
            _vertices: number[],
            _it: Packages.arc.func.Floatc4,
          ): void;
          public static iteratePolygon(
            _path: Packages.arc.func.Floatc2,
            _vertices: number[],
          ): void;
          public static getD4Points():
            | Packages.arc.math.geom.Point2[]
            | null;
          public static getD8Points():
            | Packages.arc.math.geom.Point2[]
            | null;
          public static getD8EdgePoints():
            | Packages.arc.math.geom.Point2[]
            | null;
          public static raycast(
            _x0f: number,
            _y0f: number,
            _x1: number,
            _y1: number,
            _cons: Packages.arc.math.geom.Geometry.Raycaster,
          ): boolean;
          public static d4x(_i: number): number;
          public static overlap(
            _a: Packages.arc.math.geom.Rect,
            _b: Packages.arc.math.geom.Rect,
            _x: boolean,
          ): Packages.arc.math.geom.Vec2;
          public static toBarycoord(
            _p: Packages.arc.math.geom.Vec2,
            _a: Packages.arc.math.geom.Vec2,
            _b: Packages.arc.math.geom.Vec2,
            _c: Packages.arc.math.geom.Vec2,
            _barycentricOut: Packages.arc.math.geom.Vec2,
          ): Packages.arc.math.geom.Vec2;
          public static barycoordInsideTriangle(
            _barycentric: Packages.arc.math.geom.Vec2,
          ): boolean;
          public static fromBarycoord(
            _barycentric: Packages.arc.math.geom.Vec2,
            _a: Packages.arc.math.geom.Vec2,
            _b: Packages.arc.math.geom.Vec2,
            _c: Packages.arc.math.geom.Vec2,
            _interpolatedOut: Packages.arc.math.geom.Vec2,
          ): Packages.arc.math.geom.Vec2;
          public static fromBarycoord(
            _barycentric: Packages.arc.math.geom.Vec2,
            _a: number,
            _b: number,
            _c: number,
          ): number;
          public static lowestPositiveRoot(
            _a: number,
            _b: number,
            _c: number,
          ): number;
          public static colinear(
            _x1: number,
            _y1: number,
            _x2: number,
            _y2: number,
            _x3: number,
            _y3: number,
          ): boolean;
          public static triangleCircumcenter(
            _x1: number,
            _y1: number,
            _x2: number,
            _y2: number,
            _x3: number,
            _y3: number,
            _circumcenter: Packages.arc.math.geom.Vec2,
          ): Packages.arc.math.geom.Vec2;
          public static triangleQuality(
            _x1: number,
            _y1: number,
            _x2: number,
            _y2: number,
            _x3: number,
            _y3: number,
          ): number;
          public static triangleArea(
            _x1: number,
            _y1: number,
            _x2: number,
            _y2: number,
            _x3: number,
            _y3: number,
          ): number;
          public static quadrilateralCentroid(
            _x1: number,
            _y1: number,
            _x2: number,
            _y2: number,
            _x3: number,
            _y3: number,
            _x4: number,
            _y4: number,
            _centroid: Packages.arc.math.geom.Vec2,
          ): Packages.arc.math.geom.Vec2;
          public static polygonCentroid(
            _polygon: number[],
            _offset: number,
            _count: number,
            _centroid: Packages.arc.math.geom.Vec2,
          ): Packages.arc.math.geom.Vec2;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class MeshResult extends java.lang.Object {
          public vertices: Packages.arc.struct.FloatSeq;
          public indices: Packages.arc.struct.IntSeq;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class Icosphere extends java.lang.Object {
          private static t: number;
          private static baseVert: Packages.arc.math.geom.Vec3[];
          private static baseFace: number[][];
          private static v(
            _x: number,
            _y: number,
            _z: number,
          ): Packages.arc.math.geom.Vec3;
          public static create(
            _level: number,
          ): Packages.arc.math.geom.MeshResult;
          private static subdivide(
            _v1: number,
            _v2: number,
            _v3: number,
            _vertices: Packages.arc.struct.FloatSeq,
            _faces: Packages.arc.struct.IntSeq,
            _level: number,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class Intersector extends java.lang.Object {
          public static MinimumTranslationVector = class extends java
            .lang.Object {
            public normal: Packages.arc.math.geom.Vec2;
            public depth: number;
            public constructor();
          };
          private static v0: Packages.arc.math.geom.Vec3;
          private static v1: Packages.arc.math.geom.Vec3;
          private static v2: Packages.arc.math.geom.Vec3;
          private static floatArray: Packages.arc.struct.FloatSeq;
          private static floatArray2: Packages.arc.struct.FloatSeq;
          private static ip: Packages.arc.math.geom.Vec2;
          private static ep1: Packages.arc.math.geom.Vec2;
          private static ep2: Packages.arc.math.geom.Vec2;
          private static s: Packages.arc.math.geom.Vec2;
          private static e: Packages.arc.math.geom.Vec2;
          static tmp: Packages.arc.math.geom.Vec3;
          static tmp1: Packages.arc.math.geom.Vec3;
          static tmp2: Packages.arc.math.geom.Vec3;
          static tmp3: Packages.arc.math.geom.Vec3;
          static v2tmp: Packages.arc.math.geom.Vec2;
          static det(
            _a: number,
            _b: number,
            _c: number,
            _d: number,
          ): number;
          public static overlaps(
            _c1: Packages.arc.math.geom.Circle,
            _c2: Packages.arc.math.geom.Circle,
          ): boolean;
          public static overlaps(
            _r1: Packages.arc.math.geom.Rect,
            _r2: Packages.arc.math.geom.Rect,
          ): boolean;
          public static overlaps(
            _c: Packages.arc.math.geom.Circle,
            _r: Packages.arc.math.geom.Rect,
          ): boolean;
          public static isInPolygon(
            _polygon: Packages.arc.struct.Seq<Packages.arc.math.geom.Vec2>,
            _point: Packages.arc.math.geom.Vec2,
          ): boolean;
          public static isInPolygon(
            _polygon: number[],
            _offset: number,
            _count: number,
            _x: number,
            _y: number,
          ): boolean;
          public static pointLineSide(
            _linePoint1: Packages.arc.math.geom.Vec2,
            _linePoint2: Packages.arc.math.geom.Vec2,
            _point: Packages.arc.math.geom.Vec2,
          ): number;
          public static pointLineSide(
            _linePoint1X: number,
            _linePoint1Y: number,
            _linePoint2X: number,
            _linePoint2Y: number,
            _pointX: number,
            _pointY: number,
          ): number;
          public static intersectLines(
            _p1: Packages.arc.math.geom.Vec2,
            _p2: Packages.arc.math.geom.Vec2,
            _p3: Packages.arc.math.geom.Vec2,
            _p4: Packages.arc.math.geom.Vec2,
            _intersection: Packages.arc.math.geom.Vec2,
          ): boolean;
          public static intersectLines(
            _x1: number,
            _y1: number,
            _x2: number,
            _y2: number,
            _x3: number,
            _y3: number,
            _x4: number,
            _y4: number,
            _intersection: Packages.arc.math.geom.Vec2,
          ): boolean;
          public static distanceLinePoint(
            _startX: number,
            _startY: number,
            _endX: number,
            _endY: number,
            _pointX: number,
            _pointY: number,
          ): number;
          public static distanceLinePoint(
            _start: Packages.arc.math.geom.Vec2,
            _end: Packages.arc.math.geom.Vec2,
            _point: Packages.arc.math.geom.Vec2,
          ): number;
          public static nearestSegmentPoint(
            _startX: number,
            _startY: number,
            _endX: number,
            _endY: number,
            _pointX: number,
            _pointY: number,
            _nearest: Packages.arc.math.geom.Vec2,
          ): Packages.arc.math.geom.Vec2;
          public static nearestSegmentPoint(
            _start: Packages.arc.math.geom.Vec2,
            _end: Packages.arc.math.geom.Vec2,
            _point: Packages.arc.math.geom.Vec2,
            _nearest: Packages.arc.math.geom.Vec2,
          ): Packages.arc.math.geom.Vec2;
          public static intersectSegments(
            _x1: number,
            _y1: number,
            _x2: number,
            _y2: number,
            _x3: number,
            _y3: number,
            _x4: number,
            _y4: number,
            _intersection: Packages.arc.math.geom.Vec2,
          ): boolean;
          public static intersectSegments(
            _p1: Packages.arc.math.geom.Vec2,
            _p2: Packages.arc.math.geom.Vec2,
            _p3: Packages.arc.math.geom.Vec2,
            _p4: Packages.arc.math.geom.Vec2,
            _intersection: Packages.arc.math.geom.Vec2,
          ): boolean;
          public static intersectSegmentRectangle(
            _start: Packages.arc.math.geom.Vec2,
            _end: Packages.arc.math.geom.Vec2,
            _rect: Packages.arc.math.geom.Rect,
          ): boolean;
          public static intersectSegmentRectangle(
            _startX: number,
            _startY: number,
            _endX: number,
            _endY: number,
            _rect: Packages.arc.math.geom.Rect,
          ): boolean;
          public static intersectSegmentRectangle(
            _startX: number,
            _startY: number,
            _endX: number,
            _endY: number,
            _rectX: number,
            _rectY: number,
            _rectW: number,
            _rectH: number,
          ): boolean;
          public static overlapConvexPolygons(
            _verts1: number[],
            _offset1: number,
            _count1: number,
            _verts2: number[],
            _offset2: number,
            _count2: number,
            _mtv: Packages.arc.math.geom.Intersector.MinimumTranslationVector,
          ): boolean;
          public static overlapConvexPolygons(
            _p1: Packages.arc.math.geom.Polygon,
            _p2: Packages.arc.math.geom.Polygon,
            _mtv: Packages.arc.math.geom.Intersector.MinimumTranslationVector,
          ): boolean;
          public static overlapConvexPolygons(
            _verts1: number[],
            _verts2: number[],
            _mtv: Packages.arc.math.geom.Intersector.MinimumTranslationVector,
          ): boolean;
          public static overlapConvexPolygons(
            _p1: Packages.arc.math.geom.Polygon,
            _p2: Packages.arc.math.geom.Polygon,
          ): boolean;
          public static intersectPolygons(
            _p1: Packages.arc.math.geom.Polygon,
            _p2: Packages.arc.math.geom.Polygon,
            _overlap: Packages.arc.math.geom.Polygon,
          ): boolean;
          public static intersectPolygons(
            _p1: number[],
            _p2: number[],
          ): boolean;
          public static isInTriangle(
            _p: Packages.arc.math.geom.Vec2,
            _a: Packages.arc.math.geom.Vec2,
            _b: Packages.arc.math.geom.Vec2,
            _c: Packages.arc.math.geom.Vec2,
          ): boolean;
          public static isInTriangle(
            _px: number,
            _py: number,
            _ax: number,
            _ay: number,
            _bx: number,
            _by: number,
            _cx: number,
            _cy: number,
          ): boolean;
          public static isInTriangle(
            _point: Packages.arc.math.geom.Vec3,
            _t1: Packages.arc.math.geom.Vec3,
            _t2: Packages.arc.math.geom.Vec3,
            _t3: Packages.arc.math.geom.Vec3,
          ): boolean;
          public static isInsideHexagon(
            _cx: number,
            _cy: number,
            _d: number,
            _x: number,
            _y: number,
          ): boolean;
          public static isInRegularPolygon(
            _sides: number,
            _cx: number,
            _cy: number,
            _radius: number,
            _rotation: number,
            _x: number,
            _y: number,
          ): boolean;
          public static distanceSegmentPoint(
            _start: Packages.arc.math.geom.Vec2,
            _end: Packages.arc.math.geom.Vec2,
            _point: Packages.arc.math.geom.Vec2,
          ): number;
          public static distanceSegmentPoint(
            _startX: number,
            _startY: number,
            _endX: number,
            _endY: number,
            _pointX: number,
            _pointY: number,
          ): number;
          public static intersectSegmentCircle(
            _start: Packages.arc.math.geom.Vec2,
            _end: Packages.arc.math.geom.Vec2,
            _center: Packages.arc.math.geom.Vec2,
            _squareRadius: number,
          ): boolean;
          public static intersectSegmentCircleDisplace(
            _start: Packages.arc.math.geom.Vec2,
            _end: Packages.arc.math.geom.Vec2,
            _point: Packages.arc.math.geom.Vec2,
            _radius: number,
            _displacement: Packages.arc.math.geom.Vec2,
          ): number;
          public static intersectRayRay(
            _start1: Packages.arc.math.geom.Vec2,
            _direction1: Packages.arc.math.geom.Vec2,
            _start2: Packages.arc.math.geom.Vec2,
            _direction2: Packages.arc.math.geom.Vec2,
          ): number;
          public static intersectLinePolygon(
            _p1: Packages.arc.math.geom.Vec2,
            _p2: Packages.arc.math.geom.Vec2,
            _polygon: Packages.arc.math.geom.Polygon,
          ): boolean;
          public static intersectRectangles(
            _rect1: Packages.arc.math.geom.Rect,
            _rect2: Packages.arc.math.geom.Rect,
            _intersection: Packages.arc.math.geom.Rect,
          ): boolean;
          public static intersectSegmentRectangleFast(
            _startx: number,
            _starty: number,
            _endx: number,
            _endy: number,
            _rectX: number,
            _rectY: number,
            _rectW: number,
            _rectH: number,
          ): boolean;
          public static intersectSegmentPolygon(
            _p1: Packages.arc.math.geom.Vec2,
            _p2: Packages.arc.math.geom.Vec2,
            _polygon: Packages.arc.math.geom.Polygon,
          ): boolean;
          static detd(
            _a: number,
            _b: number,
            _c: number,
            _d: number,
          ): number;
          public static overlapsRect(
            _x1: number,
            _y1: number,
            _w1: number,
            _h1: number,
            _x2: number,
            _y2: number,
            _w2: number,
            _h2: number,
          ): boolean;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class Intersector3D extends java.lang
          .Object {
          public static SplitTriangle = class extends java
            .lang.Object {
            public front: number[];
            public back: number[];
            public numFront: number;
            public numBack: number;
            public total: number;
            edgeSplit: number[];
            frontCurrent: boolean;
            frontOffset: number;
            backOffset: number;
            add(
              _vertex: number[],
              _offset: number,
              _stride: number,
            ): void;
            public toString(): string;
            reset(): void;
            getSide(): boolean;
            setSide(_front: boolean): void;
            public constructor(_numAttributes: number);
          };
          private static v0: Packages.arc.math.geom.Vec3;
          private static v1: Packages.arc.math.geom.Vec3;
          private static v2: Packages.arc.math.geom.Vec3;
          private static p: Packages.arc.math.geom.Plane;
          private static i: Packages.arc.math.geom.Vec3;
          static best: Packages.arc.math.geom.Vec3;
          static tmp: Packages.arc.math.geom.Vec3;
          static tmp1: Packages.arc.math.geom.Vec3;
          static tmp2: Packages.arc.math.geom.Vec3;
          static tmp3: Packages.arc.math.geom.Vec3;
          static intersection: Packages.arc.math.geom.Vec3;
          public static intersectRayBoundsFast(
            _ray: Packages.arc.math.geom.Ray,
            _box: Packages.arc.math.geom.BoundingBox,
          ): boolean;
          public static intersectRayBoundsFast(
            _ray: Packages.arc.math.geom.Ray,
            _center: Packages.arc.math.geom.Vec3,
            _dimensions: Packages.arc.math.geom.Vec3,
          ): boolean;
          public static intersectRayTriangle(
            _ray: Packages.arc.math.geom.Ray,
            _t1: Packages.arc.math.geom.Vec3,
            _t2: Packages.arc.math.geom.Vec3,
            _t3: Packages.arc.math.geom.Vec3,
            _intersection: Packages.arc.math.geom.Vec3,
          ): boolean;
          private static splitEdge(
            _vertices: number[],
            _s: number,
            _e: number,
            _stride: number,
            _plane: Packages.arc.math.geom.Plane,
            _split: number[],
            _offset: number,
          ): void;
          public static intersectLinePlane(
            _x: number,
            _y: number,
            _z: number,
            _x2: number,
            _y2: number,
            _z2: number,
            _plane: Packages.arc.math.geom.Plane,
            _intersection: Packages.arc.math.geom.Vec3,
          ): number;
          public static intersectRayPlane(
            _ray: Packages.arc.math.geom.Ray,
            _plane: Packages.arc.math.geom.Plane,
            _intersection: Packages.arc.math.geom.Vec3,
          ): boolean;
          public static intersectRaySphere(
            _ray: Packages.arc.math.geom.Ray,
            _center: Packages.arc.math.geom.Vec3,
            _radius: number,
            _intersection: Packages.arc.math.geom.Vec3,
          ): boolean;
          public static intersectRayBounds(
            _ray: Packages.arc.math.geom.Ray,
            _box: Packages.arc.math.geom.BoundingBox,
            _intersection: Packages.arc.math.geom.Vec3,
          ): boolean;
          public static intersectSegmentPlane(
            _start: Packages.arc.math.geom.Vec3,
            _end: Packages.arc.math.geom.Vec3,
            _plane: Packages.arc.math.geom.Plane,
            _intersection: Packages.arc.math.geom.Vec3,
          ): boolean;
          public static intersectRayTriangles(
            _ray: Packages.arc.math.geom.Ray,
            _triangles: Packages.arc.struct.Seq<Packages.arc.math.geom.Vec3>,
            _intersection: Packages.arc.math.geom.Vec3,
          ): boolean;
          public static intersectRayTriangles(
            _ray: Packages.arc.math.geom.Ray,
            _triangles: number[],
            _intersection: Packages.arc.math.geom.Vec3,
          ): boolean;
          public static intersectRayTriangles(
            _ray: Packages.arc.math.geom.Ray,
            _vertices: number[],
            _indices: Packages.short[],
            _vertexSize: number,
            _intersection: Packages.arc.math.geom.Vec3,
          ): boolean;
          public static splitTriangle(
            _triangle: number[],
            _plane: Packages.arc.math.geom.Plane,
            _split: Packages.arc.math.geom.Intersector3D.SplitTriangle,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class Point3 extends java.lang.Object {
          private static serialVersionUID: Packages.long;
          public x: number;
          public y: number;
          public z: number;
          public add(
            _other: Packages.arc.math.geom.Point3,
          ): Packages.arc.math.geom.Point3;
          public add(
            _x: number,
            _y: number,
            _z: number,
          ): Packages.arc.math.geom.Point3;
          public equals(_o: any): boolean;
          public toString(): string;
          public hashCode(): number;
          public dst(
            _x: number,
            _y: number,
            _z: number,
          ): number;
          public dst(
            _other: Packages.arc.math.geom.Point3,
          ): number;
          public set(
            _point: Packages.arc.math.geom.Point3,
          ): Packages.arc.math.geom.Point3;
          public set(
            _x: number,
            _y: number,
            _z: number,
          ): Packages.arc.math.geom.Point3;
          public sub(
            _x: number,
            _y: number,
            _z: number,
          ): Packages.arc.math.geom.Point3;
          public sub(
            _other: Packages.arc.math.geom.Point3,
          ): Packages.arc.math.geom.Point3;
          public dst2(
            _other: Packages.arc.math.geom.Point3,
          ): number;
          public dst2(
            _x: number,
            _y: number,
            _z: number,
          ): number;
          public cpy(): Packages.arc.math.geom.Point3;
          public constructor(
            _point: Packages.arc.math.geom.Point3,
          );
          public constructor(
            _x: number,
            _y: number,
            _z: number,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class Polyline
          extends java.lang.Object
          implements Packages.arc.math.geom.Shape2D
        {
          private localVertices: number[];
          private worldVertices: number[];
          private x: number;
          private y: number;
          private originX: number;
          private originY: number;
          private rotation: number;
          private scaleX: number;
          private scaleY: number;
          private length: number;
          private scaledLength: number;
          public getLength(): number;
          public scale(_amount: number): void;
          public contains(_x: number, _y: number): boolean;
          public contains(
            _point: Packages.arc.math.geom.Vec2,
          ): boolean;
          public rotate(_degrees: number): void;
          public setScale(
            _scaleX: number,
            _scaleY: number,
          ): void;
          public dirty(): void;
          public getX(): number;
          public getY(): number;
          public translate(_x: number, _y: number): void;
          public getRotation(): number;
          public setPosition(_x: number, _y: number): void;
          public setOrigin(
            _originX: number,
            _originY: number,
          ): void;
          public setRotation(_degrees: number): void;
          public getScaleX(): number;
          public getScaleY(): number;
          public getVertices(): number[] | null;
          public setVertices(_vertices: number[]): void;
          public getOriginX(): number;
          public getOriginY(): number;
          public getTransformedVertices(): number[] | null;
          public calculateScaledLength(): void;
          public calculateLength(): void;
          public getScaledLength(): number;
          public constructor();
          public constructor(_vertices: number[]);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class QuadTree<
          T extends
            Packages.arc.math.geom.QuadTree.QuadTreeObject,
        > extends java.lang.Object {
          public static QuadTreeObject = class {
            public hitbox(
              _out: Packages.arc.math.geom.Rect,
            ): void;
          };
          protected tmp: Packages.arc.math.geom.Rect;
          protected static maxObjectsPerNode: number;
          public bounds: Packages.arc.math.geom.Rect;
          public objects: Packages.arc.struct.Seq<T>;
          public botLeft: Packages.arc.math.geom.QuadTree<T>;
          public botRight: Packages.arc.math.geom.QuadTree<T>;
          public topLeft: Packages.arc.math.geom.QuadTree<T>;
          public topRight: Packages.arc.math.geom.QuadTree<T>;
          public leaf: boolean;
          public totalObjects: number;
          public remove(_obj: T): boolean;
          public insert(_obj: T): void;
          public clear(): void;
          protected split(): void;
          public any(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          ): boolean;
          protected newChild(
            _rect: Packages.arc.math.geom.Rect,
          ): Packages.arc.math.geom.QuadTree<T>;
          protected hitbox(_t: T): void;
          protected getFittingChild(
            _boundingBox: Packages.arc.math.geom.Rect,
          ): Packages.arc.math.geom.QuadTree<T>;
          protected unsplit(): void;
          public intersect(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
            _out: Packages.arc.struct.Seq<T>,
          ): void;
          public intersect(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
            _out: Packages.arc.func.Boolf<T>,
          ): boolean;
          public intersect(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
            _out: Packages.arc.func.Cons<T>,
          ): void;
          public intersect(
            _rect: Packages.arc.math.geom.Rect,
            _out: Packages.arc.func.Cons<T>,
          ): void;
          public intersect(
            _toCheck: Packages.arc.math.geom.Rect,
            _out: Packages.arc.struct.Seq<T>,
          ): void;
          public getObjects(
            _out: Packages.arc.struct.Seq<T>,
          ): void;
          public constructor(
            _bounds: Packages.arc.math.geom.Rect,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class Segment extends java.lang.Object {
          public a: Packages.arc.math.geom.Vec3;
          public b: Packages.arc.math.geom.Vec3;
          public equals(_o: any): boolean;
          public hashCode(): number;
          public len(): number;
          public len2(): number;
          public constructor(
            _a: Packages.arc.math.geom.Vec3,
            _b: Packages.arc.math.geom.Vec3,
          );
          public constructor(
            _aX: number,
            _aY: number,
            _aZ: number,
            _bX: number,
            _bY: number,
            _bZ: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class Sphere extends java.lang.Object {
          private static PI_4_3: number;
          public center: Packages.arc.math.geom.Vec3;
          public radius: number;
          public equals(_o: any): boolean;
          public hashCode(): number;
          public volume(): number;
          public overlaps(
            _sphere: Packages.arc.math.geom.Sphere,
          ): boolean;
          public surfaceArea(): number;
          public constructor(
            _center: Packages.arc.math.geom.Vec3,
            _radius: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class Spring1D extends java.lang.Object {
          public value: number;
          public target: number;
          public velocity: number;
          public damping: number;
          public frequency: number;
          public update(_deltaTime: number): void;
          public constructor(
            _damping: number,
            _frequency: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace math {
      declare namespace geom {
        declare class Spring2D extends java.lang.Object {
          public value: Packages.arc.math.geom.Vec2;
          public target: Packages.arc.math.geom.Vec2;
          public velocity: Packages.arc.math.geom.Vec2;
          public damping: number;
          public frequency: number;
          public update(_deltaTime: number): void;
          public constructor(
            _damping: number,
            _frequency: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class RunnableAction extends Packages.arc
          .scene.Action {
          private runnable: Packages.java.lang.Runnable;
          private ran: boolean;
          public run(): void;
          public reset(): void;
          public act(_delta: number): boolean;
          public restart(): void;
          public setRunnable(
            _runnable: Packages.java.lang.Runnable,
          ): void;
          public getRunnable(): Packages.java.lang.Runnable;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class RemoveActorAction extends Packages.arc
          .scene.Action {
          private removed: boolean;
          public act(_delta: number): boolean;
          public restart(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare abstract class DelegateAction extends Packages
          .arc.scene.Action {
          protected action: Packages.arc.scene.Action;
          public toString(): string;
          public setTarget(
            _target: Packages.arc.scene.Element,
          ): void;
          public reset(): void;
          protected delegate(_delta: number): boolean;
          public act(_delta: number): boolean;
          public setActor(
            _actor: Packages.arc.scene.Element,
          ): void;
          public restart(): void;
          public setAction(
            _action: Packages.arc.scene.Action,
          ): void;
          public getAction(): Packages.arc.scene.Action;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class RepeatAction extends Packages.arc
          .scene.actions.DelegateAction {
          public static FOREVER: number;
          private repeatCount: number;
          private executedCount: number;
          private finished: boolean;
          public finish(): void;
          protected delegate(_delta: number): boolean;
          public getCount(): number;
          public restart(): void;
          public setCount(_count: number): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class DelayAction extends Packages.arc.scene
          .actions.DelegateAction {
          private duration: number;
          private time: number;
          public finish(): void;
          protected delegate(_delta: number): boolean;
          public getTime(): number;
          public setTime(_time: number): void;
          public getDuration(): number;
          public restart(): void;
          public setDuration(_duration: number): void;
          public constructor();
          public constructor(_duration: number);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare abstract class TemporalAction extends Packages
          .arc.scene.Action {
          private duration: number;
          private time: number;
          private interpolation: Packages.arc.math.Interp;
          private reverse: boolean;
          private began: boolean;
          private complete: boolean;
          protected update(_percent: number): void;
          protected end(): void;
          protected begin(): void;
          public reset(): void;
          public finish(): void;
          public getTime(): number;
          public setTime(_time: number): void;
          public getDuration(): number;
          public act(_delta: number): boolean;
          public restart(): void;
          public setDuration(_duration: number): void;
          public getInterpolation(): Packages.arc.math.Interp;
          public setInterpolation(
            _interpolation: Packages.arc.math.Interp,
          ): void;
          public isReverse(): boolean;
          public setReverse(_reverse: boolean): void;
          public constructor(
            _duration: number,
            _interpolation: Packages.arc.math.Interp,
          );
          public constructor(_duration: number);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class ColorAction extends Packages.arc.scene
          .actions.TemporalAction {
          private end: Packages.arc.graphics.Color;
          private startR: number;
          private startG: number;
          private startB: number;
          private startA: number;
          private color: Packages.arc.graphics.Color;
          protected update(_percent: number): void;
          protected begin(): void;
          public reset(): void;
          public setColor(
            _color: Packages.arc.graphics.Color,
          ): void;
          public getColor(): Packages.arc.graphics.Color;
          public setEndColor(
            _color: Packages.arc.graphics.Color,
          ): void;
          public getEndColor(): Packages.arc.graphics.Color;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class AfterAction extends Packages.arc.scene
          .actions.DelegateAction {
          private waitForActions: Packages.arc.struct.Seq<Packages.arc.scene.Action>;
          public setTarget(
            _target: Packages.arc.scene.Element,
          ): void;
          protected delegate(_delta: number): boolean;
          public restart(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class ParallelAction extends Packages.arc
          .scene.Action {
          actions: Packages.arc.struct.Seq<Packages.arc.scene.Action>;
          private complete: boolean;
          public toString(): string;
          public getActions(): Packages.arc.struct.Seq<Packages.arc.scene.Action>;
          public reset(): void;
          public act(_delta: number): boolean;
          public addAction(
            _action: Packages.arc.scene.Action,
          ): void;
          public setActor(
            _actor: Packages.arc.scene.Element,
          ): void;
          public restart(): void;
          public constructor(
            _action1: Packages.arc.scene.Action,
            _action2: Packages.arc.scene.Action,
            _action3: Packages.arc.scene.Action,
            _action4: Packages.arc.scene.Action,
            _action5: Packages.arc.scene.Action,
          );
          public constructor(
            _action1: Packages.arc.scene.Action,
            _action2: Packages.arc.scene.Action,
            _action3: Packages.arc.scene.Action,
            _action4: Packages.arc.scene.Action,
          );
          public constructor(
            _action1: Packages.arc.scene.Action,
            _action2: Packages.arc.scene.Action,
            _action3: Packages.arc.scene.Action,
          );
          public constructor();
          public constructor(
            _action1: Packages.arc.scene.Action,
          );
          public constructor(
            _action1: Packages.arc.scene.Action,
            _action2: Packages.arc.scene.Action,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class SequenceAction extends Packages.arc
          .scene.actions.ParallelAction {
          private index: number;
          public act(_delta: number): boolean;
          public restart(): void;
          public constructor(
            _action1: Packages.arc.scene.Action,
            _action2: Packages.arc.scene.Action,
            _action3: Packages.arc.scene.Action,
            _action4: Packages.arc.scene.Action,
            _action5: Packages.arc.scene.Action,
          );
          public constructor(
            _action1: Packages.arc.scene.Action,
            _action2: Packages.arc.scene.Action,
            _action3: Packages.arc.scene.Action,
            _action4: Packages.arc.scene.Action,
          );
          public constructor(
            _action1: Packages.arc.scene.Action,
            _action2: Packages.arc.scene.Action,
            _action3: Packages.arc.scene.Action,
          );
          public constructor();
          public constructor(
            _action1: Packages.arc.scene.Action,
          );
          public constructor(
            _action1: Packages.arc.scene.Action,
            _action2: Packages.arc.scene.Action,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class VisibleAction extends Packages.arc
          .scene.Action {
          private visible: boolean;
          public act(_delta: number): boolean;
          public setVisible(_visible: boolean): void;
          public isVisible(): boolean;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class AddListenerAction extends Packages.arc
          .scene.Action {
          private listener: Packages.arc.scene.event.EventListener;
          private capture: boolean;
          public reset(): void;
          public act(_delta: number): boolean;
          public getListener(): Packages.arc.scene.event.EventListener;
          public setListener(
            _listener: Packages.arc.scene.event.EventListener,
          ): void;
          public getCapture(): boolean;
          public setCapture(_capture: boolean): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class RemoveListenerAction extends Packages
          .arc.scene.Action {
          private listener: Packages.arc.scene.event.EventListener;
          private capture: boolean;
          public reset(): void;
          public act(_delta: number): boolean;
          public getListener(): Packages.arc.scene.event.EventListener;
          public setListener(
            _listener: Packages.arc.scene.event.EventListener,
          ): void;
          public getCapture(): boolean;
          public setCapture(_capture: boolean): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class RotateToAction extends Packages.arc
          .scene.actions.TemporalAction {
          private start: number;
          private end: number;
          private useShortestDirection: boolean;
          protected update(_percent: number): void;
          protected begin(): void;
          public getRotation(): number;
          public setRotation(_rotation: number): void;
          public isUseShortestDirection(): boolean;
          public setUseShortestDirection(
            _useShortestDirection: boolean,
          ): void;
          public constructor();
          public constructor(
            _useShortestDirection: boolean,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class AlphaAction extends Packages.arc.scene
          .actions.TemporalAction {
          private start: number;
          private end: number;
          private color: Packages.arc.graphics.Color;
          protected update(_percent: number): void;
          protected begin(): void;
          public reset(): void;
          public setColor(
            _color: Packages.arc.graphics.Color,
          ): void;
          public getColor(): Packages.arc.graphics.Color;
          public getAlpha(): number;
          public setAlpha(_alpha: number): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class MoveToAction extends Packages.arc
          .scene.actions.TemporalAction {
          private startX: number;
          private startY: number;
          private endX: number;
          private endY: number;
          private alignment: number;
          protected update(_percent: number): void;
          protected begin(): void;
          public reset(): void;
          public getX(): number;
          public getY(): number;
          public setPosition(
            _x: number,
            _y: number,
            _alignment: number,
          ): void;
          public setPosition(_x: number, _y: number): void;
          public setX(_x: number): void;
          public setY(_y: number): void;
          public setAlignment(_alignment: number): void;
          public getAlignment(): number;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class TouchableAction extends Packages.arc
          .scene.Action {
          public touchable(
            _touchable: Packages.arc.scene.event.Touchable,
          ): void;
          public act(_delta: number): boolean;
          public getTouchable(): Packages.arc.scene.event.Touchable;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class AddAction extends Packages.arc.scene
          .Action {
          private action: Packages.arc.scene.Action;
          public reset(): void;
          public act(_delta: number): boolean;
          public restart(): void;
          public setAction(
            _action: Packages.arc.scene.Action,
          ): void;
          public getAction(): Packages.arc.scene.Action;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class LayoutAction extends Packages.arc
          .scene.Action {
          private enabled: boolean;
          public isEnabled(): boolean;
          public act(_delta: number): boolean;
          public setLayoutEnabled(_enabled: boolean): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class RemoveAction extends Packages.arc
          .scene.Action {
          private action: Packages.arc.scene.Action;
          public reset(): void;
          public act(_delta: number): boolean;
          public setAction(
            _action: Packages.arc.scene.Action,
          ): void;
          public getAction(): Packages.arc.scene.Action;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare abstract class RelativeTemporalAction extends Packages
          .arc.scene.actions.TemporalAction {
          private lastPercent: number;
          protected update(_percent: number): void;
          protected begin(): void;
          protected updateRelative(
            _percentDelta: number,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class MoveByAction extends Packages.arc
          .scene.actions.RelativeTemporalAction {
          private amountX: number;
          private amountY: number;
          public setAmount(_x: number, _y: number): void;
          protected updateRelative(
            _percentDelta: number,
          ): void;
          public getAmountX(): number;
          public setAmountX(_x: number): void;
          public getAmountY(): number;
          public setAmountY(_y: number): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class SizeByAction extends Packages.arc
          .scene.actions.RelativeTemporalAction {
          private amountWidth: number;
          private amountHeight: number;
          public setAmount(
            _width: number,
            _height: number,
          ): void;
          protected updateRelative(
            _percentDelta: number,
          ): void;
          public getAmountWidth(): number;
          public setAmountWidth(_width: number): void;
          public getAmountHeight(): number;
          public setAmountHeight(_height: number): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class ScaleByAction extends Packages.arc
          .scene.actions.RelativeTemporalAction {
          private amountX: number;
          private amountY: number;
          public setAmount(_x: number, _y: number): void;
          public setAmount(_scale: number): void;
          protected updateRelative(
            _percentDelta: number,
          ): void;
          public getAmountX(): number;
          public setAmountX(_x: number): void;
          public getAmountY(): number;
          public setAmountY(_y: number): void;
          public constructor();
          public constructor(_amount: number);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class RotateByAction extends Packages.arc
          .scene.actions.RelativeTemporalAction {
          private amount: number;
          public getAmount(): number;
          public setAmount(_rotationAmount: number): void;
          protected updateRelative(
            _percentDelta: number,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class TranslateByAction extends Packages.arc
          .scene.actions.RelativeTemporalAction {
          private amountX: number;
          private amountY: number;
          public setAmount(_x: number, _y: number): void;
          protected updateRelative(
            _percentDelta: number,
          ): void;
          public getAmountX(): number;
          public setAmountX(_x: number): void;
          public getAmountY(): number;
          public setAmountY(_y: number): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class SizeToAction extends Packages.arc
          .scene.actions.TemporalAction {
          private startWidth: number;
          private startHeight: number;
          private endWidth: number;
          private endHeight: number;
          protected update(_percent: number): void;
          protected begin(): void;
          public setSize(
            _width: number,
            _height: number,
          ): void;
          public getWidth(): number;
          public getHeight(): number;
          public setWidth(_width: number): void;
          public setHeight(_height: number): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class ScaleToAction extends Packages.arc
          .scene.actions.TemporalAction {
          private startX: number;
          private startY: number;
          private endX: number;
          private endY: number;
          protected update(_percent: number): void;
          protected begin(): void;
          public setScale(_scale: number): void;
          public setScale(_x: number, _y: number): void;
          public getX(): number;
          public getY(): number;
          public setX(_x: number): void;
          public setY(_y: number): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class TimeScaleAction extends Packages.arc
          .scene.actions.DelegateAction {
          private scale: number;
          protected delegate(_delta: number): boolean;
          public setScale(_scale: number): void;
          public getScale(): number;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class Actions extends java.lang.Object {
          public static run(
            _runnable: Packages.java.lang.Runnable,
          ): Packages.arc.scene.actions.RunnableAction;
          public static remove(): Packages.arc.scene.actions.RemoveActorAction;
          public static remove(
            _removeActor: Packages.arc.scene.Element,
          ): Packages.arc.scene.actions.RemoveActorAction;
          public static repeat(
            _count: number,
            _repeatedAction: Packages.arc.scene.Action,
          ): Packages.arc.scene.actions.RepeatAction;
          public static action<
            T extends Packages.arc.scene.Action,
          >(
            _type: Class<T> | Packages.java.lang.Class<T>,
            _sup: Packages.arc.func.Prov<T>,
          ): T | null;
          public static delay(
            _duration: number,
          ): Packages.arc.scene.actions.DelayAction;
          public static delay(
            _duration: number,
            _delayedAction: Packages.arc.scene.Action,
          ): Packages.arc.scene.actions.DelayAction;
          public static color(
            _color: Packages.arc.graphics.Color,
            _duration: number,
          ): Packages.arc.scene.actions.ColorAction;
          public static color(
            _color: Packages.arc.graphics.Color,
          ): Packages.arc.scene.actions.ColorAction;
          public static color(
            _color: Packages.arc.graphics.Color,
            _duration: number,
            _interpolation: Packages.arc.math.Interp,
          ): Packages.arc.scene.actions.ColorAction;
          public static after(
            _action: Packages.arc.scene.Action,
          ): Packages.arc.scene.actions.AfterAction;
          public static parallel(
            _action1: Packages.arc.scene.Action,
          ): Packages.arc.scene.actions.ParallelAction;
          public static parallel(): Packages.arc.scene.actions.ParallelAction;
          public static parallel(
            _action1: Packages.arc.scene.Action,
            _action2: Packages.arc.scene.Action,
            _action3: Packages.arc.scene.Action,
            _action4: Packages.arc.scene.Action,
          ): Packages.arc.scene.actions.ParallelAction;
          public static parallel(
            ..._actions: Packages.arc.scene.Action[]
          ): Packages.arc.scene.actions.ParallelAction;
          public static parallel(
            _action1: Packages.arc.scene.Action,
            _action2: Packages.arc.scene.Action,
            _action3: Packages.arc.scene.Action,
          ): Packages.arc.scene.actions.ParallelAction;
          public static parallel(
            _action1: Packages.arc.scene.Action,
            _action2: Packages.arc.scene.Action,
          ): Packages.arc.scene.actions.ParallelAction;
          public static parallel(
            _action1: Packages.arc.scene.Action,
            _action2: Packages.arc.scene.Action,
            _action3: Packages.arc.scene.Action,
            _action4: Packages.arc.scene.Action,
            _action5: Packages.arc.scene.Action,
          ): Packages.arc.scene.actions.ParallelAction;
          public static sequence(
            _action1: Packages.arc.scene.Action,
            _action2: Packages.arc.scene.Action,
            _action3: Packages.arc.scene.Action,
          ): Packages.arc.scene.actions.SequenceAction;
          public static sequence(
            _action1: Packages.arc.scene.Action,
            _action2: Packages.arc.scene.Action,
            _action3: Packages.arc.scene.Action,
            _action4: Packages.arc.scene.Action,
          ): Packages.arc.scene.actions.SequenceAction;
          public static sequence(
            _action1: Packages.arc.scene.Action,
            _action2: Packages.arc.scene.Action,
            _action3: Packages.arc.scene.Action,
            _action4: Packages.arc.scene.Action,
            _action5: Packages.arc.scene.Action,
          ): Packages.arc.scene.actions.SequenceAction;
          public static sequence(
            ..._actions: Packages.arc.scene.Action[]
          ): Packages.arc.scene.actions.SequenceAction;
          public static sequence(): Packages.arc.scene.actions.SequenceAction;
          public static sequence(
            _action1: Packages.arc.scene.Action,
          ): Packages.arc.scene.actions.SequenceAction;
          public static sequence(
            _action1: Packages.arc.scene.Action,
            _action2: Packages.arc.scene.Action,
          ): Packages.arc.scene.actions.SequenceAction;
          public static visible(
            _visible: boolean,
          ): Packages.arc.scene.actions.VisibleAction;
          public static addListener(
            _listener: Packages.arc.scene.event.EventListener,
            _capture: boolean,
          ): Packages.arc.scene.actions.AddListenerAction;
          public static addListener(
            _listener: Packages.arc.scene.event.EventListener,
            _capture: boolean,
            _targetActor: Packages.arc.scene.Element,
          ): Packages.arc.scene.actions.AddListenerAction;
          public static removeListener(
            _listener: Packages.arc.scene.event.EventListener,
            _capture: boolean,
          ): Packages.arc.scene.actions.RemoveListenerAction;
          public static removeListener(
            _listener: Packages.arc.scene.event.EventListener,
            _capture: boolean,
            _targetActor: Packages.arc.scene.Element,
          ): Packages.arc.scene.actions.RemoveListenerAction;
          public static rotateTo(
            _rotation: number,
            _duration: number,
            _interpolation: Packages.arc.math.Interp,
          ): Packages.arc.scene.actions.RotateToAction;
          public static rotateTo(
            _rotation: number,
            _duration: number,
          ): Packages.arc.scene.actions.RotateToAction;
          public static rotateTo(
            _rotation: number,
          ): Packages.arc.scene.actions.RotateToAction;
          public static alpha(
            _a: number,
          ): Packages.arc.scene.actions.AlphaAction;
          public static alpha(
            _a: number,
            _duration: number,
          ): Packages.arc.scene.actions.AlphaAction;
          public static alpha(
            _a: number,
            _duration: number,
            _interpolation: Packages.arc.math.Interp,
          ): Packages.arc.scene.actions.AlphaAction;
          public static moveTo(
            _x: number,
            _y: number,
            _duration: number,
          ): Packages.arc.scene.actions.MoveToAction;
          public static moveTo(
            _x: number,
            _y: number,
            _duration: number,
            _interpolation: Packages.arc.math.Interp,
          ): Packages.arc.scene.actions.MoveToAction;
          public static moveTo(
            _x: number,
            _y: number,
          ): Packages.arc.scene.actions.MoveToAction;
          public static touchable(
            _touchable: Packages.arc.scene.event.Touchable,
          ): Packages.arc.scene.actions.TouchableAction;
          public static addAction(
            _action: Packages.arc.scene.Action,
            _targetActor: Packages.arc.scene.Element,
          ): Packages.arc.scene.actions.AddAction;
          public static addAction(
            _action: Packages.arc.scene.Action,
          ): Packages.arc.scene.actions.AddAction;
          public static layout(
            _enabled: boolean,
          ): Packages.arc.scene.actions.LayoutAction;
          public static removeAction(
            _action: Packages.arc.scene.Action,
          ): Packages.arc.scene.actions.RemoveAction;
          public static removeAction(
            _action: Packages.arc.scene.Action,
            _targetActor: Packages.arc.scene.Element,
          ): Packages.arc.scene.actions.RemoveAction;
          public static moveBy(
            _amountX: number,
            _amountY: number,
            _duration: number,
            _interpolation: Packages.arc.math.Interp,
          ): Packages.arc.scene.actions.MoveByAction;
          public static moveBy(
            _amountX: number,
            _amountY: number,
            _duration: number,
          ): Packages.arc.scene.actions.MoveByAction;
          public static moveBy(
            _amountX: number,
            _amountY: number,
          ): Packages.arc.scene.actions.MoveByAction;
          public static sizeBy(
            _amountX: number,
            _amountY: number,
            _duration: number,
          ): Packages.arc.scene.actions.SizeByAction;
          public static sizeBy(
            _amountX: number,
            _amountY: number,
            _duration: number,
            _interpolation: Packages.arc.math.Interp,
          ): Packages.arc.scene.actions.SizeByAction;
          public static sizeBy(
            _amountX: number,
            _amountY: number,
          ): Packages.arc.scene.actions.SizeByAction;
          public static scaleBy(
            _amountX: number,
            _amountY: number,
          ): Packages.arc.scene.actions.ScaleByAction;
          public static scaleBy(
            _amountX: number,
            _amountY: number,
            _duration: number,
            _interpolation: Packages.arc.math.Interp,
          ): Packages.arc.scene.actions.ScaleByAction;
          public static scaleBy(
            _amountX: number,
            _amountY: number,
            _duration: number,
          ): Packages.arc.scene.actions.ScaleByAction;
          public static rotateBy(
            _rotationAmount: number,
            _duration: number,
          ): Packages.arc.scene.actions.RotateByAction;
          public static rotateBy(
            _rotationAmount: number,
            _duration: number,
            _interpolation: Packages.arc.math.Interp,
          ): Packages.arc.scene.actions.RotateByAction;
          public static rotateBy(
            _rotationAmount: number,
          ): Packages.arc.scene.actions.RotateByAction;
          public static hide(): Packages.arc.scene.actions.VisibleAction;
          public static show(): Packages.arc.scene.actions.VisibleAction;
          public static fadeOut(
            _duration: number,
          ): Packages.arc.scene.actions.AlphaAction;
          public static fadeOut(
            _duration: number,
            _interpolation: Packages.arc.math.Interp,
          ): Packages.arc.scene.actions.AlphaAction;
          public static fadeIn(
            _duration: number,
          ): Packages.arc.scene.actions.AlphaAction;
          public static fadeIn(
            _duration: number,
            _interpolation: Packages.arc.math.Interp,
          ): Packages.arc.scene.actions.AlphaAction;
          public static moveToAligned(
            _x: number,
            _y: number,
            _alignment: number,
          ): Packages.arc.scene.actions.MoveToAction;
          public static moveToAligned(
            _x: number,
            _y: number,
            _alignment: number,
            _duration: number,
          ): Packages.arc.scene.actions.MoveToAction;
          public static moveToAligned(
            _x: number,
            _y: number,
            _alignment: number,
            _duration: number,
            _interpolation: Packages.arc.math.Interp,
          ): Packages.arc.scene.actions.MoveToAction;
          public static translateBy(
            _amountX: number,
            _amountY: number,
            _duration: number,
            _interpolation: Packages.arc.math.Interp,
          ): Packages.arc.scene.actions.TranslateByAction;
          public static translateBy(
            _amountX: number,
            _amountY: number,
          ): Packages.arc.scene.actions.TranslateByAction;
          public static translateBy(
            _amountX: number,
            _amountY: number,
            _duration: number,
          ): Packages.arc.scene.actions.TranslateByAction;
          public static sizeTo(
            _x: number,
            _y: number,
            _duration: number,
          ): Packages.arc.scene.actions.SizeToAction;
          public static sizeTo(
            _x: number,
            _y: number,
          ): Packages.arc.scene.actions.SizeToAction;
          public static sizeTo(
            _x: number,
            _y: number,
            _duration: number,
            _interpolation: Packages.arc.math.Interp,
          ): Packages.arc.scene.actions.SizeToAction;
          public static scaleTo(
            _x: number,
            _y: number,
          ): Packages.arc.scene.actions.ScaleToAction;
          public static scaleTo(
            _x: number,
            _y: number,
            _duration: number,
            _interpolation: Packages.arc.math.Interp,
          ): Packages.arc.scene.actions.ScaleToAction;
          public static scaleTo(
            _x: number,
            _y: number,
            _duration: number,
          ): Packages.arc.scene.actions.ScaleToAction;
          public static originCenter(): Packages.arc.scene.Action;
          public static translateTo(
            _amountX: number,
            _amountY: number,
          ): Packages.arc.scene.actions.RunnableAction;
          public static timeScale(
            _scale: number,
            _scaledAction: Packages.arc.scene.Action,
          ): Packages.arc.scene.actions.TimeScaleAction;
          public static forever(
            _repeatedAction: Packages.arc.scene.Action,
          ): Packages.arc.scene.actions.RepeatAction;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class FloatAction extends Packages.arc.scene
          .actions.TemporalAction {
          private start: number;
          private end: number;
          private value: number;
          protected update(_percent: number): void;
          public getValue(): number;
          protected begin(): void;
          public setValue(_value: number): void;
          public setStart(_start: number): void;
          public getStart(): number;
          public getEnd(): number;
          public setEnd(_end: number): void;
          public constructor();
          public constructor(_start: number, _end: number);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class IntAction extends Packages.arc.scene
          .actions.TemporalAction {
          private start: number;
          private end: number;
          private value: number;
          protected update(_percent: number): void;
          public getValue(): number;
          protected begin(): void;
          public setValue(_value: number): void;
          public setStart(_start: number): void;
          public getStart(): number;
          public getEnd(): number;
          public setEnd(_end: number): void;
          public constructor();
          public constructor(_start: number, _end: number);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace actions {
        declare class OriginAction extends Packages.arc
          .scene.Action {
          public act(_delta: number): boolean;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace event {
        declare abstract class ChangeListener
          extends java.lang.Object
          implements Packages.arc.scene.event.EventListener
        {
          public static ChangeEvent = class extends Packages
            .arc.scene.event.SceneEvent {
            public constructor();
          };
          public handle(
            _event: Packages.arc.scene.event.SceneEvent,
          ): boolean;
          public changed(
            _event: Packages.arc.scene.event.ChangeListener.ChangeEvent,
            _actor: Packages.arc.scene.Element,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace event {
        declare class DragListener extends Packages.arc
          .scene.event.InputListener {
          private tapSquareSize: number;
          private touchDownX: number;
          private touchDownY: number;
          private stageTouchDownX: number;
          private stageTouchDownY: number;
          private pressedPointer: number;
          private button: number;
          private dragging: boolean;
          private deltaX: number;
          private deltaY: number;
          public cancel(): void;
          public touchDown(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
            _button: number,
          ): boolean;
          public touchDragged(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
          ): void;
          public touchUp(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
            _button: number,
          ): void;
          public getTapSquareSize(): number;
          public setTapSquareSize(
            _halfTapSquareSize: number,
          ): void;
          public getTouchDownX(): number;
          public getTouchDownY(): number;
          public getButton(): number;
          public setButton(_button: number): void;
          public isDragging(): boolean;
          public getDeltaY(): number;
          public dragStart(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
          ): void;
          public drag(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
          ): void;
          public dragStop(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
          ): void;
          public getStageTouchDownX(): number;
          public getStageTouchDownY(): number;
          public getDeltaX(): number;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace event {
        declare class DragScrollListener extends Packages
          .arc.scene.event.DragListener {
          interpolation: Packages.arc.math.Interp;
          minSpeed: number;
          maxSpeed: number;
          tickSecs: number;
          startTime: Packages.long;
          rampTime: Packages.long;
          private scroll: Packages.arc.scene.ui.ScrollPane;
          private scrollUp: Packages.arc.util.Timer.Task;
          private scrollDown: Packages.arc.util.Timer.Task;
          public setup(
            _minSpeedPixels: number,
            _maxSpeedPixels: number,
            _tickSecs: number,
            _rampSecs: number,
          ): void;
          public drag(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
          ): void;
          public dragStop(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
          ): void;
          getScrollPixels(): number;
          public constructor(
            _scroll: Packages.arc.scene.ui.ScrollPane,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace event {
        declare class HandCursorListener extends Packages
          .arc.scene.event.ClickListener {
          public enabled: Packages.arc.func.Boolp;
          public checkEnabled: boolean;
          public exit(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
            _toActor: Packages.arc.scene.Element,
          ): void;
          public enter(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
            _fromActor: Packages.arc.scene.Element,
          ): void;
          static isDisabled(
            _element: Packages.arc.scene.Element,
          ): boolean;
          public constructor(
            _enabled: Packages.arc.func.Boolp,
            _check: boolean,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace event {
        declare class IbeamCursorListener extends Packages
          .arc.scene.event.ClickListener {
          public exit(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
            _toActor: Packages.arc.scene.Element,
          ): void;
          public enter(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
            _fromActor: Packages.arc.scene.Element,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace event {
        declare class ResizeListener
          extends java.lang.Object
          implements Packages.arc.scene.event.EventListener
        {
          public handle(
            _event: Packages.arc.scene.event.SceneEvent,
          ): boolean;
          public resized(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace event {
        declare class SceneResizeEvent extends Packages.arc
          .scene.event.SceneEvent {
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace event {
        declare class VisibilityEvent extends Packages.arc
          .scene.event.SceneEvent {
          private hide: boolean;
          public isHide(): boolean;
          public constructor();
          public constructor(_hide: boolean);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace event {
        declare class VisibilityListener
          extends java.lang.Object
          implements Packages.arc.scene.event.EventListener
        {
          public handle(
            _event: Packages.arc.scene.event.SceneEvent,
          ): boolean;
          public shown(): boolean;
          public hidden(): boolean;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace style {
        declare class BaseDrawable
          extends java.lang.Object
          implements Packages.arc.scene.style.Drawable
        {
          private name: string;
          private leftWidth: number;
          private rightWidth: number;
          private topHeight: number;
          private bottomHeight: number;
          private minWidth: number;
          private minHeight: number;
          public getName(): string;
          public toString(): string;
          public setName(_name: string): void;
          public draw(
            _x: number,
            _y: number,
            _originX: number,
            _originY: number,
            _width: number,
            _height: number,
            _scaleX: number,
            _scaleY: number,
            _rotation: number,
          ): void;
          public draw(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          ): void;
          public getTopHeight(): number;
          public getLeftWidth(): number;
          public getBottomHeight(): number;
          public getRightWidth(): number;
          public getMinWidth(): number;
          public getMinHeight(): number;
          public setLeftWidth(_leftWidth: number): void;
          public setRightWidth(_rightWidth: number): void;
          public setTopHeight(_topHeight: number): void;
          public setBottomHeight(
            _bottomHeight: number,
          ): void;
          public setMinWidth(_minWidth: number): void;
          public setMinHeight(_minHeight: number): void;
          public constructor();
          public constructor(
            _drawable: Packages.arc.scene.style.Drawable,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace style {
        declare abstract class TransformDrawable
          implements Packages.arc.scene.style.Drawable
        {
          public draw(
            _x: number,
            _y: number,
            _originX: number,
            _originY: number,
            _width: number,
            _height: number,
            _scaleX: number,
            _scaleY: number,
            _rotation: number,
          ): void;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace style {
        declare class NinePatchDrawable
          extends Packages.arc.scene.style.BaseDrawable
          implements
            Packages.arc.scene.style.TransformDrawable
        {
          protected patch: Packages.arc.graphics.g2d.NinePatch;
          public draw(
            _x: number,
            _y: number,
            _originX: number,
            _originY: number,
            _width: number,
            _height: number,
            _scaleX: number,
            _scaleY: number,
            _rotation: number,
          ): void;
          public draw(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          ): void;
          public tint(
            _tint: Packages.arc.graphics.Color,
          ): Packages.arc.scene.style.NinePatchDrawable;
          public setPatch(
            _patch: Packages.arc.graphics.g2d.NinePatch,
          ): void;
          public getPatch(): Packages.arc.graphics.g2d.NinePatch;
          public constructor(
            _drawable: Packages.arc.scene.style.NinePatchDrawable,
          );
          public constructor(
            _patch: Packages.arc.graphics.g2d.NinePatch,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace style {
        declare class ScaledNinePatchDrawable extends Packages
          .arc.scene.style.NinePatchDrawable {
          private scale: number;
          public draw(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          ): void;
          public getTopHeight(): number;
          public getLeftWidth(): number;
          public getBottomHeight(): number;
          public getRightWidth(): number;
          public setPatch(
            _patch: Packages.arc.graphics.g2d.NinePatch,
          ): void;
          public constructor(
            _drawable: Packages.arc.scene.style.NinePatchDrawable,
          );
          public constructor(
            _patch: Packages.arc.graphics.g2d.NinePatch,
            _multiplier: number,
          );
          public constructor(
            _patch: Packages.arc.graphics.g2d.NinePatch,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace style {
        declare class TextureRegionDrawable
          extends Packages.arc.scene.style.BaseDrawable
          implements
            Packages.arc.scene.style.TransformDrawable
        {
          protected region: Packages.arc.graphics.g2d.TextureRegion;
          protected scale: number;
          public set(
            _region: Packages.arc.graphics.g2d.TextureRegion,
          ): Packages.arc.scene.style.TextureRegionDrawable;
          public getRegion(): Packages.arc.graphics.g2d.TextureRegion;
          public setRegion(
            _region: Packages.arc.graphics.g2d.TextureRegion,
          ): void;
          public draw(
            _x: number,
            _y: number,
            _originX: number,
            _originY: number,
            _width: number,
            _height: number,
            _scaleX: number,
            _scaleY: number,
            _rotation: number,
          ): void;
          public draw(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          ): void;
          public imageSize(): number;
          public tint(
            _r: number,
            _g: number,
            _b: number,
            _a: number,
          ): Packages.arc.scene.style.Drawable;
          public tint(
            _tint: Packages.arc.graphics.Color,
          ): Packages.arc.scene.style.Drawable;
          public constructor(
            _drawable: Packages.arc.scene.style.TextureRegionDrawable,
          );
          public constructor(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _scale: number,
          );
          public constructor(
            _region: Packages.arc.graphics.g2d.TextureRegion,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace style {
        declare class TiledDrawable extends Packages.arc
          .scene.style.TextureRegionDrawable {
          private color: Packages.arc.graphics.Color;
          private tileWidth: number;
          private tileHeight: number;
          public setRegion(
            _region: Packages.arc.graphics.g2d.TextureRegion,
          ): void;
          public draw(
            _x: number,
            _y: number,
            _originX: number,
            _originY: number,
            _width: number,
            _height: number,
            _scaleX: number,
            _scaleY: number,
            _rotation: number,
          ): void;
          public draw(
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          ): void;
          public tint(
            _tint: Packages.arc.graphics.Color,
          ): Packages.arc.scene.style.Drawable;
          public tint(
            _tint: Packages.arc.graphics.Color,
          ): Packages.arc.scene.style.TiledDrawable;
          public getColor(): Packages.arc.graphics.Color;
          public setTileSize(_w: number, _h: number): void;
          public constructor(
            _drawable: Packages.arc.scene.style.TextureRegionDrawable,
          );
          public constructor(
            _region: Packages.arc.graphics.g2d.TextureRegion,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace ui {
        declare class ColorImage extends Packages.arc.scene
          .ui.Image {
          private set: Packages.arc.graphics.Color;
          public draw(): void;
          public constructor(
            _set: Packages.arc.graphics.Color,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace ui {
        declare class Tooltip extends Packages.arc.scene
          .event.InputListener {
          public static Tooltips = class extends java.lang
            .Object {
            private static instance: Packages.arc.scene.ui.Tooltip.Tooltips;
            public textProvider: Packages.arc.func.Func<
              string,
              Packages.arc.scene.ui.Tooltip
            >;
            public initialTime: number;
            public subsequentTime: number;
            public resetTime: number;
            public enabled: boolean;
            public animations: boolean;
            public offsetX: number;
            public offsetY: number;
            public edgeDistance: number;
            time: number;
            resetTask: Packages.arc.util.Timer.Task;
            showTooltip: Packages.arc.scene.ui.Tooltip;
            showTask: Packages.arc.util.Timer.Task;
            public static getInstance(): Packages.arc.scene.ui.Tooltip.Tooltips;
            public create(
              _text: string,
              _mobile: boolean,
            ): Packages.arc.scene.ui.Tooltip;
            public create(
              _text: string,
            ): Packages.arc.scene.ui.Tooltip;
            public instant(): void;
            public enter(
              _tooltip: Packages.arc.scene.ui.Tooltip,
            ): void;
            public touchDown(
              _tooltip: Packages.arc.scene.ui.Tooltip,
            ): void;
            public hide(
              _tooltip: Packages.arc.scene.ui.Tooltip,
            ): void;
            protected hideAction(
              _tooltip: Packages.arc.scene.ui.Tooltip,
            ): void;
            protected showAction(
              _tooltip: Packages.arc.scene.ui.Tooltip,
            ): void;
            public constructor();
          };
          static tmp: Packages.arc.math.geom.Vec2;
          public manager: Packages.arc.scene.ui.Tooltip.Tooltips;
          public container: Packages.arc.scene.ui.layout.Table;
          public allowMobile: boolean;
          public instant: boolean;
          public always: boolean;
          protected targetActor: Packages.arc.scene.Element;
          public exit(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
            _toActor: Packages.arc.scene.Element,
          ): void;
          public setInstant(_instant: boolean): void;
          public enter(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
            _fromActor: Packages.arc.scene.Element,
          ): void;
          public touchDown(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
            _button: Packages.arc.input.KeyCode,
          ): boolean;
          public touchUp(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
            _pointer: number,
            _button: Packages.arc.input.KeyCode,
          ): void;
          public mouseMoved(
            _event: Packages.arc.scene.event.InputEvent,
            _x: number,
            _y: number,
          ): boolean;
          public hide(): void;
          public show(
            _element: Packages.arc.scene.Element,
            _x: number,
            _y: number,
          ): void;
          protected setContainerPosition(
            _element: Packages.arc.scene.Element,
            _x: number,
            _y: number,
          ): void;
          public getManager(): Packages.arc.scene.ui.Tooltip.Tooltips;
          public getContainer(): Packages.arc.scene.ui.layout.Table;
          public setAlways(_always: boolean): void;
          public constructor(
            _contents: Packages.arc.func.Cons<Packages.arc.scene.ui.layout.Table>,
            _manager: Packages.arc.scene.ui.Tooltip.Tooltips,
          );
          public constructor(
            _contents: Packages.arc.func.Cons<Packages.arc.scene.ui.layout.Table>,
            _show: Packages.java.lang.Runnable,
          );
          public constructor(
            _contents: Packages.arc.func.Cons<Packages.arc.scene.ui.layout.Table>,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace ui {
        declare class Touchpad extends Packages.arc.scene
          .Element {
          public static TouchpadStyle = class extends java
            .lang.Object {
            public background: Packages.arc.scene.style.Drawable;
            public knob: Packages.arc.scene.style.Drawable;
            public constructor();
            public constructor(
              _background: Packages.arc.scene.style.Drawable,
              _knob: Packages.arc.scene.style.Drawable,
            );
            public constructor(
              _style: Packages.arc.scene.ui.Touchpad.TouchpadStyle,
            );
          };
          private knobBounds: Packages.arc.math.geom.Circle;
          private touchBounds: Packages.arc.math.geom.Circle;
          private deadzoneBounds: Packages.arc.math.geom.Circle;
          private knobPosition: Packages.arc.math.geom.Vec2;
          private knobPercent: Packages.arc.math.geom.Vec2;
          touched: boolean;
          resetOnTouchUp: boolean;
          private style: Packages.arc.scene.ui.Touchpad.TouchpadStyle;
          private deadzoneRadius: number;
          public hit(
            _x: number,
            _y: number,
            _touchable: boolean,
          ): Packages.arc.scene.Element;
          public draw(): void;
          public isTouched(): boolean;
          public getStyle(): Packages.arc.scene.ui.Touchpad.TouchpadStyle;
          public setStyle(
            _style: Packages.arc.scene.ui.Touchpad.TouchpadStyle,
          ): void;
          public getPrefWidth(): number;
          public getPrefHeight(): number;
          public layout(): void;
          calculatePositionAndValue(
            _x: number,
            _y: number,
            _isTouchUp: boolean,
          ): void;
          public getResetOnTouchUp(): boolean;
          public setResetOnTouchUp(_reset: boolean): void;
          public setDeadzone(_deadzoneRadius: number): void;
          public getKnobX(): number;
          public getKnobY(): number;
          public getKnobPercentX(): number;
          public getKnobPercentY(): number;
          public constructor(_deadzoneRadius: number);
          public constructor(
            _deadzoneRadius: number,
            _style: Packages.arc.scene.ui.Touchpad.TouchpadStyle,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace utils {
        declare class Selection<T>
          extends java.lang.Object
          implements
            Packages.arc.scene.utils.Disableable,
            Packages.java.lang.Iterable<T>
        {
          selected: Packages.arc.struct.OrderedSet<T>;
          private old: Packages.arc.struct.OrderedSet<T>;
          multiple: boolean;
          required: boolean;
          lastSelected: T;
          private element: Packages.arc.scene.Element;
          private toggle: boolean;
          private programmaticChangeEvents: boolean;
          public add(_item: T): void;
          public remove(_item: T): void;
          public toString(): string;
          public clear(): void;
          public isEmpty(): boolean;
          public size(): number;
          public toArray(): Packages.arc.struct.Seq<T>;
          public toArray(
            _array: Packages.arc.struct.Seq<T>,
          ): Packages.arc.struct.Seq<T>;
          public iterator(): Packages.java.util.Iterator<T>;
          public contains(_item: T): boolean;
          public addAll(
            _items: Packages.arc.struct.Seq<T>,
          ): void;
          public first(): T | null;
          public set(_item: T): void;
          public removeAll(
            _items: Packages.arc.struct.Seq<T>,
          ): void;
          cleanup(): void;
          public setAll(
            _items: Packages.arc.struct.Seq<T>,
          ): void;
          snapshot(): void;
          protected changed(): void;
          public items(): Packages.arc.struct.OrderedSet<T>;
          public setActor(
            _element: Packages.arc.scene.Element,
          ): void;
          public isDisabled(): boolean;
          public fireChangeEvent(): boolean;
          public setProgrammaticChangeEvents(
            _programmaticChangeEvents: boolean,
          ): void;
          public setDisabled(_isDisabled: boolean): void;
          revert(): void;
          public choose(_item: T): void;
          public hasItems(): boolean;
          public getLastSelected(): T | null;
          public getToggle(): boolean;
          public setToggle(_toggle: boolean): void;
          public getMultiple(): boolean;
          public getRequired(): boolean;
          public setRequired(_required: boolean): void;
          public setMultiple(_multiple: boolean): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace ui {
        declare class TreeElement extends Packages.arc.scene
          .ui.layout.WidgetGroup {
          public static TreeStyle = class extends java.lang
            .Object {
            public plus: Packages.arc.scene.style.Drawable;
            public minus: Packages.arc.scene.style.Drawable;
            public over: Packages.arc.scene.style.Drawable;
            public selection: Packages.arc.scene.style.Drawable;
            public background: Packages.arc.scene.style.Drawable;
            public constructor();
            public constructor(
              _plus: Packages.arc.scene.style.Drawable,
              _minus: Packages.arc.scene.style.Drawable,
              _selection: Packages.arc.scene.style.Drawable,
            );
            public constructor(
              _style: Packages.arc.scene.ui.TreeElement.TreeStyle,
            );
          };
          public static TreeElementNode = class extends java
            .lang.Object {
            children: Packages.arc.struct.Seq<Packages.arc.scene.ui.TreeElement.TreeElementNode>;
            childProvider?: Packages.arc.func.Cons<
              Packages.arc.func.Cons<Packages.arc.scene.ui.TreeElement.TreeElementNode>
            >;
            element: Packages.arc.scene.Element;
            parent: Packages.arc.scene.ui.TreeElement.TreeElementNode;
            selectable: boolean;
            hoverable: boolean;
            expanded: boolean;
            icon: Packages.arc.scene.style.Drawable;
            height: number;
            object: any;
            public add(
              _node: Packages.arc.scene.ui.TreeElement.TreeElementNode,
            ): Packages.arc.scene.ui.TreeElement.TreeElementNode;
            public remove(): void;
            public remove(
              _node: Packages.arc.scene.ui.TreeElement.TreeElementNode,
            ): void;
            public insert(
              _index: number,
              _node: Packages.arc.scene.ui.TreeElement.TreeElementNode,
            ): void;
            public addAll(
              _nodes: Packages.arc.struct.Seq<Packages.arc.scene.ui.TreeElement.TreeElementNode>,
            ): Packages.arc.scene.ui.TreeElement.TreeElementNode;
            public getParent(): Packages.arc.scene.ui.TreeElement.TreeElementNode;
            public getObject(): any;
            public removeAll(): void;
            public getTree(): Packages.arc.scene.ui.TreeElement;
            public findNode(
              _object: any,
            ): Packages.arc.scene.ui.TreeElement.TreeElementNode;
            public getLevel(): number;
            public children(
              _provider: Packages.arc.func.Cons<
                Packages.arc.func.Cons<Packages.arc.scene.ui.TreeElement.TreeElementNode>
              >,
            ): Packages.arc.scene.ui.TreeElement.TreeElementNode;
            public getChildren(): Packages.arc.struct.Seq<Packages.arc.scene.ui.TreeElement.TreeElementNode>;
            public getHeight(): number;
            public hasChildren(): boolean;
            public updateChildren(): void;
            public isExpanded(): boolean;
            public getIcon(): Packages.arc.scene.style.Drawable;
            public setIcon(
              _icon: Packages.arc.scene.style.Drawable,
            ): void;
            public setSelectable(
              _selectable: boolean,
            ): void;
            public findExpandedObjects(
              _objects: Packages.arc.struct.Seq<any>,
            ): void;
            public setExpanded(_expanded: boolean): void;
            public collapseAll(): void;
            public expandAll(): void;
            protected addToTree(
              _tree: Packages.arc.scene.ui.TreeElement,
            ): void;
            protected removeFromTree(
              _tree: Packages.arc.scene.ui.TreeElement,
            ): void;
            public hoverable(
              _hover: boolean,
            ): Packages.arc.scene.ui.TreeElement.TreeElementNode;
            public isSelectable(): boolean;
            public expandTo(): void;
            public restoreExpandedObjects(
              _objects: Packages.arc.struct.Seq<any>,
            ): void;
            public setObject(_object: any): void;
            public constructor(
              _element: Packages.arc.scene.Element,
            );
          };
          rootNodes: Packages.arc.struct.Seq<Packages.arc.scene.ui.TreeElement.TreeElementNode>;
          selection: Packages.arc.scene.utils.Selection<Packages.arc.scene.ui.TreeElement.TreeElementNode>;
          style: Packages.arc.scene.ui.TreeElement.TreeStyle;
          ySpacing: number;
          iconSpacingLeft: number;
          iconSpacingRight: number;
          padding: number;
          indentSpacing: number;
          overNode: Packages.arc.scene.ui.TreeElement.TreeElementNode;
          rangeStart: Packages.arc.scene.ui.TreeElement.TreeElementNode;
          private leftColumnWidth: number;
          private prefWidth: number;
          private prefHeight: number;
          private sizeInvalid: boolean;
          private foundNode: Packages.arc.scene.ui.TreeElement.TreeElementNode;
          private clickListener: Packages.arc.scene.event.ClickListener;
          public add(
            _node: Packages.arc.scene.ui.TreeElement.TreeElementNode,
          ): void;
          public remove(
            _node: Packages.arc.scene.ui.TreeElement.TreeElementNode,
          ): void;
          public insert(
            _index: number,
            _node: Packages.arc.scene.ui.TreeElement.TreeElementNode,
          ): void;
          private initialize(): void;
          public findNode(
            _object: any,
          ): Packages.arc.scene.ui.TreeElement.TreeElementNode;
          static findNode(
            _nodes: Packages.arc.struct.Seq<Packages.arc.scene.ui.TreeElement.TreeElementNode>,
            _object: any,
          ): Packages.arc.scene.ui.TreeElement.TreeElementNode;
          public draw(): void;
          private draw(
            _nodes: Packages.arc.struct.Seq<Packages.arc.scene.ui.TreeElement.TreeElementNode>,
            _indent: number,
          ): void;
          public setPadding(_padding: number): void;
          public getStyle(): Packages.arc.scene.ui.TreeElement.TreeStyle;
          public invalidate(): void;
          protected drawBackground(): void;
          public setStyle(
            _style: Packages.arc.scene.ui.TreeElement.TreeStyle,
          ): void;
          private computeSize(
            _nodes: Packages.arc.struct.Seq<Packages.arc.scene.ui.TreeElement.TreeElementNode>,
            _indent: number,
          ): void;
          private computeSize(): void;
          public clearChildren(): void;
          public getPrefWidth(): number;
          public getPrefHeight(): number;
          public layout(): void;
          private layout(
            _nodes: Packages.arc.struct.Seq<Packages.arc.scene.ui.TreeElement.TreeElementNode>,
            _indent: number,
            _y: number,
          ): number;
          public getSelection(): Packages.arc.scene.utils.Selection<Packages.arc.scene.ui.TreeElement.TreeElementNode>;
          public getClickListener(): Packages.arc.scene.event.ClickListener;
          static findExpandedObjects(
            _nodes: Packages.arc.struct.Seq<Packages.arc.scene.ui.TreeElement.TreeElementNode>,
            _objects: Packages.arc.struct.Seq<any>,
          ): boolean;
          public findExpandedObjects(
            _objects: Packages.arc.struct.Seq<any>,
          ): void;
          static collapseAll(
            _nodes: Packages.arc.struct.Seq<Packages.arc.scene.ui.TreeElement.TreeElementNode>,
          ): void;
          public collapseAll(): void;
          public expandAll(): void;
          static expandAll(
            _nodes: Packages.arc.struct.Seq<Packages.arc.scene.ui.TreeElement.TreeElementNode>,
          ): void;
          public setOverNode(
            _overNode: Packages.arc.scene.ui.TreeElement.TreeElementNode,
          ): void;
          private getNodeAt(
            _nodes: Packages.arc.struct.Seq<Packages.arc.scene.ui.TreeElement.TreeElementNode>,
            _y: number,
            _rowY: number,
          ): number;
          public getNodeAt(
            _y: number,
          ): Packages.arc.scene.ui.TreeElement.TreeElementNode;
          selectNodes(
            _nodes: Packages.arc.struct.Seq<Packages.arc.scene.ui.TreeElement.TreeElementNode>,
            _low: number,
            _high: number,
          ): void;
          public getNodes(): Packages.arc.struct.Seq<Packages.arc.scene.ui.TreeElement.TreeElementNode>;
          public getRootNodes(): Packages.arc.struct.Seq<Packages.arc.scene.ui.TreeElement.TreeElementNode>;
          public getOverNode(): Packages.arc.scene.ui.TreeElement.TreeElementNode;
          public getOverObject(): any;
          public getIndentSpacing(): number;
          public getYSpacing(): number;
          public setYSpacing(_ySpacing: number): void;
          public setIconSpacing(
            _left: number,
            _right: number,
          ): void;
          public restoreExpandedObjects(
            _objects: Packages.arc.struct.Seq<any>,
          ): void;
          public constructor();
          public constructor(
            _style: Packages.arc.scene.ui.TreeElement.TreeStyle,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace utils {
        declare class Elem extends java.lang.Object {
          public static newField(
            _text: string,
            _listener: Packages.arc.func.Cons<string>,
          ): Packages.arc.scene.ui.TextField;
          public static newCheck(
            _text: string,
            _listener: Packages.arc.func.Boolc,
          ): Packages.arc.scene.ui.CheckBox;
          public static newButton(
            _text: string,
            _style: Packages.arc.scene.ui.TextButton.TextButtonStyle,
            _listener: Packages.java.lang.Runnable,
          ): Packages.arc.scene.ui.TextButton;
          public static newButton(
            _text: string,
            _listener: Packages.java.lang.Runnable,
          ): Packages.arc.scene.ui.TextButton;
          public static newImageButton(
            _icon: Packages.arc.scene.style.Drawable,
            _size: number,
            _color: Packages.arc.graphics.Color,
            _listener: Packages.java.lang.Runnable,
          ): Packages.arc.scene.ui.ImageButton;
          public static newImageButton(
            _style: Packages.arc.scene.ui.ImageButton.ImageButtonStyle,
            _icon: Packages.arc.scene.style.Drawable,
            _size: number,
            _listener: Packages.java.lang.Runnable,
          ): Packages.arc.scene.ui.ImageButton;
          public static newImageButton(
            _icon: Packages.arc.scene.style.Drawable,
            _size: number,
            _listener: Packages.java.lang.Runnable,
          ): Packages.arc.scene.ui.ImageButton;
          public static newImageButton(
            _icon: Packages.arc.scene.style.Drawable,
            _listener: Packages.java.lang.Runnable,
          ): Packages.arc.scene.ui.ImageButton;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace io {
        declare class ByteBufferInput
          extends java.lang.Object
          implements Packages.java.io.DataInput
        {
          public buffer: Packages.java.nio.ByteBuffer;
          public readLine(): string;
          public readInt(): number;
          public readUTF(): string;
          public readChar(): string;
          public readFloat(): number;
          public readFully(
            _bytes: string[],
            _f: number,
            _to: number,
          ): void;
          public readFully(_bytes: string[]): void;
          public skipBytes(_i: number): number;
          public readBoolean(): boolean;
          public readByte(): string;
          public readUnsignedByte(): number;
          public readShort(): Packages.short;
          public readUnsignedShort(): number;
          public readLong(): Packages.long;
          public readDouble(): number;
          public setBuffer(
            _buffer: Packages.java.nio.ByteBuffer,
          ): void;
          public constructor(
            _buffer: Packages.java.nio.ByteBuffer,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace io {
        declare class ByteBufferOutput
          extends java.lang.Object
          implements Packages.java.io.DataOutput
        {
          public buffer: Packages.java.nio.ByteBuffer;
          public write(_bytes: string[]): void;
          public write(
            _bytes: string[],
            _off: number,
            _len: number,
          ): void;
          public write(_i: number): void;
          public writeInt(_i: number): void;
          public writeUTF(_s: string): void;
          public writeBytes(_s: string): void;
          public writeChar(_i: number): void;
          public writeFloat(_v: number): void;
          public writeBoolean(_b: boolean): void;
          public writeByte(_i: number): void;
          public writeShort(_i: number): void;
          public writeLong(_l: Packages.long): void;
          public writeDouble(_v: number): void;
          public writeChars(_s: string): void;
          public constructor(
            _buffer: Packages.java.nio.ByteBuffer,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace io {
        declare class CRC extends java.lang.Object {
          public static table: number[];
          _value: number;
          public update(_data: string[]): void;
          public update(
            _data: string[],
            _offset: number,
            _size: number,
          ): void;
          public init(): void;
          public getDigest(): number;
          public updateByte(_b: number): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace io {
      declare class FilterInputStream extends Packages.java
        .io.InputStream {
        protected in: Packages.java.io.InputStream;
        public read(
          _arg0: string[],
          _arg1: number,
          _arg2: number,
        ): number;
        public read(_arg0: string[]): number;
        public read(): number;
        public close(): void;
        public mark(_arg0: number): void;
        public skip(_arg0: Packages.long): Packages.long;
        public available(): number;
        public markSupported(): boolean;
        public reset(): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace io {
        declare class CounterInputStream extends Packages
          .java.io.FilterInputStream {
          public count: number;
          public read(): number;
          public read(
            _bytes: string[],
            _offset: number,
            _length: number,
          ): number;
          public skip(_l: Packages.long): Packages.long;
          public resetCount(): void;
          public constructor(
            _inputStream: Packages.java.io.InputStream,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare namespace zip {
        declare class DeflaterOutputStream extends Packages
          .java.io.FilterOutputStream {
          protected def: Packages.java.util.zip.Deflater;
          protected buf: string[];
          private closed: boolean;
          private syncFlush: boolean;
          usesDefaultDeflater: boolean;
          public flush(): void;
          public write(_arg0: number): void;
          public write(
            _arg0: string[],
            _arg1: number,
            _arg2: number,
          ): void;
          public close(): void;
          public finish(): void;
          protected deflate(): void;
          public constructor(
            _arg0: Packages.java.io.OutputStream,
          );
          public constructor(
            _arg0: Packages.java.io.OutputStream,
            _arg1: boolean,
          );
          public constructor(
            _arg0: Packages.java.io.OutputStream,
            _arg1: Packages.java.util.zip.Deflater,
          );
          public constructor(
            _arg0: Packages.java.io.OutputStream,
            _arg1: Packages.java.util.zip.Deflater,
            _arg2: number,
            _arg3: boolean,
          );
          public constructor(
            _arg0: Packages.java.io.OutputStream,
            _arg1: Packages.java.util.zip.Deflater,
            _arg2: number,
          );
          public constructor(
            _arg0: Packages.java.io.OutputStream,
            _arg1: Packages.java.util.zip.Deflater,
            _arg2: boolean,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace io {
        declare class FastDeflaterOutputStream extends Packages
          .java.util.zip.DeflaterOutputStream {
          private tmp: string[];
          public write(_var1: number): void;
          public constructor(
            _outputStream: Packages.java.io.OutputStream,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace io {
        declare class LittleEndianInputStream
          extends Packages.java.io.FilterInputStream
          implements Packages.java.io.DataInput
        {
          private din: Packages.java.io.DataInputStream;
          public readLine(): string;
          public readInt(): number;
          public readUTF(): string;
          public readChar(): string;
          public readFloat(): number;
          public readFully(
            _b: string[],
            _off: number,
            _len: number,
          ): void;
          public readFully(_b: string[]): void;
          public skipBytes(_n: number): number;
          public readBoolean(): boolean;
          public readByte(): string;
          public readUnsignedByte(): number;
          public readShort(): Packages.short;
          public readUnsignedShort(): number;
          public readLong(): Packages.long;
          public readDouble(): number;
          public constructor(
            _in: Packages.java.io.InputStream,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace io {
        declare class PropertiesUtils extends java.lang
          .Object {
          private static NONE: number;
          private static SLASH: number;
          private static UNICODE: number;
          private static CONTINUE: number;
          private static KEY_DONE: number;
          private static IGNORE: number;
          private static LINE_SEPARATOR: string;
          public static load(
            _properties: Packages.arc.struct.ObjectMap<
              string,
              string
            >,
            _reader: Packages.java.io.Reader,
          ): void;
          public static store(
            _properties: Packages.arc.struct.ObjectMap<
              string,
              string
            >,
            _writer: Packages.java.io.Writer,
            _comment: string,
          ): void;
          public static store(
            _properties: Packages.arc.struct.ObjectMap<
              string,
              string
            >,
            _writer: Packages.java.io.Writer,
            _comment: string,
            _date: boolean,
          ): void;
          private static storeImpl(
            _properties: Packages.arc.struct.ObjectMap<
              string,
              string
            >,
            _writer: Packages.java.io.Writer,
            _comment: string,
            _date: boolean,
            _escapeUnicode: boolean,
          ): void;
          private static writeComment(
            _writer: Packages.java.io.Writer,
            _comment: string,
          ): void;
          private static dumpString(
            _outBuffer: Packages.java.lang.StringBuilder,
            _string: string,
            _escapeSpace: boolean,
            _escapeUnicode: boolean,
          ): void;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace io {
        declare class ReusableByteOutStream extends Packages
          .java.io.ByteArrayOutputStream {
          public getBytes(): string[] | null;
          public constructor(_capacity: number);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace io {
        declare class Streams extends java.lang.Object {
          public static OptimizedByteArrayOutputStream = class extends Packages
            .java.io.ByteArrayOutputStream {
            public toByteArray(): string[] | null;
            public getBuffer(): string[] | null;
            public constructor(_initialSize: number);
          };
          public static defaultBufferSize: number;
          public static emptyBytes: string[];
          public static close(
            _c: Packages.java.io.Closeable,
          ): void;
          public static copy(
            _input: Packages.java.io.InputStream,
            _output: Packages.java.nio.ByteBuffer,
            _bufferSize: number,
          ): void;
          public static copy(
            _input: Packages.java.io.InputStream,
            _output: Packages.java.io.OutputStream,
          ): void;
          public static copy(
            _input: Packages.java.io.InputStream,
            _output: Packages.java.nio.ByteBuffer,
            _buffer: string[],
          ): number;
          public static copy(
            _input: Packages.java.io.InputStream,
            _output: Packages.java.io.OutputStream,
            _buffer: string[],
          ): void;
          public static copy(
            _input: Packages.java.io.InputStream,
            _output: Packages.java.io.OutputStream,
            _bufferSize: number,
          ): void;
          public static copy(
            _input: Packages.java.io.InputStream,
            _output: Packages.java.nio.ByteBuffer,
          ): void;
          public static copyBytes(
            _input: Packages.java.io.InputStream,
          ): string[] | null;
          public static copyBytes(
            _input: Packages.java.io.InputStream,
            _estimatedSize: number,
          ): string[] | null;
          public static copyString(
            _input: Packages.java.io.InputStream,
          ): string;
          public static copyString(
            _input: Packages.java.io.InputStream,
            _estimatedSize: number,
            _charset: string,
          ): string;
          public static copyString(
            _input: Packages.java.io.InputStream,
            _estimatedSize: number,
          ): string;
          public static copyProgress(
            _input: Packages.java.io.InputStream,
            _output: Packages.java.io.OutputStream,
            _totalLength: Packages.long,
            _bufferSize: number,
            _progress: Packages.arc.func.Floatc,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace noise {
        declare class Noise extends java.lang.Object {
          private static seed: number;
          private static P: number;
          private static B: number;
          private static M: number;
          private static NP: number;
          private static N: number;
          private static p: number[];
          private static g2: number[][];
          private static g1: number[];
          private static points: number[][];
          private static init(): void;
          public static setSeed(_s: number): void;
          private static lerp(
            _t: number,
            _a: number,
            _b: number,
          ): number;
          private static G(_i: number): number[] | null;
          public static noise(
            _x: number,
            _y: number,
            _scale: number,
            _mag: number,
          ): number;
          public static noise(
            _x: number,
            _y: number,
            _scale: number,
            _mag: number,
            _xp: number,
          ): number;
          private static s_curve(_t: number): number;
          public static rawNoise(_x: number): number;
          public static rawNoise(
            _x: number,
            _y: number,
          ): number;
          static rawNoise(
            _x: number,
            _y: number,
            _z: number,
          ): number;
          public static snoise(
            _x: number,
            _y: number,
            _scale: number,
            _mag: number,
          ): number;
          public static snoise(
            _x: number,
            _y: number,
            _scale: number,
            _mag: number,
            _exp: number,
          ): number;
          private static normalize2(_v: number[]): void;
          public static snoise3(
            _x: number,
            _y: number,
            _z: number,
            _scale: number,
            _mag: number,
          ): number;
          public static nnoise(
            _x: number,
            _y: number,
            _scale: number,
            _mag: number,
          ): number;
          public static fnoise(
            _x: number,
            _y: number,
            _scale: number,
            _mag: number,
          ): number;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace noise {
        declare class Ridged extends java.lang.Object {
          static X_NOISE_GEN: number;
          static Y_NOISE_GEN: number;
          static Z_NOISE_GEN: number;
          static SEED_NOISE_GEN: number;
          static SHIFT_NOISE_GEN: number;
          static quality: number;
          static range(_n: number): number;
          static lerp(
            _n0: number,
            _n1: number,
            _a: number,
          ): number;
          public static noise2d(
            _seed: number,
            _x: number,
            _y: number,
            _frequency: number,
          ): number;
          public static noise2d(
            _seed: number,
            _x: number,
            _y: number,
            _octaves: number,
            _frequency: number,
          ): number;
          public static noise2d(
            _seed: number,
            _x: number,
            _y: number,
            _octaves: number,
            _persistence: number,
            _frequency: number,
          ): number;
          static scurve3(_a: number): number;
          static scurve5(_a: number): number;
          static gradientNoise(
            _fx: number,
            _fy: number,
            _ix: number,
            _iy: number,
            _seed: number,
          ): number;
          public static noise3d(
            _seed: number,
            _x: number,
            _y: number,
            _z: number,
            _frequency: number,
          ): number;
          public static noise3d(
            _seed: number,
            _x: number,
            _y: number,
            _z: number,
            _octaves: number,
            _frequency: number,
          ): number;
          static gradientNoise3D(
            _fx: number,
            _fy: number,
            _fz: number,
            _ix: number,
            _iy: number,
            _iz: number,
            _seed: number,
          ): number;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace noise {
        declare class Simplex extends java.lang.Object {
          static grad3: number[][];
          static grad4: number[][];
          static simplex: number[][];
          static dot(
            _g: number[],
            _x: number,
            _y: number,
            _z: number,
            _w: number,
          ): number;
          static dot(
            _g: number[],
            _x: number,
            _y: number,
          ): number;
          static dot(
            _g: number[],
            _x: number,
            _y: number,
            _z: number,
          ): number;
          static perm(_seed: number, _x: number): number;
          public static noise2d(
            _seed: number,
            _octaves: number,
            _persistence: number,
            _scale: number,
            _x: number,
            _y: number,
          ): number;
          public static raw2d(
            _seed: number,
            _x: number,
            _y: number,
          ): number;
          public static raw3d(
            _seed: number,
            _x: number,
            _y: number,
            _z: number,
          ): number;
          public static raw4d(
            _x: number,
            _y: number,
            _z: number,
            _w: number,
          ): number;
          static fastfloor(_x: number): number;
          public static noise4d(
            _octaves: number,
            _persistence: number,
            _scale: number,
            _x: number,
            _y: number,
            _z: number,
            _w: number,
          ): number;
          public static rawTiled(
            _x: number,
            _y: number,
            _x1: number,
            _y1: number,
            _w: number,
            _h: number,
            _scl: number,
          ): number;
          public static noise3d(
            _seed: number,
            _octaves: number,
            _persistence: number,
            _scale: number,
            _x: number,
            _y: number,
            _z: number,
          ): number;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace noise {
        declare class VectorTable extends java.lang.Object {
          static randomVectors: number[];
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace noise {
        declare class VoronoiNoise extends java.lang
          .Object {
          private static SQRT_2: number;
          private static SQRT_3: number;
          private useDistance: boolean;
          private seed: Packages.long;
          private useManhattan: boolean;
          private rnd: Packages.arc.math.Rand;
          public setSeed(_seed: Packages.long): void;
          public getSeed(): Packages.long;
          public noise(
            _x: number,
            _z: number,
            _frequency: number,
          ): number;
          public noise(
            _x: number,
            _y: number,
            _z: number,
            _frequency: number,
          ): number;
          public static valueNoise2D(
            _x: number,
            _z: number,
            _seed: Packages.long,
          ): number;
          private getDistance(
            _xDist: number,
            _zDist: number,
          ): number;
          private getDistance(
            _xDist: number,
            _yDist: number,
            _zDist: number,
          ): number;
          public static valueNoise3D(
            _x: number,
            _y: number,
            _z: number,
            _seed: Packages.long,
          ): number;
          public isUseDistance(): boolean;
          public setUseDistance(
            _useDistance: boolean,
          ): void;
          public constructor(
            _seed: Packages.long,
            _useManhattan: boolean,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace pooling {
        declare class Pools extends java.lang.Object {
          private static typePools: Packages.arc.struct.ObjectMap<
            Packages.java.lang.Class<any>,
            Packages.arc.util.pooling.Pool<any>
          >;
          public static get<T>(
            _type: Class<T> | Packages.java.lang.Class<T>,
            _supplier: Packages.arc.func.Prov<T>,
            _max: number,
          ): Packages.arc.util.pooling.Pool<T>;
          public static get<T>(
            _type: Class<T> | Packages.java.lang.Class<T>,
            _supplier: Packages.arc.func.Prov<T>,
          ): Packages.arc.util.pooling.Pool<T>;
          public static set<T>(
            _type: Class<T> | Packages.java.lang.Class<T>,
            _pool: Packages.arc.util.pooling.Pool<T>,
          ): void;
          public static free(_object: any): void;
          public static obtain<T>(
            _type: Class<T> | Packages.java.lang.Class<T>,
            _supplier: Packages.arc.func.Prov<T>,
          ): T | null;
          public static freeAll(
            _objects: Packages.arc.struct.Seq<any>,
            _samePool: boolean,
          ): void;
          public static freeAll(
            _objects: Packages.arc.struct.Seq<any>,
          ): void;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace serialization {
        declare class Base64Coder extends java.lang.Object {
          public static CharMap = class extends java.lang
            .Object {
            protected encodingMap: string[];
            protected decodingMap: string[];
            public getDecodingMap(): string[] | null;
            public getEncodingMap(): string[] | null;
            public constructor(
              _char63: string,
              _char64: string,
            );
          };
          public static regularMap: Packages.arc.util.serialization.Base64Coder.CharMap;
          public static urlsafeMap: Packages.arc.util.serialization.Base64Coder.CharMap;
          private static systemLineSeparator: string;
          public static decode(_s: string): string[] | null;
          public static decode(
            _in: string[],
          ): string[] | null;
          public static decode(
            _in: string[],
            _iOff: number,
            _iLen: number,
            _inverseCharMap: Packages.arc.util.serialization.Base64Coder.CharMap,
          ): string[] | null;
          public static decode(
            _in: string[],
            _iOff: number,
            _iLen: number,
            _inverseCharMap: string[],
          ): string[] | null;
          public static decode(
            _in: string[],
            _inverseCharMap: Packages.arc.util.serialization.Base64Coder.CharMap,
          ): string[] | null;
          public static decode(
            _in: string[],
            _inverseCharMap: string[],
          ): string[] | null;
          public static decode(
            _s: string,
            _inverseCharMap: Packages.arc.util.serialization.Base64Coder.CharMap,
          ): string[] | null;
          public static encode(
            _in: string[],
            _iOff: number,
            _iLen: number,
            _charMap: string[],
          ): string[] | null;
          public static encode(
            _in: string[],
            _iOff: number,
            _iLen: number,
            _charMap: Packages.arc.util.serialization.Base64Coder.CharMap,
          ): string[] | null;
          public static encode(
            _in: string[],
          ): string[] | null;
          public static encode(
            _in: string[],
            _charMap: Packages.arc.util.serialization.Base64Coder.CharMap,
          ): string[] | null;
          public static encode(
            _in: string[],
            _charMap: string[],
          ): string[] | null;
          public static encode(
            _in: string[],
            _iLen: number,
          ): string[] | null;
          public static encodeString(
            _s: string,
            _useUrlsafeEncoding: boolean,
          ): string;
          public static encodeString(_s: string): string;
          public static encodeLines(_in: string[]): string;
          public static encodeLines(
            _in: string[],
            _iOff: number,
            _iLen: number,
            _lineLen: number,
            _lineSeparator: string,
            _charMap: Packages.arc.util.serialization.Base64Coder.CharMap,
          ): string;
          public static encodeLines(
            _in: string[],
            _iOff: number,
            _iLen: number,
            _lineLen: number,
            _lineSeparator: string,
            _charMap: string[],
          ): string;
          public static decodeString(_s: string): string;
          public static decodeString(
            _s: string,
            _useUrlSafeEncoding: boolean,
          ): string;
          public static decodeLines(
            _s: string,
            _inverseCharMap: string[],
          ): string[] | null;
          public static decodeLines(
            _s: string,
          ): string[] | null;
          public static decodeLines(
            _s: string,
            _inverseCharMap: Packages.arc.util.serialization.Base64Coder.CharMap,
          ): string[] | null;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace serialization {
        declare class JsonReader
          extends java.lang.Object
          implements
            Packages.arc.util.serialization.BaseJsonReader
        {
          static json_start: number;
          static json_first_final: number;
          static json_error: number;
          static json_en_object: number;
          static json_en_array: number;
          static json_en_main: number;
          private static _json_actions: string[];
          private static _json_key_offsets: Packages.short[];
          private static _json_trans_keys: string[];
          private static _json_single_lengths: string[];
          private static _json_range_lengths: string[];
          private static _json_index_offsets: Packages.short[];
          private static _json_indicies: string[];
          private static _json_trans_targs: string[];
          private static _json_trans_actions: string[];
          private static _json_eof_actions: string[];
          private elements: Packages.arc.struct.Seq<Packages.arc.util.serialization.JsonValue>;
          private lastChild: Packages.arc.struct.Seq<Packages.arc.util.serialization.JsonValue>;
          private root: Packages.arc.util.serialization.JsonValue;
          private current: Packages.arc.util.serialization.JsonValue;
          public parse(
            _json: string,
          ): Packages.arc.util.serialization.JsonValue;
          public parse(
            _reader: Packages.java.io.Reader,
          ): Packages.arc.util.serialization.JsonValue;
          public parse(
            _input: Packages.java.io.InputStream,
          ): Packages.arc.util.serialization.JsonValue;
          public parse(
            _data: string[],
            _offset: number,
            _length: number,
          ): Packages.arc.util.serialization.JsonValue;
          public parse(
            _file: Packages.arc.files.Fi,
          ): Packages.arc.util.serialization.JsonValue;
          protected number(
            _name: string,
            _value: number,
            _stringValue: string,
          ): void;
          protected number(
            _name: string,
            _value: Packages.long,
            _stringValue: string,
          ): void;
          protected string(
            _name: string,
            _value: string,
          ): void;
          protected pop(): void;
          private unescape(_value: string): string;
          protected bool(
            _name: string,
            _value: boolean,
          ): void;
          private addChild(
            _name: string,
            _child: Packages.arc.util.serialization.JsonValue,
          ): void;
          protected startObject(_name: string): void;
          protected startArray(_name: string): void;
          private static init__json_actions_0():
            | string[]
            | null;
          private static init__json_key_offsets_0():
            | Packages.short[]
            | null;
          private static init__json_trans_keys_0():
            | string[]
            | null;
          private static init__json_single_lengths_0():
            | string[]
            | null;
          private static init__json_range_lengths_0():
            | string[]
            | null;
          private static init__json_index_offsets_0():
            | Packages.short[]
            | null;
          private static init__json_indicies_0():
            | string[]
            | null;
          private static init__json_trans_targs_0():
            | string[]
            | null;
          private static init__json_trans_actions_0():
            | string[]
            | null;
          private static init__json_eof_actions_0():
            | string[]
            | null;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace serialization {
        declare class JsonWriter
          extends Packages.java.io.Writer
          implements
            Packages.arc.util.serialization.BaseJsonWriter
        {
          public static OutputType = class extends Packages
            .java.lang
            .Enum<Packages.arc.util.serialization.JsonWriter.OutputType> {
            public static json: Packages.arc.util.serialization.JsonWriter.OutputType;
            public static javascript: Packages.arc.util.serialization.JsonWriter.OutputType;
            public static minimal: Packages.arc.util.serialization.JsonWriter.OutputType;
            private static javascriptPattern: Packages.java.util.regex.Pattern;
            private static minimalNamePattern: Packages.java.util.regex.Pattern;
            private static minimalValuePattern: Packages.java.util.regex.Pattern;
            private static $VALUES: Packages.arc.util.serialization.JsonWriter.OutputType[];
            public static values():
              | Packages.arc.util.serialization.JsonWriter.OutputType[]
              | null;
            public static valueOf(
              _name: string,
            ): Packages.arc.util.serialization.JsonWriter.OutputType;
            public quoteName(_value: string): string;
            public quoteValue(_value: any): string;
          };
          private JsonObject = class extends java.lang
            .Object {
            array: boolean;
            needsComma: boolean;
            this$0: Packages.arc.util.serialization.JsonWriter;
            close(): void;
          };
          writer: Packages.java.io.Writer;
          private stack: Packages.arc.struct.Seq<Packages.arc.util.serialization.JsonWriter.JsonObject>;
          private current: Packages.arc.util.serialization.JsonWriter.JsonObject;
          private named: boolean;
          private outputType: Packages.arc.util.serialization.JsonWriter.OutputType;
          private quoteLongValues: boolean;
          public name(
            _name: string,
          ): Packages.arc.util.serialization.BaseJsonWriter;
          public value(
            _value: any,
          ): Packages.arc.util.serialization.BaseJsonWriter;
          public flush(): void;
          public array(): Packages.arc.util.serialization.BaseJsonWriter;
          public array(
            _name: string,
          ): Packages.arc.util.serialization.BaseJsonWriter;
          public set(
            _name: string,
            _value: any,
          ): Packages.arc.util.serialization.BaseJsonWriter;
          public write(
            _cbuf: string[],
            _off: number,
            _len: number,
          ): void;
          public close(): void;
          public object(
            _name: string,
          ): Packages.arc.util.serialization.BaseJsonWriter;
          public object(): Packages.arc.util.serialization.BaseJsonWriter;
          public pop(): Packages.arc.util.serialization.BaseJsonWriter;
          public setOutputType(
            _outputType: Packages.arc.util.serialization.JsonWriter.OutputType,
          ): void;
          public setQuoteLongValues(
            _quoteLongValues: boolean,
          ): void;
          private requireCommaOrName(): void;
          public getWriter(): Packages.java.io.Writer;
          public constructor(
            _writer: Packages.java.io.Writer,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare abstract class Number {}
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace serialization {
        declare class Jval extends java.lang.Object {
          public static Jtype = class extends Packages.java
            .lang
            .Enum<Packages.arc.util.serialization.Jval.Jtype> {
            public static string: Packages.arc.util.serialization.Jval.Jtype;
            public static number: Packages.arc.util.serialization.Jval.Jtype;
            public static object: Packages.arc.util.serialization.Jval.Jtype;
            public static array: Packages.arc.util.serialization.Jval.Jtype;
            public static bool: Packages.arc.util.serialization.Jval.Jtype;
            public static nil: Packages.arc.util.serialization.Jval.Jtype;
            private static $VALUES: Packages.arc.util.serialization.Jval.Jtype[];
            public static values():
              | Packages.arc.util.serialization.Jval.Jtype[]
              | null;
            public static valueOf(
              _name: string,
            ): Packages.arc.util.serialization.Jval.Jtype;
          };
          public static JsonMap = class extends Packages.arc
            .struct.ArrayMap<
            string,
            Packages.arc.util.serialization.Jval
          > {
            public constructor();
          };
          public static JsonArray = class extends Packages
            .arc.struct
            .Seq<Packages.arc.util.serialization.Jval> {
            public constructor();
          };
          static Hparser = class extends java.lang.Object {
            private buffer: string;
            private reader: Packages.java.io.Reader;
            private index: number;
            private line: number;
            private lineOffset: number;
            private current: number;
            private captureBuffer: Packages.java.lang.StringBuilder;
            private peek: Packages.java.lang.StringBuilder;
            private capture: boolean;
            private isArray: boolean;
            private static isDigit(_ch: string): boolean;
            private readObject(
              _objectWithoutBraces: boolean,
            ): Packages.arc.util.serialization.Jval;
            private read(): boolean;
            private expected(
              _expected: string,
            ): Packages.arc.util.serialization.Jval.JsonParseException;
            reset(): void;
            private peek(): number;
            private peek(_idx: number): number;
            parse(): Packages.arc.util.serialization.Jval;
            private error(
              _message: string,
            ): Packages.arc.util.serialization.Jval.JsonParseException;
            private isHexDigit(): boolean;
            private readString(): Packages.arc.util.serialization.Jval;
            private skipWhiteSpace(): void;
            private readValue(): Packages.arc.util.serialization.Jval;
            static readToEnd(
              _reader: Packages.java.io.Reader,
            ): string;
            checkTrailing(
              _v: Packages.arc.util.serialization.Jval,
            ): Packages.arc.util.serialization.Jval;
            private isEndOfText(): boolean;
            private readTfnns(): Packages.arc.util.serialization.Jval;
            static tryParseNumber(
              _value: Packages.java.lang.StringBuilder,
              _stopAtNext: boolean,
            ): Packages.arc.util.serialization.Jval;
            static tryParseNumber(
              _value: string,
            ): Packages.arc.util.serialization.Jval;
            private readIf(_ch: string): boolean;
            private readName(): string;
            private readStringInternal(
              _allowML: boolean,
            ): string;
            private isWhiteSpace(): boolean;
            static isWhiteSpace(_ch: number): boolean;
            private skipIndent(_indent: number): void;
            private startCapture(): void;
            private readEscape(): void;
            private endCapture(): string;
            private readMlString(): string;
            private pauseCapture(): void;
            private readArray(): Packages.arc.util.serialization.Jval;
          };
          public static Jformat = class extends Packages
            .java.lang
            .Enum<Packages.arc.util.serialization.Jval.Jformat> {
            public static plain: Packages.arc.util.serialization.Jval.Jformat;
            public static formatted: Packages.arc.util.serialization.Jval.Jformat;
            public static hjson: Packages.arc.util.serialization.Jval.Jformat;
            private static $VALUES: Packages.arc.util.serialization.Jval.Jformat[];
            public static values():
              | Packages.arc.util.serialization.Jval.Jformat[]
              | null;
            public static valueOf(
              _name: string,
            ): Packages.arc.util.serialization.Jval.Jformat;
          };
          static WritingBuffer = class extends Packages.java
            .io.Writer {
            private writer: Packages.java.io.Writer;
            private buffer: string[];
            private fill: number;
            public flush(): void;
            public write(
              _str: string,
              _off: number,
              _len: number,
            ): void;
            public write(
              _cbuf: string[],
              _off: number,
              _len: number,
            ): void;
            public write(_c: number): void;
            public close(): void;
          };
          static Jwriter = class extends java.lang.Object {
            format: boolean;
            nl(
              _tw: Packages.java.io.Writer,
              _level: number,
            ): void;
            public save(
              _value: Packages.arc.util.serialization.Jval,
              _tw: Packages.java.io.Writer,
              _level: number,
            ): void;
            static escapeString(_src: string): string;
            private static getEscapedChar(
              _c: string,
            ): string;
            private static doEscapeString(
              _sb: Packages.java.lang.StringBuilder,
              _src: string,
              _cur: number,
            ): string;
            public constructor(_format: boolean);
          };
          static Hwriter = class extends java.lang.Object {
            static needsEscapeName: Packages.java.util.regex.Pattern;
            nl(
              _tw: Packages.java.io.Writer,
              _level: number,
            ): void;
            public save(
              _value: Packages.arc.util.serialization.Jval,
              _tw: Packages.java.io.Writer,
              _level: number,
              _separator: string,
              _noIndent: boolean,
            ): void;
            writeString(
              _value: string,
              _tw: Packages.java.io.Writer,
              _level: number,
              _separator: string,
            ): void;
            static isPunctuatorChar(_c: number): boolean;
            static escapeName(_name: string): string;
            static needsQuotes(_c: string): boolean;
            static startsWithKeyword(
              _text: string,
            ): boolean;
            static needsEscape(_c: string): boolean;
            static needsEscapeML(_c: string): boolean;
            writeMLString(
              _value: string,
              _tw: Packages.java.io.Writer,
              _level: number,
              _separator: string,
            ): void;
          };
          public static JsonParseException = class extends Packages
            .java.lang.RuntimeException {
            public offset: number;
            public line: number;
            public column: number;
          };
          public static TRUE: Packages.arc.util.serialization.Jval;
          public static FALSE: Packages.arc.util.serialization.Jval;
          public static NULL: Packages.arc.util.serialization.Jval;
          private value?: any;
          public add(
            _value: boolean,
          ): Packages.arc.util.serialization.Jval;
          public add(
            _value: Packages.java.lang.Number,
          ): Packages.arc.util.serialization.Jval;
          public add(
            _value: string,
          ): Packages.arc.util.serialization.Jval;
          public add(_name: string, _val: string): void;
          public add(
            _name: string,
            _val: Packages.arc.util.serialization.Jval,
          ): void;
          public add(
            _value: Packages.arc.util.serialization.Jval,
          ): Packages.arc.util.serialization.Jval;
          public remove(
            _name: string,
          ): Packages.arc.util.serialization.Jval;
          public get(
            _name: string,
          ): Packages.arc.util.serialization.Jval;
          public put(
            _name: string,
            _val: boolean,
          ): Packages.arc.util.serialization.Jval;
          public put(
            _name: string,
            _val: Packages.java.lang.Number,
          ): Packages.arc.util.serialization.Jval;
          public put(
            _name: string,
            _val: string,
          ): Packages.arc.util.serialization.Jval;
          public put(
            _name: string,
            _val: Packages.arc.util.serialization.Jval,
          ): Packages.arc.util.serialization.Jval;
          public equals(_object: any): boolean;
          public toString(): string;
          public toString(
            _format: Packages.arc.util.serialization.Jval.Jformat,
          ): string;
          public isArray(): boolean;
          public static newArray(): Packages.arc.util.serialization.Jval;
          public getInt(
            _name: string,
            _defaultValue: number,
          ): number;
          public getLong(
            _name: string,
            _defaultValue: Packages.long,
          ): Packages.long;
          public getFloat(
            _name: string,
            _defaultValue: number,
          ): number;
          public getDouble(
            _name: string,
            _defaultValue: number,
          ): number;
          public static valueOf(
            _value: number,
          ): Packages.arc.util.serialization.Jval;
          public static valueOf(
            _value: Packages.long,
          ): Packages.arc.util.serialization.Jval;
          public static valueOf(
            _value: number,
          ): Packages.arc.util.serialization.Jval;
          public static valueOf(
            _string: string,
          ): Packages.arc.util.serialization.Jval;
          public static valueOf(
            _value: boolean,
          ): Packages.arc.util.serialization.Jval;
          public static valueOf(
            _value: number,
          ): Packages.arc.util.serialization.Jval;
          public static read(
            _text: string,
          ): Packages.arc.util.serialization.Jval;
          public static read(
            _reader: Packages.java.io.Reader,
          ): Packages.arc.util.serialization.Jval;
          public static read(
            _bytes: string[],
          ): Packages.arc.util.serialization.Jval;
          public getType(): Packages.arc.util.serialization.Jval.Jtype;
          public isNull(): boolean;
          public writeTo(
            _writer: Packages.java.io.Writer,
          ): void;
          public writeTo(
            _writer: Packages.java.io.Writer,
            _format: Packages.arc.util.serialization.Jval.Jformat,
          ): void;
          public asInt(): number;
          public getString(_name: string): string | null;
          public getString(
            _name: string,
            _defaultValue: string,
          ): string;
          public has(_name: string): boolean;
          public asArray(): Packages.arc.util.serialization.Jval.JsonArray;
          public getBool(
            _name: string,
            _defaultValue: boolean,
          ): boolean;
          public isObject(): boolean;
          public asFloat(): number;
          public isNumber(): boolean;
          public asLong(): Packages.long;
          public asDouble(): number;
          public asString(): string;
          public isBoolean(): boolean;
          public isString(): boolean;
          public static newObject(): Packages.arc.util.serialization.Jval;
          public asNumber(): Packages.java.lang.Number;
          public asObject(): Packages.arc.util.serialization.Jval.JsonMap;
          public asBool(): boolean;
          public isTrue(): boolean;
          public isFalse(): boolean;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace serialization {
        declare class SerializationException extends Packages
          .java.lang.RuntimeException {
          private trace: Packages.java.lang.StringBuilder;
          public getMessage(): string;
          public addTrace(_info: string): void;
          private causedBy(
            _ex: Packages.java.lang.Throwable,
            _type:
              | Class<any>
              | Packages.java.lang.Class<any>,
          ): boolean;
          public causedBy(
            _type: Class | Packages.java.lang.Class<any>,
          ): boolean;
          public constructor(
            _cause: Packages.java.lang.Throwable,
          );
          public constructor(_message: string);
          public constructor(
            _message: string,
            _cause: Packages.java.lang.Throwable,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace serialization {
        declare class UBJsonWriter
          extends java.lang.Object
          implements
            Packages.java.io.Closeable,
            Packages.arc.util.serialization.BaseJsonWriter
        {
          private JsonObject = class extends java.lang
            .Object {
            array: boolean;
            this$0: Packages.arc.util.serialization.UBJsonWriter;
            close(): void;
          };
          out: Packages.java.io.DataOutputStream;
          private stack: Packages.arc.struct.Seq<Packages.arc.util.serialization.UBJsonWriter.JsonObject>;
          private current: Packages.arc.util.serialization.UBJsonWriter.JsonObject;
          private named: boolean;
          public name(
            _name: string,
          ): Packages.arc.util.serialization.BaseJsonWriter;
          public name(
            _name: string,
          ): Packages.arc.util.serialization.UBJsonWriter;
          public value(
            _values: number[],
          ): Packages.arc.util.serialization.UBJsonWriter;
          public value(
            _values: Packages.long[],
          ): Packages.arc.util.serialization.UBJsonWriter;
          public value(
            _values: number[],
          ): Packages.arc.util.serialization.UBJsonWriter;
          public value(
            _values: Packages.short[],
          ): Packages.arc.util.serialization.UBJsonWriter;
          public value(
            _values: string[],
          ): Packages.arc.util.serialization.UBJsonWriter;
          public value(
            _value: string,
          ): Packages.arc.util.serialization.UBJsonWriter;
          public value(): Packages.arc.util.serialization.UBJsonWriter;
          public value(
            _object: any,
          ): Packages.arc.util.serialization.UBJsonWriter;
          public value(
            _value: Packages.arc.util.serialization.JsonValue,
          ): Packages.arc.util.serialization.UBJsonWriter;
          public value(
            _values: string[],
          ): Packages.arc.util.serialization.UBJsonWriter;
          public value(
            _values: string[],
          ): Packages.arc.util.serialization.UBJsonWriter;
          public value(
            _values: number[],
          ): Packages.arc.util.serialization.UBJsonWriter;
          public value(
            _value: number,
          ): Packages.arc.util.serialization.UBJsonWriter;
          public value(
            _value: Packages.short,
          ): Packages.arc.util.serialization.UBJsonWriter;
          public value(
            _value: string,
          ): Packages.arc.util.serialization.UBJsonWriter;
          public value(
            _object: any,
          ): Packages.arc.util.serialization.BaseJsonWriter;
          public value(
            _values: boolean[],
          ): Packages.arc.util.serialization.UBJsonWriter;
          public value(
            _value: string,
          ): Packages.arc.util.serialization.UBJsonWriter;
          public value(
            _value: boolean,
          ): Packages.arc.util.serialization.UBJsonWriter;
          public value(
            _value: number,
          ): Packages.arc.util.serialization.UBJsonWriter;
          public value(
            _value: Packages.long,
          ): Packages.arc.util.serialization.UBJsonWriter;
          public value(
            _value: number,
          ): Packages.arc.util.serialization.UBJsonWriter;
          public flush(): void;
          private checkName(): void;
          public array(
            _name: string,
          ): Packages.arc.util.serialization.BaseJsonWriter;
          public array(): Packages.arc.util.serialization.UBJsonWriter;
          public array(
            _name: string,
          ): Packages.arc.util.serialization.UBJsonWriter;
          public array(): Packages.arc.util.serialization.BaseJsonWriter;
          public set(
            _name: string,
            _value: Packages.long[],
          ): Packages.arc.util.serialization.UBJsonWriter;
          public set(
            _name: string,
            _value: number[],
          ): Packages.arc.util.serialization.UBJsonWriter;
          public set(
            _name: string,
            _value: number[],
          ): Packages.arc.util.serialization.UBJsonWriter;
          public set(
            _name: string,
            _value: number[],
          ): Packages.arc.util.serialization.UBJsonWriter;
          public set(
            _name: string,
            _value: Packages.short[],
          ): Packages.arc.util.serialization.UBJsonWriter;
          public set(
            _name: string,
            _value: any,
          ): Packages.arc.util.serialization.BaseJsonWriter;
          public set(
            _name: string,
          ): Packages.arc.util.serialization.UBJsonWriter;
          public set(
            _name: string,
            _value: string[],
          ): Packages.arc.util.serialization.UBJsonWriter;
          public set(
            _name: string,
            _value: string[],
          ): Packages.arc.util.serialization.UBJsonWriter;
          public set(
            _name: string,
            _value: boolean[],
          ): Packages.arc.util.serialization.UBJsonWriter;
          public set(
            _name: string,
            _value: number,
          ): Packages.arc.util.serialization.UBJsonWriter;
          public set(
            _name: string,
            _value: Packages.long,
          ): Packages.arc.util.serialization.UBJsonWriter;
          public set(
            _name: string,
            _value: string,
          ): Packages.arc.util.serialization.UBJsonWriter;
          public set(
            _name: string,
            _value: Packages.short,
          ): Packages.arc.util.serialization.UBJsonWriter;
          public set(
            _name: string,
            _value: number,
          ): Packages.arc.util.serialization.UBJsonWriter;
          public set(
            _name: string,
            _value: any,
          ): Packages.arc.util.serialization.UBJsonWriter;
          public set(
            _name: string,
            _value: string[],
          ): Packages.arc.util.serialization.UBJsonWriter;
          public set(
            _name: string,
            _value: string,
          ): Packages.arc.util.serialization.UBJsonWriter;
          public set(
            _name: string,
            _value: string,
          ): Packages.arc.util.serialization.UBJsonWriter;
          public set(
            _name: string,
            _value: boolean,
          ): Packages.arc.util.serialization.UBJsonWriter;
          public set(
            _name: string,
            _value: number,
          ): Packages.arc.util.serialization.UBJsonWriter;
          public close(): void;
          public reset(): void;
          public object(): Packages.arc.util.serialization.BaseJsonWriter;
          public object(): Packages.arc.util.serialization.UBJsonWriter;
          public object(
            _name: string,
          ): Packages.arc.util.serialization.BaseJsonWriter;
          public object(
            _name: string,
          ): Packages.arc.util.serialization.UBJsonWriter;
          public pop(): Packages.arc.util.serialization.UBJsonWriter;
          protected pop(
            _silent: boolean,
          ): Packages.arc.util.serialization.UBJsonWriter;
          public pop(): Packages.arc.util.serialization.BaseJsonWriter;
          public setOutputType(
            _outputType: Packages.arc.util.serialization.JsonWriter.OutputType,
          ): void;
          public setQuoteLongValues(
            _quoteLongValues: boolean,
          ): void;
          public constructor(
            _out: Packages.java.io.OutputStream,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace viewport {
        declare class ExtendViewport extends Packages.arc
          .util.viewport.Viewport {
          private minWorldWidth: number;
          private minWorldHeight: number;
          private maxWorldWidth: number;
          private maxWorldHeight: number;
          public update(
            _screenWidth: number,
            _screenHeight: number,
            _centerCamera: boolean,
          ): void;
          public getMinWorldWidth(): number;
          public setMinWorldWidth(
            _minWorldWidth: number,
          ): void;
          public getMinWorldHeight(): number;
          public setMinWorldHeight(
            _minWorldHeight: number,
          ): void;
          public getMaxWorldWidth(): number;
          public setMaxWorldWidth(
            _maxWorldWidth: number,
          ): void;
          public getMaxWorldHeight(): number;
          public setMaxWorldHeight(
            _maxWorldHeight: number,
          ): void;
          public constructor(
            _minWorldWidth: number,
            _minWorldHeight: number,
            _maxWorldWidth: number,
            _maxWorldHeight: number,
            _camera: Packages.arc.graphics.Camera,
          );
          public constructor(
            _minWorldWidth: number,
            _minWorldHeight: number,
            _maxWorldWidth: number,
            _maxWorldHeight: number,
          );
          public constructor(
            _minWorldWidth: number,
            _minWorldHeight: number,
            _camera: Packages.arc.graphics.Camera,
          );
          public constructor(
            _minWorldWidth: number,
            _minWorldHeight: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace viewport {
        declare class ScalingViewport extends Packages.arc
          .util.viewport.Viewport {
          private scaling: Packages.arc.util.Scaling;
          public update(
            _screenWidth: number,
            _screenHeight: number,
            _centerCamera: boolean,
          ): void;
          public setScaling(
            _scaling: Packages.arc.util.Scaling,
          ): void;
          public getScaling(): Packages.arc.util.Scaling;
          public constructor(
            _scaling: Packages.arc.util.Scaling,
            _worldWidth: number,
            _worldHeight: number,
          );
          public constructor(
            _scaling: Packages.arc.util.Scaling,
            _worldWidth: number,
            _worldHeight: number,
            _camera: Packages.arc.graphics.Camera,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace viewport {
        declare class FillViewport extends Packages.arc.util
          .viewport.ScalingViewport {
          public constructor(
            _worldWidth: number,
            _worldHeight: number,
          );
          public constructor(
            _worldWidth: number,
            _worldHeight: number,
            _camera: Packages.arc.graphics.Camera,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace viewport {
        declare class FitViewport extends Packages.arc.util
          .viewport.ScalingViewport {
          public constructor(
            _worldWidth: number,
            _worldHeight: number,
          );
          public constructor(
            _worldWidth: number,
            _worldHeight: number,
            _camera: Packages.arc.graphics.Camera,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace viewport {
        declare class ScreenViewport extends Packages.arc
          .util.viewport.Viewport {
          private unitsPerPixel: number;
          public update(
            _screenWidth: number,
            _screenHeight: number,
            _centerCamera: boolean,
          ): void;
          public getUnitsPerPixel(): number;
          public setUnitsPerPixel(
            _unitsPerPixel: number,
          ): void;
          public constructor();
          public constructor(
            _camera: Packages.arc.graphics.Camera,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace util {
      declare namespace viewport {
        declare class StretchViewport extends Packages.arc
          .util.viewport.ScalingViewport {
          public constructor(
            _worldWidth: number,
            _worldHeight: number,
          );
          public constructor(
            _worldWidth: number,
            _worldHeight: number,
            _camera: Packages.arc.graphics.Camera,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace arc {
    declare namespace scene {
      declare namespace ui {
        declare namespace layout {
          declare class Scl extends java.lang.Object {
            private static addition: number;
            private static product: number;
            private static debugScale: number;
            public static scl(): number;
            public static scl(_amount: number): number;
            public static setProduct(
              _product: number,
            ): void;
            public static setAddition(
              _addition: number,
            ): void;
            public constructor();
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare abstract class Publishable {
        public getSteamID(): string | null;
        public addSteamID(_id: string): void;
        public removeSteamID(): void;
        public steamTitle(): string;
        public steamDescription(): string | null;
        public steamTag(): string;
        public createSteamFolder(
          _id: string,
        ): Packages.arc.files.Fi;
        public createSteamPreview(
          _id: string,
        ): Packages.arc.files.Fi;
        public extraTags(): Packages.arc.struct.Seq<string>;
        public hasSteamID(): boolean;
        public prePublish(): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Entityc {
        public add(): void;
        public remove(): void;
        public update(): void;
        public id(_id: number): void;
        public id(): number;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public as<T>(): T | null;
        public self<
          T extends Packages.mindustry.gen.Entityc,
        >(): T | null;
        public afterRead(): void;
        public isLocal(): boolean;
        public isAdded(): boolean;
        public isRemote(): boolean;
        public classId(): number;
        public serialize(): boolean;
        public afterAllRead(): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare abstract class Displayable {
        public display(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public displayable(): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare abstract class Sized
        implements Packages.arc.math.geom.Position
      {
        public hitSize(): number;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Healthc
        implements
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Entityc
      {
        public update(): void;
        public isValid(): boolean;
        public dead(_dead: boolean): void;
        public dead(): boolean;
        public maxHealth(): number;
        public maxHealth(_maxHealth: number): void;
        public hitTime(): number;
        public hitTime(_hitTime: number): void;
        public damage(
          _amount: number,
          _withEffect: boolean,
        ): void;
        public damage(_amount: number): void;
        public damageContinuous(_amount: number): void;
        public damagePierce(_amount: number): void;
        public damagePierce(
          _amount: number,
          _withEffect: boolean,
        ): void;
        public damaged(): boolean;
        public healthf(): number;
        public clampHealth(): void;
        public heal(): void;
        public heal(_amount: number): void;
        public killed(): void;
        public health(): number;
        public health(_health: number): void;
        public damageContinuousPierce(
          _amount: number,
        ): void;
        public healFract(_amount: number): void;
        public kill(): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace mod {
      declare abstract class Mod extends java.lang.Object {
        public init(): void;
        public getConfigFolder(): Packages.arc.files.Fi;
        public loadContent(): void;
        public getConfig(): Packages.arc.files.Fi;
        public registerServerCommands(
          _handler: Packages.arc.util.CommandHandler,
        ): void;
        public registerClientCommands(
          _handler: Packages.arc.util.CommandHandler,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ctype {
      declare class ContentType extends Packages.java.lang
        .Enum<Packages.mindustry.ctype.ContentType> {
        public static item: Packages.mindustry.ctype.ContentType;
        public static block: Packages.mindustry.ctype.ContentType;
        public static mech_UNUSED: Packages.mindustry.ctype.ContentType;
        public static bullet: Packages.mindustry.ctype.ContentType;
        public static liquid: Packages.mindustry.ctype.ContentType;
        public static status: Packages.mindustry.ctype.ContentType;
        public static unit: Packages.mindustry.ctype.ContentType;
        public static weather: Packages.mindustry.ctype.ContentType;
        public static effect_UNUSED: Packages.mindustry.ctype.ContentType;
        public static sector: Packages.mindustry.ctype.ContentType;
        public static loadout_UNUSED: Packages.mindustry.ctype.ContentType;
        public static typeid_UNUSED: Packages.mindustry.ctype.ContentType;
        public static error: Packages.mindustry.ctype.ContentType;
        public static planet: Packages.mindustry.ctype.ContentType;
        public static ammo_UNUSED: Packages.mindustry.ctype.ContentType;
        public static team: Packages.mindustry.ctype.ContentType;
        public static unitCommand: Packages.mindustry.ctype.ContentType;
        public static unitStance: Packages.mindustry.ctype.ContentType;
        public static all: Packages.mindustry.ctype.ContentType[];
        public contentClass?: Packages.java.lang.Class<any>;
        private static $VALUES: Packages.mindustry.ctype.ContentType[];
        public static values():
          | Packages.mindustry.ctype.ContentType[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.mindustry.ctype.ContentType;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ctype {
      declare abstract class Content
        extends java.lang.Object
        implements
          Packages.java.lang
            .Comparable<Packages.mindustry.ctype.Content>
      {
        public static ModContentInfo = class extends java
          .lang.Object {
          public mod?: Packages.mindustry.mod.Mods.LoadedMod;
          public sourceFile?: Packages.arc.files.Fi;
          public error?: string;
          public baseError?: Packages.java.lang.Throwable;
          public constructor();
        };
        public id: Packages.short;
        public minfo: Packages.mindustry.ctype.Content.ModContentInfo;
        public toString(): string;
        public compareTo(_c: any): number;
        public compareTo(
          _c: Packages.mindustry.ctype.Content,
        ): number;
        public load(): void;
        public init(): void;
        public hasErrored(): boolean;
        public loadIcon(): void;
        public isVanilla(): boolean;
        public isModded(): boolean;
        public getContentType(): Packages.mindustry.ctype.ContentType;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ctype {
      declare abstract class MappableContent extends Packages
        .mindustry.ctype.Content {
        public name: string;
        public toString(): string;
        public constructor(_name: string);
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace meta {
        declare class StatCat
          extends java.lang.Object
          implements
            Packages.java.lang
              .Comparable<Packages.mindustry.world.meta.StatCat>
        {
          public static all: Packages.arc.struct.Seq<Packages.mindustry.world.meta.StatCat>;
          public static general: Packages.mindustry.world.meta.StatCat;
          public static power: Packages.mindustry.world.meta.StatCat;
          public static liquids: Packages.mindustry.world.meta.StatCat;
          public static items: Packages.mindustry.world.meta.StatCat;
          public static crafting: Packages.mindustry.world.meta.StatCat;
          public static function: Packages.mindustry.world.meta.StatCat;
          public static optional: Packages.mindustry.world.meta.StatCat;
          public name: string;
          public id: number;
          public toString(): string;
          public compareTo(
            _o: Packages.mindustry.world.meta.StatCat,
          ): number;
          public compareTo(_o: any): number;
          public localized(): string;
          public constructor(_name: string);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace meta {
        declare class Stat
          extends java.lang.Object
          implements
            Packages.java.lang
              .Comparable<Packages.mindustry.world.meta.Stat>
        {
          public static all: Packages.arc.struct.Seq<Packages.mindustry.world.meta.Stat>;
          public static health: Packages.mindustry.world.meta.Stat;
          public static armor: Packages.mindustry.world.meta.Stat;
          public static size: Packages.mindustry.world.meta.Stat;
          public static displaySize: Packages.mindustry.world.meta.Stat;
          public static buildTime: Packages.mindustry.world.meta.Stat;
          public static buildCost: Packages.mindustry.world.meta.Stat;
          public static memoryCapacity: Packages.mindustry.world.meta.Stat;
          public static explosiveness: Packages.mindustry.world.meta.Stat;
          public static flammability: Packages.mindustry.world.meta.Stat;
          public static radioactivity: Packages.mindustry.world.meta.Stat;
          public static charge: Packages.mindustry.world.meta.Stat;
          public static heatCapacity: Packages.mindustry.world.meta.Stat;
          public static viscosity: Packages.mindustry.world.meta.Stat;
          public static temperature: Packages.mindustry.world.meta.Stat;
          public static flying: Packages.mindustry.world.meta.Stat;
          public static speed: Packages.mindustry.world.meta.Stat;
          public static buildSpeed: Packages.mindustry.world.meta.Stat;
          public static mineSpeed: Packages.mindustry.world.meta.Stat;
          public static mineTier: Packages.mindustry.world.meta.Stat;
          public static payloadCapacity: Packages.mindustry.world.meta.Stat;
          public static baseDeflectChance: Packages.mindustry.world.meta.Stat;
          public static lightningChance: Packages.mindustry.world.meta.Stat;
          public static lightningDamage: Packages.mindustry.world.meta.Stat;
          public static abilities: Packages.mindustry.world.meta.Stat;
          public static canBoost: Packages.mindustry.world.meta.Stat;
          public static maxUnits: Packages.mindustry.world.meta.Stat;
          public static damageMultiplier: Packages.mindustry.world.meta.Stat;
          public static healthMultiplier: Packages.mindustry.world.meta.Stat;
          public static speedMultiplier: Packages.mindustry.world.meta.Stat;
          public static reloadMultiplier: Packages.mindustry.world.meta.Stat;
          public static buildSpeedMultiplier: Packages.mindustry.world.meta.Stat;
          public static reactive: Packages.mindustry.world.meta.Stat;
          public static healing: Packages.mindustry.world.meta.Stat;
          public static immunities: Packages.mindustry.world.meta.Stat;
          public static itemCapacity: Packages.mindustry.world.meta.Stat;
          public static itemsMoved: Packages.mindustry.world.meta.Stat;
          public static launchTime: Packages.mindustry.world.meta.Stat;
          public static maxConsecutive: Packages.mindustry.world.meta.Stat;
          public static liquidCapacity: Packages.mindustry.world.meta.Stat;
          public static powerCapacity: Packages.mindustry.world.meta.Stat;
          public static powerUse: Packages.mindustry.world.meta.Stat;
          public static powerDamage: Packages.mindustry.world.meta.Stat;
          public static powerRange: Packages.mindustry.world.meta.Stat;
          public static powerConnections: Packages.mindustry.world.meta.Stat;
          public static basePowerGeneration: Packages.mindustry.world.meta.Stat;
          public static tiles: Packages.mindustry.world.meta.Stat;
          public static input: Packages.mindustry.world.meta.Stat;
          public static output: Packages.mindustry.world.meta.Stat;
          public static productionTime: Packages.mindustry.world.meta.Stat;
          public static maxEfficiency: Packages.mindustry.world.meta.Stat;
          public static drillTier: Packages.mindustry.world.meta.Stat;
          public static drillSpeed: Packages.mindustry.world.meta.Stat;
          public static linkRange: Packages.mindustry.world.meta.Stat;
          public static instructions: Packages.mindustry.world.meta.Stat;
          public static weapons: Packages.mindustry.world.meta.Stat;
          public static bullet: Packages.mindustry.world.meta.Stat;
          public static speedIncrease: Packages.mindustry.world.meta.Stat;
          public static repairTime: Packages.mindustry.world.meta.Stat;
          public static repairSpeed: Packages.mindustry.world.meta.Stat;
          public static range: Packages.mindustry.world.meta.Stat;
          public static shootRange: Packages.mindustry.world.meta.Stat;
          public static inaccuracy: Packages.mindustry.world.meta.Stat;
          public static shots: Packages.mindustry.world.meta.Stat;
          public static reload: Packages.mindustry.world.meta.Stat;
          public static targetsAir: Packages.mindustry.world.meta.Stat;
          public static targetsGround: Packages.mindustry.world.meta.Stat;
          public static damage: Packages.mindustry.world.meta.Stat;
          public static ammo: Packages.mindustry.world.meta.Stat;
          public static ammoCapacity: Packages.mindustry.world.meta.Stat;
          public static ammoUse: Packages.mindustry.world.meta.Stat;
          public static shieldHealth: Packages.mindustry.world.meta.Stat;
          public static cooldownTime: Packages.mindustry.world.meta.Stat;
          public static moduleTier: Packages.mindustry.world.meta.Stat;
          public static unitType: Packages.mindustry.world.meta.Stat;
          public static booster: Packages.mindustry.world.meta.Stat;
          public static boostEffect: Packages.mindustry.world.meta.Stat;
          public static affinities: Packages.mindustry.world.meta.Stat;
          public static opposites: Packages.mindustry.world.meta.Stat;
          public category: Packages.mindustry.world.meta.StatCat;
          public name: string;
          public id: number;
          public toString(): string;
          public compareTo(_o: any): number;
          public compareTo(
            _o: Packages.mindustry.world.meta.Stat,
          ): number;
          public localized(): string;
          public constructor(
            _name: string,
            _category: Packages.mindustry.world.meta.StatCat,
          );
          public constructor(_name: string);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace meta {
        declare abstract class StatValue {
          public display(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace meta {
        declare class Attribute extends java.lang.Object {
          public static all: Packages.mindustry.world.meta.Attribute[];
          public static map: Packages.arc.struct.ObjectMap<
            string,
            Packages.mindustry.world.meta.Attribute
          >;
          public static heat: Packages.mindustry.world.meta.Attribute;
          public static spores: Packages.mindustry.world.meta.Attribute;
          public static water: Packages.mindustry.world.meta.Attribute;
          public static oil: Packages.mindustry.world.meta.Attribute;
          public static light: Packages.mindustry.world.meta.Attribute;
          public static sand: Packages.mindustry.world.meta.Attribute;
          public static steam: Packages.mindustry.world.meta.Attribute;
          public id: number;
          public name: string;
          public static add(
            _name: string,
          ): Packages.mindustry.world.meta.Attribute;
          public static get(
            _name: string,
          ): Packages.mindustry.world.meta.Attribute;
          public toString(): string;
          public static exists(_name: string): boolean;
          public env(): number;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare class LAccess extends Packages.java.lang
        .Enum<Packages.mindustry.logic.LAccess> {
        public static totalItems: Packages.mindustry.logic.LAccess;
        public static firstItem: Packages.mindustry.logic.LAccess;
        public static totalLiquids: Packages.mindustry.logic.LAccess;
        public static totalPower: Packages.mindustry.logic.LAccess;
        public static itemCapacity: Packages.mindustry.logic.LAccess;
        public static liquidCapacity: Packages.mindustry.logic.LAccess;
        public static powerCapacity: Packages.mindustry.logic.LAccess;
        public static powerNetStored: Packages.mindustry.logic.LAccess;
        public static powerNetCapacity: Packages.mindustry.logic.LAccess;
        public static powerNetIn: Packages.mindustry.logic.LAccess;
        public static powerNetOut: Packages.mindustry.logic.LAccess;
        public static ammo: Packages.mindustry.logic.LAccess;
        public static ammoCapacity: Packages.mindustry.logic.LAccess;
        public static currentAmmoType: Packages.mindustry.logic.LAccess;
        public static health: Packages.mindustry.logic.LAccess;
        public static maxHealth: Packages.mindustry.logic.LAccess;
        public static heat: Packages.mindustry.logic.LAccess;
        public static shield: Packages.mindustry.logic.LAccess;
        public static armor: Packages.mindustry.logic.LAccess;
        public static efficiency: Packages.mindustry.logic.LAccess;
        public static progress: Packages.mindustry.logic.LAccess;
        public static timescale: Packages.mindustry.logic.LAccess;
        public static rotation: Packages.mindustry.logic.LAccess;
        public static x: Packages.mindustry.logic.LAccess;
        public static y: Packages.mindustry.logic.LAccess;
        public static velocityX: Packages.mindustry.logic.LAccess;
        public static velocityY: Packages.mindustry.logic.LAccess;
        public static shootX: Packages.mindustry.logic.LAccess;
        public static shootY: Packages.mindustry.logic.LAccess;
        public static cameraX: Packages.mindustry.logic.LAccess;
        public static cameraY: Packages.mindustry.logic.LAccess;
        public static cameraWidth: Packages.mindustry.logic.LAccess;
        public static cameraHeight: Packages.mindustry.logic.LAccess;
        public static size: Packages.mindustry.logic.LAccess;
        public static solid: Packages.mindustry.logic.LAccess;
        public static dead: Packages.mindustry.logic.LAccess;
        public static range: Packages.mindustry.logic.LAccess;
        public static shooting: Packages.mindustry.logic.LAccess;
        public static boosting: Packages.mindustry.logic.LAccess;
        public static mineX: Packages.mindustry.logic.LAccess;
        public static mineY: Packages.mindustry.logic.LAccess;
        public static mining: Packages.mindustry.logic.LAccess;
        public static speed: Packages.mindustry.logic.LAccess;
        public static team: Packages.mindustry.logic.LAccess;
        public static type: Packages.mindustry.logic.LAccess;
        public static flag: Packages.mindustry.logic.LAccess;
        public static controlled: Packages.mindustry.logic.LAccess;
        public static controller: Packages.mindustry.logic.LAccess;
        public static name: Packages.mindustry.logic.LAccess;
        public static payloadCount: Packages.mindustry.logic.LAccess;
        public static payloadType: Packages.mindustry.logic.LAccess;
        public static id: Packages.mindustry.logic.LAccess;
        public static enabled: Packages.mindustry.logic.LAccess;
        public static shoot: Packages.mindustry.logic.LAccess;
        public static shootp: Packages.mindustry.logic.LAccess;
        public static config: Packages.mindustry.logic.LAccess;
        public static color: Packages.mindustry.logic.LAccess;
        public static accept: Packages.mindustry.logic.LAccess;
        public static consume: Packages.mindustry.logic.LAccess;
        public static isPartOf: Packages.mindustry.logic.LAccess;
        public params: string[];
        public isObj: boolean;
        public static all: Packages.mindustry.logic.LAccess[];
        public static senseable: Packages.mindustry.logic.LAccess[];
        public static controls: Packages.mindustry.logic.LAccess[];
        public static settable: Packages.mindustry.logic.LAccess[];
        private static $VALUES: Packages.mindustry.logic.LAccess[];
        public static values():
          | Packages.mindustry.logic.LAccess[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.mindustry.logic.LAccess;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare abstract class Senseable {
        public static noSensed: any;
        public sense(
          _sensor: Packages.mindustry.logic.LAccess,
        ): number;
        public sense(
          _content: Packages.mindustry.ctype.Content,
        ): number;
        public senseObject(
          _sensor: Packages.mindustry.logic.LAccess,
        ): any;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Hitboxc
        implements
          Packages.mindustry.gen.Posc,
          Packages.mindustry.entities.Sized,
          Packages.arc.math.geom.QuadTree.QuadTreeObject,
          Packages.mindustry.gen.Entityc
      {
        public add(): void;
        public update(): void;
        public deltaX(): number;
        public deltaX(_deltaX: number): void;
        public deltaY(_deltaY: number): void;
        public deltaY(): number;
        public lastX(_lastX: number): void;
        public lastX(): number;
        public lastY(_lastY: number): void;
        public lastY(): number;
        public hitbox(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public afterRead(): void;
        public hitSize(_hitSize: number): void;
        public hitSize(): number;
        public collision(
          _other: Packages.mindustry.gen.Hitboxc,
          _x: number,
          _y: number,
        ): void;
        public collides(
          _other: Packages.mindustry.gen.Hitboxc,
        ): boolean;
        public deltaAngle(): number;
        public deltaLen(): number;
        public getCollisions(
          _consumer: Packages.arc.func.Cons<
            Packages.arc.math.geom.QuadTree<any>
          >,
        ): void;
        public hitboxTile(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public updateLastPosition(): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Velc
        implements
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Entityc
      {
        public update(): void;
        public move(_v: Packages.arc.math.geom.Vec2): void;
        public move(_cx: number, _cy: number): void;
        public vel(): Packages.arc.math.geom.Vec2;
        public vel(_vel: Packages.arc.math.geom.Vec2): void;
        public drag(): number;
        public drag(_drag: number): void;
        public solidity(): Packages.mindustry.entities.EntityCollisions.SolidPred;
        public canPassOn(): boolean;
        public canPass(
          _tileX: number,
          _tileY: number,
        ): boolean;
        public moving(): boolean;
        public velAddNet(_vx: number, _vy: number): void;
        public velAddNet(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace effect {
        declare class WrapEffect extends Packages.mindustry
          .entities.Effect {
          public effect: Packages.mindustry.entities.Effect;
          public color: Packages.arc.graphics.Color;
          public rotation: number;
          public init(): void;
          public create(
            _x: number,
            _y: number,
            _rotation: number,
            _color: Packages.arc.graphics.Color,
            _data: any,
          ): void;
          public render(
            _e: Packages.mindustry.entities.Effect.EffectContainer,
          ): void;
          public constructor(
            _effect: Packages.mindustry.entities.Effect,
            _color: Packages.arc.graphics.Color,
            _rotation: number,
          );
          public constructor(
            _effect: Packages.mindustry.entities.Effect,
            _color: Packages.arc.graphics.Color,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare class Effect extends java.lang.Object {
        public static EffectContainer = class
          extends java.lang.Object
          implements Packages.arc.math.Scaled
        {
          public x: number;
          public y: number;
          public time: number;
          public lifetime: number;
          public rotation: number;
          public color: Packages.arc.graphics.Color;
          public id: number;
          public data: any;
          private innerContainer: Packages.mindustry.entities.Effect.EffectContainer;
          public data<T>(): T | null;
          public set(
            _id: number,
            _color: Packages.arc.graphics.Color,
            _life: number,
            _lifetime: number,
            _rotation: number,
            _x: number,
            _y: number,
            _data: any,
          ): void;
          public inner(): Packages.mindustry.entities.Effect.EffectContainer;
          public fin(): number;
          public scaled(
            _lifetime: number,
            _cons: Packages.arc.func.Cons<Packages.mindustry.entities.Effect.EffectContainer>,
          ): void;
          public constructor();
        };
        private static shakeFalloff: number;
        private static container: Packages.mindustry.entities.Effect.EffectContainer;
        public static all: Packages.arc.struct.Seq<Packages.mindustry.entities.Effect>;
        private initialized: boolean;
        public id: number;
        public renderer: Packages.arc.func.Cons<Packages.mindustry.entities.Effect.EffectContainer>;
        public lifetime: number;
        public clip: number;
        public layerDuration: number;
        protected add(
          _x: number,
          _y: number,
          _rotation: number,
          _color: Packages.arc.graphics.Color,
          _data: any,
        ): void;
        public static get(
          _id: number,
        ): Packages.mindustry.entities.Effect | null;
        public wrap(
          _color: Packages.arc.graphics.Color,
          _rotation: number,
        ): Packages.mindustry.entities.effect.WrapEffect;
        public wrap(
          _color: Packages.arc.graphics.Color,
        ): Packages.mindustry.entities.effect.WrapEffect;
        public init(): void;
        public layer(
          _l: number,
        ): Packages.mindustry.entities.Effect;
        public layer(
          _l: number,
          _duration: number,
        ): Packages.mindustry.entities.Effect;
        public at(
          _x: number,
          _y: number,
          _color: Packages.arc.graphics.Color,
        ): void;
        public at(
          _x: number,
          _y: number,
          _rotation: number,
          _color: Packages.arc.graphics.Color,
        ): void;
        public at(
          _x: number,
          _y: number,
          _rotation: number,
        ): void;
        public at(
          _x: number,
          _y: number,
          _rotation: number,
          _data: any,
        ): void;
        public at(
          _x: number,
          _y: number,
          _rotation: number,
          _color: Packages.arc.graphics.Color,
          _data: any,
        ): void;
        public at(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public at(
          _pos: Packages.arc.math.geom.Position,
          _parentize: boolean,
        ): void;
        public at(_x: number, _y: number): void;
        public at(
          _pos: Packages.arc.math.geom.Position,
          _rotation: number,
        ): void;
        public create(
          _x: number,
          _y: number,
          _rotation: number,
          _color: Packages.arc.graphics.Color,
          _data: any,
        ): void;
        public static shake(
          _intensity: number,
          _duration: number,
          _x: number,
          _y: number,
        ): void;
        private static shake(
          _intensity: number,
          _duration: number,
        ): void;
        public static shake(
          _intensity: number,
          _duration: number,
          _loc: Packages.arc.math.geom.Position,
        ): void;
        public render(
          _id: number,
          _color: Packages.arc.graphics.Color,
          _life: number,
          _lifetime: number,
          _rotation: number,
          _x: number,
          _y: number,
          _data: any,
        ): number;
        public render(
          _e: Packages.mindustry.entities.Effect.EffectContainer,
        ): void;
        public static rubble(
          _x: number,
          _y: number,
          _blockSize: number,
        ): void;
        public followParent(
          _follow: boolean,
        ): Packages.mindustry.entities.Effect;
        public startDelay(
          _d: number,
        ): Packages.mindustry.entities.Effect;
        public rotWithParent(
          _follow: boolean,
        ): Packages.mindustry.entities.Effect;
        public baseRotation(
          _d: number,
        ): Packages.mindustry.entities.Effect;
        public shouldCreate(): boolean;
        public static decal(
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _x: number,
          _y: number,
          _rotation: number,
        ): void;
        public static decal(
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _x: number,
          _y: number,
          _rotation: number,
          _lifetime: number,
          _color: Packages.arc.graphics.Color,
        ): void;
        public static floorDust(
          _x: number,
          _y: number,
          _size: number,
        ): void;
        public static floorDustAngle(
          _effect: Packages.mindustry.entities.Effect,
          _x: number,
          _y: number,
          _angle: number,
        ): void;
        public static scorch(
          _x: number,
          _y: number,
          _size: number,
        ): void;
        public constructor();
        public constructor(
          _life: number,
          _renderer: Packages.arc.func.Cons<Packages.mindustry.entities.Effect.EffectContainer>,
        );
        public constructor(
          _life: number,
          _clipsize: number,
          _renderer: Packages.arc.func.Cons<Packages.mindustry.entities.Effect.EffectContainer>,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare class MultiPacker
        extends java.lang.Object
        implements Packages.arc.util.Disposable
      {
        public static PageType = class extends Packages.java
          .lang
          .Enum<Packages.mindustry.graphics.MultiPacker.PageType> {
          public static main: Packages.mindustry.graphics.MultiPacker.PageType;
          public static environment: Packages.mindustry.graphics.MultiPacker.PageType;
          public static ui: Packages.mindustry.graphics.MultiPacker.PageType;
          public static rubble: Packages.mindustry.graphics.MultiPacker.PageType;
          public static editor: Packages.mindustry.graphics.MultiPacker.PageType;
          public static all: Packages.mindustry.graphics.MultiPacker.PageType[];
          public width: number;
          public height: number;
          private static $VALUES: Packages.mindustry.graphics.MultiPacker.PageType[];
          public static values():
            | Packages.mindustry.graphics.MultiPacker.PageType[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.mindustry.graphics.MultiPacker.PageType;
        };
        private packers: Packages.arc.graphics.g2d.PixmapPacker[];
        private outlined: Packages.arc.struct.ObjectSet<string>;
        public add(
          _type: Packages.mindustry.graphics.MultiPacker.PageType,
          _name: string,
          _pix: Packages.arc.graphics.Pixmap,
        ): void;
        public add(
          _type: Packages.mindustry.graphics.MultiPacker.PageType,
          _name: string,
          _region: Packages.arc.graphics.g2d.PixmapRegion,
          _splits: number[],
          _pads: number[],
        ): void;
        public add(
          _type: Packages.mindustry.graphics.MultiPacker.PageType,
          _name: string,
          _region: Packages.arc.graphics.g2d.PixmapRegion,
        ): void;
        public get(
          _name: string,
        ): Packages.arc.graphics.g2d.PixmapRegion | null;
        public flush(
          _filter: Packages.arc.graphics.Texture.TextureFilter,
          _atlas: Packages.arc.graphics.g2d.TextureAtlas,
        ): Packages.arc.graphics.g2d.TextureAtlas;
        public dispose(): void;
        public has(_name: string): boolean;
        public has(
          _type: Packages.mindustry.graphics.MultiPacker.PageType,
          _name: string,
        ): boolean;
        public printStats(): void;
        public registerOutlined(_named: string): boolean;
        public isOutlined(_name: string): boolean;
        public getPacker(
          _type: Packages.mindustry.graphics.MultiPacker.PageType,
        ): Packages.arc.graphics.g2d.PixmapPacker;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare class CacheLayer extends java.lang.Object {
        public static ShaderLayer = class extends Packages
          .mindustry.graphics.CacheLayer {
          public shader?: Packages.arc.graphics.gl.Shader;
          public end(): void;
          public begin(): void;
          public constructor(
            _shader: Packages.arc.graphics.gl.Shader,
          );
        };
        public static water: Packages.mindustry.graphics.CacheLayer;
        public static mud: Packages.mindustry.graphics.CacheLayer;
        public static cryofluid: Packages.mindustry.graphics.CacheLayer;
        public static tar: Packages.mindustry.graphics.CacheLayer;
        public static slag: Packages.mindustry.graphics.CacheLayer;
        public static arkycite: Packages.mindustry.graphics.CacheLayer;
        public static space: Packages.mindustry.graphics.CacheLayer;
        public static normal: Packages.mindustry.graphics.CacheLayer;
        public static walls: Packages.mindustry.graphics.CacheLayer;
        public static all: Packages.mindustry.graphics.CacheLayer[];
        public id: number;
        public static add(
          ..._layers: Packages.mindustry.graphics.CacheLayer[]
        ): void;
        public static add(
          _index: number,
          _layer: Packages.mindustry.graphics.CacheLayer,
        ): void;
        public end(): void;
        public begin(): void;
        public static init(): void;
        public static addLast(
          ..._layers: Packages.mindustry.graphics.CacheLayer[]
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace environment {
          declare class Floor extends Packages.mindustry
            .world.Block {
            public static UpdateRenderState = class extends java
              .lang.Object {
              public tile: Packages.mindustry.world.Tile;
              public floor: Packages.mindustry.world.blocks.environment.Floor;
              public data: number;
              public constructor(
                _tile: Packages.mindustry.world.Tile,
                _floor: Packages.mindustry.world.blocks.environment.Floor,
              );
            };
            public speedMultiplier: number;
            public dragMultiplier: number;
            public damageTaken: number;
            public drownTime: number;
            public walkEffect: Packages.mindustry.entities.Effect;
            public walkSound: Packages.arc.audio.Sound;
            public walkSoundVolume: number;
            public walkSoundPitchMin: number;
            public walkSoundPitchMax: number;
            public drownUpdateEffect: Packages.mindustry.entities.Effect;
            public status: Packages.mindustry._type.StatusEffect;
            public statusDuration: number;
            public liquidDrop?: Packages.mindustry._type.Liquid;
            public liquidMultiplier: number;
            public isLiquid: boolean;
            public overlayAlpha: number;
            public supportsOverlay: boolean;
            public shallow: boolean;
            public blendGroup: Packages.mindustry.world.Block;
            public oreDefault: boolean;
            public oreScale: number;
            public oreThreshold: number;
            public wall: Packages.mindustry.world.Block;
            public decoration: Packages.mindustry.world.Block;
            public canShadow: boolean;
            public needsSurface: boolean;
            public allowCorePlacement: boolean;
            public wallOre: boolean;
            public blendId: number;
            protected blenders: Packages.arc.struct.Seq<Packages.mindustry.world.blocks.environment.Floor>;
            protected blended: Packages.arc.struct.Bits;
            protected dirs: number[];
            protected edgeRegion: Packages.arc.graphics.g2d.TextureRegion;
            public load(): void;
            public init(): void;
            public getDisplayName(
              _tile: Packages.mindustry.world.Tile,
            ): string;
            public variant(_x: number, _y: number): number;
            protected edge(
              _x: number,
              _y: number,
              _rx: number,
              _ry: number,
            ): Packages.arc.graphics.g2d.TextureRegion;
            protected edges(
              _x: number,
              _y: number,
            ):
              | Packages.arc.graphics.g2d.TextureRegion[][]
              | null;
            protected edges():
              | Packages.arc.graphics.g2d.TextureRegion[][]
              | null;
            public drawOverlay(
              _tile: Packages.mindustry.world.Tile,
            ): void;
            public isDeep(): boolean;
            public getDisplayIcon(
              _tile: Packages.mindustry.world.Tile,
            ): Packages.arc.graphics.g2d.TextureRegion;
            public createIcons(
              _packer: Packages.mindustry.graphics.MultiPacker,
            ): void;
            public drawBase(
              _tile: Packages.mindustry.world.Tile,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            protected drawEdges(
              _tile: Packages.mindustry.world.Tile,
            ): void;
            protected drawBlended(
              _tile: Packages.mindustry.world.Tile,
              _checkId: boolean,
            ): void;
            protected doEdge(
              _tile: Packages.mindustry.world.Tile,
              _otherTile: Packages.mindustry.world.Tile,
              _other: Packages.mindustry.world.blocks.environment.Floor,
            ): boolean;
            public realBlendId(
              _tile: Packages.mindustry.world.Tile,
            ): number;
            public updateRender(
              _tile: Packages.mindustry.world.Tile,
            ): boolean;
            public renderUpdate(
              _tile: Packages.mindustry.world.blocks.environment.Floor.UpdateRenderState,
            ): void;
            public hasSurface(): boolean;
            public drawNonLayer(
              _tile: Packages.mindustry.world.Tile,
              _layer: Packages.mindustry.graphics.CacheLayer,
            ): void;
            protected drawEdgesFlat(
              _tile: Packages.mindustry.world.Tile,
              _sameLayer: boolean,
            ): void;
            public constructor(_name: string);
            public constructor(
              _name: string,
              _variants: number,
            );
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Flyingc
        implements
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc,
          Packages.mindustry.gen.Velc
      {
        public update(): void;
        public elevation(_elevation: number): void;
        public elevation(): number;
        public isFlying(): boolean;
        public checkTarget(
          _targetAir: boolean,
          _targetGround: boolean,
        ): boolean;
        public drownTime(): number;
        public drownTime(_drownTime: number): void;
        public hovering(_hovering: boolean): void;
        public hovering(): boolean;
        public splashTimer(_splashTimer: number): void;
        public splashTimer(): number;
        public lastDrownFloor(
          _lastDrownFloor: Packages.mindustry.world.blocks.environment.Floor | null,
        ): void;
        public lastDrownFloor(): Packages.mindustry.world.blocks.environment.Floor | null;
        public canDrown(): boolean;
        public emitWalkSound(): boolean;
        public isGrounded(): boolean;
        public floorSpeedMultiplier(): number;
        public drownFloor(): Packages.mindustry.world.blocks.environment.Floor;
        public landed(): void;
        public moveAt(
          _vector: Packages.arc.math.geom.Vec2,
          _acceleration: number,
        ): void;
        public updateDrowning(): void;
        public wobble(): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Boundedc
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc,
          Packages.mindustry.gen.Velc
      {
        public update(): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Rotc
        implements Packages.mindustry.gen.Entityc
      {
        public rotation(): number;
        public rotation(_rotation: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace units {
        declare class StatusEntry extends java.lang.Object {
          public effect: Packages.mindustry._type.StatusEffect;
          public time: number;
          public damageMultiplier: number;
          public healthMultiplier: number;
          public speedMultiplier: number;
          public reloadMultiplier: number;
          public buildSpeedMultiplier: number;
          public dragMultiplier: number;
          public armorOverride: number;
          public set(
            _effect: Packages.mindustry._type.StatusEffect,
            _time: number,
          ): Packages.mindustry.entities.units.StatusEntry;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Statusc
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc,
          Packages.mindustry.gen.Velc
      {
        public update(): void;
        public apply(
          _effect: Packages.mindustry._type.StatusEffect,
        ): void;
        public apply(
          _effect: Packages.mindustry._type.StatusEffect,
          _duration: number,
        ): void;
        public getDuration(
          _effect: Packages.mindustry._type.StatusEffect,
        ): number;
        public draw(): void;
        public isBoss(): boolean;
        public buildSpeedMultiplier(): number;
        public buildSpeedMultiplier(
          _buildSpeedMultiplier: number,
        ): void;
        public speedMultiplier(): number;
        public speedMultiplier(
          _speedMultiplier: number,
        ): void;
        public dragMultiplier(
          _dragMultiplier: number,
        ): void;
        public dragMultiplier(): number;
        public damageMultiplier(): number;
        public damageMultiplier(
          _damageMultiplier: number,
        ): void;
        public healthMultiplier(): number;
        public healthMultiplier(
          _healthMultiplier: number,
        ): void;
        public reloadMultiplier(): number;
        public reloadMultiplier(
          _reloadMultiplier: number,
        ): void;
        public armorOverride(_armorOverride: number): void;
        public armorOverride(): number;
        public disarmed(_disarmed: boolean): void;
        public disarmed(): boolean;
        public applyDynamicStatus(): Packages.mindustry.entities.units.StatusEntry;
        public unapply(
          _effect: Packages.mindustry._type.StatusEffect,
        ): void;
        public statusDamageMultiplier(
          _damageMultiplier: number,
        ): void;
        public statusReloadMultiplier(
          _reloadMultiplier: number,
        ): void;
        public statusArmor(_armor: number): void;
        public statusBuildSpeed(_buildSpeed: number): void;
        public statusDrag(_drag: number): void;
        public statusMaxHealth(_health: number): void;
        public statusSpeed(_speed: number): void;
        public statusColor(): Packages.arc.graphics.Color;
        public statusBits(): Packages.arc.struct.Bits;
        public hasEffect(
          _effect: Packages.mindustry._type.StatusEffect,
        ): boolean;
        public isImmune(
          _effect: Packages.mindustry._type.StatusEffect,
        ): boolean;
        public clearStatuses(): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace units {
        declare class BuildPlan
          extends java.lang.Object
          implements
            Packages.arc.math.geom.Position,
            Packages.arc.math.geom.QuadTree.QuadTreeObject
        {
          public x: number;
          public y: number;
          public rotation: number;
          public block?: Packages.mindustry.world.Block;
          public breaking: boolean;
          public config: any;
          public originalX: number;
          public originalY: number;
          public originalWidth: number;
          public originalHeight: number;
          public progress: number;
          public initialized: boolean;
          public stuck: boolean;
          public cachedValid: boolean;
          public worldContext: boolean;
          public animScale: number;
          public toString(): string;
          public original(
            _x: number,
            _y: number,
            _originalWidth: number,
            _originalHeight: number,
          ): Packages.mindustry.entities.units.BuildPlan;
          public bounds(
            _rect: Packages.arc.math.geom.Rect,
          ): Packages.arc.math.geom.Rect;
          public set(
            _x: number,
            _y: number,
            _rotation: number,
            _block: Packages.mindustry.world.Block,
          ): Packages.mindustry.entities.units.BuildPlan;
          public copy(): Packages.mindustry.entities.units.BuildPlan;
          public build(): Packages.mindustry.gen.Building | null;
          public getX(): number;
          public getY(): number;
          public hitbox(
            _out: Packages.arc.math.geom.Rect,
          ): void;
          public tile(): Packages.mindustry.world.Tile | null;
          public drawx(): number;
          public drawy(): number;
          public pointConfig(
            _cons: Packages.arc.func.Cons<Packages.arc.math.geom.Point2>,
          ): void;
          public static pointConfig(
            _block: Packages.mindustry.world.Block,
            _config: any,
            _cons: Packages.arc.func.Cons<Packages.arc.math.geom.Point2>,
          ): any;
          public placeable(
            _team: Packages.mindustry.game.Team,
          ): boolean;
          public isRotation(
            _team: Packages.mindustry.game.Team,
          ): boolean;
          public samePos(
            _other: Packages.mindustry.entities.units.BuildPlan,
          ): boolean;
          public constructor();
          public constructor(_x: number, _y: number);
          public constructor(
            _x: number,
            _y: number,
            _rotation: number,
            _block: Packages.mindustry.world.Block,
            _config: any,
          );
          public constructor(
            _x: number,
            _y: number,
            _rotation: number,
            _block: Packages.mindustry.world.Block,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Builderc
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc,
          Packages.mindustry.gen.Velc
      {
        public update(): void;
        public afterRead(): void;
        public canBuild(): boolean;
        public plans(): Packages.arc.struct.Queue<Packages.mindustry.entities.units.BuildPlan>;
        public plans(
          _plans: Packages.arc.struct.Queue<Packages.mindustry.entities.units.BuildPlan>,
        ): void;
        public drawPlan(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _alpha: number,
        ): void;
        public buildAlpha(): number;
        public buildAlpha(_buildAlpha: number): void;
        public updateBuilding(): boolean;
        public updateBuilding(
          _updateBuilding: boolean,
        ): void;
        public buildPlan(): Packages.mindustry.entities.units.BuildPlan;
        public shouldSkip(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _core: Packages.mindustry.gen.Building,
        ): boolean;
        public addBuild(
          _place: Packages.mindustry.entities.units.BuildPlan,
        ): void;
        public addBuild(
          _place: Packages.mindustry.entities.units.BuildPlan,
          _tail: boolean,
        ): void;
        public clearBuilding(): void;
        public drawBuildPlans(): void;
        public isBuilding(): boolean;
        public activelyBuilding(): boolean;
        public drawBuilding(): void;
        public drawBuildingBeam(
          _px: number,
          _py: number,
        ): void;
        public drawPlanTop(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _alpha: number,
        ): void;
        public removeBuild(
          _x: number,
          _y: number,
          _breaking: boolean,
        ): void;
        public updateBuildLogic(): void;
        public validatePlans(): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class IndexableEntity__all {
        public setIndex__all(_index: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class IndexableEntity__draw {
        public setIndex__draw(_index: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class IndexableEntity__sync {
        public setIndex__sync(_index: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class IndexableEntity__unit {
        public setIndex__unit(_index: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare namespace g3d {
        declare class PlanetParams extends java.lang
          .Object {
          public camPos: Packages.arc.math.geom.Vec3;
          public otherCamPos?: Packages.arc.math.geom.Vec3;
          public otherCamAlpha: number;
          public camUp: Packages.arc.math.geom.Vec3;
          public camDir: Packages.arc.math.geom.Vec3;
          public solarSystem: Packages.mindustry._type.Planet;
          public planet: Packages.mindustry._type.Planet;
          public zoom: number;
          public uiAlpha: number;
          public drawUi: boolean;
          public drawSkybox: boolean;
          public renderer?: Packages.mindustry.graphics.g3d.PlanetRenderer.PlanetInterfaceRenderer;
          public viewW: number;
          public viewH: number;
          public alwaysDrawAtmosphere: boolean;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare namespace g3d {
        declare abstract class GenericMesh {
          public render(
            _params: Packages.mindustry.graphics.g3d.PlanetParams,
            _projection: Packages.arc.math.geom.Mat3D,
            _transform: Packages.arc.math.geom.Mat3D,
          ): void;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare namespace g3d {
        declare class PlanetGrid extends java.lang.Object {
          public static Ptile = class extends java.lang
            .Object {
            public static empty: Packages.mindustry.graphics.g3d.PlanetGrid.Ptile;
            public id: number;
            public edgeCount: number;
            public tiles: Packages.mindustry.graphics.g3d.PlanetGrid.Ptile[];
            public corners: Packages.mindustry.graphics.g3d.PlanetGrid.Corner[];
            public edges: Packages.mindustry.graphics.g3d.PlanetGrid.Edge[];
            public v: Packages.arc.math.geom.Vec3;
            public constructor(
              _id: number,
              _edgeCount: number,
            );
          };
          public static Corner = class extends java.lang
            .Object {
            public id: number;
            public tiles: Packages.mindustry.graphics.g3d.PlanetGrid.Ptile[];
            public corners: Packages.mindustry.graphics.g3d.PlanetGrid.Corner[];
            public edges: Packages.mindustry.graphics.g3d.PlanetGrid.Edge[];
            public v: Packages.arc.math.geom.Vec3;
            public constructor(_id: number);
          };
          public static Edge = class extends java.lang
            .Object {
            public id: number;
            public tiles: Packages.mindustry.graphics.g3d.PlanetGrid.Ptile[];
            public corners: Packages.mindustry.graphics.g3d.PlanetGrid.Corner[];
            public constructor(_id: number);
          };
          private static cache: Packages.mindustry.graphics.g3d.PlanetGrid[];
          private static x: number;
          private static z: number;
          private static iTiles: Packages.arc.math.geom.Vec3[];
          private static iTilesP: number[][];
          public size: number;
          public tiles: Packages.mindustry.graphics.g3d.PlanetGrid.Ptile[];
          public corners: Packages.mindustry.graphics.g3d.PlanetGrid.Corner[];
          public edges: Packages.mindustry.graphics.g3d.PlanetGrid.Edge[];
          static pos(
            _c: Packages.mindustry.graphics.g3d.PlanetGrid.Corner,
            _n: Packages.mindustry.graphics.g3d.PlanetGrid.Corner,
          ): number;
          static pos(
            _t: Packages.mindustry.graphics.g3d.PlanetGrid.Ptile,
            _n: Packages.mindustry.graphics.g3d.PlanetGrid.Ptile,
          ): number;
          static pos(
            _t: Packages.mindustry.graphics.g3d.PlanetGrid.Ptile,
            _c: Packages.mindustry.graphics.g3d.PlanetGrid.Corner,
          ): number;
          public static create(
            _size: number,
          ): Packages.mindustry.graphics.g3d.PlanetGrid;
          static tileCount(_size: number): number;
          static cornerCount(_size: number): number;
          static edgeCount(_size: number): number;
          public static initialGrid(): Packages.mindustry.graphics.g3d.PlanetGrid;
          public static subdividedGrid(
            _prev: Packages.mindustry.graphics.g3d.PlanetGrid,
          ): Packages.mindustry.graphics.g3d.PlanetGrid;
          static addCorner(
            _id: number,
            _grid: Packages.mindustry.graphics.g3d.PlanetGrid,
            _t1: number,
            _t2: number,
            _t3: number,
          ): void;
          static addEdge(
            _id: number,
            _grid: Packages.mindustry.graphics.g3d.PlanetGrid,
            _t1: number,
            _t2: number,
          ): void;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class IndexableEntity__puddle {
        public setIndex__puddle(_index: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Syncc
        implements Packages.mindustry.gen.Entityc
      {
        public remove(): void;
        public update(): void;
        public interpolate(): void;
        public lastUpdated(
          _lastUpdated: Packages.long,
        ): void;
        public lastUpdated(): Packages.long;
        public updateSpacing(
          _updateSpacing: Packages.long,
        ): void;
        public updateSpacing(): Packages.long;
        public afterSync(): void;
        public snapInterpolation(): void;
        public isSyncHidden(
          _player: Packages.mindustry.gen.Player,
        ): boolean;
        public handleSyncHidden(): void;
        public readSync(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public readSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public snapSync(): void;
        public writeSync(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public writeSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Puddlec
        implements
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Entityc
      {
        public remove(): void;
        public update(): void;
        public amount(_amount: number): void;
        public amount(): number;
        public updateTime(): number;
        public updateTime(_updateTime: number): void;
        public draw(): void;
        public afterRead(): void;
        public afterSync(): void;
        public tile(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public tile(): Packages.mindustry.world.Tile;
        public clipSize(): number;
        public getFlammability(): number;
        public liquid(
          _liquid: Packages.mindustry._type.Liquid,
        ): void;
        public liquid(): Packages.mindustry._type.Liquid;
        public effectTime(): number;
        public effectTime(_effectTime: number): void;
        public lastRipple(): number;
        public lastRipple(_lastRipple: number): void;
        public accepting(_accepting: number): void;
        public accepting(): number;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class Puddle
        extends java.lang.Object
        implements
          Packages.mindustry.gen.IndexableEntity__all,
          Packages.mindustry.gen.Puddlec,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.IndexableEntity__puddle,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.IndexableEntity__sync,
          Packages.arc.util.pooling.Pool.Poolable,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.IndexableEntity__draw
      {
        protected static paramPuddle: Packages.mindustry.gen.Puddle;
        protected static rect: Packages.arc.math.geom.Rect;
        protected static rect2: Packages.arc.math.geom.Rect;
        protected static unitCons: Packages.arc.func.Cons<Packages.mindustry.gen.Unit>;
        protected added: boolean;
        protected index__all: number;
        protected index__draw: number;
        protected index__puddle: number;
        protected index__sync: number;
        private x_LAST_: number;
        private x_TARGET_: number;
        private y_LAST_: number;
        private y_TARGET_: number;
        public add(): void;
        public remove(): void;
        public toString(): string;
        public update(): void;
        public x(_x: number): void;
        public x(): number;
        public id(): number;
        public id(_id: number): void;
        public set(_x: number, _y: number): void;
        public set(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public reset(): void;
        public static create(): Packages.mindustry.gen.Puddle;
        public as<T>(): T | null;
        public y(_y: number): void;
        public y(): number;
        public self<
          T extends Packages.mindustry.gen.Entityc,
        >(): T | null;
        public amount(): number;
        public amount(_amount: number): void;
        public updateTime(): number;
        public updateTime(_updateTime: number): void;
        public getX(): number;
        public getY(): number;
        public interpolate(): void;
        public trns(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public trns(_x: number, _y: number): void;
        public draw(): void;
        public lastUpdated(): Packages.long;
        public lastUpdated(
          _lastUpdated: Packages.long,
        ): void;
        public updateSpacing(
          _updateSpacing: Packages.long,
        ): void;
        public updateSpacing(): Packages.long;
        public afterRead(): void;
        public isLocal(): boolean;
        public isAdded(): boolean;
        public tileOn(): Packages.mindustry.world.Tile;
        public afterSync(): void;
        public isRemote(): boolean;
        public snapInterpolation(): void;
        public onSolid(): boolean;
        public classId(): number;
        public setIndex__all(_index: number): void;
        public setIndex__draw(_index: number): void;
        public setIndex__sync(_index: number): void;
        public buildOn(): Packages.mindustry.gen.Building;
        public isSyncHidden(
          _player: Packages.mindustry.gen.Player,
        ): boolean;
        public tile(): Packages.mindustry.world.Tile;
        public tile(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public serialize(): boolean;
        public clipSize(): number;
        public tileX(): number;
        public tileY(): number;
        public blockOn(): Packages.mindustry.world.Block;
        public floorOn(): Packages.mindustry.world.blocks.environment.Floor;
        public afterAllRead(): void;
        public handleSyncHidden(): void;
        public readSync(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public readSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public snapSync(): void;
        public writeSync(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public writeSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public getFlammability(): number;
        public liquid(
          _liquid: Packages.mindustry._type.Liquid,
        ): void;
        public liquid(): Packages.mindustry._type.Liquid;
        public effectTime(_effectTime: number): void;
        public effectTime(): number;
        public lastRipple(_lastRipple: number): void;
        public lastRipple(): number;
        public accepting(): number;
        public accepting(_accepting: number): void;
        public setIndex__puddle(_index: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Timedc
        implements
          Packages.arc.math.Scaled,
          Packages.mindustry.gen.Entityc
      {
        public update(): void;
        public time(): number;
        public time(_time: number): void;
        public fin(): number;
        public lifetime(): number;
        public lifetime(_lifetime: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Firec
        implements
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Timedc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Entityc
      {
        public remove(): void;
        public update(): void;
        public draw(): void;
        public afterRead(): void;
        public afterSync(): void;
        public tile(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public tile(): Packages.mindustry.world.Tile;
        public clipSize(): number;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class IndexableEntity__fire {
        public setIndex__fire(_index: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class Fire
        extends java.lang.Object
        implements
          Packages.mindustry.gen.IndexableEntity__all,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Timedc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.IndexableEntity__sync,
          Packages.arc.util.pooling.Pool.Poolable,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Firec,
          Packages.mindustry.gen.IndexableEntity__fire,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.IndexableEntity__draw
      {
        protected static damageDelay: number;
        public static duration: number;
        protected static fireballDelay: number;
        public static frames: number;
        public static regions: Packages.arc.graphics.g2d.TextureRegion[];
        protected static spreadDelay: number;
        protected static ticksPerFrame: number;
        protected static tileDamage: number;
        protected static unitDamage: number;
        protected static warmupDuration: number;
        protected added: boolean;
        protected animation: number;
        protected damageTimer: number;
        protected fireballTimer: number;
        protected index__all: number;
        protected index__draw: number;
        protected index__fire: number;
        protected index__sync: number;
        protected puddleFlammability: number;
        protected spreadTimer: number;
        protected warmup: number;
        private x_LAST_: number;
        private x_TARGET_: number;
        private y_LAST_: number;
        private y_TARGET_: number;
        public add(): void;
        public remove(): void;
        public toString(): string;
        public update(): void;
        public x(_x: number): void;
        public x(): number;
        public id(_id: number): void;
        public id(): number;
        public set(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public set(_x: number, _y: number): void;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public reset(): void;
        public static create(): Packages.mindustry.gen.Fire;
        public as<T>(): T | null;
        public y(): number;
        public y(_y: number): void;
        public time(): number;
        public time(_time: number): void;
        public self<
          T extends Packages.mindustry.gen.Entityc,
        >(): T | null;
        public getX(): number;
        public getY(): number;
        public interpolate(): void;
        public trns(_x: number, _y: number): void;
        public trns(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public draw(): void;
        public fin(): number;
        public lastUpdated(
          _lastUpdated: Packages.long,
        ): void;
        public lastUpdated(): Packages.long;
        public updateSpacing(): Packages.long;
        public updateSpacing(
          _updateSpacing: Packages.long,
        ): void;
        public afterRead(): void;
        public isLocal(): boolean;
        public isAdded(): boolean;
        public tileOn(): Packages.mindustry.world.Tile;
        public afterSync(): void;
        public isRemote(): boolean;
        public snapInterpolation(): void;
        public onSolid(): boolean;
        public classId(): number;
        public setIndex__all(_index: number): void;
        public setIndex__draw(_index: number): void;
        public setIndex__sync(_index: number): void;
        public buildOn(): Packages.mindustry.gen.Building;
        public isSyncHidden(
          _player: Packages.mindustry.gen.Player,
        ): boolean;
        public tile(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public tile(): Packages.mindustry.world.Tile;
        public serialize(): boolean;
        public clipSize(): number;
        public tileX(): number;
        public tileY(): number;
        public blockOn(): Packages.mindustry.world.Block;
        public floorOn(): Packages.mindustry.world.blocks.environment.Floor;
        public afterAllRead(): void;
        public handleSyncHidden(): void;
        public readSync(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public readSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public snapSync(): void;
        public writeSync(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public writeSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public lifetime(): number;
        public lifetime(_lifetime: number): void;
        public setIndex__fire(_index: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare class Tiles
        extends java.lang.Object
        implements
          Packages.java.lang
            .Iterable<Packages.mindustry.world.Tile>
      {
        private TileIterator = class
          extends java.lang.Object
          implements
            Packages.java.util
              .Iterator<Packages.mindustry.world.Tile>
        {
          index: number;
          this$0: Packages.mindustry.world.Tiles;
          public hasNext(): boolean;
          public next(): any;
          public next(): Packages.mindustry.world.Tile;
        };
        public width: number;
        public height: number;
        array: Packages.mindustry.world.Tile[];
        puddles: Packages.mindustry.gen.Puddle[];
        fires: Packages.mindustry.gen.Fire[];
        public get(
          _x: number,
          _y: number,
        ): Packages.mindustry.world.Tile | null;
        public iterator(): Packages.java.util.Iterator<Packages.mindustry.world.Tile>;
        public fill(): void;
        public set(
          _x: number,
          _y: number,
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public in(_x: number, _y: number): boolean;
        public each(_cons: Packages.arc.func.Intc2): void;
        public getPuddle(
          _pos: number,
        ): Packages.mindustry.gen.Puddle;
        public getc(
          _x: number,
          _y: number,
        ): Packages.mindustry.world.Tile;
        public geti(
          _idx: number,
        ): Packages.mindustry.world.Tile;
        public getn(
          _x: number,
          _y: number,
        ): Packages.mindustry.world.Tile;
        public setPuddle(
          _pos: number,
          _p: Packages.mindustry.gen.Puddle,
        ): void;
        public getFire(
          _pos: number,
        ): Packages.mindustry.gen.Fire | null;
        public setFire(
          _pos: number,
          _f: Packages.mindustry.gen.Fire,
        ): void;
        public seti(
          _i: number,
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public getp(
          _pos: number,
        ): Packages.mindustry.world.Tile | null;
        public eachTile(
          _cons: Packages.arc.func.Cons<Packages.mindustry.world.Tile>,
        ): void;
        public constructor(_width: number, _height: number);
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace generators {
        declare abstract class WorldGenerator {
          public generate(
            _tiles: Packages.mindustry.world.Tiles,
          ): void;
          public postGenerate(
            _tiles: Packages.mindustry.world.Tiles,
          ): void;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace generators {
        declare abstract class BasicGenerator
          extends java.lang.Object
          implements
            Packages.mindustry.maps.generators
              .WorldGenerator
        {
          protected static ints1: Packages.arc.struct.ShortSeq;
          protected static ints2: Packages.arc.struct.ShortSeq;
          protected rand: Packages.arc.math.Rand;
          protected width: number;
          protected height: number;
          protected tiles?: Packages.mindustry.world.Tiles;
          protected floor?: Packages.mindustry.world.Block;
          protected block?: Packages.mindustry.world.Block;
          public defaultLoadout: Packages.mindustry.game.Schematic;
          public blend(
            _floor: Packages.mindustry.world.Block,
            _around: Packages.mindustry.world.Block,
            _radius: number,
          ): void;
          public erase(
            _cx: number,
            _cy: number,
            _rad: number,
          ): void;
          public each(_r: Packages.arc.func.Intc2): void;
          protected generate(): void;
          public generate(
            _tiles: Packages.mindustry.world.Tiles,
          ): void;
          public pass(_r: Packages.arc.func.Intc2): void;
          public cells(_iterations: number): void;
          public cells(
            _iterations: number,
            _birthLimit: number,
            _deathLimit: number,
            _cradius: number,
          ): void;
          public near(
            _cx: number,
            _cy: number,
            _rad: number,
            _block: Packages.mindustry.world.Block,
          ): boolean;
          protected noise(
            _x: number,
            _y: number,
            _octaves: number,
            _falloff: number,
            _scl: number,
            _mag: number,
          ): number;
          protected noise(
            _x: number,
            _y: number,
            _octaves: number,
            _falloff: number,
            _scl: number,
          ): number;
          public noise(
            _floor: Packages.mindustry.world.Block,
            _block: Packages.mindustry.world.Block,
            _octaves: number,
            _falloff: number,
            _scl: number,
            _threshold: number,
          ): void;
          protected noise(
            _x: number,
            _y: number,
            _scl: number,
            _mag: number,
          ): number;
          public median(_radius: number): void;
          public median(
            _radius: number,
            _percentile: number,
            _targetFloor: Packages.mindustry.world.Block | null,
          ): void;
          public median(
            _radius: number,
            _percentile: number,
          ): void;
          public overlay(
            _floor: Packages.mindustry.world.Block,
            _block: Packages.mindustry.world.Block,
            _chance: number,
            _octaves: number,
            _falloff: number,
            _scl: number,
            _threshold: number,
          ): void;
          public wallOre(
            _src: Packages.mindustry.world.Block,
            _dest: Packages.mindustry.world.Block,
            _scl: number,
            _thresh: number,
          ): void;
          public ore(
            _dest: Packages.mindustry.world.Block,
            _src: Packages.mindustry.world.Block,
            _i: number,
            _thresh: number,
          ): void;
          public ores(
            _ores: Packages.arc.struct.Seq<Packages.mindustry.world.Block>,
          ): void;
          public decoration(_chance: number): void;
          public tech(
            _floor1: Packages.mindustry.world.Block,
            _floor2: Packages.mindustry.world.Block,
            _wall: Packages.mindustry.world.Block,
          ): void;
          public tech(): void;
          public pathfind(
            _startX: number,
            _startY: number,
            _endX: number,
            _endY: number,
            _th: Packages.mindustry.ai.Astar.TileHueristic,
            _dh: Packages.mindustry.ai.Astar.DistanceHeuristic,
          ): Packages.arc.struct.Seq<Packages.mindustry.world.Tile>;
          public oreAround(
            _ore: Packages.mindustry.world.Block,
            _wall: Packages.mindustry.world.Block,
            _radius: number,
            _scl: number,
            _thresh: number,
          ): void;
          public cliffs(): void;
          public terrain(
            _dst: Packages.mindustry.world.Block,
            _scl: number,
            _mag: number,
            _cmag: number,
          ): void;
          public distort(_scl: number, _mag: number): void;
          public scatter(
            _target: Packages.mindustry.world.Block,
            _dst: Packages.mindustry.world.Block,
            _chance: number,
          ): void;
          public nearWall(_x: number, _y: number): boolean;
          public nearAir(_x: number, _y: number): boolean;
          public removeWall(
            _cx: number,
            _cy: number,
            _rad: number,
            _pred: Packages.arc.func.Boolf<Packages.mindustry.world.Block>,
          ): void;
          public brush(
            _path: Packages.arc.struct.Seq<Packages.mindustry.world.Tile>,
            _rad: number,
          ): void;
          public trimDark(): void;
          public inverseFloodFill(
            _start: Packages.mindustry.world.Tile,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare namespace g3d {
        declare abstract class HexMesher {
          public skip(
            _position: Packages.arc.math.geom.Vec3,
          ): boolean;
          public getHeight(
            _position: Packages.arc.math.geom.Vec3,
          ): number;
          public getColor(
            _position: Packages.arc.math.geom.Vec3,
          ): Packages.arc.graphics.Color;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace lang {
      declare abstract class Cloneable {}
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class BaseDialog extends Packages.arc.scene
          .ui.Dialog {
          protected wasPaused: boolean;
          protected shouldPause: boolean;
          public addCloseButton(_width: number): void;
          public addCloseButton(): void;
          public addCloseListener(): void;
          protected makeButtonOverlay(): void;
          protected onResize(
            _run: Packages.java.lang.Runnable,
          ): void;
          public constructor(
            _title: string,
            _style: Packages.arc.scene.ui.Dialog.DialogStyle,
          );
          public constructor(_title: string);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace filters {
        declare abstract class FilterOption extends java
          .lang.Object {
          static ToggleOption = class extends Packages
            .mindustry.maps.filters.FilterOption {
            name: string;
            getter: Packages.arc.func.Boolp;
            setter: Packages.arc.func.Boolc;
            public build(
              _table: Packages.arc.scene.ui.layout.Table,
            ): void;
          };
          static BlockOption = class extends Packages
            .mindustry.maps.filters.FilterOption {
            name: string;
            supplier: Packages.arc.func.Prov<Packages.mindustry.world.Block>;
            consumer: Packages.arc.func.Cons<Packages.mindustry.world.Block>;
            filter: Packages.arc.func.Boolf<Packages.mindustry.world.Block>;
            public build(
              _table: Packages.arc.scene.ui.layout.Table,
            ): void;
          };
          static SliderOption = class extends Packages
            .mindustry.maps.filters.FilterOption {
            name: string;
            getter: Packages.arc.func.Floatp;
            setter: Packages.arc.func.Floatc;
            min: number;
            max: number;
            step: number;
            display: boolean;
            public build(
              _table: Packages.arc.scene.ui.layout.Table,
            ): void;
            public display(): Packages.mindustry.maps.filters.FilterOption.SliderOption;
          };
          public static floorsOnly: Packages.arc.func.Boolf<Packages.mindustry.world.Block>;
          public static wallsOnly: Packages.arc.func.Boolf<Packages.mindustry.world.Block>;
          public static floorsOptional: Packages.arc.func.Boolf<Packages.mindustry.world.Block>;
          public static wallsOptional: Packages.arc.func.Boolf<Packages.mindustry.world.Block>;
          public static wallsOresOptional: Packages.arc.func.Boolf<Packages.mindustry.world.Block>;
          public static oresOnly: Packages.arc.func.Boolf<Packages.mindustry.world.Block>;
          public static oresFloorsOptional: Packages.arc.func.Boolf<Packages.mindustry.world.Block>;
          public static anyOptional: Packages.arc.func.Boolf<Packages.mindustry.world.Block>;
          public changed: Packages.java.lang.Runnable;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace filters {
        declare abstract class GenerateFilter
          extends java.lang.Object
          implements Packages.java.lang.Cloneable
        {
          public static GenerateInput = class extends java
            .lang.Object {
            public static TileProvider = class {
              public get(
                _x: number,
                _y: number,
              ): Packages.mindustry.world.Tile;
            };
            public x: number;
            public y: number;
            public width: number;
            public height: number;
            public floor: Packages.mindustry.world.Block;
            public block: Packages.mindustry.world.Block;
            public overlay: Packages.mindustry.world.Block;
            buffer: Packages.mindustry.maps.filters.GenerateFilter.GenerateInput.TileProvider;
            public begin(
              _width: number,
              _height: number,
              _buffer: Packages.mindustry.maps.filters.GenerateFilter.GenerateInput.TileProvider,
            ): void;
            public set(
              _x: number,
              _y: number,
              _block: Packages.mindustry.world.Block,
              _floor: Packages.mindustry.world.Block,
              _overlay: Packages.mindustry.world.Block,
            ): void;
            tile(
              _x: number,
              _y: number,
            ): Packages.mindustry.world.Tile;
            public constructor();
          };
          PackTileStruct = class extends java.lang.Object {
            block: Packages.short;
            floor: Packages.short;
            overlay: Packages.short;
            this$0: Packages.mindustry.maps.filters.GenerateFilter;
          };
          public seed: number;
          public name(): string;
          public apply(
            _in: Packages.mindustry.maps.filters.GenerateFilter.GenerateInput,
          ): void;
          public apply(
            _tiles: Packages.mindustry.world.Tiles,
            _in: Packages.mindustry.maps.filters.GenerateFilter.GenerateInput,
          ): void;
          public simpleName(): string;
          public copy(): Packages.mindustry.maps.filters.GenerateFilter;
          public options():
            | Packages.mindustry.maps.filters.FilterOption[]
            | null;
          protected chance(_x: number, _y: number): number;
          public draw(
            _image: Packages.arc.scene.ui.Image,
          ): void;
          public icon(): string;
          protected noise(
            _in: Packages.mindustry.maps.filters.GenerateFilter.GenerateInput,
            _scl: number,
            _mag: number,
          ): number;
          protected noise(
            _in: Packages.mindustry.maps.filters.GenerateFilter.GenerateInput,
            _scl: number,
            _mag: number,
            _octaves: number,
            _persistence: number,
          ): number;
          protected noise(
            _x: number,
            _y: number,
            _scl: number,
            _mag: number,
            _octaves: number,
            _persistence: number,
          ): number;
          protected noise(
            _seedOffset: number,
            _in: Packages.mindustry.maps.filters.GenerateFilter.GenerateInput,
            _scl: number,
            _mag: number,
          ): number;
          public isBuffered(): boolean;
          public randomize(): void;
          public isPost(): boolean;
          protected rnoise(
            _x: number,
            _y: number,
            _octaves: number,
            _scl: number,
            _falloff: number,
            _mag: number,
          ): number;
          protected rnoise(
            _x: number,
            _y: number,
            _scl: number,
            _mag: number,
          ): number;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare class Attributes
          extends java.lang.Object
          implements
            Packages.arc.util.serialization.Json
              .JsonSerializable
        {
          private arr: number[];
          public add(
            _other: Packages.mindustry.world.blocks.Attributes,
            _scl: number,
          ): void;
          public add(
            _other: Packages.mindustry.world.blocks.Attributes,
          ): void;
          public get(
            _attr: Packages.mindustry.world.meta.Attribute,
          ): number;
          public clear(): void;
          public set(
            _attr: Packages.mindustry.world.meta.Attribute,
            _value: number,
          ): void;
          public write(
            _json: Packages.arc.util.serialization.Json,
          ): void;
          public read(
            _json: Packages.arc.util.serialization.Json,
            _data: Packages.arc.util.serialization.JsonValue,
          ): void;
          private check(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Damagec
        implements Packages.mindustry.gen.Entityc
      {
        public damage(): number;
        public damage(_damage: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Ownerc
        implements Packages.mindustry.gen.Entityc
      {
        public owner(): Packages.mindustry.gen.Entityc;
        public owner(
          _owner: Packages.mindustry.gen.Entityc,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Shielderc
        implements
          Packages.mindustry.gen.Damagec,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Entityc
      {
        public absorb(): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Timerc
        implements Packages.mindustry.gen.Entityc
      {
        public timer(): Packages.arc.util.Interval;
        public timer(
          _index: number,
          _time: number,
        ): boolean;
        public timer(
          _timer: Packages.arc.util.Interval,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace part {
        declare abstract class DrawPart extends java.lang
          .Object {
          public static PartParams = class extends java.lang
            .Object {
            public warmup: number;
            public reload: number;
            public smoothReload: number;
            public heat: number;
            public recoil: number;
            public life: number;
            public charge: number;
            public x: number;
            public y: number;
            public rotation: number;
            public sideOverride: number;
            public sideMultiplier: number;
            public set(
              _warmup: number,
              _reload: number,
              _smoothReload: number,
              _heat: number,
              _recoil: number,
              _charge: number,
              _x: number,
              _y: number,
              _rotation: number,
            ): Packages.mindustry.entities.part.DrawPart.PartParams;
            public setRecoil(
              _recoils: number,
            ): Packages.mindustry.entities.part.DrawPart.PartParams;
            public constructor();
          };
          public static PartFunc = class {
            public get(_a: number, _b: number): number;
          };
          public static PartProgress = class {
            public static reload: Packages.mindustry.entities.part.DrawPart.PartProgress;
            public static smoothReload: Packages.mindustry.entities.part.DrawPart.PartProgress;
            public static warmup: Packages.mindustry.entities.part.DrawPart.PartProgress;
            public static charge: Packages.mindustry.entities.part.DrawPart.PartProgress;
            public static recoil: Packages.mindustry.entities.part.DrawPart.PartProgress;
            public static heat: Packages.mindustry.entities.part.DrawPart.PartProgress;
            public static life: Packages.mindustry.entities.part.DrawPart.PartProgress;
            public static time: Packages.mindustry.entities.part.DrawPart.PartProgress;
            public add(
              _amount: number,
            ): Packages.mindustry.entities.part.DrawPart.PartProgress;
            public add(
              _other: Packages.mindustry.entities.part.DrawPart.PartProgress,
            ): Packages.mindustry.entities.part.DrawPart.PartProgress;
            public get(
              _p: Packages.mindustry.entities.part.DrawPart.PartParams,
            ): number;
            public sin(
              _offset: number,
              _scl: number,
              _mag: number,
            ): Packages.mindustry.entities.part.DrawPart.PartProgress;
            public sin(
              _scl: number,
              _mag: number,
            ): Packages.mindustry.entities.part.DrawPart.PartProgress;
            public min(
              _other: Packages.mindustry.entities.part.DrawPart.PartProgress,
            ): Packages.mindustry.entities.part.DrawPart.PartProgress;
            public compress(
              _start: number,
              _end: number,
            ): Packages.mindustry.entities.part.DrawPart.PartProgress;
            public blend(
              _other: Packages.mindustry.entities.part.DrawPart.PartProgress,
              _amount: number,
            ): Packages.mindustry.entities.part.DrawPart.PartProgress;
            public apply(
              _other: Packages.mindustry.entities.part.DrawPart.PartProgress,
              _func: Packages.mindustry.entities.part.DrawPart.PartFunc,
            ): Packages.mindustry.entities.part.DrawPart.PartProgress;
            public static constant(
              _value: number,
            ): Packages.mindustry.entities.part.DrawPart.PartProgress;
            public delay(
              _amount: number,
            ): Packages.mindustry.entities.part.DrawPart.PartProgress;
            public mod(
              _amount: number,
            ): Packages.mindustry.entities.part.DrawPart.PartProgress;
            public loop(
              _time: number,
            ): Packages.mindustry.entities.part.DrawPart.PartProgress;
            public inv(): Packages.mindustry.entities.part.DrawPart.PartProgress;
            public mul(
              _other: Packages.mindustry.entities.part.DrawPart.PartProgress,
            ): Packages.mindustry.entities.part.DrawPart.PartProgress;
            public mul(
              _amount: number,
            ): Packages.mindustry.entities.part.DrawPart.PartProgress;
            public clamp(): Packages.mindustry.entities.part.DrawPart.PartProgress;
            public slope(): Packages.mindustry.entities.part.DrawPart.PartProgress;
            public absin(
              _scl: number,
              _mag: number,
            ): Packages.mindustry.entities.part.DrawPart.PartProgress;
            public curve(
              _offset: number,
              _duration: number,
            ): Packages.mindustry.entities.part.DrawPart.PartProgress;
            public curve(
              _interp: Packages.arc.math.Interp,
            ): Packages.mindustry.entities.part.DrawPart.PartProgress;
            public shorten(
              _amount: number,
            ): Packages.mindustry.entities.part.DrawPart.PartProgress;
            public getClamp(
              _p: Packages.mindustry.entities.part.DrawPart.PartParams,
            ): number;
            public sustain(
              _offset: number,
              _grow: number,
              _sustain: number,
            ): Packages.mindustry.entities.part.DrawPart.PartProgress;
          };
          public static PartMove = class extends java.lang
            .Object {
            public progress: Packages.mindustry.entities.part.DrawPart.PartProgress;
            public x: number;
            public y: number;
            public gx: number;
            public gy: number;
            public rot: number;
            public constructor(
              _progress: Packages.mindustry.entities.part.DrawPart.PartProgress,
              _x: number,
              _y: number,
              _gx: number,
              _gy: number,
              _rot: number,
            );
            public constructor(
              _progress: Packages.mindustry.entities.part.DrawPart.PartProgress,
              _x: number,
              _y: number,
              _rot: number,
            );
            public constructor();
          };
          public static params: Packages.mindustry.entities.part.DrawPart.PartParams;
          public turretShading: boolean;
          public under: boolean;
          public weaponIndex: number;
          public recoilIndex: number;
          public load(_name: string): void;
          public draw(
            _params: Packages.mindustry.entities.part.DrawPart.PartParams,
          ): void;
          public getOutlines(
            _out: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.TextureRegion>,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare abstract class Mover {
        public move(
          _bullet: Packages.mindustry.gen.Bullet,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace bullet {
        declare class BulletType
          extends Packages.mindustry.ctype.Content
          implements Packages.java.lang.Cloneable
        {
          static bulletDamageEvent: Packages.mindustry.game.EventType.UnitDamageEvent;
          public lifetime: number;
          public speed: number;
          public damage: number;
          public hitSize: number;
          public drawSize: number;
          public drag: number;
          public pierce: boolean;
          public pierceBuilding: boolean;
          public pierceCap: number;
          public pierceDamageFactor: number;
          public maxDamageFraction: number;
          public removeAfterPierce: boolean;
          public laserAbsorb: boolean;
          public optimalLifeFract: number;
          public layer: number;
          public hitEffect: Packages.mindustry.entities.Effect;
          public despawnEffect: Packages.mindustry.entities.Effect;
          public shootEffect: Packages.mindustry.entities.Effect;
          public chargeEffect: Packages.mindustry.entities.Effect;
          public smokeEffect: Packages.mindustry.entities.Effect;
          public hitSound: Packages.arc.audio.Sound;
          public despawnSound: Packages.arc.audio.Sound;
          public hitSoundPitch: number;
          public hitSoundVolume: number;
          public inaccuracy: number;
          public ammoMultiplier: number;
          public reloadMultiplier: number;
          public buildingDamageMultiplier: number;
          public recoil: number;
          public killShooter: boolean;
          public instantDisappear: boolean;
          public splashDamage: number;
          public scaledSplashDamage: boolean;
          public knockback: number;
          public impact: boolean;
          public status: Packages.mindustry._type.StatusEffect;
          public statusDuration: number;
          public collidesTiles: boolean;
          public collidesTeam: boolean;
          public collidesAir: boolean;
          public collidesGround: boolean;
          public collides: boolean;
          public collideFloor: boolean;
          public collideTerrain: boolean;
          public keepVelocity: boolean;
          public scaleLife: boolean;
          public hittable: boolean;
          public reflectable: boolean;
          public absorbable: boolean;
          public backMove: boolean;
          public ignoreSpawnAngle: boolean;
          public createChance: number;
          public maxRange: number;
          public rangeOverride: number;
          public rangeChange: number;
          public range: number;
          public healPercent: number;
          public healAmount: number;
          public makeFire: boolean;
          public despawnHit: boolean;
          public fragOnHit: boolean;
          public fragOnAbsorb: boolean;
          public pierceArmor: boolean;
          public setDefaults: boolean;
          public hitShake: number;
          public despawnShake: number;
          public fragBullet?: Packages.mindustry.entities.bullet.BulletType;
          public delayFrags: boolean;
          public fragRandomSpread: number;
          public fragSpread: number;
          public fragAngle: number;
          public fragBullets: number;
          public fragVelocityMin: number;
          public fragVelocityMax: number;
          public fragLifeMin: number;
          public fragLifeMax: number;
          public fragOffsetMin: number;
          public fragOffsetMax: number;
          public pierceFragCap: number;
          public intervalBullet?: Packages.mindustry.entities.bullet.BulletType;
          public bulletInterval: number;
          public intervalBullets: number;
          public intervalRandomSpread: number;
          public intervalSpread: number;
          public intervalAngle: number;
          public intervalDelay: number;
          public hitColor: Packages.arc.graphics.Color;
          public healColor: Packages.arc.graphics.Color;
          public healEffect: Packages.mindustry.entities.Effect;
          public spawnBullets: Packages.arc.struct.Seq<Packages.mindustry.entities.bullet.BulletType>;
          public spawnUnit?: Packages.mindustry._type.UnitType;
          public despawnUnit?: Packages.mindustry._type.UnitType;
          public despawnUnitChance: number;
          public despawnUnitCount: number;
          public despawnUnitRadius: number;
          public faceOutwards: boolean;
          public parts: Packages.arc.struct.Seq<Packages.mindustry.entities.part.DrawPart>;
          public trailColor: Packages.arc.graphics.Color;
          public trailChance: number;
          public trailInterval: number;
          public trailEffect: Packages.mindustry.entities.Effect;
          public trailParam: number;
          public trailRotation: boolean;
          public trailInterp: Packages.arc.math.Interp;
          public trailLength: number;
          public trailWidth: number;
          public trailSinMag: number;
          public trailSinScl: number;
          public splashDamageRadius: number;
          public splashDamagePierce: boolean;
          public incendAmount: number;
          public incendSpread: number;
          public incendChance: number;
          public homingPower: number;
          public homingRange: number;
          public homingDelay: number;
          public suppressionRange: number;
          public suppressionDuration: number;
          public suppressionEffectChance: number;
          public suppressColor: Packages.arc.graphics.Color;
          public lightningColor: Packages.arc.graphics.Color;
          public lightning: number;
          public lightningLength: number;
          public lightningLengthRand: number;
          public lightningDamage: number;
          public lightningCone: number;
          public lightningAngle: number;
          public lightningType?: Packages.mindustry.entities.bullet.BulletType;
          public weaveScale: number;
          public weaveMag: number;
          public weaveRandom: boolean;
          public puddles: number;
          public puddleRange: number;
          public puddleAmount: number;
          public puddleLiquid: Packages.mindustry._type.Liquid;
          public displayAmmoMultiplier: boolean;
          public lightRadius: number;
          public lightOpacity: number;
          public lightColor: Packages.arc.graphics.Color;
          protected cachedDps: number;
          public update(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public load(): void;
          public init(): void;
          public init(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public copy(): Packages.mindustry.entities.bullet.BulletType;
          public create(
            _parent: Packages.mindustry.gen.Bullet,
            _x: number,
            _y: number,
            _angle: number,
            _velocityScl: number,
          ): Packages.mindustry.gen.Bullet | null;
          public create(
            _owner: Packages.mindustry.gen.Entityc | null,
            _team: Packages.mindustry.game.Team,
            _x: number,
            _y: number,
            _angle: number,
            _damage: number,
            _velocityScl: number,
            _lifetimeScl: number,
            _data: any,
          ): Packages.mindustry.gen.Bullet | null;
          public create(
            _owner: Packages.mindustry.gen.Entityc,
            _team: Packages.mindustry.game.Team,
            _x: number,
            _y: number,
            _angle: number,
            _velocityScl: number,
            _lifetimeScl: number,
            _mover: Packages.mindustry.entities.Mover,
          ): Packages.mindustry.gen.Bullet | null;
          public create(
            _owner: Packages.mindustry.gen.Entityc | null,
            _team: Packages.mindustry.game.Team,
            _x: number,
            _y: number,
            _angle: number,
            _damage: number,
            _velocityScl: number,
            _lifetimeScl: number,
            _data: any,
            _mover: Packages.mindustry.entities.Mover | null,
          ): Packages.mindustry.gen.Bullet | null;
          public create(
            _owner: Packages.mindustry.gen.Entityc,
            _team: Packages.mindustry.game.Team,
            _x: number,
            _y: number,
            _angle: number,
            _velocityScl: number,
            _lifetimeScl: number,
          ): Packages.mindustry.gen.Bullet | null;
          public create(
            _owner: Packages.mindustry.gen.Entityc,
            _team: Packages.mindustry.game.Team,
            _x: number,
            _y: number,
            _angle: number,
            _velocityScl: number,
          ): Packages.mindustry.gen.Bullet | null;
          public create(
            _owner: Packages.mindustry.gen.Entityc,
            _team: Packages.mindustry.game.Team,
            _x: number,
            _y: number,
            _angle: number,
          ): Packages.mindustry.gen.Bullet | null;
          public create(
            _owner: Packages.mindustry.gen.Teamc,
            _x: number,
            _y: number,
            _angle: number,
          ): Packages.mindustry.gen.Bullet | null;
          public create(
            _parent: Packages.mindustry.gen.Bullet,
            _x: number,
            _y: number,
            _angle: number,
          ): Packages.mindustry.gen.Bullet | null;
          public create(
            _parent: Packages.mindustry.gen.Bullet,
            _x: number,
            _y: number,
            _angle: number,
            _velocityScl: number,
            _lifeScale: number,
          ): Packages.mindustry.gen.Bullet | null;
          public create(
            _owner: Packages.mindustry.gen.Entityc | null,
            _shooter: Packages.mindustry.gen.Entityc | null,
            _team: Packages.mindustry.game.Team,
            _x: number,
            _y: number,
            _angle: number,
            _damage: number,
            _velocityScl: number,
            _lifetimeScl: number,
            _data: any,
            _mover: Packages.mindustry.entities.Mover | null,
            _aimX: number,
            _aimY: number,
          ): Packages.mindustry.gen.Bullet | null;
          public create(
            _owner: Packages.mindustry.gen.Entityc | null,
            _team: Packages.mindustry.game.Team,
            _x: number,
            _y: number,
            _angle: number,
            _damage: number,
            _velocityScl: number,
            _lifetimeScl: number,
            _data: any,
            _mover: Packages.mindustry.entities.Mover | null,
            _aimX: number,
            _aimY: number,
          ): Packages.mindustry.gen.Bullet | null;
          public removed(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public hit(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public hit(
            _b: Packages.mindustry.gen.Bullet,
            _x: number,
            _y: number,
          ): void;
          protected calculateRange(): number;
          public draw(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public drawLight(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public damageMultiplier(
            _b: Packages.mindustry.gen.Bullet,
          ): number;
          public createNet(
            _team: Packages.mindustry.game.Team,
            _x: number,
            _y: number,
            _angle: number,
            _damage: number,
            _velocityScl: number,
            _lifetimeScl: number,
          ): void;
          public hitEntity(
            _b: Packages.mindustry.gen.Bullet,
            _entity: Packages.mindustry.gen.Hitboxc,
            _health: number,
          ): void;
          public despawned(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public testCollision(
            _bullet: Packages.mindustry.gen.Bullet,
            _tile: Packages.mindustry.gen.Building,
          ): boolean;
          public estimateDPS(): number;
          public handlePierce(
            _b: Packages.mindustry.gen.Bullet,
            _initialHealth: number,
            _x: number,
            _y: number,
          ): void;
          public createFrags(
            _b: Packages.mindustry.gen.Bullet,
            _x: number,
            _y: number,
          ): void;
          public createPuddles(
            _b: Packages.mindustry.gen.Bullet,
            _x: number,
            _y: number,
          ): void;
          public createIncend(
            _b: Packages.mindustry.gen.Bullet,
            _x: number,
            _y: number,
          ): void;
          public createUnits(
            _b: Packages.mindustry.gen.Bullet,
            _x: number,
            _y: number,
          ): void;
          public createSplashDamage(
            _b: Packages.mindustry.gen.Bullet,
            _x: number,
            _y: number,
          ): void;
          public drawParts(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public updateTrail(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public updateHoming(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public updateWeaving(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public updateTrailEffects(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public updateBulletInterval(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public static createBullet(
            _type: Packages.mindustry.entities.bullet.BulletType,
            _team: Packages.mindustry.game.Team,
            _x: number,
            _y: number,
            _angle: number,
            _damage: number,
            _velocityScl: number,
            _lifetimeScl: number,
          ): void;
          public continuousDamage(): number;
          public hitTile(
            _b: Packages.mindustry.gen.Bullet,
            _build: Packages.mindustry.gen.Building,
            _x: number,
            _y: number,
            _initialHealth: number,
            _direct: boolean,
          ): void;
          public drawTrail(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public heals(): boolean;
          public getContentType(): Packages.mindustry.ctype.ContentType;
          public constructor(
            _speed: number,
            _damage: number,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare class Trail extends java.lang.Object {
        public length: number;
        protected points: Packages.arc.struct.FloatSeq;
        protected lastX: number;
        protected lastY: number;
        protected lastAngle: number;
        protected counter: number;
        protected lastW: number;
        public update(_x: number, _y: number): void;
        public update(
          _x: number,
          _y: number,
          _width: number,
        ): void;
        public clear(): void;
        public size(): number;
        public copy(): Packages.mindustry.graphics.Trail;
        public width(): number;
        public draw(
          _color: Packages.arc.graphics.Color,
          _width: number,
        ): void;
        public drawCap(
          _color: Packages.arc.graphics.Color,
          _width: number,
        ): void;
        public shorten(): void;
        public constructor(_length: number);
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Bulletc
        implements
          Packages.mindustry.gen.Damagec,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Timedc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Ownerc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Timerc,
          Packages.mindustry.gen.Shielderc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Velc
      {
        public add(): void;
        public remove(): void;
        public type(
          _type: Packages.mindustry.entities.bullet.BulletType,
        ): void;
        public type(): Packages.mindustry.entities.bullet.BulletType;
        public update(): void;
        public data(): any;
        public data(_data: any): void;
        public trail(
          _trail: Packages.mindustry.graphics.Trail | null,
        ): void;
        public trail(): Packages.mindustry.graphics.Trail | null;
        public keepAlive(): boolean;
        public keepAlive(_keepAlive: boolean): void;
        public hit(_hit: boolean): void;
        public hit(): boolean;
        public draw(): void;
        public originX(): number;
        public originX(_originX: number): void;
        public originY(): number;
        public originY(_originY: number): void;
        public rotation(): number;
        public rotation(_angle: number): void;
        public isLocal(): boolean;
        public clipSize(): number;
        public collision(
          _other: Packages.mindustry.gen.Hitboxc,
          _x: number,
          _y: number,
        ): void;
        public damageMultiplier(): number;
        public aimX(_aimX: number): void;
        public aimX(): number;
        public aimY(): number;
        public aimY(_aimY: number): void;
        public collides(
          _other: Packages.mindustry.gen.Hitboxc,
        ): boolean;
        public getCollisions(
          _consumer: Packages.arc.func.Cons<
            Packages.arc.math.geom.QuadTree<any>
          >,
        ): void;
        public collided(): Packages.arc.struct.IntSeq;
        public collided(
          _collided: Packages.arc.struct.IntSeq,
        ): void;
        public absorbed(_absorbed: boolean): void;
        public absorbed(): boolean;
        public fdata(): number;
        public fdata(_fdata: number): void;
        public frags(): number;
        public frags(_frags: number): void;
        public mover(): Packages.mindustry.entities.Mover | null;
        public mover(
          _mover: Packages.mindustry.entities.Mover | null,
        ): void;
        public aimTile(
          _aimTile: Packages.mindustry.world.Tile | null,
        ): void;
        public aimTile(): Packages.mindustry.world.Tile | null;
        public hasCollided(_id: number): boolean;
        public checkUnderBuild(
          _build: Packages.mindustry.gen.Building,
          _x: number,
          _y: number,
        ): boolean;
        public tileRaycast(
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
        ): void;
        public absorb(): void;
        public initVel(
          _angle: number,
          _amount: number,
        ): void;
        public moveRelative(_x: number, _y: number): void;
        public turn(_x: number, _y: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class IndexableEntity__bullet {
        public setIndex__bullet(_index: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace storage {
          declare class StorageBlock extends Packages
            .mindustry.world.Block {
            public StorageBuild = class extends Packages
              .mindustry.gen.Building {
              public linkedCore?: Packages.mindustry.gen.Building;
              this$0: Packages.mindustry.world.blocks.storage.StorageBlock;
              public getMaximumAccepted(
                _item: Packages.mindustry._type.Item,
              ): number;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public handleItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): void;
              public sense(
                _sensor: Packages.mindustry.logic.LAccess,
              ): number;
              public explosionItemCap(): number;
              public removeStack(
                _item: Packages.mindustry._type.Item,
                _amount: number,
              ): number;
              public canPickup(): boolean;
              public drawSelect(): void;
              public itemTaken(
                _item: Packages.mindustry._type.Item,
              ): void;
              public overwrote(
                _previous: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>,
              ): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.storage.StorageBlock,
              );
            };
            public coreMerge: boolean;
            public static incinerateEffect(
              _self: Packages.mindustry.gen.Building,
              _source: Packages.mindustry.gen.Building,
            ): void;
            public outputsItems(): boolean;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace modules {
        declare abstract class BlockModule extends java.lang
          .Object {
          public write(
            _write: Packages.arc.util.io.Writes,
          ): void;
          public read(
            _read: Packages.arc.util.io.Reads,
          ): void;
          public read(
            _read: Packages.arc.util.io.Reads,
            _legacy: boolean,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare class ItemSeq
        extends java.lang.Object
        implements
          Packages.java.lang
            .Iterable<Packages.mindustry._type.ItemStack>,
          Packages.arc.util.serialization.Json
            .JsonSerializable
      {
        protected values: number[];
        public total: number;
        public add(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): void;
        public add(
          _item: Packages.mindustry._type.Item,
        ): void;
        public add(
          _stacks: Packages.mindustry._type.ItemStack[],
        ): void;
        public add(
          _stack: Packages.mindustry._type.ItemStack,
        ): void;
        public add(
          _seq: Packages.mindustry._type.ItemSeq,
        ): void;
        public add(
          _itemModule: Packages.mindustry.world.modules.ItemModule,
        ): void;
        public remove(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): void;
        public remove(
          _stack: Packages.mindustry._type.ItemStack,
        ): void;
        public remove(
          _item: Packages.mindustry._type.Item,
        ): void;
        public get(
          _item: Packages.mindustry._type.Item,
        ): number;
        public toString(): string;
        public min(_number: number): void;
        public clear(): void;
        public toArray():
          | Packages.mindustry._type.ItemStack[]
          | null;
        public iterator(): Packages.java.util.Iterator<Packages.mindustry._type.ItemStack>;
        public set(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): void;
        public write(
          _json: Packages.arc.util.serialization.Json,
        ): void;
        public read(
          _json: Packages.arc.util.serialization.Json,
          _jsonData: Packages.arc.util.serialization.JsonValue,
        ): void;
        public copy(): Packages.mindustry._type.ItemSeq;
        public each(
          _cons: Packages.mindustry.world.modules.ItemModule.ItemConsumer,
        ): void;
        public has(
          _seq: Packages.mindustry._type.ItemSeq,
        ): boolean;
        public has(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public has(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): boolean;
        public toSeq(): Packages.arc.struct.Seq<Packages.mindustry._type.ItemStack>;
        public checkNegative(): void;
        public constructor();
        public constructor(
          _stacks: Packages.arc.struct.Seq<Packages.mindustry._type.ItemStack>,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace modules {
        declare class ItemModule extends Packages.mindustry
          .world.modules.BlockModule {
          public static ItemConsumer = class {
            public accept(
              _item: Packages.mindustry._type.Item,
              _amount: number,
            ): void;
          };
          public static ItemCalculator = class {
            public get(
              _item: Packages.mindustry._type.Item,
              _amount: number,
            ): number;
          };
          private static windowSize: number;
          private static cacheFlow: Packages.arc.math.WindowedMean[];
          private static cacheSums: number[];
          private static displayFlow: number[];
          private static cacheBits: Packages.arc.struct.Bits;
          private static flowTimer: Packages.arc.util.Interval;
          private static pollScl: number;
          protected items: number[];
          protected takeRotation: number;
          private flow?: Packages.arc.math.WindowedMean[];
          public add(
            _stacks: Packages.java.lang.Iterable<Packages.mindustry._type.ItemStack>,
          ): void;
          public add(
            _stacks: Packages.mindustry._type.ItemSeq,
          ): void;
          public add(
            _item: Packages.mindustry._type.Item,
            _amount: number,
          ): void;
          public add(
            _items: Packages.mindustry.world.modules.ItemModule,
          ): void;
          private add(_item: number, _amount: number): void;
          public remove(
            _stack: Packages.mindustry._type.ItemStack,
          ): void;
          public remove(
            _stacks: Packages.mindustry._type.ItemSeq,
          ): void;
          public remove(
            _stacks: Packages.java.lang.Iterable<Packages.mindustry._type.ItemStack>,
          ): void;
          public remove(
            _item: Packages.mindustry._type.Item,
            _amount: number,
          ): void;
          public remove(
            _stacks: Packages.mindustry._type.ItemStack[],
          ): void;
          public get(
            _item: Packages.mindustry._type.Item,
          ): number;
          public get(_id: number): number;
          public length(): number;
          public toString(): string;
          public clear(): void;
          public empty(): boolean;
          public first(): Packages.mindustry._type.Item | null;
          public set(
            _item: Packages.mindustry._type.Item,
            _amount: number,
          ): void;
          public set(
            _other: Packages.mindustry.world.modules.ItemModule,
          ): void;
          public write(
            _write: Packages.arc.util.io.Writes,
          ): void;
          public read(
            _read: Packages.arc.util.io.Reads,
            _legacy: boolean,
          ): void;
          public copy(): Packages.mindustry.world.modules.ItemModule;
          public total(): number;
          public nextIndex(_takeRotation: number): number;
          public sum(
            _calc: Packages.mindustry.world.modules.ItemModule.ItemCalculator,
          ): number;
          public each(
            _cons: Packages.mindustry.world.modules.ItemModule.ItemConsumer,
          ): void;
          public take(): Packages.mindustry._type.Item | null;
          public has(
            _item: Packages.mindustry._type.Item,
            _amount: number,
          ): boolean;
          public has(
            _stacks: Packages.mindustry._type.ItemStack[],
          ): boolean;
          public has(
            _items: Packages.mindustry._type.ItemSeq,
          ): boolean;
          public has(
            _item: Packages.mindustry._type.Item,
          ): boolean;
          public has(_id: number): boolean;
          public has(
            _stacks: Packages.mindustry._type.ItemStack[],
            _multiplier: number,
          ): boolean;
          public has(
            _stacks: Packages.java.lang.Iterable<Packages.mindustry._type.ItemStack>,
          ): boolean;
          public any(): boolean;
          public getFlowRate(
            _item: Packages.mindustry._type.Item,
          ): number;
          public hasFlowItem(
            _item: Packages.mindustry._type.Item,
          ): boolean;
          public updateFlow(): void;
          public stopFlow(): void;
          public hasOne(
            _stacks: Packages.mindustry._type.ItemStack[],
          ): boolean;
          public takeIndex(
            _takeRotation: number,
          ): Packages.mindustry._type.Item | null;
          public handleFlow(
            _item: Packages.mindustry._type.Item,
            _amount: number,
          ): void;
          public undoFlow(
            _item: Packages.mindustry._type.Item,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare class Bar extends Packages.arc.scene.Element {
        private static scissor: Packages.arc.math.geom.Rect;
        private fraction: Packages.arc.func.Floatp;
        private name: Packages.java.lang.CharSequence;
        private value: number;
        private lastValue: number;
        private outlineRadius: number;
        private blinkColor: Packages.arc.graphics.Color;
        private outlineColor: Packages.arc.graphics.Color;
        public set(
          _name: Packages.arc.func.Prov<string>,
          _fraction: Packages.arc.func.Floatp,
          _color: Packages.arc.graphics.Color,
        ): void;
        public reset(_value: number): void;
        public snap(): void;
        public draw(): void;
        public outline(
          _color: Packages.arc.graphics.Color,
          _stroke: number,
        ): Packages.mindustry.ui.Bar;
        public blink(
          _color: Packages.arc.graphics.Color,
        ): Packages.mindustry.ui.Bar;
        public flash(): void;
        public constructor();
        public constructor(
          _name: Packages.arc.func.Prov<Packages.java.lang.CharSequence>,
          _color: Packages.arc.func.Prov<Packages.arc.graphics.Color>,
          _fraction: Packages.arc.func.Floatp,
        );
        public constructor(
          _name: string,
          _color: Packages.arc.graphics.Color,
          _fraction: Packages.arc.func.Floatp,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace storage {
          declare class CoreBlock extends Packages.mindustry
            .world.blocks.storage.StorageBlock {
            public CoreBuild = class extends Packages
              .mindustry.gen.Building {
              public storageCapacity: number;
              public noEffect: boolean;
              public lastDamage: Packages.mindustry.game.Team;
              public iframes: number;
              public thrusterTime: number;
              protected cloudSeed: number;
              this$0: Packages.mindustry.world.blocks.storage.CoreBlock;
              public created(): void;
              public owns(
                _core: Packages.mindustry.gen.Building,
                _tile: Packages.mindustry.gen.Building,
              ): boolean;
              public owns(
                _tile: Packages.mindustry.gen.Building,
              ): boolean;
              public draw(): void;
              public requestSpawn(
                _player: Packages.mindustry.gen.Player,
              ): void;
              public getMaximumAccepted(
                _item: Packages.mindustry._type.Item,
              ): number;
              public damage(
                _source: Packages.mindustry.game.Team | null,
                _damage: number,
              ): void;
              public damage(_amount: number): void;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public handleItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): void;
              public sense(
                _sensor: Packages.mindustry.logic.LAccess,
              ): number;
              public onDestroyed(): void;
              public afterDestroyed(): void;
              public handleStack(
                _item: Packages.mindustry._type.Item,
                _amount: number,
                _source: Packages.mindustry.gen.Teamc,
              ): void;
              public removeStack(
                _item: Packages.mindustry._type.Item,
                _amount: number,
              ): number;
              public updateTile(): void;
              public onProximityUpdate(): void;
              public onRemoved(): void;
              public changeTeam(
                _next: Packages.mindustry.game.Team,
              ): void;
              public beginLaunch(
                _launchType: Packages.mindustry.world.blocks.storage.CoreBlock | null,
              ): void;
              public endLaunch(): void;
              public zoomLaunching(): number;
              public updateLaunching(): void;
              public placed(): void;
              public canControlSelect(
                _player: Packages.mindustry.gen.Unit,
              ): boolean;
              public canPickup(): boolean;
              public drawLight(): void;
              public drawSelect(): void;
              public itemTaken(
                _item: Packages.mindustry._type.Item,
              ): void;
              public onControlSelect(
                _unit: Packages.mindustry.gen.Unit,
              ): void;
              public landDuration(): number;
              public landMusic(): Packages.arc.audio.Music;
              public launchMusic(): Packages.arc.audio.Music;
              public drawThrusters(_frame: number): void;
              public drawLanding(
                _block: Packages.mindustry.world.blocks.storage.CoreBlock,
              ): void;
              public updateLandParticles(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.storage.CoreBlock,
              );
            };
            protected static cloudScaling: number;
            protected static cfinScl: number;
            protected static cfinOffset: number;
            protected static calphaFinOffset: number;
            protected static cloudAlpha: number;
            protected static cloudAlphas: number[];
            private static nextItems: Packages.mindustry.world.modules.ItemModule;
            protected static thrusterSizes: number[];
            public thruster1: Packages.arc.graphics.g2d.TextureRegion;
            public thruster2: Packages.arc.graphics.g2d.TextureRegion;
            public thrusterLength: number;
            public isFirstTier: boolean;
            public requiresCoreZone: boolean;
            public incinerateNonBuildable: boolean;
            public unitType: Packages.mindustry._type.UnitType;
            public landDuration: number;
            public landMusic: Packages.arc.audio.Music;
            public launchMusic: Packages.arc.audio.Music;
            public launchEffect: Packages.mindustry.entities.Effect;
            public landZoomInterp: Packages.arc.math.Interp;
            public landZoomFrom: number;
            public landZoomTo: number;
            public captureInvicibility: number;
            public init(): void;
            public setBars(): void;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public canPlaceOn(
              _tile: Packages.mindustry.world.Tile,
              _team: Packages.mindustry.game.Team,
              _rotation: number,
            ): boolean;
            public canBreak(
              _tile: Packages.mindustry.world.Tile,
            ): boolean;
            public canReplace(
              _other: Packages.mindustry.world.Block,
            ): boolean;
            public beforePlaceBegan(
              _tile: Packages.mindustry.world.Tile,
              _previous: Packages.mindustry.world.Block,
            ): void;
            public setStats(): void;
            public placeBegan(
              _tile: Packages.mindustry.world.Tile,
              _previous: Packages.mindustry.world.Block,
              _builder: Packages.mindustry.gen.Unit,
            ): void;
            public drawLanding(
              _build: Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild,
              _x: number,
              _y: number,
            ): void;
            public static playerSpawn(
              _tile: Packages.mindustry.world.Tile,
              _player: Packages.mindustry.gen.Player,
            ): void;
            protected drawLandingThrusters(
              _x: number,
              _y: number,
              _rotation: number,
              _frame: number,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class Bullet
        extends java.lang.Object
        implements
          Packages.mindustry.gen.Damagec,
          Packages.mindustry.gen.Timedc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Ownerc,
          Packages.mindustry.gen.Bulletc,
          Packages.mindustry.gen.IndexableEntity__draw,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.IndexableEntity__all,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Timerc,
          Packages.mindustry.gen.IndexableEntity__bullet,
          Packages.arc.util.pooling.Pool.Poolable,
          Packages.mindustry.gen.Shielderc,
          Packages.mindustry.gen.Entityc
      {
        protected added: boolean;
        protected index__all: number;
        protected index__bullet: number;
        protected index__draw: number;
        public add(): void;
        public remove(): void;
        public type(): Packages.mindustry.entities.bullet.BulletType;
        public type(
          _type: Packages.mindustry.entities.bullet.BulletType,
        ): void;
        public toString(): string;
        public update(): void;
        public x(): number;
        public x(_x: number): void;
        public data(_data: any): void;
        public data(): any;
        public id(_id: number): void;
        public id(): number;
        public set(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public set(_x: number, _y: number): void;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public owner(): Packages.mindustry.gen.Entityc;
        public owner(
          _owner: Packages.mindustry.gen.Entityc,
        ): void;
        public reset(): void;
        public static create(): Packages.mindustry.gen.Bullet;
        public as<T>(): T | null;
        public y(): number;
        public y(_y: number): void;
        public time(_time: number): void;
        public time(): number;
        public self<
          T extends Packages.mindustry.gen.Entityc,
        >(): T | null;
        public move(_cx: number, _cy: number): void;
        public move(_v: Packages.arc.math.geom.Vec2): void;
        public trail(
          _trail: Packages.mindustry.graphics.Trail,
        ): void;
        public trail(): Packages.mindustry.graphics.Trail;
        public keepAlive(): boolean;
        public keepAlive(_keepAlive: boolean): void;
        public hit(_hit: boolean): void;
        public hit(): boolean;
        public getX(): number;
        public getY(): number;
        public trns(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public trns(_x: number, _y: number): void;
        public draw(): void;
        public deltaX(_deltaX: number): void;
        public deltaX(): number;
        public deltaY(): number;
        public deltaY(_deltaY: number): void;
        public originX(_originX: number): void;
        public originX(): number;
        public originY(): number;
        public originY(_originY: number): void;
        public rotation(_angle: number): void;
        public rotation(): number;
        public timer(
          _index: number,
          _time: number,
        ): boolean;
        public timer(): Packages.arc.util.Interval;
        public timer(
          _timer: Packages.arc.util.Interval,
        ): void;
        public lastX(): number;
        public lastX(_lastX: number): void;
        public lastY(_lastY: number): void;
        public lastY(): number;
        public fin(): number;
        public vel(_vel: Packages.arc.math.geom.Vec2): void;
        public vel(): Packages.arc.math.geom.Vec2;
        public hitbox(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public drag(): number;
        public drag(_drag: number): void;
        public team(): Packages.mindustry.game.Team;
        public team(
          _team: Packages.mindustry.game.Team,
        ): void;
        public afterRead(): void;
        public core(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public isLocal(): boolean;
        public isAdded(): boolean;
        public tileOn(): Packages.mindustry.world.Tile;
        public hitSize(): number;
        public hitSize(_hitSize: number): void;
        public closestCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public inFogTo(
          _viewer: Packages.mindustry.game.Team,
        ): boolean;
        public isRemote(): boolean;
        public onSolid(): boolean;
        public classId(): number;
        public setIndex__all(_index: number): void;
        public setIndex__draw(_index: number): void;
        public buildOn(): Packages.mindustry.gen.Building;
        public damage(): number;
        public damage(_damage: number): void;
        public closestEnemyCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public cheating(): boolean;
        public serialize(): boolean;
        public clipSize(): number;
        public tileX(): number;
        public tileY(): number;
        public blockOn(): Packages.mindustry.world.Block;
        public floorOn(): Packages.mindustry.world.blocks.environment.Floor;
        public afterAllRead(): void;
        public collision(
          _other: Packages.mindustry.gen.Hitboxc,
          _x: number,
          _y: number,
        ): void;
        public damageMultiplier(): number;
        public lifetime(): number;
        public lifetime(_lifetime: number): void;
        public aimX(): number;
        public aimX(_aimX: number): void;
        public aimY(): number;
        public aimY(_aimY: number): void;
        public collides(
          _other: Packages.mindustry.gen.Hitboxc,
        ): boolean;
        public deltaAngle(): number;
        public deltaLen(): number;
        public getCollisions(
          _consumer: Packages.arc.func.Cons<
            Packages.arc.math.geom.QuadTree<any>
          >,
        ): void;
        public hitboxTile(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public updateLastPosition(): void;
        public solidity(): Packages.mindustry.entities.EntityCollisions.SolidPred;
        public canPassOn(): boolean;
        public canPass(
          _tileX: number,
          _tileY: number,
        ): boolean;
        public moving(): boolean;
        public velAddNet(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public velAddNet(_vx: number, _vy: number): void;
        public collided(
          _collided: Packages.arc.struct.IntSeq,
        ): void;
        public collided(): Packages.arc.struct.IntSeq;
        public absorbed(_absorbed: boolean): void;
        public absorbed(): boolean;
        public fdata(_fdata: number): void;
        public fdata(): number;
        public frags(): number;
        public frags(_frags: number): void;
        public mover(): Packages.mindustry.entities.Mover;
        public mover(
          _mover: Packages.mindustry.entities.Mover,
        ): void;
        public aimTile(): Packages.mindustry.world.Tile;
        public aimTile(
          _aimTile: Packages.mindustry.world.Tile,
        ): void;
        public hasCollided(_id: number): boolean;
        public checkUnderBuild(
          _build: Packages.mindustry.gen.Building,
          _x: number,
          _y: number,
        ): boolean;
        public tileRaycast(
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
        ): void;
        public setIndex__bullet(_index: number): void;
        public absorb(): void;
        public initVel(
          _angle: number,
          _amount: number,
        ): void;
        public moveRelative(_x: number, _y: number): void;
        public turn(_x: number, _y: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace units {
        declare abstract class UnitController {
          public removed(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public unit(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public unit(): Packages.mindustry.gen.Unit;
          public hit(
            _bullet: Packages.mindustry.gen.Bullet,
          ): void;
          public afterRead(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public isLogicControllable(): boolean;
          public isValidController(): boolean;
          public updateUnit(): void;
          public isBeingControlled(
            _player: Packages.mindustry.gen.Unit,
          ): boolean;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace abilities {
        declare abstract class Ability
          extends java.lang.Object
          implements Packages.java.lang.Cloneable
        {
          protected static descriptionWidth: number;
          public display: boolean;
          public data: number;
          public update(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public init(
            _type: Packages.mindustry._type.UnitType,
          ): void;
          public copy(): Packages.mindustry.entities.abilities.Ability;
          public localized(): string;
          public getBundle(): string;
          public death(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public draw(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public displayBars(
            _unit: Packages.mindustry.gen.Unit,
            _bars: Packages.arc.scene.ui.layout.Table,
          ): void;
          public addStats(
            _t: Packages.arc.scene.ui.layout.Table,
          ): void;
          public abilityStat(
            _stat: string,
            ..._values: any[]
          ): string;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace pattern {
        declare class ShootPattern
          extends java.lang.Object
          implements Packages.java.lang.Cloneable
        {
          public static BulletHandler = class {
            public shoot(
              _x: number,
              _y: number,
              _rotation: number,
              _delay: number,
            ): void;
            public shoot(
              _x: number,
              _y: number,
              _rotation: number,
              _delay: number,
              _move: Packages.mindustry.entities.Mover,
            ): void;
          };
          public shots: number;
          public firstShotDelay: number;
          public shotDelay: number;
          public copy(): Packages.mindustry.entities.pattern.ShootPattern;
          public flip(): void;
          public shoot(
            _totalShots: number,
            _handler: Packages.mindustry.entities.pattern.ShootPattern.BulletHandler,
            _barrelIncrementer: Packages.java.lang.Runnable | null,
          ): void;
          public shoot(
            _totalShots: number,
            _handler: Packages.mindustry.entities.pattern.ShootPattern.BulletHandler,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace audio {
      declare class SoundLoop extends java.lang.Object {
        private static fadeSpeed: number;
        private sound: Packages.arc.audio.Sound;
        private id: number;
        private volume: number;
        private baseVolume: number;
        public update(
          _x: number,
          _y: number,
          _play: boolean,
          _volumeScl: number,
        ): void;
        public update(
          _x: number,
          _y: number,
          _play: boolean,
        ): void;
        public stop(): void;
        public constructor(
          _sound: Packages.arc.audio.Sound,
          _baseVolume: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace units {
        declare class WeaponMount extends java.lang.Object {
          public weapon: Packages.mindustry._type.Weapon;
          public reload: number;
          public rotation: number;
          public recoil: number;
          public recoils?: number[];
          public targetRotation: number;
          public heat: number;
          public warmup: number;
          public charging: boolean;
          public charge: number;
          public smoothReload: number;
          public aimX: number;
          public aimY: number;
          public shoot: boolean;
          public rotate: boolean;
          public side: boolean;
          public totalShots: number;
          public barrelCounter: number;
          public lastLength: number;
          public bullet?: Packages.mindustry.gen.Bullet;
          public sound?: Packages.mindustry.audio.SoundLoop;
          public target?: Packages.mindustry.gen.Teamc;
          public retarget: number;
          public constructor(
            _weapon: Packages.mindustry._type.Weapon,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare class Weapon
        extends java.lang.Object
        implements Packages.java.lang.Cloneable
      {
        public name: string;
        public ejectEffect: Packages.mindustry.entities.Effect;
        public display: boolean;
        public useAmmo: boolean;
        public mirror: boolean;
        public flipSprite: boolean;
        public alternate: boolean;
        public rotate: boolean;
        public showStatSprite: boolean;
        public baseRotation: number;
        public top: boolean;
        public continuous: boolean;
        public alwaysContinuous: boolean;
        public aimChangeSpeed: number;
        public controllable: boolean;
        public aiControllable: boolean;
        public alwaysShooting: boolean;
        public autoTarget: boolean;
        public predictTarget: boolean;
        public useAttackRange: boolean;
        public targetInterval: number;
        public targetSwitchInterval: number;
        public rotateSpeed: number;
        public reload: number;
        public inaccuracy: number;
        public shake: number;
        public recoil: number;
        public recoils: number;
        public recoilTime: number;
        public recoilPow: number;
        public cooldownTime: number;
        public shootX: number;
        public shootY: number;
        public x: number;
        public y: number;
        public xRand: number;
        public shadow: number;
        public velocityRnd: number;
        public shootCone: number;
        public rotationLimit: number;
        public minWarmup: number;
        public shootWarmupSpeed: number;
        public smoothReloadSpeed: number;
        public linearWarmup: boolean;
        public soundPitchMin: number;
        public soundPitchMax: number;
        public ignoreRotation: boolean;
        public noAttack: boolean;
        public minShootVelocity: number;
        public parentizeEffects: boolean;
        public otherSide: number;
        public layerOffset: number;
        public shootSound: Packages.arc.audio.Sound;
        public chargeSound: Packages.arc.audio.Sound;
        public noAmmoSound: Packages.arc.audio.Sound;
        public region: Packages.arc.graphics.g2d.TextureRegion;
        public heatRegion: Packages.arc.graphics.g2d.TextureRegion;
        public cellRegion: Packages.arc.graphics.g2d.TextureRegion;
        public outlineRegion: Packages.arc.graphics.g2d.TextureRegion;
        public heatColor: Packages.arc.graphics.Color;
        public shootStatus: Packages.mindustry._type.StatusEffect;
        public mountType: Packages.arc.func.Func<
          Packages.mindustry._type.Weapon,
          Packages.mindustry.entities.units.WeaponMount
        >;
        public shootStatusDuration: number;
        public shootOnDeath: boolean;
        public parts: Packages.arc.struct.Seq<Packages.mindustry.entities.part.DrawPart>;
        public toString(): string;
        public update(
          _unit: Packages.mindustry.gen.Unit,
          _mount: Packages.mindustry.entities.units.WeaponMount,
        ): void;
        public load(): void;
        public init(): void;
        public copy(): Packages.mindustry._type.Weapon;
        public flip(): void;
        public range(): number;
        public draw(
          _unit: Packages.mindustry.gen.Unit,
          _mount: Packages.mindustry.entities.units.WeaponMount,
        ): void;
        protected bullet(
          _unit: Packages.mindustry.gen.Unit,
          _mount: Packages.mindustry.entities.units.WeaponMount,
          _xOffset: number,
          _yOffset: number,
          _angleOffset: number,
          _mover: Packages.mindustry.entities.Mover,
        ): void;
        protected findTarget(
          _unit: Packages.mindustry.gen.Unit,
          _x: number,
          _y: number,
          _range: number,
          _air: boolean,
          _ground: boolean,
        ): Packages.mindustry.gen.Teamc;
        protected checkTarget(
          _unit: Packages.mindustry.gen.Unit,
          _target: Packages.mindustry.gen.Teamc,
          _x: number,
          _y: number,
          _range: number,
        ): boolean;
        public dps(): number;
        protected shoot(
          _unit: Packages.mindustry.gen.Unit,
          _mount: Packages.mindustry.entities.units.WeaponMount,
          _shootX: number,
          _shootY: number,
          _rotation: number,
        ): void;
        public drawOutline(
          _unit: Packages.mindustry.gen.Unit,
          _mount: Packages.mindustry.entities.units.WeaponMount,
        ): void;
        protected bulletRotation(
          _unit: Packages.mindustry.gen.Unit,
          _mount: Packages.mindustry.entities.units.WeaponMount,
          _bulletX: number,
          _bulletY: number,
        ): number;
        protected handleBullet(
          _unit: Packages.mindustry.gen.Unit,
          _mount: Packages.mindustry.entities.units.WeaponMount,
          _bullet: Packages.mindustry.gen.Bullet,
        ): void;
        public hasStats(
          _u: Packages.mindustry._type.UnitType,
        ): boolean;
        public shotsPerSec(): number;
        public addStats(
          _u: Packages.mindustry._type.UnitType,
          _t: Packages.arc.scene.ui.layout.Table,
        ): void;
        public constructor(_name: string);
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace meta {
        declare class BlockFlag extends Packages.java.lang
          .Enum<Packages.mindustry.world.meta.BlockFlag> {
          public static core: Packages.mindustry.world.meta.BlockFlag;
          public static storage: Packages.mindustry.world.meta.BlockFlag;
          public static generator: Packages.mindustry.world.meta.BlockFlag;
          public static turret: Packages.mindustry.world.meta.BlockFlag;
          public static factory: Packages.mindustry.world.meta.BlockFlag;
          public static repair: Packages.mindustry.world.meta.BlockFlag;
          public static battery: Packages.mindustry.world.meta.BlockFlag;
          public static reactor: Packages.mindustry.world.meta.BlockFlag;
          public static extinguisher: Packages.mindustry.world.meta.BlockFlag;
          public static drill: Packages.mindustry.world.meta.BlockFlag;
          public static launchPad: Packages.mindustry.world.meta.BlockFlag;
          public static unitCargoUnloadPoint: Packages.mindustry.world.meta.BlockFlag;
          public static unitAssembler: Packages.mindustry.world.meta.BlockFlag;
          public static hasFogRadius: Packages.mindustry.world.meta.BlockFlag;
          public static all: Packages.mindustry.world.meta.BlockFlag[];
          public static allLogic: Packages.mindustry.world.meta.BlockFlag[];
          private static $VALUES: Packages.mindustry.world.meta.BlockFlag[];
          public static values():
            | Packages.mindustry.world.meta.BlockFlag[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.mindustry.world.meta.BlockFlag;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace units {
        declare class AIController
          extends java.lang.Object
          implements
            Packages.mindustry.entities.units.UnitController
        {
          protected static vec: Packages.arc.math.geom.Vec2;
          protected static rotateBackTimer: number;
          protected static timerTarget: number;
          protected static timerTarget2: number;
          protected static timerTarget3: number;
          protected static timerTarget4: number;
          protected timer: Packages.arc.util.Interval;
          protected noTargetTime: number;
          public target(
            _x: number,
            _y: number,
            _range: number,
            _air: boolean,
            _ground: boolean,
          ): Packages.mindustry.gen.Teamc;
          public init(): void;
          public fallback(): Packages.mindustry.entities.units.AIController | null;
          public unit(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public unit(): Packages.mindustry.gen.Unit;
          public invalid(
            _target: Packages.mindustry.gen.Teamc,
          ): boolean;
          public circle(
            _target: Packages.arc.math.geom.Position,
            _circleLength: number,
          ): void;
          public circle(
            _target: Packages.arc.math.geom.Position,
            _circleLength: number,
            _speed: number,
          ): void;
          public moveTo(
            _target: Packages.arc.math.geom.Position,
            _circleLength: number,
            _smooth: number,
          ): void;
          public moveTo(
            _target: Packages.arc.math.geom.Position,
            _circleLength: number,
            _smooth: number,
            _keepDistance: boolean,
            _offset: Packages.arc.math.geom.Vec2 | null,
            _arrive: boolean,
          ): void;
          public moveTo(
            _target: Packages.arc.math.geom.Position,
            _circleLength: number,
            _smooth: number,
            _keepDistance: boolean,
            _offset: Packages.arc.math.geom.Vec2 | null,
          ): void;
          public moveTo(
            _target: Packages.arc.math.geom.Position,
            _circleLength: number,
          ): void;
          public afterRead(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public isLogicControllable(): boolean;
          public updateUnit(): void;
          public findTarget(
            _x: number,
            _y: number,
            _range: number,
            _air: boolean,
            _ground: boolean,
          ): Packages.mindustry.gen.Teamc;
          public commandPosition(
            _pos: Packages.arc.math.geom.Vec2,
          ): void;
          public commandTarget(
            _moveTo: Packages.mindustry.gen.Teamc,
          ): void;
          public checkTarget(
            _target: Packages.mindustry.gen.Teamc,
            _x: number,
            _y: number,
            _range: number,
          ): boolean;
          public pathfind(_pathTarget: number): void;
          public faceTarget(): void;
          public retarget(): boolean;
          public useFallback(): boolean;
          public updateVisuals(): void;
          public updateTargeting(): void;
          public updateMovement(): void;
          public updateWeapons(): void;
          public prefSpeed(): number;
          public findMainTarget(
            _x: number,
            _y: number,
            _range: number,
            _air: boolean,
            _ground: boolean,
          ): Packages.mindustry.gen.Teamc;
          public shouldShoot(): boolean;
          public shouldFire(): boolean;
          public keepState(): boolean;
          public stopShooting(): void;
          public faceMovement(): void;
          public targetFlag(
            _x: number,
            _y: number,
            _flag: Packages.mindustry.world.meta.BlockFlag,
            _enemy: boolean,
          ): Packages.mindustry.gen.Teamc;
          public getClosestSpawner(): Packages.mindustry.world.Tile | null;
          public unloadPayloads(): void;
          public circleAttack(_circleLength: number): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace input {
      declare class Binding
        extends Packages.java.lang
          .Enum<Packages.mindustry.input.Binding>
        implements Packages.arc.KeyBinds.KeyBind
      {
        public static move_x: Packages.mindustry.input.Binding;
        public static move_y: Packages.mindustry.input.Binding;
        public static mouse_move: Packages.mindustry.input.Binding;
        public static pan: Packages.mindustry.input.Binding;
        public static boost: Packages.mindustry.input.Binding;
        public static respawn: Packages.mindustry.input.Binding;
        public static control: Packages.mindustry.input.Binding;
        public static select: Packages.mindustry.input.Binding;
        public static deselect: Packages.mindustry.input.Binding;
        public static break_block: Packages.mindustry.input.Binding;
        public static pickupCargo: Packages.mindustry.input.Binding;
        public static dropCargo: Packages.mindustry.input.Binding;
        public static clear_building: Packages.mindustry.input.Binding;
        public static pause_building: Packages.mindustry.input.Binding;
        public static rotate: Packages.mindustry.input.Binding;
        public static rotateplaced: Packages.mindustry.input.Binding;
        public static diagonal_placement: Packages.mindustry.input.Binding;
        public static pick: Packages.mindustry.input.Binding;
        public static rebuild_select: Packages.mindustry.input.Binding;
        public static schematic_select: Packages.mindustry.input.Binding;
        public static schematic_flip_x: Packages.mindustry.input.Binding;
        public static schematic_flip_y: Packages.mindustry.input.Binding;
        public static schematic_menu: Packages.mindustry.input.Binding;
        public static command_mode: Packages.mindustry.input.Binding;
        public static command_queue: Packages.mindustry.input.Binding;
        public static create_control_group: Packages.mindustry.input.Binding;
        public static select_all_units: Packages.mindustry.input.Binding;
        public static select_all_unit_factories: Packages.mindustry.input.Binding;
        public static cancel_orders: Packages.mindustry.input.Binding;
        public static unit_stance_shoot: Packages.mindustry.input.Binding;
        public static unit_stance_hold_fire: Packages.mindustry.input.Binding;
        public static unit_stance_pursue_target: Packages.mindustry.input.Binding;
        public static unit_stance_patrol: Packages.mindustry.input.Binding;
        public static unit_stance_ram: Packages.mindustry.input.Binding;
        public static unit_command_move: Packages.mindustry.input.Binding;
        public static unit_command_repair: Packages.mindustry.input.Binding;
        public static unit_command_rebuild: Packages.mindustry.input.Binding;
        public static unit_command_assist: Packages.mindustry.input.Binding;
        public static unit_command_mine: Packages.mindustry.input.Binding;
        public static unit_command_boost: Packages.mindustry.input.Binding;
        public static unit_command_enter_payload: Packages.mindustry.input.Binding;
        public static unit_command_load_units: Packages.mindustry.input.Binding;
        public static unit_command_load_blocks: Packages.mindustry.input.Binding;
        public static unit_command_unload_payload: Packages.mindustry.input.Binding;
        public static category_prev: Packages.mindustry.input.Binding;
        public static category_next: Packages.mindustry.input.Binding;
        public static block_select_left: Packages.mindustry.input.Binding;
        public static block_select_right: Packages.mindustry.input.Binding;
        public static block_select_up: Packages.mindustry.input.Binding;
        public static block_select_down: Packages.mindustry.input.Binding;
        public static block_select_01: Packages.mindustry.input.Binding;
        public static block_select_02: Packages.mindustry.input.Binding;
        public static block_select_03: Packages.mindustry.input.Binding;
        public static block_select_04: Packages.mindustry.input.Binding;
        public static block_select_05: Packages.mindustry.input.Binding;
        public static block_select_06: Packages.mindustry.input.Binding;
        public static block_select_07: Packages.mindustry.input.Binding;
        public static block_select_08: Packages.mindustry.input.Binding;
        public static block_select_09: Packages.mindustry.input.Binding;
        public static block_select_10: Packages.mindustry.input.Binding;
        public static zoom: Packages.mindustry.input.Binding;
        public static menu: Packages.mindustry.input.Binding;
        public static fullscreen: Packages.mindustry.input.Binding;
        public static pause: Packages.mindustry.input.Binding;
        public static minimap: Packages.mindustry.input.Binding;
        public static research: Packages.mindustry.input.Binding;
        public static planet_map: Packages.mindustry.input.Binding;
        public static block_info: Packages.mindustry.input.Binding;
        public static toggle_menus: Packages.mindustry.input.Binding;
        public static screenshot: Packages.mindustry.input.Binding;
        public static toggle_power_lines: Packages.mindustry.input.Binding;
        public static toggle_block_status: Packages.mindustry.input.Binding;
        public static player_list: Packages.mindustry.input.Binding;
        public static chat: Packages.mindustry.input.Binding;
        public static chat_history_prev: Packages.mindustry.input.Binding;
        public static chat_history_next: Packages.mindustry.input.Binding;
        public static chat_scroll: Packages.mindustry.input.Binding;
        public static chat_mode: Packages.mindustry.input.Binding;
        public static console: Packages.mindustry.input.Binding;
        private static $VALUES: Packages.mindustry.input.Binding[];
        public static values():
          | Packages.mindustry.input.Binding[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.mindustry.input.Binding;
        public defaultValue(
          _type: Packages.arc.input.InputDevice.DeviceType,
        ): Packages.arc.KeyBinds.KeybindValue;
        public category(): string;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare class UnitCommand extends Packages.mindustry
        .ctype.MappableContent {
        public static all: Packages.arc.struct.Seq<Packages.mindustry.ai.UnitCommand>;
        public static moveCommand: Packages.mindustry.ai.UnitCommand;
        public static repairCommand: Packages.mindustry.ai.UnitCommand;
        public static rebuildCommand: Packages.mindustry.ai.UnitCommand;
        public static assistCommand: Packages.mindustry.ai.UnitCommand;
        public static mineCommand: Packages.mindustry.ai.UnitCommand;
        public static boostCommand: Packages.mindustry.ai.UnitCommand;
        public static enterPayloadCommand: Packages.mindustry.ai.UnitCommand;
        public static loadUnitsCommand: Packages.mindustry.ai.UnitCommand;
        public static loadBlocksCommand: Packages.mindustry.ai.UnitCommand;
        public static unloadPayloadCommand: Packages.mindustry.ai.UnitCommand;
        public icon: string;
        public controller: Packages.arc.func.Func<
          Packages.mindustry.gen.Unit,
          Packages.mindustry.entities.units.AIController
        >;
        public switchToMove: boolean;
        public drawTarget: boolean;
        public resetTarget: boolean;
        public exactArrival: boolean;
        public keybind?: Packages.mindustry.input.Binding;
        public toString(): string;
        public localized(): string;
        public getIcon(): Packages.arc.scene.style.TextureRegionDrawable;
        public getEmoji(): string;
        public static loadAll(): void;
        public getContentType(): Packages.mindustry.ctype.ContentType;
        public constructor(
          _name: string,
          _icon: string,
          _controller: Packages.arc.func.Func<
            Packages.mindustry.gen.Unit,
            Packages.mindustry.entities.units.AIController
          >,
        );
        public constructor(
          _name: string,
          _icon: string,
          _keybind: Packages.mindustry.input.Binding,
          _controller: Packages.arc.func.Func<
            Packages.mindustry.gen.Unit,
            Packages.mindustry.entities.units.AIController
          >,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare class UnitStance extends Packages.mindustry
        .ctype.MappableContent {
        public static all: Packages.arc.struct.Seq<Packages.mindustry.ai.UnitStance>;
        public static stop: Packages.mindustry.ai.UnitStance;
        public static shoot: Packages.mindustry.ai.UnitStance;
        public static holdFire: Packages.mindustry.ai.UnitStance;
        public static pursueTarget: Packages.mindustry.ai.UnitStance;
        public static patrol: Packages.mindustry.ai.UnitStance;
        public static ram: Packages.mindustry.ai.UnitStance;
        public icon: string;
        public keybind?: Packages.mindustry.input.Binding;
        public toString(): string;
        public localized(): string;
        public getIcon(): Packages.arc.scene.style.TextureRegionDrawable;
        public getEmoji(): string;
        public static loadAll(): void;
        public getContentType(): Packages.mindustry.ctype.ContentType;
        public constructor(
          _name: string,
          _icon: string,
          _keybind: Packages.mindustry.input.Binding,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare abstract class AmmoType {
        public color(): Packages.arc.graphics.Color;
        public icon(): string;
        public barColor(): Packages.arc.graphics.Color;
        public resupply(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Minerc
        implements
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Itemsc
      {
        public update(): void;
        public mining(): boolean;
        public mineTimer(): number;
        public mineTimer(_mineTimer: number): void;
        public mineTile(): Packages.mindustry.world.Tile | null;
        public mineTile(
          _mineTile: Packages.mindustry.world.Tile | null,
        ): void;
        public canMine(): boolean;
        public canMine(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public offloadImmediately(): boolean;
        public validMine(
          _tile: Packages.mindustry.world.Tile,
          _checkDst: boolean,
        ): boolean;
        public validMine(
          _tile: Packages.mindustry.world.Tile,
        ): boolean;
        public getMineResult(
          _tile: Packages.mindustry.world.Tile,
        ): Packages.mindustry._type.Item;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Physicsc
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc,
          Packages.mindustry.gen.Velc
      {
        public physref(
          _physref: Packages.mindustry.async.PhysicsProcess.PhysicRef,
        ): void;
        public physref(): Packages.mindustry.async.PhysicsProcess.PhysicRef;
        public mass(): number;
        public impulse(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public impulse(_x: number, _y: number): void;
        public impulseNet(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Shieldc
        implements
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public update(): void;
        public damage(_amount: number): void;
        public armor(): number;
        public armor(_armor: number): void;
        public damagePierce(
          _amount: number,
          _withEffect: boolean,
        ): void;
        public shield(): number;
        public shield(_shield: number): void;
        public shieldAlpha(): number;
        public shieldAlpha(_shieldAlpha: number): void;
        public rawDamage(_amount: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Weaponsc
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc,
          Packages.mindustry.gen.Velc
      {
        public remove(): void;
        public update(): void;
        public aim(_x: number, _y: number): void;
        public aim(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public controlWeapons(_rotateShoot: boolean): void;
        public controlWeapons(
          _rotate: boolean,
          _shoot: boolean,
        ): void;
        public ammo(): number;
        public ammo(_ammo: number): void;
        public mounts(
          _mounts: Packages.mindustry.entities.units.WeaponMount[],
        ): void;
        public mounts():
          | Packages.mindustry.entities.units.WeaponMount[]
          | null;
        public isShooting(_isShooting: boolean): void;
        public isShooting(): boolean;
        public aimX(): number;
        public aimX(_aimX: number): void;
        public aimY(): number;
        public aimY(_aimY: number): void;
        public canShoot(): boolean;
        public isRotate(): boolean;
        public ammof(): number;
        public setWeaponRotation(_rotation: number): void;
        public setupWeapons(
          _def: Packages.mindustry._type.UnitType,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare abstract class Ranged
        implements
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Teamc
      {
        public range(): number;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare abstract class Settable {
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: number,
        ): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: any,
        ): void;
        public setProp(
          _content: Packages.mindustry.ctype.UnlockableContent,
          _value: number,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace payloads {
          declare abstract class Payload
            implements Packages.arc.math.geom.Position
          {
            public static payloadUnit: number;
            public static payloadBlock: number;
            public destroyed(): void;
            public update(
              _unitHolder: Packages.mindustry.gen.Unit | null,
              _buildingHolder: Packages.mindustry.gen.Building | null,
            ): void;
            public size(): number;
            public x(): number;
            public set(
              _x: number,
              _y: number,
              _rotation: number,
            ): void;
            public write(
              _write: Packages.arc.util.io.Writes,
            ): void;
            public static write(
              _payload: Packages.mindustry.world.blocks.payloads.Payload | null,
              _write: Packages.arc.util.io.Writes,
            ): void;
            public static read<
              T extends
                Packages.mindustry.world.blocks.payloads.Payload,
            >(_read: Packages.arc.util.io.Reads): T | null;
            public y(): number;
            public content(): Packages.mindustry.ctype.UnlockableContent;
            public getX(): number;
            public getY(): number;
            public draw(): void;
            public rotation(): number;
            public icon(): Packages.arc.graphics.g2d.TextureRegion;
            public dump(): boolean;
            public drawShadow(_alpha: number): void;
            public requirements():
              | Packages.mindustry._type.ItemStack[]
              | null;
            public buildTime(): number;
            public fits(_s: number): boolean;
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace payloads {
          declare class UnitPayload
            extends java.lang.Object
            implements
              Packages.mindustry.world.blocks.payloads
                .Payload
          {
            public static overlayDuration: number;
            public unit: Packages.mindustry.gen.Unit;
            public overlayTime: number;
            public overlayRegion?: Packages.arc.graphics.g2d.TextureRegion;
            public update(
              _unitHolder: Packages.mindustry.gen.Unit | null,
              _buildingHolder: Packages.mindustry.gen.Building | null,
            ): void;
            public size(): number;
            public x(): number;
            public set(
              _x: number,
              _y: number,
              _rotation: number,
            ): void;
            public write(
              _write: Packages.arc.util.io.Writes,
            ): void;
            public y(): number;
            public content(): Packages.mindustry.ctype.UnlockableContent;
            public draw(): void;
            public rotation(): number;
            public icon(): Packages.arc.graphics.g2d.TextureRegion;
            public dump(): boolean;
            public drawShadow(_alpha: number): void;
            public requirements():
              | Packages.mindustry._type.ItemStack[]
              | null;
            public buildTime(): number;
            public showOverlay(
              _icon: Packages.arc.scene.style.TextureRegionDrawable,
            ): void;
            public showOverlay(
              _icon: Packages.arc.graphics.g2d.TextureRegion,
            ): void;
            public constructor(
              _unit: Packages.mindustry.gen.Unit,
            );
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare class UnitGroup extends java.lang.Object {
        public units: Packages.arc.struct.Seq<Packages.mindustry.gen.Unit>;
        public collisionLayer: number;
        public positions: number[];
        public originalPositions: number[];
        public valid: boolean;
        private updateRaycast(
          _index: number,
          _dest: Packages.arc.math.geom.Vec2,
          _v1: Packages.arc.math.geom.Vec2,
        ): void;
        public updateRaycast(
          _index: number,
          _dest: Packages.arc.math.geom.Vec2,
        ): void;
        public calculateFormation(
          _dest: Packages.arc.math.geom.Vec2,
          _collisionLayer: number,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare namespace _types {
        declare class CommandAI extends Packages.mindustry
          .entities.units.AIController {
          protected static maxCommandQueueSize: number;
          protected static avoidInterval: number;
          protected static vecOut: Packages.arc.math.geom.Vec2;
          protected static vecMovePos: Packages.arc.math.geom.Vec2;
          protected static noFound: boolean[];
          protected static tmpPayload: Packages.mindustry.world.blocks.payloads.UnitPayload;
          public targetPos?: Packages.arc.math.geom.Vec2;
          public attackTarget?: Packages.mindustry.gen.Teamc;
          public group?: Packages.mindustry.ai.UnitGroup;
          public groupIndex: number;
          public unreachableBuildings: Packages.arc.struct.IntSeq;
          public readAttackTarget: number;
          protected stopAtTarget: boolean;
          protected stopWhenInRange: boolean;
          protected lastTargetPos: Packages.arc.math.geom.Vec2;
          protected blockingUnit: boolean;
          protected timeSpentBlocked: number;
          public stance: Packages.mindustry.ai.UnitStance;
          protected commandController?: Packages.mindustry.entities.units.AIController;
          protected lastCommand?: Packages.mindustry.ai.UnitCommand;
          public command(
            _command: Packages.mindustry.ai.UnitCommand,
          ): void;
          public hit(
            _bullet: Packages.mindustry.gen.Bullet,
          ): void;
          public afterRead(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public isLogicControllable(): boolean;
          public updateUnit(): void;
          public hasCommand(): boolean;
          public isAttacking(): boolean;
          public findTarget(
            _x: number,
            _y: number,
            _range: number,
            _air: boolean,
            _ground: boolean,
          ): Packages.mindustry.gen.Teamc;
          public commandPosition(
            _pos: Packages.arc.math.geom.Vec2,
          ): void;
          public commandPosition(
            _pos: Packages.arc.math.geom.Vec2,
            _stopWhenInRange: boolean,
          ): void;
          public commandTarget(
            _moveTo: Packages.mindustry.gen.Teamc,
          ): void;
          public commandTarget(
            _moveTo: Packages.mindustry.gen.Teamc,
            _stopAtTarget: boolean,
          ): void;
          public retarget(): boolean;
          public shouldFire(): boolean;
          public keepState(): boolean;
          public defaultBehavior(): void;
          public commandQueue(
            _location: Packages.arc.math.geom.Position,
          ): void;
          public nearAttackTarget(
            _x: number,
            _y: number,
            _range: number,
          ): boolean;
          finishPath(): void;
          public currentCommand(): Packages.mindustry.ai.UnitCommand;
          public clearCommands(): void;
          public setupLastPos(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Unitc
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.logic.Ranged,
          Packages.mindustry.ui.Displayable,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.logic.Settable,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.logic.Senseable,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public add(): void;
        public remove(): void;
        public type(): Packages.mindustry._type.UnitType;
        public type(
          _type: Packages.mindustry._type.UnitType,
        ): void;
        public toString(): string;
        public update(): void;
        public count(): number;
        public bounds(): number;
        public set(
          _def: Packages.mindustry._type.UnitType,
          _controller: Packages.mindustry.entities.units.UnitController,
        ): void;
        public destroy(): void;
        public cap(): number;
        public flag(_flag: number): void;
        public flag(): number;
        public command(): Packages.mindustry.ai._types.CommandAI;
        public display(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public range(): number;
        public inRange(
          _other: Packages.arc.math.geom.Position,
        ): boolean;
        public trail(): Packages.mindustry.graphics.Trail | null;
        public trail(
          _trail: Packages.mindustry.graphics.Trail | null,
        ): void;
        public approach(
          _vector: Packages.arc.math.geom.Vec2,
        ): void;
        public speed(): number;
        public draw(): void;
        public controller(
          _next: Packages.mindustry.entities.units.UnitController,
        ): void;
        public controller(): Packages.mindustry.entities.units.UnitController;
        public icon(): Packages.arc.graphics.g2d.TextureRegion;
        public lookAt(_x: number, _y: number): void;
        public lookAt(_angle: number): void;
        public lookAt(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public afterRead(): void;
        public isPlayer(): boolean;
        public inFogTo(
          _viewer: Packages.mindustry.game.Team,
        ): boolean;
        public afterSync(): void;
        public resetController(): void;
        public canLand(): boolean;
        public isSyncHidden(
          _player: Packages.mindustry.gen.Player,
        ): boolean;
        public sense(
          _content: Packages.mindustry.ctype.Content,
        ): number;
        public sense(
          _sensor: Packages.mindustry.logic.LAccess,
        ): number;
        public getPlayer(): Packages.mindustry.gen.Player;
        public heal(_amount: number): void;
        public itemCapacity(): number;
        public clipSize(): number;
        public afterAllRead(): void;
        public handleSyncHidden(): void;
        public killed(): void;
        public displayable(): boolean;
        public isCommandable(): boolean;
        public isPathImpassable(
          _tileX: number,
          _tileY: number,
        ): boolean;
        public collision(
          _other: Packages.mindustry.gen.Hitboxc,
          _x: number,
          _y: number,
        ): void;
        public senseObject(
          _sensor: Packages.mindustry.logic.LAccess,
        ): any;
        public kill(): void;
        public setProp(
          _content: Packages.mindustry.ctype.UnlockableContent,
          _value: number,
        ): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: any,
        ): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: number,
        ): void;
        public targetable(
          _targeter: Packages.mindustry.game.Team,
        ): boolean;
        public isAI(): boolean;
        public isEnemy(): boolean;
        public abilities():
          | Packages.mindustry.entities.abilities.Ability[]
          | null;
        public abilities(
          _abilities: Packages.mindustry.entities.abilities.Ability[],
        ): void;
        public shadowAlpha(_shadowAlpha: number): void;
        public shadowAlpha(): number;
        public spawnedByCore(_spawnedByCore: boolean): void;
        public spawnedByCore(): boolean;
        public healTime(): number;
        public healTime(_healTime: number): void;
        public lastFogPos(): number;
        public lastFogPos(_lastFogPos: number): void;
        public lastCommanded(_lastCommanded: string): void;
        public lastCommanded(): string;
        public dockedType(): Packages.mindustry._type.UnitType | null;
        public dockedType(
          _dockedType: Packages.mindustry._type.UnitType | null,
        ): void;
        public canDrown(): boolean;
        public landed(): void;
        public moveAt(
          _vector: Packages.arc.math.geom.Vec2,
        ): void;
        public collides(
          _other: Packages.mindustry.gen.Hitboxc,
        ): boolean;
        public isImmune(
          _effect: Packages.mindustry._type.StatusEffect,
        ): boolean;
        public physicSize(): number;
        public getControllerName(): string;
        public pathType(): number;
        public collisionLayer(): number;
        public prefRotation(): number;
        public unloaded(): void;
        public movePref(
          _movement: Packages.arc.math.geom.Vec2,
        ): void;
        public canShoot(): boolean;
        public canTarget(
          _other: Packages.mindustry.gen.Unit,
        ): boolean;
        public hasWeapons(): boolean;
        public hittable(): boolean;
        public aimLook(_x: number, _y: number): void;
        public aimLook(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public rotateMove(
          _vec: Packages.arc.math.geom.Vec2,
        ): void;
        public updateBoosting(_boost: boolean): void;
        public setType(
          _type: Packages.mindustry._type.UnitType,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace payloads {
          declare class BuildPayload
            extends java.lang.Object
            implements
              Packages.mindustry.world.blocks.payloads
                .Payload
          {
            public build: Packages.mindustry.gen.Building;
            public destroyed(): void;
            public update(
              _unitHolder: Packages.mindustry.gen.Unit | null,
              _buildingHolder: Packages.mindustry.gen.Building | null,
            ): void;
            public size(): number;
            public x(): number;
            public set(
              _x: number,
              _y: number,
              _rotation: number,
            ): void;
            public write(
              _write: Packages.arc.util.io.Writes,
            ): void;
            public y(): number;
            public block(): Packages.mindustry.world.Block;
            public content(): Packages.mindustry.ctype.UnlockableContent;
            public draw(): void;
            public icon(): Packages.arc.graphics.g2d.TextureRegion;
            public drawShadow(_alpha: number): void;
            public place(
              _tile: Packages.mindustry.world.Tile,
            ): void;
            public place(
              _tile: Packages.mindustry.world.Tile,
              _rotation: number,
            ): void;
            public requirements():
              | Packages.mindustry._type.ItemStack[]
              | null;
            public buildTime(): number;
            public constructor(
              _block: Packages.mindustry.world.Block,
              _team: Packages.mindustry.game.Team,
            );
            public constructor(
              _build: Packages.mindustry.gen.Building,
            );
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Payloadc
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public update(): void;
        public destroy(): void;
        public payloads(): Packages.arc.struct.Seq<Packages.mindustry.world.blocks.payloads.Payload>;
        public payloads(
          _payloads: Packages.arc.struct.Seq<Packages.mindustry.world.blocks.payloads.Payload>,
        ): void;
        public canPickup(
          _unit: Packages.mindustry.gen.Unit,
        ): boolean;
        public canPickup(
          _build: Packages.mindustry.gen.Building,
        ): boolean;
        public pickup(
          _tile: Packages.mindustry.gen.Building,
        ): void;
        public pickup(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public hasPayload(): boolean;
        public payloadUsed(): number;
        public contentInfo(
          _table: Packages.arc.scene.ui.layout.Table,
          _itemSize: number,
          _width: number,
        ): void;
        public dropLastPayload(): boolean;
        public dropBlock(
          _payload: Packages.mindustry.world.blocks.payloads.BuildPayload,
        ): boolean;
        public canPickupPayload(
          _pay: Packages.mindustry.world.blocks.payloads.Payload,
        ): boolean;
        public dropUnit(
          _payload: Packages.mindustry.world.blocks.payloads.UnitPayload,
        ): boolean;
        public tryDropPayload(
          _payload: Packages.mindustry.world.blocks.payloads.Payload,
        ): boolean;
        public addPayload(
          _load: Packages.mindustry.world.blocks.payloads.Payload,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class ElevationMovec
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc,
          Packages.mindustry.gen.Velc
      {
        public solidity(): Packages.mindustry.entities.EntityCollisions.SolidPred;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Mechc
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.ElevationMovec,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public update(): void;
        public approach(
          _vector: Packages.arc.math.geom.Vec2,
        ): void;
        public baseRotation(_baseRotation: number): void;
        public baseRotation(): number;
        public drownFloor(): Packages.mindustry.world.blocks.environment.Floor;
        public moveAt(
          _vector: Packages.arc.math.geom.Vec2,
          _acceleration: number,
        ): void;
        public rotateMove(
          _vec: Packages.arc.math.geom.Vec2,
        ): void;
        public walkExtend(_scaled: boolean): number;
        public walkExtension(_walkExtension: number): void;
        public walkExtension(): number;
        public walkTime(_walkTime: number): void;
        public walkTime(): number;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Tankc
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.ElevationMovec,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public update(): void;
        public approach(
          _vector: Packages.arc.math.geom.Vec2,
        ): void;
        public floorSpeedMultiplier(): number;
        public drownFloor(): Packages.mindustry.world.blocks.environment.Floor;
        public moveAt(
          _vector: Packages.arc.math.geom.Vec2,
          _acceleration: number,
        ): void;
        public treadTime(_treadTime: number): void;
        public treadTime(): number;
        public walked(_walked: boolean): void;
        public walked(): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare class Leg extends java.lang.Object {
        public joint: Packages.arc.math.geom.Vec2;
        public base: Packages.arc.math.geom.Vec2;
        public group: number;
        public moving: boolean;
        public stage: number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Legsc
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public add(): void;
        public update(): void;
        public destroy(): void;
        public totalLength(): number;
        public totalLength(_totalLength: number): void;
        public baseRotation(_baseRotation: number): void;
        public baseRotation(): number;
        public drownFloor(): Packages.mindustry.world.blocks.environment.Floor;
        public solidity(): Packages.mindustry.entities.EntityCollisions.SolidPred;
        public pathType(): number;
        public unloaded(): void;
        public legOffset(
          _out: Packages.arc.math.geom.Vec2,
          _index: number,
        ): Packages.arc.math.geom.Vec2;
        public legs(
          _legs: Packages.mindustry.entities.Leg[],
        ): void;
        public legs():
          | Packages.mindustry.entities.Leg[]
          | null;
        public lastDeepFloor(
          _lastDeepFloor: Packages.mindustry.world.blocks.environment.Floor,
        ): void;
        public lastDeepFloor(): Packages.mindustry.world.blocks.environment.Floor;
        public legAngle(_index: number): number;
        public curMoveOffset(): Packages.arc.math.geom.Vec2;
        public curMoveOffset(
          _curMoveOffset: Packages.arc.math.geom.Vec2,
        ): void;
        public defaultLegAngle(_index: number): number;
        public moveSpace(_moveSpace: number): void;
        public moveSpace(): number;
        public resetLegs(_legLength: number): void;
        public resetLegs(): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Crawlc
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public add(): void;
        public update(): void;
        public floorSpeedMultiplier(): number;
        public drownFloor(): Packages.mindustry.world.blocks.environment.Floor;
        public solidity(): Packages.mindustry.entities.EntityCollisions.SolidPred;
        public pathType(): number;
        public crawlTime(_crawlTime: number): void;
        public crawlTime(): number;
        public segmentRot(_segmentRot: number): void;
        public segmentRot(): number;
        public lastCrawlSlowdown(
          _lastCrawlSlowdown: number,
        ): void;
        public lastCrawlSlowdown(): number;
        public lastDeepFloor(): Packages.mindustry.world.blocks.environment.Floor;
        public lastDeepFloor(
          _lastDeepFloor: Packages.mindustry.world.blocks.environment.Floor,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare class PayloadStack
        extends java.lang.Object
        implements
          Packages.java.lang
            .Comparable<Packages.mindustry._type.PayloadStack>
      {
        public item: Packages.mindustry.ctype.UnlockableContent;
        public amount: number;
        public equals(_o: any): boolean;
        public toString(): string;
        public compareTo(
          _stack: Packages.mindustry._type.PayloadStack,
        ): number;
        public compareTo(_stack: any): number;
        public static list(
          ..._items: any[]
        ): Packages.arc.struct.Seq<Packages.mindustry._type.PayloadStack>;
        public static with(
          ..._items: any[]
        ): Packages.mindustry._type.PayloadStack[] | null;
        public constructor();
        public constructor(
          _item: Packages.mindustry.ctype.UnlockableContent,
        );
        public constructor(
          _item: Packages.mindustry.ctype.UnlockableContent,
          _amount: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace consumers {
        declare abstract class Consume extends java.lang
          .Object {
          public booster: boolean;
          public multiplier: Packages.arc.func.Floatf<Packages.mindustry.gen.Building>;
          public update(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public update(
            _update: boolean,
          ): Packages.mindustry.world.consumers.Consume;
          public trigger(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public apply(
            _block: Packages.mindustry.world.Block,
          ): void;
          public ignore(): boolean;
          public build(
            _build: Packages.mindustry.gen.Building,
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public optional(
            _optional: boolean,
            _boost: boolean,
          ): Packages.mindustry.world.consumers.Consume;
          public display(
            _stats: Packages.mindustry.world.meta.Stats,
          ): void;
          public efficiency(
            _build: Packages.mindustry.gen.Building,
          ): number;
          public efficiencyMultiplier(
            _build: Packages.mindustry.gen.Building,
          ): number;
          public boost(): Packages.mindustry.world.consumers.Consume;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare class UnitType
        extends Packages.mindustry.ctype.UnlockableContent
        implements Packages.mindustry.logic.Senseable
      {
        public static UnitEngine = class
          extends java.lang.Object
          implements Packages.java.lang.Cloneable
        {
          public x: number;
          public y: number;
          public radius: number;
          public rotation: number;
          public copy(): Packages.mindustry._type.UnitType.UnitEngine;
          public draw(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public constructor(
            _x: number,
            _y: number,
            _radius: number,
            _rotation: number,
          );
          public constructor();
        };
        public static shadowTX: number;
        public static shadowTY: number;
        private static legOffset: Packages.arc.math.geom.Vec2;
        public envRequired: number;
        public envEnabled: number;
        public envDisabled: number;
        public speed: number;
        public boostMultiplier: number;
        public rotateSpeed: number;
        public baseRotateSpeed: number;
        public drag: number;
        public accel: number;
        public hitSize: number;
        public stepShake: number;
        public rippleScale: number;
        public riseSpeed: number;
        public fallSpeed: number;
        public missileAccelTime: number;
        public health: number;
        public armor: number;
        public range: number;
        public maxRange: number;
        public mineRange: number;
        public buildRange: number;
        public crashDamageMultiplier: number;
        public dpsEstimate: number;
        public clipSize: number;
        public drownTimeMultiplier: number;
        public strafePenalty: number;
        public researchCostMultiplier: number;
        public groundLayer: number;
        public payloadCapacity: number;
        public buildSpeed: number;
        public aimDst: number;
        public buildBeamOffset: number;
        public targetPriority: number;
        public shadowElevation: number;
        public shadowElevationScl: number;
        public engineOffset: number;
        public engineSize: number;
        public engineLayer: number;
        public itemOffsetY: number;
        public lightRadius: number;
        public lightOpacity: number;
        public fogRadius: number;
        public waveTrailX: number;
        public waveTrailY: number;
        public trailScl: number;
        public isEnemy: boolean;
        public flying: boolean;
        public wobble: boolean;
        public targetAir: boolean;
        public targetGround: boolean;
        public faceTarget: boolean;
        public circleTarget: boolean;
        public canBoost: boolean;
        public logicControllable: boolean;
        public playerControllable: boolean;
        public allowedInPayloads: boolean;
        public killable: boolean;
        public vulnerableWithPayloads: boolean;
        public pickupUnits: boolean;
        public physics: boolean;
        public canDrown: boolean;
        public useUnitCap: boolean;
        public coreUnitDock: boolean;
        public createWreck: boolean;
        public createScorch: boolean;
        public lowAltitude: boolean;
        public rotateToBuilding: boolean;
        public allowLegStep: boolean;
        public legPhysicsLayer: boolean;
        public hovering: boolean;
        public omniMovement: boolean;
        public rotateMoveFirst: boolean;
        public healFlash: boolean;
        public canHeal: boolean;
        public singleTarget: boolean;
        public forceMultiTarget: boolean;
        public canAttack: boolean;
        public hidden: boolean;
        public internal: boolean;
        public bounded: boolean;
        public naval: boolean;
        public autoFindTarget: boolean;
        public targetUnderBlocks: boolean;
        public alwaysShootWhenMoving: boolean;
        public hoverable: boolean;
        public alwaysCreateOutline: boolean;
        public squareShape: boolean;
        public drawBuildBeam: boolean;
        public drawShields: boolean;
        public drawMinimap: boolean;
        public aiController: Packages.arc.func.Prov<any>;
        public controller: Packages.arc.func.Func<
          Packages.mindustry.gen.Unit,
          any
        >;
        public _constructor: Packages.arc.func.Prov<any>;
        public abilities: Packages.arc.struct.Seq<Packages.mindustry.entities.abilities.Ability>;
        public weapons: Packages.arc.struct.Seq<Packages.mindustry._type.Weapon>;
        public immunities: Packages.arc.struct.ObjectSet<Packages.mindustry._type.StatusEffect>;
        public healColor: Packages.arc.graphics.Color;
        public lightColor: Packages.arc.graphics.Color;
        public deathSound: Packages.arc.audio.Sound;
        public loopSound: Packages.arc.audio.Sound;
        public loopSoundVolume: number;
        public fallEffect: Packages.mindustry.entities.Effect;
        public fallEngineEffect: Packages.mindustry.entities.Effect;
        public deathExplosionEffect: Packages.mindustry.entities.Effect;
        public treadEffect?: Packages.mindustry.entities.Effect;
        public parts: Packages.arc.struct.Seq<Packages.mindustry.entities.part.DrawPart>;
        public engines: Packages.arc.struct.Seq<Packages.mindustry._type.UnitType.UnitEngine>;
        public useEngineElevation: boolean;
        public engineColor?: Packages.arc.graphics.Color;
        public engineColorInner: Packages.arc.graphics.Color;
        public trailLength: number;
        public trailColor?: Packages.arc.graphics.Color;
        public pathCost?: Packages.mindustry.ai.Pathfinder.PathCost;
        public pathCostId: number;
        public sample?: Packages.mindustry.gen.Unit;
        public targetFlags: Packages.mindustry.world.meta.BlockFlag[];
        public commands: Packages.mindustry.ai.UnitCommand[];
        public defaultCommand?: Packages.mindustry.ai.UnitCommand;
        public stances: Packages.mindustry.ai.UnitStance[];
        public outlineColor: Packages.arc.graphics.Color;
        public outlineRadius: number;
        public outlines: boolean;
        public itemCapacity: number;
        public ammoCapacity: number;
        public ammoType: Packages.mindustry._type.AmmoType;
        public mineTier: number;
        public mineSpeed: number;
        public mineWalls: boolean;
        public mineFloor: boolean;
        public mineHardnessScaling: boolean;
        public mineSound: Packages.arc.audio.Sound;
        public mineSoundVolume: number;
        public mineItems: Packages.arc.struct.Seq<Packages.mindustry._type.Item>;
        public legCount: number;
        public legGroupSize: number;
        public legLength: number;
        public legSpeed: number;
        public legForwardScl: number;
        public legBaseOffset: number;
        public legMoveSpace: number;
        public legExtension: number;
        public legPairOffset: number;
        public legLengthScl: number;
        public legStraightLength: number;
        public legMaxLength: number;
        public legMinLength: number;
        public legSplashDamage: number;
        public legSplashRange: number;
        public baseLegStraightness: number;
        public legStraightness: number;
        public lockLegBase: boolean;
        public legContinuousMove: boolean;
        public flipBackLegs: boolean;
        public flipLegSide: boolean;
        public mechLandShake: number;
        public mechSideSway: number;
        public mechFrontSway: number;
        public mechStride: number;
        public mechStepParticles: boolean;
        public mechLegColor: Packages.arc.graphics.Color;
        public treadRects: Packages.arc.math.geom.Rect[];
        public treadFrames: number;
        public treadPullOffset: number;
        public segments: number;
        public segmentMag: number;
        public segmentScl: number;
        public segmentPhase: number;
        public segmentRotSpeed: number;
        public segmentMaxRot: number;
        public crawlSlowdown: number;
        public crushDamage: number;
        public crawlSlowdownFrac: number;
        public lifetime: number;
        public homingDelay: number;
        public baseRegion: Packages.arc.graphics.g2d.TextureRegion;
        public legRegion: Packages.arc.graphics.g2d.TextureRegion;
        public region: Packages.arc.graphics.g2d.TextureRegion;
        public previewRegion: Packages.arc.graphics.g2d.TextureRegion;
        public shadowRegion: Packages.arc.graphics.g2d.TextureRegion;
        public cellRegion: Packages.arc.graphics.g2d.TextureRegion;
        public itemCircleRegion: Packages.arc.graphics.g2d.TextureRegion;
        public softShadowRegion: Packages.arc.graphics.g2d.TextureRegion;
        public jointRegion: Packages.arc.graphics.g2d.TextureRegion;
        public footRegion: Packages.arc.graphics.g2d.TextureRegion;
        public legBaseRegion: Packages.arc.graphics.g2d.TextureRegion;
        public baseJointRegion: Packages.arc.graphics.g2d.TextureRegion;
        public outlineRegion: Packages.arc.graphics.g2d.TextureRegion;
        public treadRegion: Packages.arc.graphics.g2d.TextureRegion;
        public mineLaserRegion: Packages.arc.graphics.g2d.TextureRegion;
        public mineLaserEndRegion: Packages.arc.graphics.g2d.TextureRegion;
        public wreckRegions: Packages.arc.graphics.g2d.TextureRegion[];
        public segmentRegions: Packages.arc.graphics.g2d.TextureRegion[];
        public segmentOutlineRegions: Packages.arc.graphics.g2d.TextureRegion[];
        public treadRegions: Packages.arc.graphics.g2d.TextureRegion[][];
        protected buildTime: number;
        protected totalRequirements?: Packages.mindustry._type.ItemStack[];
        protected cachedRequirements?: Packages.mindustry._type.ItemStack[];
        protected firstRequirements?: Packages.mindustry._type.ItemStack[];
        public isHidden(): boolean;
        public update(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public load(): void;
        public init(): void;
        public create(
          _team: Packages.mindustry.game.Team,
        ): Packages.mindustry.gen.Unit;
        public display(
          _unit: Packages.mindustry.gen.Unit,
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public draw(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public getDependencies(
          _cons: Packages.arc.func.Cons<Packages.mindustry.ctype.UnlockableContent>,
        ): void;
        public researchRequirements():
          | Packages.mindustry._type.ItemStack[]
          | null;
        public supportsEnv(_env: number): boolean;
        public sense(
          _sensor: Packages.mindustry.logic.LAccess,
        ): number;
        public spawn(
          _x: number,
          _y: number,
        ): Packages.mindustry.gen.Unit;
        public spawn(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
        ): Packages.mindustry.gen.Unit;
        public spawn(
          _team: Packages.mindustry.game.Team,
          _pos: Packages.arc.math.geom.Position,
        ): Packages.mindustry.gen.Unit;
        public spawn(
          _pos: Packages.arc.math.geom.Position,
        ): Packages.mindustry.gen.Unit;
        public spawn(
          _pos: Packages.arc.math.geom.Position,
          _team: Packages.mindustry.game.Team,
        ): Packages.mindustry.gen.Unit;
        public killed(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public estimateDps(): number;
        public createIcons(
          _packer: Packages.mindustry.graphics.MultiPacker,
        ): void;
        public getRegionsToOutline(
          _out: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.TextureRegion>,
        ): void;
        public drawShadow(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public senseObject(
          _sensor: Packages.mindustry.logic.LAccess,
        ): any;
        public drawLight(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public updatePayload(
          _unit: Packages.mindustry.gen.Unit,
          _unitHolder: Packages.mindustry.gen.Unit | null,
          _buildingHolder: Packages.mindustry.gen.Building | null,
        ): void;
        public targetable(
          _unit: Packages.mindustry.gen.Unit,
          _targeter: Packages.mindustry.game.Team,
        ): boolean;
        public setStats(): void;
        public isBanned(): boolean;
        public landed(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public applyColor(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public hasWeapons(): boolean;
        public hittable(
          _unit: Packages.mindustry.gen.Unit,
        ): boolean;
        public drawCell(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public drawItems(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public drawBody(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public getFirstRequirements():
          | Packages.mindustry._type.ItemStack[]
          | null;
        public getTotalRequirements():
          | Packages.mindustry._type.ItemStack[]
          | null;
        public getRequirements(
          _prevReturn:
            | Packages.mindustry._type.UnitType[]
            | null,
          _timeReturn: number[] | null,
        ): Packages.mindustry._type.ItemStack[] | null;
        public drawMining(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public drawControl(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public drawMech(
          _mech: Packages.mindustry.gen.Mechc,
        ): void;
        public drawTank<
          T extends Packages.mindustry.gen.Unit &
            Packages.mindustry.gen.Tankc,
        >(_unit: T): void;
        public drawLegs<
          T extends Packages.mindustry.gen.Unit &
            Packages.mindustry.gen.Legsc,
        >(_unit: T): void;
        public drawPayload<
          T extends Packages.mindustry.gen.Unit &
            Packages.mindustry.gen.Payloadc,
        >(_unit: T): void;
        public drawSoftShadow(
          _x: number,
          _y: number,
          _rotation: number,
          _alpha: number,
        ): void;
        public drawSoftShadow(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public drawSoftShadow(
          _unit: Packages.mindustry.gen.Unit,
          _alpha: number,
        ): void;
        public drawCrawl(
          _crawl: Packages.mindustry.gen.Crawlc,
        ): void;
        public drawOutline(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public drawWeaponOutlines(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public drawTrail(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public drawEngines(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public drawWeapons(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public drawShield(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public shieldColor(
          _unit: Packages.mindustry.gen.Unit,
        ): Packages.arc.graphics.Color;
        public applyOutlineColor(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public cellColor(
          _unit: Packages.mindustry.gen.Unit,
        ): Packages.arc.graphics.Color;
        public createController(
          _unit: Packages.mindustry.gen.Unit,
        ): Packages.mindustry.entities.units.UnitController;
        protected validateWeapons(): void;
        public needsBodyOutline(): boolean;
        public getBuildTime(): number;
        public setEnginesMirror(
          ..._array: Packages.mindustry._type.UnitType.UnitEngine[]
        ): void;
        public getContentType(): Packages.mindustry.ctype.ContentType;
        public constructor(_name: string);
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace game {
      declare class SpawnGroup
        extends java.lang.Object
        implements
          Packages.java.lang.Cloneable,
          Packages.arc.util.serialization.Json
            .JsonSerializable
      {
        public static never: number;
        public type: Packages.mindustry._type.UnitType;
        public end: number;
        public begin: number;
        public spacing: number;
        public max: number;
        public unitScaling: number;
        public shields: number;
        public shieldScaling: number;
        public unitAmount: number;
        public spawn: number;
        public payloads?: Packages.arc.struct.Seq<Packages.mindustry._type.UnitType>;
        public effect?: Packages.mindustry._type.StatusEffect;
        public items?: Packages.mindustry._type.ItemStack;
        public equals(_o: any): boolean;
        public toString(): string;
        public hashCode(): number;
        public write(
          _json: Packages.arc.util.serialization.Json,
        ): void;
        public read(
          _json: Packages.arc.util.serialization.Json,
          _data: Packages.arc.util.serialization.JsonValue,
        ): void;
        public copy(): Packages.mindustry.game.SpawnGroup;
        public getShield(_wave: number): number;
        public canSpawn(_position: number): boolean;
        public getSpawned(_wave: number): number;
        public createUnit(
          _team: Packages.mindustry.game.Team,
          _wave: number,
        ): Packages.mindustry.gen.Unit;
        public constructor(
          _type: Packages.mindustry._type.UnitType,
        );
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class IndexableEntity__weather {
        public setIndex__weather(_index: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class WeatherStatec
        implements
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Entityc
      {
        public update(): void;
        public init(
          _weather: Packages.mindustry._type.Weather,
        ): void;
        public draw(): void;
        public intensity(_intensity: number): void;
        public intensity(): number;
        public opacity(): number;
        public opacity(_opacity: number): void;
        public weather(
          _weather: Packages.mindustry._type.Weather,
        ): void;
        public weather(): Packages.mindustry._type.Weather;
        public life(): number;
        public life(_life: number): void;
        public effectTimer(_effectTimer: number): void;
        public effectTimer(): number;
        public windVector(
          _windVector: Packages.arc.math.geom.Vec2,
        ): void;
        public windVector(): Packages.arc.math.geom.Vec2;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class WeatherState
        extends java.lang.Object
        implements
          Packages.mindustry.gen.IndexableEntity__all,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.IndexableEntity__weather,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.WeatherStatec,
          Packages.mindustry.gen.IndexableEntity__sync,
          Packages.arc.util.pooling.Pool.Poolable,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.IndexableEntity__draw
      {
        public static fadeTime: number;
        protected added: boolean;
        protected index__all: number;
        protected index__draw: number;
        protected index__sync: number;
        protected index__weather: number;
        private x_LAST_: number;
        private x_TARGET_: number;
        private y_LAST_: number;
        private y_TARGET_: number;
        public add(): void;
        public remove(): void;
        public toString(): string;
        public update(): void;
        public x(_x: number): void;
        public x(): number;
        public id(): number;
        public id(_id: number): void;
        public set(_x: number, _y: number): void;
        public set(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public init(
          _weather: Packages.mindustry._type.Weather,
        ): void;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public reset(): void;
        public static create(): Packages.mindustry.gen.WeatherState;
        public as<T>(): T | null;
        public y(_y: number): void;
        public y(): number;
        public self<
          T extends Packages.mindustry.gen.Entityc,
        >(): T | null;
        public getX(): number;
        public getY(): number;
        public interpolate(): void;
        public trns(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public trns(_x: number, _y: number): void;
        public draw(): void;
        public intensity(_intensity: number): void;
        public intensity(): number;
        public opacity(): number;
        public opacity(_opacity: number): void;
        public lastUpdated(): Packages.long;
        public lastUpdated(
          _lastUpdated: Packages.long,
        ): void;
        public updateSpacing(
          _updateSpacing: Packages.long,
        ): void;
        public updateSpacing(): Packages.long;
        public afterRead(): void;
        public isLocal(): boolean;
        public isAdded(): boolean;
        public tileOn(): Packages.mindustry.world.Tile;
        public afterSync(): void;
        public isRemote(): boolean;
        public snapInterpolation(): void;
        public onSolid(): boolean;
        public classId(): number;
        public setIndex__all(_index: number): void;
        public setIndex__draw(_index: number): void;
        public setIndex__sync(_index: number): void;
        public buildOn(): Packages.mindustry.gen.Building;
        public isSyncHidden(
          _player: Packages.mindustry.gen.Player,
        ): boolean;
        public serialize(): boolean;
        public clipSize(): number;
        public tileX(): number;
        public tileY(): number;
        public blockOn(): Packages.mindustry.world.Block;
        public floorOn(): Packages.mindustry.world.blocks.environment.Floor;
        public afterAllRead(): void;
        public handleSyncHidden(): void;
        public readSync(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public readSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public snapSync(): void;
        public writeSync(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public writeSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public weather(
          _weather: Packages.mindustry._type.Weather,
        ): void;
        public weather(): Packages.mindustry._type.Weather;
        public life(): number;
        public life(_life: number): void;
        public setIndex__weather(_index: number): void;
        public effectTimer(_effectTimer: number): void;
        public effectTimer(): number;
        public windVector(
          _windVector: Packages.arc.math.geom.Vec2,
        ): void;
        public windVector(): Packages.arc.math.geom.Vec2;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare class Weather extends Packages.mindustry.ctype
        .UnlockableContent {
        static WeatherStateComp = class
          extends java.lang.Object
          implements
            Packages.mindustry.gen.Drawc,
            Packages.mindustry.gen.Syncc
        {
          public static fadeTime: number;
          weather: Packages.mindustry._type.Weather;
          intensity: number;
          opacity: number;
          life: number;
          effectTimer: number;
          windVector: Packages.arc.math.geom.Vec2;
          public update(): void;
          init(
            _weather: Packages.mindustry._type.Weather,
          ): void;
          public draw(): void;
        };
        public static WeatherEntry = class extends java.lang
          .Object {
          public weather: Packages.mindustry._type.Weather;
          public minFrequency: number;
          public maxFrequency: number;
          public minDuration: number;
          public maxDuration: number;
          public cooldown: number;
          public intensity: number;
          public always: boolean;
          public constructor(
            _weather: Packages.mindustry._type.Weather,
          );
          public constructor(
            _weather: Packages.mindustry._type.Weather,
            _minFrequency: number,
            _maxFrequency: number,
            _minDuration: number,
            _maxDuration: number,
          );
          public constructor();
        };
        public static rand: Packages.arc.math.Rand;
        public duration: number;
        public opacityMultiplier: number;
        public attrs: Packages.mindustry.world.blocks.Attributes;
        public sound: Packages.arc.audio.Sound;
        public soundVol: number;
        public soundVolMin: number;
        public soundVolOscMag: number;
        public soundVolOscScl: number;
        public hidden: boolean;
        public type: Packages.arc.func.Prov<Packages.mindustry.gen.WeatherState>;
        public status: Packages.mindustry._type.StatusEffect;
        public statusDuration: number;
        public statusAir: boolean;
        public statusGround: boolean;
        public remove(): void;
        public isHidden(): boolean;
        public update(
          _state: Packages.mindustry.gen.WeatherState,
        ): void;
        public create(
          _intensity: number,
        ): Packages.mindustry.gen.WeatherState;
        public create(): Packages.mindustry.gen.WeatherState;
        public create(
          _intensity: number,
          _duration: number,
        ): Packages.mindustry.gen.WeatherState;
        public isActive(): boolean;
        public instance(): Packages.mindustry.gen.WeatherState | null;
        public drawOver(
          _state: Packages.mindustry.gen.WeatherState,
        ): void;
        public static drawNoise(
          _noise: Packages.arc.graphics.Texture,
          _color: Packages.arc.graphics.Color,
          _noisescl: number,
          _opacity: number,
          _baseSpeed: number,
          _intensity: number,
          _vwindx: number,
          _vwindy: number,
          _offset: number,
        ): void;
        public updateEffect(
          _state: Packages.mindustry.gen.WeatherState,
        ): void;
        public drawUnder(
          _state: Packages.mindustry.gen.WeatherState,
        ): void;
        public static drawParticles(
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _color: Packages.arc.graphics.Color,
          _sizeMin: number,
          _sizeMax: number,
          _density: number,
          _intensity: number,
          _opacity: number,
          _windx: number,
          _windy: number,
          _minAlpha: number,
          _maxAlpha: number,
          _sinSclMin: number,
          _sinSclMax: number,
          _sinMagMin: number,
          _sinMagMax: number,
          _randomParticleRotation: boolean,
        ): void;
        public static drawRain(
          _sizeMin: number,
          _sizeMax: number,
          _xspeed: number,
          _yspeed: number,
          _density: number,
          _intensity: number,
          _stroke: number,
          _color: Packages.arc.graphics.Color,
        ): void;
        public static drawSplashes(
          _splashes: Packages.arc.graphics.g2d.TextureRegion[],
          _padding: number,
          _density: number,
          _intensity: number,
          _opacity: number,
          _timeScale: number,
          _stroke: number,
          _color: Packages.arc.graphics.Color,
          _splasher: Packages.mindustry._type.Liquid,
        ): void;
        public static drawNoiseLayers(
          _noise: Packages.arc.graphics.Texture,
          _color: Packages.arc.graphics.Color,
          _noisescl: number,
          _opacity: number,
          _baseSpeed: number,
          _intensity: number,
          _vwindx: number,
          _vwindy: number,
          _layers: number,
          _layerSpeedM: number,
          _layerAlphaM: number,
          _layerSclM: number,
          _layerColorM: number,
        ): void;
        public static createWeather(
          _weather: Packages.mindustry._type.Weather,
          _intensity: number,
          _duration: number,
          _windX: number,
          _windY: number,
        ): void;
        public getContentType(): Packages.mindustry.ctype.ContentType;
        public constructor(
          _name: string,
          _type: Packages.arc.func.Prov<Packages.mindustry.gen.WeatherState>,
        );
        public constructor(_name: string);
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare class LMarkerControl extends Packages.java
        .lang
        .Enum<Packages.mindustry.logic.LMarkerControl> {
        public static remove: Packages.mindustry.logic.LMarkerControl;
        public static world: Packages.mindustry.logic.LMarkerControl;
        public static minimap: Packages.mindustry.logic.LMarkerControl;
        public static autoscale: Packages.mindustry.logic.LMarkerControl;
        public static pos: Packages.mindustry.logic.LMarkerControl;
        public static endPos: Packages.mindustry.logic.LMarkerControl;
        public static drawLayer: Packages.mindustry.logic.LMarkerControl;
        public static color: Packages.mindustry.logic.LMarkerControl;
        public static radius: Packages.mindustry.logic.LMarkerControl;
        public static stroke: Packages.mindustry.logic.LMarkerControl;
        public static rotation: Packages.mindustry.logic.LMarkerControl;
        public static shape: Packages.mindustry.logic.LMarkerControl;
        public static arc: Packages.mindustry.logic.LMarkerControl;
        public static flushText: Packages.mindustry.logic.LMarkerControl;
        public static fontSize: Packages.mindustry.logic.LMarkerControl;
        public static textHeight: Packages.mindustry.logic.LMarkerControl;
        public static labelFlags: Packages.mindustry.logic.LMarkerControl;
        public static texture: Packages.mindustry.logic.LMarkerControl;
        public static textureSize: Packages.mindustry.logic.LMarkerControl;
        public static posi: Packages.mindustry.logic.LMarkerControl;
        public static uvi: Packages.mindustry.logic.LMarkerControl;
        public static colori: Packages.mindustry.logic.LMarkerControl;
        public params: string[];
        public static all: Packages.mindustry.logic.LMarkerControl[];
        private static $VALUES: Packages.mindustry.logic.LMarkerControl[];
        public static values():
          | Packages.mindustry.logic.LMarkerControl[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.mindustry.logic.LMarkerControl;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace game {
      declare class MapObjectives
        extends java.lang.Object
        implements
          Packages.java.lang
            .Iterable<Packages.mindustry.game.MapObjectives.MapObjective>,
          Packages.arc.util
            .Eachable<Packages.mindustry.game.MapObjectives.MapObjective>
      {
        public static MapObjective = class extends java.lang
          .Object {
          public details?: string;
          public flagsAdded: string[];
          public flagsRemoved: string[];
          public markers: Packages.mindustry.game.MapObjectives.ObjectiveMarker[];
          public parents: Packages.arc.struct.Seq<Packages.mindustry.game.MapObjectives.MapObjective>;
          private children: Packages.arc.struct.Seq<Packages.mindustry.game.MapObjectives.MapObjective>;
          public editorX: number;
          public editorY: number;
          private completed: boolean;
          private depFinished: boolean;
          public parent(
            _parent: Packages.mindustry.game.MapObjectives.MapObjective,
          ): Packages.mindustry.game.MapObjectives.MapObjective;
          public update(): boolean;
          public typeName(): string;
          public reset(): void;
          public text(): string | null;
          public child(
            _child: Packages.mindustry.game.MapObjectives.MapObjective,
          ): Packages.mindustry.game.MapObjectives.MapObjective;
          public done(): void;
          public isCompleted(): boolean;
          public details(
            _details: string,
          ): Packages.mindustry.game.MapObjectives.MapObjective;
          public details(): string | null;
          public qualified(): boolean;
          public flagsAdded(
            ..._flagsAdded: string[]
          ): Packages.mindustry.game.MapObjectives.MapObjective;
          public flagsRemoved(
            ..._flagsRemoved: string[]
          ): Packages.mindustry.game.MapObjectives.MapObjective;
          public markers(
            ..._markers: Packages.mindustry.game.MapObjectives.ObjectiveMarker[]
          ): Packages.mindustry.game.MapObjectives.MapObjective;
          public dependencyFinished(): boolean;
          public constructor();
        };
        public static ObjectiveMarker = class extends java
          .lang.Object {
          public arrayIndex: number;
          public world: boolean;
          public minimap: boolean;
          public autoscale: boolean;
          protected drawLayer: number;
          public typeName(): string;
          public control(
            _type: Packages.mindustry.logic.LMarkerControl,
            _p1: number,
            _p2: number,
            _p3: number,
          ): void;
          public setText(
            _text: string,
            _fetch: boolean,
          ): void;
          public draw(_scaleFactor: number): void;
          public setTexture(_textureName: string): void;
          public static fetchText(_text: string): string;
          public constructor();
        };
        public static TilePos = class
          implements
            Packages.java.lang.annotation.Annotation {};
        public static Second = class
          implements
            Packages.java.lang.annotation.Annotation {};
        public static Multiline = class
          implements
            Packages.java.lang.annotation.Annotation {};
        public static Synthetic = class
          implements
            Packages.java.lang.annotation.Annotation {};
        public static Researchable = class
          implements
            Packages.java.lang.annotation.Annotation {};
        public static LabelFlag = class
          implements
            Packages.java.lang.annotation.Annotation {};
        public static Vertices = class
          implements
            Packages.java.lang.annotation.Annotation {};
        public static Immutable = class
          implements
            Packages.java.lang.annotation.Annotation {};
        public static Unordered = class
          implements
            Packages.java.lang.annotation.Annotation {};
        public static QuadMarker = class extends Packages
          .mindustry.game.MapObjectives.ObjectiveMarker {
          public textureName: string;
          public vertices: number[];
          private mapRegion: boolean;
          private fetchedRegion: Packages.arc.graphics.g2d.TextureRegion;
          public control(
            _type: Packages.mindustry.logic.LMarkerControl,
            _p1: number,
            _p2: number,
            _p3: number,
          ): void;
          private setColor(_i: number, _c: number): void;
          public draw(_scaleFactor: number): void;
          public setTexture(_textureName: string): void;
          private setPos(
            _i: number,
            _x: number,
            _y: number,
          ): void;
          private setUv(
            _i: number,
            _u: number,
            _v: number,
          ): void;
          public constructor();
        };
        public static TextureMarker = class extends Packages
          .mindustry.game.MapObjectives.PosMarker {
          public rotation: number;
          public width: number;
          public height: number;
          public textureName: string;
          public color: Packages.arc.graphics.Color;
          private fetchedRegion: Packages.arc.graphics.g2d.TextureRegion;
          public control(
            _type: Packages.mindustry.logic.LMarkerControl,
            _p1: number,
            _p2: number,
            _p3: number,
          ): void;
          public draw(_scaleFactor: number): void;
          public setTexture(_textureName: string): void;
          public constructor();
          public constructor(
            _textureName: string,
            _x: number,
            _y: number,
          );
          public constructor(
            _textureName: string,
            _x: number,
            _y: number,
            _width: number,
            _height: number,
          );
        };
        public static LineMarker = class extends Packages
          .mindustry.game.MapObjectives.PosMarker {
          public endPos: Packages.arc.math.geom.Vec2;
          public stroke: number;
          public outline: boolean;
          public color1: Packages.arc.graphics.Color;
          public color2: Packages.arc.graphics.Color;
          public control(
            _type: Packages.mindustry.logic.LMarkerControl,
            _p1: number,
            _p2: number,
            _p3: number,
          ): void;
          public draw(_scaleFactor: number): void;
          public constructor();
          public constructor(
            _x1: number,
            _y1: number,
            _x2: number,
            _y2: number,
          );
          public constructor(
            _x1: number,
            _y1: number,
            _x2: number,
            _y2: number,
            _stroke: number,
          );
        };
        public static TextMarker = class extends Packages
          .mindustry.game.MapObjectives.PosMarker {
          public text: string;
          public fontSize: number;
          public flags: string;
          private fetchedText: string;
          public control(
            _type: Packages.mindustry.logic.LMarkerControl,
            _p1: number,
            _p2: number,
            _p3: number,
          ): void;
          public setText(
            _text: string,
            _fetch: boolean,
          ): void;
          public draw(_scaleFactor: number): void;
          public constructor();
          public constructor(
            _text: string,
            _x: number,
            _y: number,
          );
          public constructor(
            _text: string,
            _x: number,
            _y: number,
            _fontSize: number,
            _flags: string,
          );
        };
        public static ShapeMarker = class extends Packages
          .mindustry.game.MapObjectives.PosMarker {
          public radius: number;
          public rotation: number;
          public stroke: number;
          public startAngle: number;
          public endAngle: number;
          public fill: boolean;
          public outline: boolean;
          public sides: number;
          public color: Packages.arc.graphics.Color;
          public control(
            _type: Packages.mindustry.logic.LMarkerControl,
            _p1: number,
            _p2: number,
            _p3: number,
          ): void;
          public draw(_scaleFactor: number): void;
          public constructor();
          public constructor(
            _x: number,
            _y: number,
            _radius: number,
            _rotation: number,
          );
          public constructor(_x: number, _y: number);
        };
        public static PointMarker = class extends Packages
          .mindustry.game.MapObjectives.PosMarker {
          public radius: number;
          public stroke: number;
          public color: Packages.arc.graphics.Color;
          public control(
            _type: Packages.mindustry.logic.LMarkerControl,
            _p1: number,
            _p2: number,
            _p3: number,
          ): void;
          public draw(_scaleFactor: number): void;
          public constructor();
          public constructor(
            _x: number,
            _y: number,
            _radius: number,
            _stroke: number,
            _color: Packages.arc.graphics.Color,
          );
          public constructor(
            _x: number,
            _y: number,
            _color: Packages.arc.graphics.Color,
          );
          public constructor(_x: number, _y: number);
        };
        public static ShapeTextMarker = class extends Packages
          .mindustry.game.MapObjectives.PosMarker {
          public text: string;
          public fontSize: number;
          public textHeight: number;
          public flags: string;
          public radius: number;
          public rotation: number;
          public sides: number;
          public color: Packages.arc.graphics.Color;
          private fetchedText: string;
          public control(
            _type: Packages.mindustry.logic.LMarkerControl,
            _p1: number,
            _p2: number,
            _p3: number,
          ): void;
          public setText(
            _text: string,
            _fetch: boolean,
          ): void;
          public draw(_scaleFactor: number): void;
          public constructor();
          public constructor(
            _text: string,
            _x: number,
            _y: number,
            _radius: number,
            _rotation: number,
            _textHeight: number,
          );
          public constructor(
            _text: string,
            _x: number,
            _y: number,
            _radius: number,
            _rotation: number,
          );
          public constructor(
            _text: string,
            _x: number,
            _y: number,
            _radius: number,
          );
          public constructor(
            _text: string,
            _x: number,
            _y: number,
          );
        };
        public static PosMarker = class extends Packages
          .mindustry.game.MapObjectives.ObjectiveMarker {
          public pos: Packages.arc.math.geom.Vec2;
          public control(
            _type: Packages.mindustry.logic.LMarkerControl,
            _p1: number,
            _p2: number,
            _p3: number,
          ): void;
          public constructor();
        };
        public static DestroyCoreObjective = class extends Packages
          .mindustry.game.MapObjectives.MapObjective {
          public update(): boolean;
          public text(): string;
          public constructor();
        };
        public static FlagObjective = class extends Packages
          .mindustry.game.MapObjectives.MapObjective {
          public flag: string;
          public text: string;
          public update(): boolean;
          public text(): string | null;
          public constructor(_flag: string, _text: string);
          public constructor();
        };
        public static CommandModeObjective = class extends Packages
          .mindustry.game.MapObjectives.MapObjective {
          public update(): boolean;
          public text(): string;
          public constructor();
        };
        public static DestroyBlocksObjective = class extends Packages
          .mindustry.game.MapObjectives.MapObjective {
          public positions: Packages.arc.math.geom.Point2[];
          public team: Packages.mindustry.game.Team;
          public block: Packages.mindustry.world.Block;
          public update(): boolean;
          public text(): string;
          public progress(): number;
          public constructor(
            _block: Packages.mindustry.world.Block,
            _team: Packages.mindustry.game.Team,
            ..._positions: Packages.arc.math.geom.Point2[]
          );
          public constructor();
        };
        public static DestroyBlockObjective = class extends Packages
          .mindustry.game.MapObjectives.MapObjective {
          public pos: Packages.arc.math.geom.Point2;
          public team: Packages.mindustry.game.Team;
          public block: Packages.mindustry.world.Block;
          public update(): boolean;
          public text(): string;
          public constructor(
            _block: Packages.mindustry.world.Block,
            _x: number,
            _y: number,
            _team: Packages.mindustry.game.Team,
          );
          public constructor();
        };
        public static TimerObjective = class extends Packages
          .mindustry.game.MapObjectives.MapObjective {
          public text: string;
          public duration: number;
          protected countup: number;
          public update(): boolean;
          public reset(): void;
          public text(): string | null;
          public constructor(
            _text: string,
            _duration: number,
          );
          public constructor();
        };
        public static DestroyUnitsObjective = class extends Packages
          .mindustry.game.MapObjectives.MapObjective {
          public count: number;
          public update(): boolean;
          public text(): string;
          public constructor(_count: number);
          public constructor();
        };
        public static UnitCountObjective = class extends Packages
          .mindustry.game.MapObjectives.MapObjective {
          public unit: Packages.mindustry._type.UnitType;
          public count: number;
          public update(): boolean;
          public text(): string;
          public constructor(
            _unit: Packages.mindustry._type.UnitType,
            _count: number,
          );
          public constructor();
        };
        public static BuildCountObjective = class extends Packages
          .mindustry.game.MapObjectives.MapObjective {
          public block: Packages.mindustry.world.Block;
          public count: number;
          public update(): boolean;
          public text(): string;
          public constructor(
            _block: Packages.mindustry.world.Block,
            _count: number,
          );
          public constructor();
        };
        public static CoreItemObjective = class extends Packages
          .mindustry.game.MapObjectives.MapObjective {
          public item: Packages.mindustry._type.Item;
          public amount: number;
          public update(): boolean;
          public text(): string;
          public constructor(
            _item: Packages.mindustry._type.Item,
            _amount: number,
          );
          public constructor();
        };
        public static ItemObjective = class extends Packages
          .mindustry.game.MapObjectives.MapObjective {
          public item: Packages.mindustry._type.Item;
          public amount: number;
          public update(): boolean;
          public text(): string;
          public constructor(
            _item: Packages.mindustry._type.Item,
            _amount: number,
          );
          public constructor();
        };
        public static ProduceObjective = class extends Packages
          .mindustry.game.MapObjectives.MapObjective {
          public content: Packages.mindustry.ctype.UnlockableContent;
          public update(): boolean;
          public text(): string;
          public constructor(
            _content: Packages.mindustry.ctype.UnlockableContent,
          );
          public constructor();
        };
        public static ResearchObjective = class extends Packages
          .mindustry.game.MapObjectives.MapObjective {
          public content: Packages.mindustry.ctype.UnlockableContent;
          public update(): boolean;
          public text(): string;
          public constructor(
            _content: Packages.mindustry.ctype.UnlockableContent,
          );
          public constructor();
        };
        public static allObjectiveTypes: Packages.arc.struct.Seq<
          Packages.arc.func.Prov<any>
        >;
        public static allMarkerTypes: Packages.arc.struct.Seq<
          Packages.arc.func.Prov<any>
        >;
        public static markerNameToType: Packages.arc.struct.ObjectMap<
          string,
          Packages.arc.func.Prov<any>
        >;
        public static allMarkerTypeNames: Packages.arc.struct.Seq<string>;
        public all: Packages.arc.struct.Seq<Packages.mindustry.game.MapObjectives.MapObjective>;
        public add(
          ..._objectives: Packages.mindustry.game.MapObjectives.MapObjective[]
        ): void;
        public get(
          _index: number,
        ): Packages.mindustry.game.MapObjectives.MapObjective | null;
        public update(): void;
        public clear(): void;
        public iterator(): Packages.java.util.Iterator<Packages.mindustry.game.MapObjectives.MapObjective>;
        public each(
          _cons: Packages.arc.func.Cons<any>,
        ): void;
        private flatten(
          _objective: Packages.mindustry.game.MapObjectives.MapObjective,
        ): void;
        public any(): boolean;
        private static lookupRegion(
          _name: string,
          _out: Packages.arc.graphics.g2d.TextureRegion,
        ): void;
        public eachRunning<
          T extends
            Packages.mindustry.game.MapObjectives.MapObjective,
        >(
          _pred: Packages.arc.func.Boolf<any>,
          _cons: Packages.arc.func.Cons<T>,
        ): void;
        public eachRunning(
          _cons: Packages.arc.func.Cons<Packages.mindustry.game.MapObjectives.MapObjective>,
        ): void;
        public static registerObjective(
          ..._providers: Packages.arc.func.Prov<any>[]
        ): void;
        public static registerMarker(
          ..._providers: Packages.arc.func.Prov<any>[]
        ): void;
        public static registerLegacyMarker(
          _name: string,
          _prov: Packages.arc.func.Prov<any>,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace game {
      declare class Gamemode extends Packages.java.lang
        .Enum<Packages.mindustry.game.Gamemode> {
        public static survival: Packages.mindustry.game.Gamemode;
        public static sandbox: Packages.mindustry.game.Gamemode;
        public static attack: Packages.mindustry.game.Gamemode;
        public static pvp: Packages.mindustry.game.Gamemode;
        public static editor: Packages.mindustry.game.Gamemode;
        private rules: Packages.arc.func.Cons<Packages.mindustry.game.Rules>;
        private validator: Packages.arc.func.Boolf<Packages.mindustry.maps.Map>;
        public hidden: boolean;
        public static all: Packages.mindustry.game.Gamemode[];
        private static $VALUES: Packages.mindustry.game.Gamemode[];
        public toString(): string;
        public static values():
          | Packages.mindustry.game.Gamemode[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.mindustry.game.Gamemode;
        public apply(
          _in: Packages.mindustry.game.Rules,
        ): Packages.mindustry.game.Rules;
        public valid(
          _map: Packages.mindustry.maps.Map,
        ): boolean;
        public description(): string;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace game {
      declare class Rules extends java.lang.Object {
        public static TeamRules = class
          extends java.lang.Object
          implements
            Packages.arc.util.serialization.Json
              .JsonSerializable
        {
          values: Packages.mindustry.game.Rules.TeamRule[];
          public get(
            _team: Packages.mindustry.game.Team,
          ): Packages.mindustry.game.Rules.TeamRule;
          public write(
            _json: Packages.arc.util.serialization.Json,
          ): void;
          public read(
            _json: Packages.arc.util.serialization.Json,
            _jsonData: Packages.arc.util.serialization.JsonValue,
          ): void;
          public constructor();
        };
        public static TeamRule = class extends java.lang
          .Object {
          public aiCoreSpawn: boolean;
          public cheat: boolean;
          public infiniteResources: boolean;
          public infiniteAmmo: boolean;
          public buildAi: boolean;
          public buildAiTier: number;
          public rtsAi: boolean;
          public rtsMinSquad: number;
          public rtsMaxSquad: number;
          public rtsMinWeight: number;
          public unitBuildSpeedMultiplier: number;
          public unitDamageMultiplier: number;
          public unitCrashDamageMultiplier: number;
          public unitCostMultiplier: number;
          public unitHealthMultiplier: number;
          public blockHealthMultiplier: number;
          public blockDamageMultiplier: number;
          public buildSpeedMultiplier: number;
          public constructor();
        };
        public allowEditRules: boolean;
        public infiniteResources: boolean;
        public teams: Packages.mindustry.game.Rules.TeamRules;
        public waveTimer: boolean;
        public waveSending: boolean;
        public waves: boolean;
        public airUseSpawns: boolean;
        public pvp: boolean;
        public pvpAutoPause: boolean;
        public waitEnemies: boolean;
        public attackMode: boolean;
        public editor: boolean;
        public derelictRepair: boolean;
        public canGameOver: boolean;
        public coreCapture: boolean;
        public reactorExplosions: boolean;
        public possessionAllowed: boolean;
        public schematicsAllowed: boolean;
        public damageExplosions: boolean;
        public fire: boolean;
        public unitAmmo: boolean;
        public unitPayloadUpdate: boolean;
        public unitPayloadsExplode: boolean;
        public unitCapVariable: boolean;
        public showSpawns: boolean;
        public solarMultiplier: number;
        public unitBuildSpeedMultiplier: number;
        public unitCostMultiplier: number;
        public unitDamageMultiplier: number;
        public unitHealthMultiplier: number;
        public unitCrashDamageMultiplier: number;
        public ghostBlocks: boolean;
        public logicUnitBuild: boolean;
        public disableWorldProcessors: boolean;
        public blockHealthMultiplier: number;
        public blockDamageMultiplier: number;
        public buildCostMultiplier: number;
        public buildSpeedMultiplier: number;
        public deconstructRefundMultiplier: number;
        public enemyCoreBuildRadius: number;
        public polygonCoreProtection: boolean;
        public placeRangeCheck: boolean;
        public cleanupDeadTeams: boolean;
        public onlyDepositCore: boolean;
        public itemDepositCooldown: number;
        public coreDestroyClear: boolean;
        public hideBannedBlocks: boolean;
        public allowEnvironmentDeconstruct: boolean;
        public instantBuild: boolean;
        public blockWhitelist: boolean;
        public unitWhitelist: boolean;
        public dropZoneRadius: number;
        public waveSpacing: number;
        public initialWaveSpacing: number;
        public winWave: number;
        public unitCap: number;
        public dragMultiplier: number;
        public env: number;
        public attributes: Packages.mindustry.world.blocks.Attributes;
        public sector?: Packages.mindustry._type.Sector;
        public spawns: Packages.arc.struct.Seq<Packages.mindustry.game.SpawnGroup>;
        public loadout: Packages.arc.struct.Seq<Packages.mindustry._type.ItemStack>;
        public weather: Packages.arc.struct.Seq<Packages.mindustry._type.Weather.WeatherEntry>;
        public bannedBlocks: Packages.arc.struct.ObjectSet<Packages.mindustry.world.Block>;
        public bannedUnits: Packages.arc.struct.ObjectSet<Packages.mindustry._type.UnitType>;
        public revealedBlocks: Packages.arc.struct.ObjectSet<Packages.mindustry.world.Block>;
        public researched: Packages.arc.struct.ObjectSet<string>;
        public hiddenBuildItems: Packages.arc.struct.ObjectSet<Packages.mindustry._type.Item>;
        public objectives: Packages.mindustry.game.MapObjectives;
        public objectiveFlags: Packages.arc.struct.ObjectSet<string>;
        public fog: boolean;
        public staticFog: boolean;
        public staticColor: Packages.arc.graphics.Color;
        public dynamicColor: Packages.arc.graphics.Color;
        public lighting: boolean;
        public ambientLight: Packages.arc.graphics.Color;
        public defaultTeam: Packages.mindustry.game.Team;
        public waveTeam: Packages.mindustry.game.Team;
        public cloudColor: Packages.arc.graphics.Color;
        public modeName?: string;
        public mission?: string;
        public coreIncinerates: boolean;
        public borderDarkness: boolean;
        public limitMapArea: boolean;
        public limitX: number;
        public limitY: number;
        public limitWidth: number;
        public limitHeight: number;
        public disableOutsideArea: boolean;
        public tags: Packages.arc.struct.StringMap;
        public customBackgroundCallback?: string;
        public backgroundTexture?: string;
        public backgroundSpeed: number;
        public backgroundScl: number;
        public backgroundOffsetX: number;
        public backgroundOffsetY: number;
        public planetBackground?: Packages.mindustry.graphics.g3d.PlanetParams;
        public planet: Packages.mindustry._type.Planet;
        public allowLogicData: boolean;
        public copy(): Packages.mindustry.game.Rules;
        public mode(): Packages.mindustry.game.Gamemode;
        public hasEnv(_env: number): boolean;
        public blockHealth(
          _team: Packages.mindustry.game.Team,
        ): number;
        public isBanned(
          _block: Packages.mindustry.world.Block,
        ): boolean;
        public isBanned(
          _unit: Packages.mindustry._type.UnitType,
        ): boolean;
        public buildSpeed(
          _team: Packages.mindustry.game.Team,
        ): number;
        public unitDamage(
          _team: Packages.mindustry.game.Team,
        ): number;
        public unitBuildSpeed(
          _team: Packages.mindustry.game.Team,
        ): number;
        public unitCost(
          _team: Packages.mindustry.game.Team,
        ): number;
        public unitHealth(
          _team: Packages.mindustry.game.Team,
        ): number;
        public unitCrashDamage(
          _team: Packages.mindustry.game.Team,
        ): number;
        public blockDamage(
          _team: Packages.mindustry.game.Team,
        ): number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare class Map
        extends java.lang.Object
        implements
          Packages.mindustry._type.Publishable,
          Packages.java.lang
            .Comparable<Packages.mindustry.maps.Map>
      {
        public custom: boolean;
        public tags: Packages.arc.struct.StringMap;
        public file: Packages.arc.files.Fi;
        public version: number;
        public workshop: boolean;
        public width: number;
        public height: number;
        public texture: Packages.arc.graphics.Texture;
        public build: number;
        public teams: Packages.arc.struct.IntSet;
        public spawns: number;
        public mod?: Packages.mindustry.mod.Mods.LoadedMod;
        public name(): string;
        public toString(): string;
        public compareTo(_map: any): number;
        public compareTo(
          _map: Packages.mindustry.maps.Map,
        ): number;
        public filters(): Packages.arc.struct.Seq<Packages.mindustry.maps.filters.GenerateFilter>;
        public tag(_name: string): string;
        public rules(
          _base: Packages.mindustry.game.Rules,
        ): Packages.mindustry.game.Rules;
        public rules(): Packages.mindustry.game.Rules;
        public description(): string;
        public getSteamID(): string;
        public addSteamID(_id: string): void;
        public removeSteamID(): void;
        public steamTitle(): string;
        public steamDescription(): string;
        public steamTag(): string;
        public createSteamFolder(
          _id: string,
        ): Packages.arc.files.Fi;
        public createSteamPreview(
          _id: string,
        ): Packages.arc.files.Fi;
        public extraTags(): Packages.arc.struct.Seq<string>;
        public prePublish(): boolean;
        public plainName(): string;
        public author(): string;
        public applyRules(
          _mode: Packages.mindustry.game.Gamemode,
        ): Packages.mindustry.game.Rules;
        public previewFile(): Packages.arc.files.Fi;
        public hasTag(_name: string): boolean;
        public getHightScore(): number;
        public safeTexture(): Packages.arc.graphics.Texture;
        public cacheFile(): Packages.arc.files.Fi;
        public setHighScore(_score: number): void;
        public plainAuthor(): string;
        public plainDescription(): string;
        public constructor(
          _tags: Packages.arc.struct.StringMap,
        );
        public constructor(
          _file: Packages.arc.files.Fi,
          _width: number,
          _height: number,
          _tags: Packages.arc.struct.StringMap,
          _custom: boolean,
        );
        public constructor(
          _file: Packages.arc.files.Fi,
          _width: number,
          _height: number,
          _tags: Packages.arc.struct.StringMap,
          _custom: boolean,
          _version: number,
        );
        public constructor(
          _file: Packages.arc.files.Fi,
          _width: number,
          _height: number,
          _tags: Packages.arc.struct.StringMap,
          _custom: boolean,
          _version: number,
          _build: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace io {
      declare class SaveMeta extends java.lang.Object {
        public version: number;
        public build: number;
        public timestamp: Packages.long;
        public timePlayed: Packages.long;
        public map: Packages.mindustry.maps.Map;
        public wave: number;
        public rules: Packages.mindustry.game.Rules;
        public tags: Packages.arc.struct.StringMap;
        public mods: string[];
        public constructor(
          _version: number,
          _timestamp: Packages.long,
          _timePlayed: Packages.long,
          _build: number,
          _map: string,
          _wave: number,
          _rules: Packages.mindustry.game.Rules,
          _tags: Packages.arc.struct.StringMap,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace text {
      declare abstract class DateFormat {}
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace game {
      declare class Saves extends java.lang.Object {
        public SaveSlot = class extends java.lang.Object {
          public file: Packages.arc.files.Fi;
          requestedPreview: boolean;
          public meta: Packages.mindustry.io.SaveMeta;
          this$0: Packages.mindustry.game.Saves;
          private index(): string;
          public getName(): string;
          public isHidden(): boolean;
          public load(): void;
          public delete(): void;
          public setName(_name: string): void;
          public save(): void;
          public mode(): Packages.mindustry.game.Gamemode;
          public getMap(): Packages.mindustry.maps.Map;
          public getTimestamp(): Packages.long;
          public getDate(): string;
          public setAutosave(_save: boolean): void;
          private savePreview(): void;
          public getSector(): Packages.mindustry._type.Sector | null;
          private loadPreviewFile(): Packages.arc.files.Fi;
          private previewFile(): Packages.arc.files.Fi;
          public isSector(): boolean;
          public getMods(): string[] | null;
          public previewTexture(): Packages.arc.graphics.Texture;
          public getPlayTime(): string;
          public cautiousLoad(
            _run: Packages.java.lang.Runnable,
          ): void;
          public getBuild(): number;
          public getWave(): number;
          public isAutosave(): boolean;
          public importFile(
            _from: Packages.arc.files.Fi,
          ): void;
          public exportFile(
            _to: Packages.arc.files.Fi,
          ): void;
          public constructor(
            _this$0: Packages.mindustry.game.Saves,
            _file: Packages.arc.files.Fi,
          );
        };
        private static dateFormat: Packages.java.text.DateFormat;
        saves: Packages.arc.struct.Seq<Packages.mindustry.game.Saves.SaveSlot>;
        current?: Packages.mindustry.game.Saves.SaveSlot;
        private lastSectorSave?: Packages.mindustry.game.Saves.SaveSlot;
        private saving: boolean;
        private time: number;
        totalPlaytime: Packages.long;
        private lastTimestamp: Packages.long;
        public update(): void;
        public load(): void;
        public getCurrent(): Packages.mindustry.game.Saves.SaveSlot | null;
        public getLastSector(): Packages.mindustry.game.Saves.SaveSlot | null;
        public getSectorFile(
          _sector: Packages.mindustry._type.Sector,
        ): Packages.arc.files.Fi;
        public getNextSlotFile(): Packages.arc.files.Fi;
        public getTotalPlaytime(): Packages.long;
        public resetSave(): void;
        public isSaving(): boolean;
        public saveSector(
          _sector: Packages.mindustry._type.Sector,
        ): void;
        public addSave(
          _name: string,
        ): Packages.mindustry.game.Saves.SaveSlot;
        public importSave(
          _file: Packages.arc.files.Fi,
        ): Packages.mindustry.game.Saves.SaveSlot;
        public getSaveSlots(): Packages.arc.struct.Seq<Packages.mindustry.game.Saves.SaveSlot>;
        public deleteAll(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace generators {
        declare class FileMapGenerator
          extends java.lang.Object
          implements
            Packages.mindustry.maps.generators
              .WorldGenerator
        {
          public map: Packages.mindustry.maps.Map;
          public preset: Packages.mindustry._type.SectorPreset;
          public generate(
            _tiles: Packages.mindustry.world.Tiles,
          ): void;
          public constructor(
            _preset: Packages.mindustry._type.SectorPreset,
          );
          public constructor(
            _map: Packages.mindustry.maps.Map,
            _preset: Packages.mindustry._type.SectorPreset,
          );
          public constructor(
            _mapName: string,
            _preset: Packages.mindustry._type.SectorPreset,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare class SectorPreset extends Packages.mindustry
        .ctype.UnlockableContent {
        public generator: Packages.mindustry.maps.generators.FileMapGenerator;
        public planet: Packages.mindustry._type.Planet;
        public sector: Packages.mindustry._type.Sector;
        public captureWave: number;
        public rules: Packages.arc.func.Cons<Packages.mindustry.game.Rules>;
        public difficulty: number;
        public startWaveTimeMultiplier: number;
        public addStartingItems: boolean;
        public noLighting: boolean;
        public isLastSector: boolean;
        public showSectorLandInfo: boolean;
        public overrideLaunchDefaults: boolean;
        public allowLaunchSchematics: boolean;
        public allowLaunchLoadout: boolean;
        public attackAfterWaves: boolean;
        public isHidden(): boolean;
        public initialize(
          _planet: Packages.mindustry._type.Planet,
          _sector: number,
        ): void;
        public loadIcon(): void;
        public getContentType(): Packages.mindustry.ctype.ContentType;
        public constructor(_name: string);
        public constructor(
          _name: string,
          _mod: Packages.mindustry.mod.Mods.LoadedMod,
        );
        public constructor(
          _name: string,
          _planet: Packages.mindustry._type.Planet,
          _sector: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace game {
      declare class SectorInfo extends java.lang.Object {
        public static ExportStat = class extends java.lang
          .Object {
          public counter: number;
          public means: Packages.arc.math.WindowedMean;
          public loaded: boolean;
          public mean: number;
          public toString(): string;
          public constructor();
        };
        private static valueWindow: number;
        private static refreshPeriod: number;
        private static returnf: number;
        public production: Packages.arc.struct.ObjectMap<
          Packages.mindustry._type.Item,
          Packages.mindustry.game.SectorInfo.ExportStat
        >;
        public rawProduction: Packages.arc.struct.ObjectMap<
          Packages.mindustry._type.Item,
          Packages.mindustry.game.SectorInfo.ExportStat
        >;
        public export: Packages.arc.struct.ObjectMap<
          Packages.mindustry._type.Item,
          Packages.mindustry.game.SectorInfo.ExportStat
        >;
        public items: Packages.mindustry._type.ItemSeq;
        public bestCoreType: Packages.mindustry.world.Block;
        public storageCapacity: number;
        public hasCore: boolean;
        public wasCaptured: boolean;
        public origin?: Packages.mindustry._type.Sector;
        public destination?: Packages.mindustry._type.Sector;
        public resources: Packages.arc.struct.Seq<Packages.mindustry.ctype.UnlockableContent>;
        public waves: boolean;
        public attack: boolean;
        public hasSpawns: boolean;
        public wave: number;
        public winWave: number;
        public wavesSurvived: number;
        public waveSpacing: number;
        public damage: number;
        public wavesPassed: number;
        public spawnPosition: number;
        public secondsPassed: number;
        public minutesCaptured: number;
        public name?: string;
        public icon?: string;
        public contentIcon?: Packages.mindustry.ctype.UnlockableContent;
        public waveVersion: number;
        public shown: boolean;
        public lastImported: Packages.mindustry._type.ItemSeq;
        public sumHealth: number;
        public sumRps: number;
        public sumDps: number;
        public waveHealthBase: number;
        public waveHealthSlope: number;
        public waveDpsBase: number;
        public waveDpsSlope: number;
        public bossHealth: number;
        public bossDps: number;
        public curEnemyHealth: number;
        public curEnemyDps: number;
        public bossWave: number;
        private time: Packages.arc.util.Interval;
        private coreDeltas?: number[];
        private productionDeltas?: number[];
        public update(): void;
        public write(): void;
        public prepare(): void;
        public handleProduction(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): void;
        public handleCoreItem(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): void;
        public exportRates(): Packages.arc.struct.ObjectFloatMap<Packages.mindustry._type.Item>;
        public importStats(
          _planet: Packages.mindustry._type.Planet,
        ): Packages.arc.struct.ObjectMap<
          Packages.mindustry._type.Item,
          Packages.mindustry.game.SectorInfo.ExportStat
        >;
        public handleItemExport(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): void;
        public handleItemExport(
          _stack: Packages.mindustry._type.ItemStack,
        ): void;
        updateDelta(
          _item: Packages.mindustry._type.Item,
          _map: Packages.arc.struct.ObjectMap<
            Packages.mindustry._type.Item,
            Packages.mindustry.game.SectorInfo.ExportStat
          >,
          _deltas: number[],
        ): void;
        public eachImport(
          _planet: Packages.mindustry._type.Planet,
          _cons: Packages.arc.func.Cons<Packages.mindustry._type.Sector>,
        ): void;
        public getRealDestination(): Packages.mindustry._type.Sector;
        public anyExports(): boolean;
        public getExport(
          _item: Packages.mindustry._type.Item,
        ): number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare class Sector extends java.lang.Object {
        public static SectorRect = class extends java.lang
          .Object {
          public center: Packages.arc.math.geom.Vec3;
          public top: Packages.arc.math.geom.Vec3;
          public right: Packages.arc.math.geom.Vec3;
          public result: Packages.arc.math.geom.Vec3;
          public radius: number;
          public rotation: number;
          public project(
            _x: number,
            _y: number,
          ): Packages.arc.math.geom.Vec3;
          public constructor(
            _radius: number,
            _center: Packages.arc.math.geom.Vec3,
            _top: Packages.arc.math.geom.Vec3,
            _right: Packages.arc.math.geom.Vec3,
            _rotation: number,
          );
        };
        private static tmpSeq1: Packages.arc.struct.Seq<Packages.mindustry._type.Sector>;
        public rect: Packages.mindustry._type.Sector.SectorRect;
        public plane: Packages.arc.math.geom.Plane;
        public planet: Packages.mindustry._type.Planet;
        public tile: Packages.mindustry.graphics.g3d.PlanetGrid.Ptile;
        public id: number;
        public save?: Packages.mindustry.game.Saves.SaveSlot;
        public preset?: Packages.mindustry._type.SectorPreset;
        public info: Packages.mindustry.game.SectorInfo;
        public threat: number;
        public generateEnemyBase: boolean;
        public name(): string;
        public toString(): string;
        public setName(_name: string): void;
        public getSize(): number;
        public items(): Packages.mindustry._type.ItemSeq;
        public near(
          _cons: Packages.arc.func.Cons<Packages.mindustry._type.Sector>,
        ): void;
        public near(): Packages.arc.struct.Seq<Packages.mindustry._type.Sector>;
        public icon(): Packages.arc.graphics.g2d.TextureRegion | null;
        public unlocked(): boolean;
        public locked(): boolean;
        public allowLaunchSchematics(): boolean;
        public allowLaunchLoadout(): boolean;
        public hasBase(): boolean;
        public hasEnemyBase(): boolean;
        public loadInfo(): void;
        protected makeRect(): Packages.mindustry._type.Sector.SectorRect;
        public isBeingPlayed(): boolean;
        public saveInfo(): void;
        public addItems(
          _items: Packages.mindustry._type.ItemSeq,
        ): void;
        public displayThreat(): string;
        public clearInfo(): void;
        public getProductionScale(): number;
        public isAttacked(): boolean;
        public iconChar(): string | null;
        public isCaptured(): boolean;
        public hasSave(): boolean;
        public getLight(): number;
        public removeItems(
          _items: Packages.mindustry._type.ItemSeq,
        ): void;
        public removeItem(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): void;
        public constructor(
          _planet: Packages.mindustry._type.Planet,
          _tile: Packages.mindustry.graphics.g3d.PlanetGrid.Ptile,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare class TileGen extends java.lang.Object {
        public floor: Packages.mindustry.world.Block;
        public block: Packages.mindustry.world.Block;
        public overlay: Packages.mindustry.world.Block;
        public reset(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace generators {
        declare abstract class PlanetGenerator
          extends Packages.mindustry.maps.generators
            .BasicGenerator
          implements
            Packages.mindustry.graphics.g3d.HexMesher
        {
          public baseSeed: number;
          public seed: number;
          protected ints: Packages.arc.struct.IntSeq;
          protected sector?: Packages.mindustry._type.Sector;
          public generate(
            _tiles: Packages.mindustry.world.Tiles,
            _sec: Packages.mindustry._type.Sector,
            _seed: number,
          ): void;
          protected noise(
            _x: number,
            _y: number,
            _octaves: number,
            _falloff: number,
            _scl: number,
            _mag: number,
          ): number;
          public getSizeScl(): number;
          protected genTile(
            _position: Packages.arc.math.geom.Vec3,
            _tile: Packages.mindustry.world.TileGen,
          ): void;
          public allowLanding(
            _sector: Packages.mindustry._type.Sector,
          ): boolean;
          public addWeather(
            _sector: Packages.mindustry._type.Sector,
            _rules: Packages.mindustry.game.Rules,
          ): void;
          public getSectorSize(
            _sector: Packages.mindustry._type.Sector,
          ): number;
          public generateSector(
            _sector: Packages.mindustry._type.Sector,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare class Planet extends Packages.mindustry.ctype
        .UnlockableContent {
        private static intersectResult: Packages.arc.math.geom.Vec3;
        private static mat: Packages.arc.math.geom.Mat3D;
        private static points: Packages.arc.struct.Seq<Packages.arc.math.geom.Vec3>;
        public mesh?: Packages.mindustry.graphics.g3d.GenericMesh;
        public cloudMesh?: Packages.mindustry.graphics.g3d.GenericMesh;
        public gridMesh?: Packages.arc.graphics.Mesh;
        public position: Packages.arc.math.geom.Vec3;
        public grid?: Packages.mindustry.graphics.g3d.PlanetGrid;
        public generator?: Packages.mindustry.maps.generators.PlanetGenerator;
        public sectors: Packages.arc.struct.Seq<Packages.mindustry._type.Sector>;
        public orbitSpacing: number;
        public radius: number;
        public camRadius: number;
        public minZoom: number;
        public drawOrbit: boolean;
        public atmosphereRadIn: number;
        public atmosphereRadOut: number;
        public clipRadius: number;
        public orbitRadius: number;
        public totalRadius: number;
        public orbitTime: number;
        public rotateTime: number;
        public orbitOffset: number;
        public sectorApproxRadius: number;
        public tidalLock: boolean;
        public accessible: boolean;
        public defaultEnv: number;
        public defaultAttributes: Packages.mindustry.world.blocks.Attributes;
        public updateLighting: boolean;
        public lightSrcFrom: number;
        public lightSrcTo: number;
        public lightDstFrom: number;
        public lightDstTo: number;
        public startSector: number;
        public sectorSeed: number;
        public launchCapacityMultiplier: number;
        public bloom: boolean;
        public landCloudColor: Packages.arc.graphics.Color;
        public lightColor: Packages.arc.graphics.Color;
        public atmosphereColor: Packages.arc.graphics.Color;
        public iconColor: Packages.arc.graphics.Color;
        public hasAtmosphere: boolean;
        public allowLaunchSchematics: boolean;
        public allowLaunchLoadout: boolean;
        public allowWaveSimulation: boolean;
        public allowSectorInvasion: boolean;
        public clearSectorOnLose: boolean;
        public enemyBuildSpeedMultiplier: number;
        public enemyCoreSpawnReplace: boolean;
        public prebuildBase: boolean;
        public allowWaves: boolean;
        public allowLaunchToNumbered: boolean;
        public icon: string;
        public launchMusic: Packages.arc.audio.Music;
        public defaultCore: Packages.mindustry.world.Block;
        public ruleSetter: Packages.arc.func.Cons<Packages.mindustry.game.Rules>;
        public parent?: Packages.mindustry._type.Planet;
        public solarSystem: Packages.mindustry._type.Planet;
        public children: Packages.arc.struct.Seq<Packages.mindustry._type.Planet>;
        public techTree?: Packages.mindustry.content.TechTree.TechNode;
        public launchCandidates: Packages.arc.struct.Seq<Packages.mindustry._type.Planet>;
        public hiddenItems: Packages.arc.struct.Seq<Packages.mindustry._type.Item>;
        public itemWhitelist: Packages.arc.struct.Seq<Packages.mindustry._type.Item>;
        public unlockedOnLand: Packages.arc.struct.Seq<Packages.mindustry.ctype.UnlockableContent>;
        public meshLoader: Packages.arc.func.Prov<Packages.mindustry.graphics.g3d.GenericMesh>;
        public cloudMeshLoader: Packages.arc.func.Prov<Packages.mindustry.graphics.g3d.GenericMesh>;
        public gridMeshLoader: Packages.arc.func.Prov<Packages.arc.graphics.Mesh>;
        public isHidden(): boolean;
        public load(): void;
        public fill(
          _batch: Packages.arc.graphics.g3d.VertexBatch3D,
          _sector: Packages.mindustry._type.Sector,
          _color: Packages.arc.graphics.Color,
          _offset: number,
        ): void;
        public init(): void;
        public visible(): boolean;
        public getRotation(): number;
        public draw(
          _params: Packages.mindustry.graphics.g3d.PlanetParams,
          _projection: Packages.arc.math.geom.Mat3D,
          _transform: Packages.arc.math.geom.Mat3D,
        ): void;
        public project(
          _sector: Packages.mindustry._type.Sector,
          _cam: Packages.arc.graphics.g3d.Camera3D,
          _out: Packages.arc.math.geom.Vec3,
        ): Packages.arc.math.geom.Vec3;
        public getTransform(
          _mat: Packages.arc.math.geom.Mat3D,
        ): Packages.arc.math.geom.Mat3D;
        public drawSelection(
          _batch: Packages.arc.graphics.g3d.VertexBatch3D,
          _sector: Packages.mindustry._type.Sector,
          _color: Packages.arc.graphics.Color,
          _stroke: number,
          _length: number,
        ): void;
        public lookAt(
          _sector: Packages.mindustry._type.Sector,
          _out: Packages.arc.math.geom.Vec3,
        ): Packages.arc.math.geom.Vec3;
        public setPlane(
          _sector: Packages.mindustry._type.Sector,
          _projector: Packages.arc.graphics.g3d.PlaneBatch3D,
        ): void;
        public intersect(
          _ray: Packages.arc.math.geom.Ray,
          _radius: number,
        ): Packages.arc.math.geom.Vec3 | null;
        public preset(
          _index: number,
          _preset: Packages.mindustry._type.SectorPreset,
        ): void;
        public updateTotalRadius(): void;
        public getOrbitAngle(): number;
        public addParentOffset(
          _in: Packages.arc.math.geom.Vec3,
        ): Packages.arc.math.geom.Vec3;
        public updateBaseCoverage(): void;
        public getSector(
          _tile: Packages.mindustry.graphics.g3d.PlanetGrid.Ptile,
        ): Packages.mindustry._type.Sector;
        public getSector(
          _ray: Packages.arc.math.geom.Ray,
        ): Packages.mindustry._type.Sector | null;
        public getSector(
          _ray: Packages.arc.math.geom.Ray,
          _radius: number,
        ): Packages.mindustry._type.Sector | null;
        public renderSectors(
          _batch: Packages.arc.graphics.g3d.VertexBatch3D,
          _cam: Packages.arc.graphics.g3d.Camera3D,
          _params: Packages.mindustry.graphics.g3d.PlanetParams,
        ): void;
        public getStartSector(): Packages.mindustry._type.Sector | null;
        public applyRules(
          _rules: Packages.mindustry.game.Rules,
        ): void;
        public getLastSector(): Packages.mindustry._type.Sector | null;
        public setLastSector(
          _sector: Packages.mindustry._type.Sector,
        ): void;
        public hasGrid(): boolean;
        public isLandable(): boolean;
        public getLightNormal(): Packages.arc.math.geom.Vec3;
        public getWorldPosition(
          _in: Packages.arc.math.geom.Vec3,
        ): Packages.arc.math.geom.Vec3;
        public reloadMesh(): void;
        public drawAtmosphere(
          _atmosphere: Packages.arc.graphics.Mesh,
          _cam: Packages.arc.graphics.g3d.Camera3D,
        ): void;
        public drawClouds(
          _params: Packages.mindustry.graphics.g3d.PlanetParams,
          _projection: Packages.arc.math.geom.Mat3D,
          _transform: Packages.arc.math.geom.Mat3D,
        ): void;
        public drawBorders(
          _batch: Packages.arc.graphics.g3d.VertexBatch3D,
          _sector: Packages.mindustry._type.Sector,
          _base: Packages.arc.graphics.Color,
          _alpha: number,
        ): void;
        public drawArc(
          _batch: Packages.arc.graphics.g3d.VertexBatch3D,
          _a: Packages.arc.math.geom.Vec3,
          _b: Packages.arc.math.geom.Vec3,
          _from: Packages.arc.graphics.Color,
          _to: Packages.arc.graphics.Color,
          _length: number,
          _timeScale: number,
          _pointCount: number,
        ): void;
        public getContentType(): Packages.mindustry.ctype.ContentType;
        public constructor(
          _name: string,
          _parent: Packages.mindustry._type.Planet,
          _radius: number,
        );
        public constructor(
          _name: string,
          _parent: Packages.mindustry._type.Planet,
          _radius: number,
          _sectorSize: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare class Item
        extends Packages.mindustry.ctype.UnlockableContent
        implements Packages.mindustry.logic.Senseable
      {
        public color: Packages.arc.graphics.Color;
        public explosiveness: number;
        public flammability: number;
        public radioactivity: number;
        public charge: number;
        public hardness: number;
        public cost: number;
        public healthScaling: number;
        public lowPriority: boolean;
        public frames: number;
        public transitionFrames: number;
        public frameTime: number;
        public buildable: boolean;
        public hidden: boolean;
        public hiddenOnPlanets?: Packages.mindustry._type.Planet[];
        public toString(): string;
        public isHidden(): boolean;
        public init(): void;
        public sense(
          _sensor: Packages.mindustry.logic.LAccess,
        ): number;
        public static getAllOres(): Packages.arc.struct.Seq<Packages.mindustry._type.Item>;
        public createIcons(
          _packer: Packages.mindustry.graphics.MultiPacker,
        ): void;
        public senseObject(
          _sensor: Packages.mindustry.logic.LAccess,
        ): any;
        public setStats(): void;
        public loadIcon(): void;
        public getContentType(): Packages.mindustry.ctype.ContentType;
        public constructor(
          _name: string,
          _color: Packages.arc.graphics.Color,
        );
        public constructor(_name: string);
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare class ItemStack
        extends java.lang.Object
        implements
          Packages.java.lang
            .Comparable<Packages.mindustry._type.ItemStack>
      {
        public static empty: Packages.mindustry._type.ItemStack[];
        public item: Packages.mindustry._type.Item;
        public amount: number;
        public equals(_o: any): boolean;
        public equals(
          _other: Packages.mindustry._type.ItemStack,
        ): boolean;
        public toString(): string;
        public compareTo(_itemStack: any): number;
        public compareTo(
          _itemStack: Packages.mindustry._type.ItemStack,
        ): number;
        public static list(
          ..._items: any[]
        ): Packages.arc.struct.Seq<Packages.mindustry._type.ItemStack>;
        public set(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): Packages.mindustry._type.ItemStack;
        public copy(): Packages.mindustry._type.ItemStack;
        public static copy(
          _stacks: Packages.mindustry._type.ItemStack[],
        ): Packages.mindustry._type.ItemStack[] | null;
        public static mult(
          _stacks: Packages.mindustry._type.ItemStack[],
          _amount: number,
        ): Packages.mindustry._type.ItemStack[] | null;
        public static with(
          ..._items: any[]
        ): Packages.mindustry._type.ItemStack[] | null;
        public constructor(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        );
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Itemsc
        implements
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Entityc
      {
        public update(): void;
        public stack(
          _stack: Packages.mindustry._type.ItemStack,
        ): void;
        public stack(): Packages.mindustry._type.ItemStack;
        public item(): Packages.mindustry._type.Item;
        public itemCapacity(): number;
        public itemTime(_itemTime: number): void;
        public itemTime(): number;
        public acceptsItem(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public hasItem(): boolean;
        public maxAccepted(
          _item: Packages.mindustry._type.Item,
        ): number;
        public addItem(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): void;
        public addItem(
          _item: Packages.mindustry._type.Item,
        ): void;
        public clearItem(): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Unit
        extends java.lang.Object
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.IndexableEntity__sync,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.IndexableEntity__draw,
          Packages.mindustry.gen.IndexableEntity__unit,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.IndexableEntity__all,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        protected index__all: number;
        protected index__draw: number;
        protected index__sync: number;
        protected index__unit: number;
        public type(
          _type: Packages.mindustry._type.UnitType,
        ): void;
        public type(): Packages.mindustry._type.UnitType;
        public x(): number;
        public x(_x: number): void;
        public id(_id: number): void;
        public id(): number;
        public stack(): Packages.mindustry._type.ItemStack;
        public stack(
          _stack: Packages.mindustry._type.ItemStack,
        ): void;
        public flag(_flag: number): void;
        public flag(): number;
        public y(): number;
        public y(_y: number): void;
        public trail(): Packages.mindustry.graphics.Trail;
        public trail(
          _trail: Packages.mindustry.graphics.Trail,
        ): void;
        public deltaX(): number;
        public deltaX(_deltaX: number): void;
        public deltaY(): number;
        public deltaY(_deltaY: number): void;
        public rotation(_rotation: number): void;
        public rotation(): number;
        public lastX(_lastX: number): void;
        public lastX(): number;
        public lastY(): number;
        public lastY(_lastY: number): void;
        public vel(_vel: Packages.arc.math.geom.Vec2): void;
        public vel(): Packages.arc.math.geom.Vec2;
        public drag(): number;
        public drag(_drag: number): void;
        public team(): Packages.mindustry.game.Team;
        public team(
          _team: Packages.mindustry.game.Team,
        ): void;
        public lastUpdated(): Packages.long;
        public lastUpdated(
          _lastUpdated: Packages.long,
        ): void;
        public updateSpacing(
          _updateSpacing: Packages.long,
        ): void;
        public updateSpacing(): Packages.long;
        public dead(_dead: boolean): void;
        public dead(): boolean;
        public hitSize(_hitSize: number): void;
        public elevation(): number;
        public elevation(_elevation: number): void;
        public setIndex__all(_index: number): void;
        public setIndex__draw(_index: number): void;
        public setIndex__sync(_index: number): void;
        public maxHealth(_maxHealth: number): void;
        public maxHealth(): number;
        public hitTime(_hitTime: number): void;
        public hitTime(): number;
        public armor(_armor: number): void;
        public armor(): number;
        public plans(): Packages.arc.struct.Queue<Packages.mindustry.entities.units.BuildPlan>;
        public plans(
          _plans: Packages.arc.struct.Queue<Packages.mindustry.entities.units.BuildPlan>,
        ): void;
        public health(): number;
        public health(_health: number): void;
        public buildSpeedMultiplier(): number;
        public buildSpeedMultiplier(
          _buildSpeedMultiplier: number,
        ): void;
        public speedMultiplier(): number;
        public speedMultiplier(
          _speedMultiplier: number,
        ): void;
        public dragMultiplier(): number;
        public dragMultiplier(
          _dragMultiplier: number,
        ): void;
        public drownTime(_drownTime: number): void;
        public drownTime(): number;
        public abilities():
          | Packages.mindustry.entities.abilities.Ability[]
          | null;
        public abilities(
          _abilities: Packages.mindustry.entities.abilities.Ability[],
        ): void;
        public damageMultiplier(
          _damageMultiplier: number,
        ): void;
        public damageMultiplier(): number;
        public healthMultiplier(
          _healthMultiplier: number,
        ): void;
        public healthMultiplier(): number;
        public reloadMultiplier(): number;
        public reloadMultiplier(
          _reloadMultiplier: number,
        ): void;
        public ammo(): number;
        public ammo(_ammo: number): void;
        public shield(): number;
        public shield(_shield: number): void;
        public armorOverride(_armorOverride: number): void;
        public armorOverride(): number;
        public buildAlpha(_buildAlpha: number): void;
        public buildAlpha(): number;
        public disarmed(_disarmed: boolean): void;
        public disarmed(): boolean;
        public mounts():
          | Packages.mindustry.entities.units.WeaponMount[]
          | null;
        public mounts(
          _mounts: Packages.mindustry.entities.units.WeaponMount[],
        ): void;
        public shadowAlpha(): number;
        public shadowAlpha(_shadowAlpha: number): void;
        public shieldAlpha(): number;
        public shieldAlpha(_shieldAlpha: number): void;
        public updateBuilding(
          _updateBuilding: boolean,
        ): void;
        public updateBuilding(): boolean;
        public hovering(): boolean;
        public hovering(_hovering: boolean): void;
        public isShooting(_isShooting: boolean): void;
        public isShooting(): boolean;
        public spawnedByCore(): boolean;
        public spawnedByCore(_spawnedByCore: boolean): void;
        public aimX(_aimX: number): void;
        public aimX(): number;
        public aimY(_aimY: number): void;
        public aimY(): number;
        public healTime(): number;
        public healTime(_healTime: number): void;
        public itemTime(_itemTime: number): void;
        public itemTime(): number;
        public mineTimer(): number;
        public mineTimer(_mineTimer: number): void;
        public splashTimer(_splashTimer: number): void;
        public splashTimer(): number;
        public lastFogPos(): number;
        public lastFogPos(_lastFogPos: number): void;
        public lastCommanded(): string;
        public lastCommanded(_lastCommanded: string): void;
        public physref(): Packages.mindustry.async.PhysicsProcess.PhysicRef;
        public physref(
          _physref: Packages.mindustry.async.PhysicsProcess.PhysicRef,
        ): void;
        public dockedType(
          _dockedType: Packages.mindustry._type.UnitType,
        ): void;
        public dockedType(): Packages.mindustry._type.UnitType;
        public mineTile(): Packages.mindustry.world.Tile;
        public mineTile(
          _mineTile: Packages.mindustry.world.Tile,
        ): void;
        public lastDrownFloor(
          _lastDrownFloor: Packages.mindustry.world.blocks.environment.Floor,
        ): void;
        public lastDrownFloor(): Packages.mindustry.world.blocks.environment.Floor;
        public setIndex__unit(_index: number): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare class StatusEffect extends Packages.mindustry
        .ctype.UnlockableContent {
        public static TransitionHandler = class {
          public handle(
            _unit: Packages.mindustry.gen.Unit,
            _current: Packages.mindustry.entities.units.StatusEntry,
            _time: number,
          ): void;
        };
        public damageMultiplier: number;
        public healthMultiplier: number;
        public speedMultiplier: number;
        public reloadMultiplier: number;
        public buildSpeedMultiplier: number;
        public dragMultiplier: number;
        public transitionDamage: number;
        public disarm: boolean;
        public damage: number;
        public effectChance: number;
        public parentizeEffect: boolean;
        public permanent: boolean;
        public reactive: boolean;
        public dynamic: boolean;
        public show: boolean;
        public color: Packages.arc.graphics.Color;
        public effect: Packages.mindustry.entities.Effect;
        public applyEffect: Packages.mindustry.entities.Effect;
        public applyExtend: boolean;
        public applyColor: Packages.arc.graphics.Color;
        public parentizeApplyEffect: boolean;
        public affinities: Packages.arc.struct.ObjectSet<Packages.mindustry._type.StatusEffect>;
        public opposites: Packages.arc.struct.ObjectSet<Packages.mindustry._type.StatusEffect>;
        public outline: boolean;
        protected transitions: Packages.arc.struct.ObjectMap<
          Packages.mindustry._type.StatusEffect,
          Packages.mindustry._type.StatusEffect.TransitionHandler
        >;
        protected initblock: Packages.java.lang.Runnable;
        public toString(): string;
        public isHidden(): boolean;
        public update(
          _unit: Packages.mindustry.gen.Unit,
          _time: number,
        ): void;
        public init(
          _run: Packages.java.lang.Runnable,
        ): void;
        public init(): void;
        protected trans(
          _effect: Packages.mindustry._type.StatusEffect,
          _handler: Packages.mindustry._type.StatusEffect.TransitionHandler,
        ): void;
        public applied(
          _unit: Packages.mindustry.gen.Unit,
          _time: number,
          _extend: boolean,
        ): void;
        public draw(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public draw(
          _unit: Packages.mindustry.gen.Unit,
          _time: number,
        ): void;
        public onRemoved(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public createIcons(
          _packer: Packages.mindustry.graphics.MultiPacker,
        ): void;
        public setStats(): void;
        public showUnlock(): boolean;
        protected handleOpposite(
          _other: Packages.mindustry._type.StatusEffect,
        ): void;
        protected affinity(
          _effect: Packages.mindustry._type.StatusEffect,
          _handler: Packages.mindustry._type.StatusEffect.TransitionHandler,
        ): void;
        protected opposite(
          ..._effect: Packages.mindustry._type.StatusEffect[]
        ): void;
        public reactsWith(
          _effect: Packages.mindustry._type.StatusEffect,
        ): boolean;
        public applyTransition(
          _unit: Packages.mindustry.gen.Unit,
          _to: Packages.mindustry._type.StatusEffect,
          _entry: Packages.mindustry.entities.units.StatusEntry,
          _time: number,
        ): boolean;
        public getContentType(): Packages.mindustry.ctype.ContentType;
        public constructor(_name: string);
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare class Liquid
        extends Packages.mindustry.ctype.UnlockableContent
        implements Packages.mindustry.logic.Senseable
      {
        public static animationFrames: number;
        public static animationScaleGas: number;
        public static animationScaleLiquid: number;
        protected static rand: Packages.arc.math.Rand;
        public gas: boolean;
        public color: Packages.arc.graphics.Color;
        public gasColor: Packages.arc.graphics.Color;
        public lightColor: Packages.arc.graphics.Color;
        public flammability: number;
        public temperature: number;
        public heatCapacity: number;
        public viscosity: number;
        public explosiveness: number;
        public blockReactive: boolean;
        public coolant: boolean;
        public moveThroughBlocks: boolean;
        public incinerable: boolean;
        public effect: Packages.mindustry._type.StatusEffect;
        public particleEffect: Packages.mindustry.entities.Effect;
        public particleSpacing: number;
        public boilPoint: number;
        public capPuddles: boolean;
        public vaporEffect: Packages.mindustry.entities.Effect;
        public hidden: boolean;
        public canStayOn: Packages.arc.struct.ObjectSet<Packages.mindustry._type.Liquid>;
        public toString(): string;
        public isHidden(): boolean;
        public update(
          _puddle: Packages.mindustry.gen.Puddle,
        ): void;
        public init(): void;
        public sense(
          _sensor: Packages.mindustry.logic.LAccess,
        ): number;
        public barColor(): Packages.arc.graphics.Color;
        public senseObject(
          _sensor: Packages.mindustry.logic.LAccess,
        ): any;
        public setStats(): void;
        public getAnimationFrame(): number;
        public willBoil(): boolean;
        public canExtinguish(): boolean;
        public drawPuddle(
          _puddle: Packages.mindustry.gen.Puddle,
        ): void;
        public react(
          _other: Packages.mindustry._type.Liquid,
          _amount: number,
          _tile: Packages.mindustry.world.Tile,
          _x: number,
          _y: number,
        ): number;
        public getContentType(): Packages.mindustry.ctype.ContentType;
        public constructor(
          _name: string,
          _color: Packages.arc.graphics.Color,
        );
        public constructor(_name: string);
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace meta {
        declare class StatUnit extends java.lang.Object {
          public static blocks: Packages.mindustry.world.meta.StatUnit;
          public static blocksSquared: Packages.mindustry.world.meta.StatUnit;
          public static tilesSecond: Packages.mindustry.world.meta.StatUnit;
          public static powerSecond: Packages.mindustry.world.meta.StatUnit;
          public static liquidSecond: Packages.mindustry.world.meta.StatUnit;
          public static itemsSecond: Packages.mindustry.world.meta.StatUnit;
          public static liquidUnits: Packages.mindustry.world.meta.StatUnit;
          public static powerUnits: Packages.mindustry.world.meta.StatUnit;
          public static heatUnits: Packages.mindustry.world.meta.StatUnit;
          public static degrees: Packages.mindustry.world.meta.StatUnit;
          public static seconds: Packages.mindustry.world.meta.StatUnit;
          public static minutes: Packages.mindustry.world.meta.StatUnit;
          public static shots: Packages.mindustry.world.meta.StatUnit;
          public static perSecond: Packages.mindustry.world.meta.StatUnit;
          public static perMinute: Packages.mindustry.world.meta.StatUnit;
          public static perShot: Packages.mindustry.world.meta.StatUnit;
          public static timesSpeed: Packages.mindustry.world.meta.StatUnit;
          public static percent: Packages.mindustry.world.meta.StatUnit;
          public static shieldHealth: Packages.mindustry.world.meta.StatUnit;
          public static none: Packages.mindustry.world.meta.StatUnit;
          public static items: Packages.mindustry.world.meta.StatUnit;
          public space: boolean;
          public name: string;
          public icon?: string;
          public localized(): string;
          public constructor(_name: string, _icon: string);
          public constructor(_name: string);
          public constructor(
            _name: string,
            _space: boolean,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace meta {
        declare class Stats extends java.lang.Object {
          public useCategories: boolean;
          public intialized: boolean;
          public timePeriod: number;
          private map?: Packages.arc.struct.OrderedMap<
            Packages.mindustry.world.meta.StatCat,
            Packages.arc.struct.OrderedMap<
              Packages.mindustry.world.meta.Stat,
              Packages.arc.struct.Seq<Packages.mindustry.world.meta.StatValue>
            >
          >;
          private dirty: boolean;
          public add(
            _stat: Packages.mindustry.world.meta.Stat,
            _attr: Packages.mindustry.world.meta.Attribute,
            _floating: boolean,
          ): void;
          public add(
            _stat: Packages.mindustry.world.meta.Stat,
            _attr: Packages.mindustry.world.meta.Attribute,
            _scale: number,
          ): void;
          public add(
            _stat: Packages.mindustry.world.meta.Stat,
            _attr: Packages.mindustry.world.meta.Attribute,
          ): void;
          public add(
            _stat: Packages.mindustry.world.meta.Stat,
            _liquid: Packages.mindustry._type.Liquid,
            _amount: number,
            _perSecond: boolean,
          ): void;
          public add(
            _stat: Packages.mindustry.world.meta.Stat,
            _attr: Packages.mindustry.world.meta.Attribute,
            _floating: boolean,
            _scale: number,
            _startZero: boolean,
          ): void;
          public add(
            _stat: Packages.mindustry.world.meta.Stat,
            _format: string,
            ..._args: any[]
          ): void;
          public add(
            _stat: Packages.mindustry.world.meta.Stat,
            _value: Packages.mindustry.world.meta.StatValue,
          ): void;
          public add(
            _stat: Packages.mindustry.world.meta.Stat,
            _value: number,
            _unit: Packages.mindustry.world.meta.StatUnit,
          ): void;
          public add(
            _stat: Packages.mindustry.world.meta.Stat,
            _value: number,
          ): void;
          public add(
            _stat: Packages.mindustry.world.meta.Stat,
            _value: boolean,
          ): void;
          public add(
            _stat: Packages.mindustry.world.meta.Stat,
            _item: Packages.mindustry._type.ItemStack,
          ): void;
          public add(
            _stat: Packages.mindustry.world.meta.Stat,
            _item: Packages.mindustry._type.Item,
          ): void;
          public remove(
            _stat: Packages.mindustry.world.meta.Stat,
          ): void;
          public toMap(): Packages.arc.struct.OrderedMap<
            Packages.mindustry.world.meta.StatCat,
            Packages.arc.struct.OrderedMap<
              Packages.mindustry.world.meta.Stat,
              Packages.arc.struct.Seq<Packages.mindustry.world.meta.StatValue>
            >
          >;
          public addPercent(
            _stat: Packages.mindustry.world.meta.Stat,
            _value: number,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ctype {
      declare abstract class UnlockableContent extends Packages
        .mindustry.ctype.MappableContent {
        public stats: Packages.mindustry.world.meta.Stats;
        public localizedName: string;
        public description?: string;
        public details?: string;
        public alwaysUnlocked: boolean;
        public inlineDescription: boolean;
        public hideDetails: boolean;
        public generateIcons: boolean;
        public iconId: number;
        public selectionSize: number;
        public uiIcon: Packages.arc.graphics.g2d.TextureRegion;
        public fullIcon: Packages.arc.graphics.g2d.TextureRegion;
        public fullOverride: string;
        public techNode?: Packages.mindustry.content.TechTree.TechNode;
        public techNodes: Packages.arc.struct.Seq<Packages.mindustry.content.TechTree.TechNode>;
        public isHidden(): boolean;
        public unlock(): void;
        public getDependencies(
          _cons: Packages.arc.func.Cons<Packages.mindustry.ctype.UnlockableContent>,
        ): void;
        public researchRequirements():
          | Packages.mindustry._type.ItemStack[]
          | null;
        public emoji(): string;
        public createIcons(
          _packer: Packages.mindustry.graphics.MultiPacker,
        ): void;
        public getLogicId(): number;
        public unlockedNow(): boolean;
        public setStats(): void;
        public unlocked(): boolean;
        public logicVisible(): boolean;
        protected makeOutline(
          _packer: Packages.mindustry.graphics.MultiPacker,
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _name: string,
          _outlineColor: Packages.arc.graphics.Color,
        ): void;
        protected makeOutline(
          _page: Packages.mindustry.graphics.MultiPacker.PageType,
          _packer: Packages.mindustry.graphics.MultiPacker,
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _makeNew: boolean,
          _outlineColor: Packages.arc.graphics.Color,
          _outlineRadius: number,
        ): void;
        protected makeOutline(
          _packer: Packages.mindustry.graphics.MultiPacker,
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _name: string,
          _outlineColor: Packages.arc.graphics.Color,
          _outlineRadius: number,
        ): void;
        public onUnlock(): void;
        public loadIcon(): void;
        public displayDescription(): string;
        public checkStats(): void;
        public displayExtra(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public emojiChar(): number;
        public hasEmoji(): boolean;
        public showUnlock(): boolean;
        public quietUnlock(): void;
        public unlockedNowHost(): boolean;
        public clearUnlock(): void;
        public locked(): boolean;
        public constructor(_name: string);
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace meta {
        declare class BlockGroup extends Packages.java.lang
          .Enum<Packages.mindustry.world.meta.BlockGroup> {
          public static none: Packages.mindustry.world.meta.BlockGroup;
          public static walls: Packages.mindustry.world.meta.BlockGroup;
          public static projectors: Packages.mindustry.world.meta.BlockGroup;
          public static turrets: Packages.mindustry.world.meta.BlockGroup;
          public static transportation: Packages.mindustry.world.meta.BlockGroup;
          public static power: Packages.mindustry.world.meta.BlockGroup;
          public static liquids: Packages.mindustry.world.meta.BlockGroup;
          public static drills: Packages.mindustry.world.meta.BlockGroup;
          public static units: Packages.mindustry.world.meta.BlockGroup;
          public static logic: Packages.mindustry.world.meta.BlockGroup;
          public static payloads: Packages.mindustry.world.meta.BlockGroup;
          public static heat: Packages.mindustry.world.meta.BlockGroup;
          public anyReplace: boolean;
          private static $VALUES: Packages.mindustry.world.meta.BlockGroup[];
          public static values():
            | Packages.mindustry.world.meta.BlockGroup[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.mindustry.world.meta.BlockGroup;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare class Category extends Packages.java.lang
        .Enum<Packages.mindustry._type.Category> {
        public static turret: Packages.mindustry._type.Category;
        public static production: Packages.mindustry._type.Category;
        public static distribution: Packages.mindustry._type.Category;
        public static liquid: Packages.mindustry._type.Category;
        public static power: Packages.mindustry._type.Category;
        public static defense: Packages.mindustry._type.Category;
        public static crafting: Packages.mindustry._type.Category;
        public static units: Packages.mindustry._type.Category;
        public static effect: Packages.mindustry._type.Category;
        public static logic: Packages.mindustry._type.Category;
        public static all: Packages.mindustry._type.Category[];
        private static $VALUES: Packages.mindustry._type.Category[];
        public static values():
          | Packages.mindustry._type.Category[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.mindustry._type.Category;
        public next(): Packages.mindustry._type.Category;
        public prev(): Packages.mindustry._type.Category;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace meta {
        declare class BuildVisibility extends java.lang
          .Object {
          public static hidden: Packages.mindustry.world.meta.BuildVisibility;
          public static shown: Packages.mindustry.world.meta.BuildVisibility;
          public static debugOnly: Packages.mindustry.world.meta.BuildVisibility;
          public static editorOnly: Packages.mindustry.world.meta.BuildVisibility;
          public static sandboxOnly: Packages.mindustry.world.meta.BuildVisibility;
          public static campaignOnly: Packages.mindustry.world.meta.BuildVisibility;
          public static lightingOnly: Packages.mindustry.world.meta.BuildVisibility;
          public static ammoOnly: Packages.mindustry.world.meta.BuildVisibility;
          public static fogOnly: Packages.mindustry.world.meta.BuildVisibility;
          public visible(): boolean;
          public constructor(
            _visible: Packages.arc.func.Boolp,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace consumers {
        declare class ConsumePower extends Packages
          .mindustry.world.consumers.Consume {
          public usage: number;
          public capacity: number;
          public buffered: boolean;
          public apply(
            _block: Packages.mindustry.world.Block,
          ): void;
          public ignore(): boolean;
          public display(
            _stats: Packages.mindustry.world.meta.Stats,
          ): void;
          public efficiency(
            _build: Packages.mindustry.gen.Building,
          ): number;
          public requestedPower(
            _entity: Packages.mindustry.gen.Building,
          ): number;
          public constructor(
            _usage: number,
            _capacity: number,
            _buffered: boolean,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace consumers {
        declare class ConsumeItems extends Packages
          .mindustry.world.consumers.Consume {
          public items: Packages.mindustry._type.ItemStack[];
          public trigger(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public apply(
            _block: Packages.mindustry.world.Block,
          ): void;
          public build(
            _build: Packages.mindustry.gen.Building,
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public display(
            _stats: Packages.mindustry.world.meta.Stats,
          ): void;
          public efficiency(
            _build: Packages.mindustry.gen.Building,
          ): number;
          public constructor(
            _items: Packages.mindustry._type.ItemStack[],
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace consumers {
        declare abstract class ConsumeLiquidBase extends Packages
          .mindustry.world.consumers.Consume {
          public amount: number;
          public apply(
            _block: Packages.mindustry.world.Block,
          ): void;
          public constructor(_amount: number);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace consumers {
        declare class ConsumeLiquid extends Packages
          .mindustry.world.consumers.ConsumeLiquidBase {
          public liquid: Packages.mindustry._type.Liquid;
          public update(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public apply(
            _block: Packages.mindustry.world.Block,
          ): void;
          public build(
            _build: Packages.mindustry.gen.Building,
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public display(
            _stats: Packages.mindustry.world.meta.Stats,
          ): void;
          public efficiency(
            _build: Packages.mindustry.gen.Building,
          ): number;
          public constructor(
            _liquid: Packages.mindustry._type.Liquid,
            _amount: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare class LiquidStack
        extends java.lang.Object
        implements
          Packages.java.lang
            .Comparable<Packages.mindustry._type.LiquidStack>
      {
        public static empty: Packages.mindustry._type.LiquidStack[];
        public liquid: Packages.mindustry._type.Liquid;
        public amount: number;
        public equals(_o: any): boolean;
        public equals(
          _other: Packages.mindustry._type.LiquidStack,
        ): boolean;
        public toString(): string;
        public compareTo(
          _liquidStack: Packages.mindustry._type.LiquidStack,
        ): number;
        public compareTo(_liquidStack: any): number;
        public static list(
          ..._items: any[]
        ): Packages.arc.struct.Seq<Packages.mindustry._type.LiquidStack>;
        public set(
          _liquid: Packages.mindustry._type.Liquid,
          _amount: number,
        ): Packages.mindustry._type.LiquidStack;
        public copy(): Packages.mindustry._type.LiquidStack;
        public static mult(
          _stacks: Packages.mindustry._type.LiquidStack[],
          _amount: number,
        ): Packages.mindustry._type.LiquidStack[] | null;
        public static with(
          ..._items: any[]
        ): Packages.mindustry._type.LiquidStack[] | null;
        public constructor(
          _liquid: Packages.mindustry._type.Liquid,
          _amount: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace consumers {
        declare class ConsumeLiquids extends Packages
          .mindustry.world.consumers.Consume {
          public liquids: Packages.mindustry._type.LiquidStack[];
          public update(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public apply(
            _block: Packages.mindustry.world.Block,
          ): void;
          public build(
            _build: Packages.mindustry.gen.Building,
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public display(
            _stats: Packages.mindustry.world.meta.Stats,
          ): void;
          public efficiency(
            _build: Packages.mindustry.gen.Building,
          ): number;
          public constructor(
            _liquids: Packages.mindustry._type.LiquidStack[],
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare class ReqImage extends Packages.arc.scene.ui
        .layout.Stack {
        public valid(): boolean;
        public constructor(
          _image: Packages.arc.scene.Element,
          _valid: Packages.arc.func.Boolp,
        );
        public constructor(
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _valid: Packages.arc.func.Boolp,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare class MultiReqImage extends Packages.arc.scene
        .ui.layout.Stack {
        private displays: Packages.arc.struct.Seq<Packages.mindustry.ui.ReqImage>;
        private time: number;
        public add(
          _display: Packages.mindustry.ui.ReqImage,
        ): void;
        public act(_delta: number): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace consumers {
        declare class ConsumeLiquidFilter extends Packages
          .mindustry.world.consumers.ConsumeLiquidBase {
          public filter: Packages.arc.func.Boolf<Packages.mindustry._type.Liquid>;
          public update(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public apply(
            _block: Packages.mindustry.world.Block,
          ): void;
          public build(
            _build: Packages.mindustry.gen.Building,
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public display(
            _stats: Packages.mindustry.world.meta.Stats,
          ): void;
          public efficiency(
            _build: Packages.mindustry.gen.Building,
          ): number;
          public getConsumed(
            _build: Packages.mindustry.gen.Building,
          ): Packages.mindustry._type.Liquid | null;
          public constructor(
            _liquid: Packages.arc.func.Boolf<Packages.mindustry._type.Liquid>,
            _amount: number,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace consumers {
        declare class ConsumeCoolant extends Packages
          .mindustry.world.consumers.ConsumeLiquidFilter {
          public maxTemp: number;
          public maxFlammability: number;
          public allowLiquid: boolean;
          public allowGas: boolean;
          public constructor();
          public constructor(_amount: number);
          public constructor(
            _amount: number,
            _allowLiquid: boolean,
            _allowGas: boolean,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare class Block
        extends Packages.mindustry.ctype.UnlockableContent
        implements Packages.mindustry.logic.Senseable
      {
        public hasItems: boolean;
        public hasLiquids: boolean;
        public hasPower: boolean;
        public outputsLiquid: boolean;
        public consumesPower: boolean;
        public outputsPower: boolean;
        public connectedPower: boolean;
        public conductivePower: boolean;
        public outputsPayload: boolean;
        public acceptsPayloads: boolean;
        public acceptsPayload: boolean;
        public acceptsItems: boolean;
        public separateItemCapacity: boolean;
        public itemCapacity: number;
        public liquidCapacity: number;
        public liquidPressure: number;
        public outputFacing: boolean;
        public noSideBlend: boolean;
        public displayFlow: boolean;
        public inEditor: boolean;
        public lastConfig?: any;
        public saveConfig: boolean;
        public copyConfig: boolean;
        public clearOnDoubleTap: boolean;
        public update: boolean;
        public destructible: boolean;
        public unloadable: boolean;
        public isDuct: boolean;
        public allowResupply: boolean;
        public solid: boolean;
        public solidifes: boolean;
        public teamPassable: boolean;
        public underBullets: boolean;
        public rotate: boolean;
        public rotateDraw: boolean;
        public lockRotation: boolean;
        public invertFlip: boolean;
        public variants: number;
        public drawArrow: boolean;
        public drawTeamOverlay: boolean;
        public saveData: boolean;
        public breakable: boolean;
        public rebuildable: boolean;
        public privileged: boolean;
        public requiresWater: boolean;
        public placeableLiquid: boolean;
        public placeablePlayer: boolean;
        public placeableOn: boolean;
        public insulated: boolean;
        public squareSprite: boolean;
        public absorbLasers: boolean;
        public enableDrawStatus: boolean;
        public drawDisabled: boolean;
        public autoResetEnabled: boolean;
        public noUpdateDisabled: boolean;
        public updateInUnits: boolean;
        public alwaysUpdateInUnits: boolean;
        public deconstructDropAllLiquid: boolean;
        public useColor: boolean;
        public itemDrop?: Packages.mindustry._type.Item;
        public playerUnmineable: boolean;
        public attributes: Packages.mindustry.world.blocks.Attributes;
        public scaledHealth: number;
        public health: number;
        public armor: number;
        public baseExplosiveness: number;
        public destroyBullet?: Packages.mindustry.entities.bullet.BulletType;
        public destroyBulletSameTeam: boolean;
        public lightLiquid?: Packages.mindustry._type.Liquid;
        public drawCracks: boolean;
        public createRubble: boolean;
        public floating: boolean;
        public size: number;
        public offset: number;
        public sizeOffset: number;
        public clipSize: number;
        public placeOverlapRange: number;
        public crushDamageMultiplier: number;
        public timers: number;
        public cacheLayer: Packages.mindustry.graphics.CacheLayer;
        public fillsTile: boolean;
        public forceDark: boolean;
        public alwaysReplace: boolean;
        public replaceable: boolean;
        public group: Packages.mindustry.world.meta.BlockGroup;
        public flags: Packages.arc.struct.EnumSet<Packages.mindustry.world.meta.BlockFlag>;
        public priority: number;
        public unitCapModifier: number;
        public configurable: boolean;
        public ignoreResizeConfig: boolean;
        public commandable: boolean;
        public allowConfigInventory: boolean;
        public selectionRows: number;
        public selectionColumns: number;
        public logicConfigurable: boolean;
        public consumesTap: boolean;
        public drawLiquidLight: boolean;
        public envRequired: number;
        public envEnabled: number;
        public envDisabled: number;
        public sync: boolean;
        public conveyorPlacement: boolean;
        public allowDiagonal: boolean;
        public swapDiagonalPlacement: boolean;
        public allowRectanglePlacement: boolean;
        public schematicPriority: number;
        public mapColor: Packages.arc.graphics.Color;
        public hasColor: boolean;
        public targetable: boolean;
        public attacks: boolean;
        public suppressable: boolean;
        public canOverdrive: boolean;
        public outlineColor: Packages.arc.graphics.Color;
        public outlineIcon: boolean;
        public outlineRadius: number;
        public outlinedIcon: number;
        public hasShadow: boolean;
        public customShadow: boolean;
        public placePitchChange: boolean;
        public breakPitchChange: boolean;
        public placeSound: Packages.arc.audio.Sound;
        public breakSound: Packages.arc.audio.Sound;
        public destroySound: Packages.arc.audio.Sound;
        public albedo: number;
        public lightColor: Packages.arc.graphics.Color;
        public emitLight: boolean;
        public lightRadius: number;
        public fogRadius: number;
        public loopSound: Packages.arc.audio.Sound;
        public loopSoundVolume: number;
        public ambientSound: Packages.arc.audio.Sound;
        public ambientSoundVolume: number;
        public category: Packages.mindustry._type.Category;
        public buildCost: number;
        public buildVisibility: Packages.mindustry.world.meta.BuildVisibility;
        public buildCostMultiplier: number;
        public deconstructThreshold: number;
        public instantDeconstruct: boolean;
        public instantBuild: boolean;
        public placeEffect: Packages.mindustry.entities.Effect;
        public breakEffect: Packages.mindustry.entities.Effect;
        public destroyEffect: Packages.mindustry.entities.Effect;
        public researchCostMultiplier: number;
        public researchCostMultipliers: Packages.arc.struct.ObjectFloatMap<Packages.mindustry._type.Item>;
        public researchCost?: Packages.mindustry._type.ItemStack[];
        public instantTransfer: boolean;
        public quickRotate: boolean;
        public allowDerelictRepair: boolean;
        public subclass?: Packages.java.lang.Class<any>;
        public selectScroll: number;
        public buildType: Packages.arc.func.Prov<Packages.mindustry.gen.Building>;
        public configurations: Packages.arc.struct.ObjectMap<
          Packages.java.lang.Class<any>,
          Packages.arc.func.Cons2<anyany>
        >;
        public itemFilter: boolean[];
        public liquidFilter: boolean[];
        public consumers: Packages.mindustry.world.consumers.Consume[];
        public optionalConsumers: Packages.mindustry.world.consumers.Consume[];
        public nonOptionalConsumers: Packages.mindustry.world.consumers.Consume[];
        public updateConsumers: Packages.mindustry.world.consumers.Consume[];
        public hasConsumers: boolean;
        public consPower?: Packages.mindustry.world.consumers.ConsumePower;
        protected barMap: Packages.arc.struct.OrderedMap<
          string,
          Packages.arc.func.Func<
            Packages.mindustry.gen.Building,
            Packages.mindustry.ui.Bar
          >
        >;
        protected consumeBuilder: Packages.arc.struct.Seq<Packages.mindustry.world.consumers.Consume>;
        protected generatedIcons: Packages.arc.graphics.g2d.TextureRegion[];
        public regionRotated1: number;
        public regionRotated2: number;
        public region: Packages.arc.graphics.g2d.TextureRegion;
        public customShadowRegion: Packages.arc.graphics.g2d.TextureRegion;
        public teamRegion: Packages.arc.graphics.g2d.TextureRegion;
        public teamRegions: Packages.arc.graphics.g2d.TextureRegion[];
        public variantShadowRegions: Packages.arc.graphics.g2d.TextureRegion[];
        protected static tempTiles: Packages.arc.struct.Seq<Packages.mindustry.world.Tile>;
        protected static tempBuilds: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
        protected timerDump: number;
        public dumpTime: number;
        public isHidden(): boolean;
        public load(): void;
        public isStatic(): boolean;
        public bounds(
          _x: number,
          _y: number,
          _rect: Packages.arc.math.geom.Rect,
        ): Packages.arc.math.geom.Rect;
        public init(): void;
        public isAccessible(): boolean;
        public synthetic(): boolean;
        public getDisplayName(
          _tile: Packages.mindustry.world.Tile,
        ): string;
        public config<
          T,
          E extends Packages.mindustry.gen.Building,
        >(
          _type: Class<T> | Packages.java.lang.Class<T>,
          _config: Packages.arc.func.Cons2<E, T>,
        ): void;
        public consume<
          T extends
            Packages.mindustry.world.consumers.Consume,
        >(_consume: T): T | null;
        public getDependencies(
          _cons: Packages.arc.func.Cons<Packages.mindustry.ctype.UnlockableContent>,
        ): void;
        public isVisible(): boolean;
        public researchRequirements():
          | Packages.mindustry._type.ItemStack[]
          | null;
        public consumesItem(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public consumesLiquid(
          _liq: Packages.mindustry._type.Liquid,
        ): boolean;
        public supportsEnv(_env: number): boolean;
        public sense(
          _sensor: Packages.mindustry.logic.LAccess,
        ): number;
        public sense(
          _content: Packages.mindustry.ctype.Content,
        ): number;
        public configSenseable(): boolean;
        public listBars(): Packages.java.lang.Iterable<
          Packages.arc.func.Func<
            Packages.mindustry.gen.Building,
            Packages.mindustry.ui.Bar
          >
        >;
        public variantRegions():
          | Packages.arc.graphics.g2d.TextureRegion[]
          | null;
        public drawOverlay(
          _x: number,
          _y: number,
          _rotation: number,
        ): void;
        public checkForceDark(
          _tile: Packages.mindustry.world.Tile,
        ): boolean;
        public isMultiblock(): boolean;
        public getEdges():
          | Packages.arc.math.geom.Point2[]
          | null;
        public hasBuilding(): boolean;
        public asFloor(): Packages.mindustry.world.blocks.environment.Floor;
        public getDisplayIcon(
          _tile: Packages.mindustry.world.Tile,
        ): Packages.arc.graphics.g2d.TextureRegion;
        public newBuilding(): Packages.mindustry.gen.Building;
        public consumeItem(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): Packages.mindustry.world.consumers.ConsumeItems;
        public consumeItem(
          _item: Packages.mindustry._type.Item,
        ): Packages.mindustry.world.consumers.ConsumeItems;
        public setBars(): void;
        public createIcons(
          _packer: Packages.mindustry.graphics.MultiPacker,
        ): void;
        public getRegionsToOutline(
          _out: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.TextureRegion>,
        ): void;
        public planRotation(_rot: number): number;
        public drawBase(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public drawShadow(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public percentSolid(_x: number, _y: number): number;
        public drawEnvironmentLight(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public drawPlace(
          _x: number,
          _y: number,
          _rotation: number,
          _valid: boolean,
        ): void;
        public drawPlaceText(
          _text: string,
          _x: number,
          _y: number,
          _valid: boolean,
        ): number;
        public sumAttribute(
          _attr: Packages.mindustry.world.meta.Attribute | null,
          _x: number,
          _y: number,
        ): number;
        public minimapColor(
          _tile: Packages.mindustry.world.Tile,
        ): number;
        public outputsItems(): boolean;
        public canPlaceOn(
          _tile: Packages.mindustry.world.Tile,
          _team: Packages.mindustry.game.Team,
          _rotation: number,
        ): boolean;
        public canBreak(
          _tile: Packages.mindustry.world.Tile,
        ): boolean;
        public removeBar(_name: string): void;
        public canReplace(
          _other: Packages.mindustry.world.Block,
        ): boolean;
        public getReplacement(
          _req: Packages.mindustry.entities.units.BuildPlan,
          _plans: Packages.arc.struct.Seq<Packages.mindustry.entities.units.BuildPlan>,
        ): Packages.mindustry.world.Block;
        public handlePlacementLine(
          _plans: Packages.arc.struct.Seq<Packages.mindustry.entities.units.BuildPlan>,
        ): void;
        public nextConfig(): any;
        public onNewPlan(
          _plan: Packages.mindustry.entities.units.BuildPlan,
        ): void;
        public drawPlanConfigTop(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
        ): void;
        public pointConfig(
          _config: any,
          _transformer: Packages.arc.func.Cons<Packages.arc.math.geom.Point2>,
        ): any;
        public configClear<
          E extends Packages.mindustry.gen.Building,
        >(_cons: Packages.arc.func.Cons<E>): void;
        public nearbySide(
          _x: number,
          _y: number,
          _rotation: number,
          _index: number,
          _out: Packages.arc.math.geom.Point2,
        ): void;
        public iterateTaken(
          _x: number,
          _y: number,
          _placer: Packages.arc.func.Intc2,
        ): void;
        public makeIconRegions():
          | Packages.arc.graphics.g2d.TextureRegion[]
          | null;
        public getGeneratedIcons():
          | Packages.arc.graphics.g2d.TextureRegion[]
          | null;
        public resetGeneratedIcons(): void;
        public updateClipRadius(_size: number): void;
        public isVisibleOn(
          _planet: Packages.mindustry._type.Planet,
        ): boolean;
        public isPlaceable(): boolean;
        public beforePlaceBegan(
          _tile: Packages.mindustry.world.Tile,
          _previous: Packages.mindustry.world.Block,
        ): void;
        public isFloor(): boolean;
        public isOverlay(): boolean;
        public isAir(): boolean;
        public environmentBuildable(): boolean;
        public findConsumer<
          T extends
            Packages.mindustry.world.consumers.Consume,
        >(
          _filter: Packages.arc.func.Boolf<Packages.mindustry.world.consumers.Consume>,
        ): T | null;
        public hasConsumer(
          _cons: Packages.mindustry.world.consumers.Consume,
        ): boolean;
        public removeConsumer(
          _cons: Packages.mindustry.world.consumers.Consume,
        ): void;
        public removeConsumers(
          _b: Packages.arc.func.Boolf<Packages.mindustry.world.consumers.Consume>,
        ): void;
        public consumeLiquid(
          _liquid: Packages.mindustry._type.Liquid,
          _amount: number,
        ): Packages.mindustry.world.consumers.ConsumeLiquid;
        public consumeLiquids(
          ..._stacks: Packages.mindustry._type.LiquidStack[]
        ): Packages.mindustry.world.consumers.ConsumeLiquids;
        public consumePower(
          _powerPerTick: number,
        ): Packages.mindustry.world.consumers.ConsumePower;
        public consumePowerCond<
          T extends Packages.mindustry.gen.Building,
        >(
          _usage: number,
          _cons: Packages.arc.func.Boolf<T>,
        ): Packages.mindustry.world.consumers.ConsumePower;
        public consumePowerDynamic<
          T extends Packages.mindustry.gen.Building,
        >(
          _displayed: number,
          _usage: Packages.arc.func.Floatf<T>,
        ): Packages.mindustry.world.consumers.ConsumePower;
        public consumePowerDynamic<
          T extends Packages.mindustry.gen.Building,
        >(
          _usage: Packages.arc.func.Floatf<T>,
        ): Packages.mindustry.world.consumers.ConsumePower;
        public consumePowerBuffered(
          _powerCapacity: number,
        ): Packages.mindustry.world.consumers.ConsumePower;
        public consumeItems(
          ..._items: Packages.mindustry._type.ItemStack[]
        ): Packages.mindustry.world.consumers.ConsumeItems;
        public senseObject(
          _sensor: Packages.mindustry.logic.LAccess,
        ): any;
        public requirements(
          _cat: Packages.mindustry._type.Category,
          _stacks: Packages.mindustry._type.ItemStack[],
        ): void;
        public requirements(
          _cat: Packages.mindustry._type.Category,
          _visible: Packages.mindustry.world.meta.BuildVisibility,
          _stacks: Packages.mindustry._type.ItemStack[],
        ): void;
        public requirements(
          _cat: Packages.mindustry._type.Category,
          _stacks: Packages.mindustry._type.ItemStack[],
          _unlocked: boolean,
        ): void;
        protected initBuilding(): void;
        public drawPotentialLinks(
          _x: number,
          _y: number,
        ): void;
        public rotatedOutput(
          _fromX: number,
          _fromY: number,
          _destination: Packages.mindustry.world.Tile,
        ): boolean;
        public rotatedOutput(
          _x: number,
          _y: number,
        ): boolean;
        public setStats(): void;
        public canBeBuilt(): boolean;
        public addBar<
          T extends Packages.mindustry.gen.Building,
        >(
          _name: string,
          _sup: Packages.arc.func.Func<
            T,
            Packages.mindustry.ui.Bar
          >,
        ): void;
        public addLiquidBar(
          _liq: Packages.mindustry._type.Liquid,
        ): void;
        public addLiquidBar<
          T extends Packages.mindustry.gen.Building,
        >(
          _current: Packages.arc.func.Func<
            T,
            Packages.mindustry._type.Liquid
          >,
        ): void;
        public changePlacementPath(
          _points: Packages.arc.struct.Seq<Packages.arc.math.geom.Point2>,
          _rotation: number,
          _diagonalOn: boolean,
        ): void;
        public changePlacementPath(
          _points: Packages.arc.struct.Seq<Packages.arc.math.geom.Point2>,
          _rotation: number,
        ): void;
        public drawPlan(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
          _valid: boolean,
        ): void;
        public drawPlan(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
          _valid: boolean,
          _alpha: number,
        ): void;
        public drawPlanRegion(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
        ): void;
        public drawDefaultPlanRegion(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
        ): void;
        public getPlanRegion(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
        ): Packages.arc.graphics.g2d.TextureRegion;
        public drawPlanConfig(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
        ): void;
        public drawPlanConfigCenter(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _content: any,
          _region: string,
        ): void;
        public drawPlanConfigCenter(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _content: any,
          _region: string,
          _cross: boolean,
        ): void;
        public getInsideEdges():
          | Packages.arc.math.geom.Point2[]
          | null;
        public editorIcon(): Packages.arc.graphics.g2d.TextureRegion;
        public editorVariantRegions():
          | Packages.arc.graphics.g2d.TextureRegion[]
          | null;
        protected icons():
          | Packages.arc.graphics.g2d.TextureRegion[]
          | null;
        public placeBegan(
          _tile: Packages.mindustry.world.Tile,
          _previous: Packages.mindustry.world.Block,
          _builder: Packages.mindustry.gen.Unit | null,
        ): void;
        public placeBegan(
          _tile: Packages.mindustry.world.Tile,
          _previous: Packages.mindustry.world.Block,
        ): void;
        public consumeCoolant(
          _amount: number,
        ): Packages.mindustry.world.consumers.ConsumeCoolant;
        public consumeCoolant(
          _amount: number,
          _allowLiquid: boolean,
          _allowGas: boolean,
        ): Packages.mindustry.world.consumers.ConsumeCoolant;
        public setupRequirements(
          _cat: Packages.mindustry._type.Category,
          _visible: Packages.mindustry.world.meta.BuildVisibility,
          _stacks: Packages.mindustry._type.ItemStack[],
        ): void;
        public setupRequirements(
          _cat: Packages.mindustry._type.Category,
          _stacks: Packages.mindustry._type.ItemStack[],
        ): void;
        public logicVisible(): boolean;
        public flipRotation(
          _req: Packages.mindustry.entities.units.BuildPlan,
          _x: boolean,
        ): void;
        public getContentType(): Packages.mindustry.ctype.ContentType;
        public constructor(_name: string);
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace game {
      declare class Schematic
        extends java.lang.Object
        implements
          Packages.java.lang
            .Comparable<Packages.mindustry.game.Schematic>,
          Packages.mindustry._type.Publishable
      {
        public static Stile = class extends java.lang
          .Object {
          public block: Packages.mindustry.world.Block;
          public x: Packages.short;
          public y: Packages.short;
          public config: any;
          public rotation: string;
          public set(
            _other: Packages.mindustry.game.Schematic.Stile,
          ): Packages.mindustry.game.Schematic.Stile;
          public copy(): Packages.mindustry.game.Schematic.Stile;
          public constructor(
            _block: Packages.mindustry.world.Block,
            _x: number,
            _y: number,
            _config: any,
            _rotation: string,
          );
          public constructor();
        };
        public tiles: Packages.arc.struct.Seq<Packages.mindustry.game.Schematic.Stile>;
        public labels: Packages.arc.struct.Seq<string>;
        public tags: Packages.arc.struct.StringMap;
        public width: number;
        public height: number;
        public file?: Packages.arc.files.Fi;
        public mod?: Packages.mindustry.mod.Mods.LoadedMod;
        public name(): string;
        public compareTo(
          _schematic: Packages.mindustry.game.Schematic,
        ): number;
        public compareTo(_schematic: any): number;
        public save(): void;
        public description(): string;
        public getSteamID(): string;
        public addSteamID(_id: string): void;
        public removeSteamID(): void;
        public steamTitle(): string;
        public steamDescription(): string;
        public steamTag(): string;
        public createSteamFolder(
          _id: string,
        ): Packages.arc.files.Fi;
        public createSteamPreview(
          _id: string,
        ): Packages.arc.files.Fi;
        public powerProduction(): number;
        public powerConsumption(): number;
        public findCore(): Packages.mindustry.world.blocks.storage.CoreBlock;
        public hasCore(): boolean;
        public requirements(): Packages.mindustry._type.ItemSeq;
        public constructor(
          _tiles: Packages.arc.struct.Seq<Packages.mindustry.game.Schematic.Stile>,
          _tags: Packages.arc.struct.StringMap,
          _width: number,
          _height: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare class BaseBuilderAI extends java.lang.Object {
        private static axis: Packages.arc.math.geom.Vec2;
        private static rotator: Packages.arc.math.geom.Vec2;
        private static attempts: number;
        private static coreUnitMultiplier: number;
        private static emptyChance: number;
        private static timerStep: number;
        private static timerSpawn: number;
        private static timerRefreshPath: number;
        private static placeIntervalMin: number;
        private static placeIntervalMax: number;
        private static pathStep: number;
        private static tmpTiles: Packages.arc.struct.Seq<Packages.mindustry.world.Tile>;
        private static correct: number;
        private static incorrect: number;
        private foundPath: boolean;
        data: Packages.mindustry.game.Teams.TeamData;
        timer: Packages.arc.util.Interval;
        path: Packages.arc.struct.IntSet;
        calcPath: Packages.arc.struct.IntSet;
        calcTile?: Packages.mindustry.world.Tile;
        calculating: boolean;
        startedCalculating: boolean;
        calcCount: number;
        totalCalcs: number;
        public update(): void;
        private randomPosition(): Packages.arc.math.geom.Position;
        private tryPlace(
          _part: Packages.mindustry.ai.BaseRegistry.BasePart,
          _x: number,
          _y: number,
        ): boolean;
        public constructor(
          _data: Packages.mindustry.game.Teams.TeamData,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare class RtsAI extends java.lang.Object {
        static targets: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
        static squad: Packages.arc.struct.Seq<Packages.mindustry.gen.Unit>;
        static used: Packages.arc.struct.IntSet;
        static assignedTargets: Packages.arc.struct.IntSet;
        static invalidTarget: Packages.arc.struct.IntSet;
        static squadRadius: number;
        static timeUpdate: number;
        static timerSpawn: number;
        static maxTargetsChecked: number;
        static flags: Packages.mindustry.world.meta.BlockFlag[];
        static weights: Packages.arc.struct.ObjectFloatMap<Packages.mindustry.gen.Building>;
        static debug: boolean;
        timer: Packages.arc.util.Interval;
        data: Packages.mindustry.game.Teams.TeamData;
        damagedSet: Packages.arc.struct.ObjectSet<Packages.mindustry.gen.Building>;
        damaged: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
        public update(): void;
        assignSquads(): void;
        checkBuilding(): void;
        handleSquad(
          _units: Packages.arc.struct.Seq<Packages.mindustry.gen.Unit>,
          _noDefenders: boolean,
        ): boolean;
        findTarget(
          _x: number,
          _y: number,
          _total: number,
          _dps: number,
          _health: number,
          _checkWeight: boolean,
          _air: boolean,
        ): Packages.mindustry.gen.Building | null;
        estimateStats(
          _fromX: number,
          _fromY: number,
          _x: number,
          _y: number,
          _selfDps: number,
          _selfHealth: number,
          _air: boolean,
        ): number;
        public constructor(
          _data: Packages.mindustry.game.Teams.TeamData,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace game {
      declare class Team
        extends java.lang.Object
        implements
          Packages.java.lang
            .Comparable<Packages.mindustry.game.Team>
      {
        public id: number;
        public color: Packages.arc.graphics.Color;
        public palette: Packages.arc.graphics.Color[];
        public palettei: number[];
        public emoji: string;
        public hasPalette: boolean;
        public name: string;
        public static all: Packages.mindustry.game.Team[];
        public static baseTeams: Packages.mindustry.game.Team[];
        public static derelict: Packages.mindustry.game.Team;
        public static sharded: Packages.mindustry.game.Team;
        public static crux: Packages.mindustry.game.Team;
        public static malis: Packages.mindustry.game.Team;
        public static green: Packages.mindustry.game.Team;
        public static blue: Packages.mindustry.game.Team;
        public static neoplastic: Packages.mindustry.game.Team;
        public static get(
          _id: number,
        ): Packages.mindustry.game.Team;
        public toString(): string;
        public compareTo(
          _team: Packages.mindustry.game.Team,
        ): number;
        public compareTo(_team: any): number;
        public data(): Packages.mindustry.game.Teams.TeamData;
        public localized(): string;
        public rules(): Packages.mindustry.game.Rules.TeamRule;
        public active(): boolean;
        public items(): Packages.mindustry.world.modules.ItemModule;
        public cores(): Packages.arc.struct.Seq<Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild>;
        public core(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild | null;
        public coloredName(): string;
        public isAI(): boolean;
        public isOnlyAI(): boolean;
        public needsFlowField(): boolean;
        public isEnemy(
          _other: Packages.mindustry.game.Team,
        ): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Teamc
        implements
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Entityc
      {
        public team(): Packages.mindustry.game.Team;
        public team(
          _team: Packages.mindustry.game.Team,
        ): void;
        public core(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public closestCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public inFogTo(
          _viewer: Packages.mindustry.game.Team,
        ): boolean;
        public closestEnemyCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public cheating(): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare class LVar extends java.lang.Object {
        public name: string;
        public id: number;
        public isobj: boolean;
        public constant: boolean;
        public objval: any;
        public numval: number;
        public syncTime: Packages.long;
        public obj(): any | null;
        public num(): number;
        public static invalid(_d: number): boolean;
        public bool(): boolean;
        public building(): Packages.mindustry.gen.Building | null;
        public team(): Packages.mindustry.game.Team | null;
        public setnum(_value: number): void;
        public numOrNan(): number;
        public numf(): number;
        public numfOrNan(): number;
        public numi(): number;
        public setbool(_value: boolean): void;
        public setobj(_value: any): void;
        public setconst(_value: any): void;
        public constructor(
          _name: string,
          _id: number,
          _constant: boolean,
        );
        public constructor(_name: string, _id: number);
        public constructor(_name: string);
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare abstract class Controllable {
        public control(
          _type: Packages.mindustry.logic.LAccess,
          _p1: Packages.mindustry.logic.LVar,
          _p2: any,
          _p3: number,
          _p4: number,
        ): void;
        public control(
          _type: Packages.mindustry.logic.LAccess,
          _p1: Packages.mindustry.logic.LVar,
          _p2: number,
          _p3: number,
          _p4: number,
        ): void;
        public control(
          _type: Packages.mindustry.logic.LAccess,
          _p1: any,
          _p2: number,
          _p3: number,
          _p4: number,
        ): void;
        public control(
          _type: Packages.mindustry.logic.LAccess,
          _p1: number,
          _p2: number,
          _p3: number,
          _p4: number,
        ): void;
        public team(): Packages.mindustry.game.Team;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace meta {
        declare class BlockStatus extends Packages.java.lang
          .Enum<Packages.mindustry.world.meta.BlockStatus> {
          public static active: Packages.mindustry.world.meta.BlockStatus;
          public static noOutput: Packages.mindustry.world.meta.BlockStatus;
          public static noInput: Packages.mindustry.world.meta.BlockStatus;
          public static logicDisable: Packages.mindustry.world.meta.BlockStatus;
          public color: Packages.arc.graphics.Color;
          private static $VALUES: Packages.mindustry.world.meta.BlockStatus[];
          public static values():
            | Packages.mindustry.world.meta.BlockStatus[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.mindustry.world.meta.BlockStatus;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class IndexableEntity__powerGraph {
        public setIndex__powerGraph(_index: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class PowerGraphUpdaterc
        implements Packages.mindustry.gen.Entityc
      {
        public update(): void;
        public graph(
          _graph: Packages.mindustry.world.blocks.power.PowerGraph,
        ): void;
        public graph(): Packages.mindustry.world.blocks.power.PowerGraph;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class PowerGraphUpdater
        extends java.lang.Object
        implements
          Packages.mindustry.gen.IndexableEntity__all,
          Packages.mindustry.gen.PowerGraphUpdaterc,
          Packages.mindustry.gen
            .IndexableEntity__powerGraph,
          Packages.mindustry.gen.Entityc
      {
        protected added: boolean;
        protected index__all: number;
        protected index__powerGraph: number;
        public add(): void;
        public remove(): void;
        public toString(): string;
        public update(): void;
        public id(): number;
        public id(_id: number): void;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public static create(): Packages.mindustry.gen.PowerGraphUpdater;
        public as<T>(): T | null;
        public graph(
          _graph: Packages.mindustry.world.blocks.power.PowerGraph,
        ): void;
        public graph(): Packages.mindustry.world.blocks.power.PowerGraph;
        public self<
          T extends Packages.mindustry.gen.Entityc,
        >(): T | null;
        public afterRead(): void;
        public isLocal(): boolean;
        public isAdded(): boolean;
        public isRemote(): boolean;
        public classId(): number;
        public setIndex__all(_index: number): void;
        public serialize(): boolean;
        public afterAllRead(): void;
        public setIndex__powerGraph(_index: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace power {
          declare class PowerGraph extends java.lang
            .Object {
            private static queue: Packages.arc.struct.Queue<Packages.mindustry.gen.Building>;
            private static outArray1: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
            private static outArray2: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
            private static closedSet: Packages.arc.struct.IntSet;
            public producers: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
            public consumers: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
            public batteries: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
            public all: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
            private entity?: Packages.mindustry.gen.PowerGraphUpdater;
            private powerBalance: Packages.arc.math.WindowedMean;
            private lastPowerProduced: number;
            private lastPowerNeeded: number;
            private lastPowerStored: number;
            private lastScaledPowerIn: number;
            private lastScaledPowerOut: number;
            private lastCapacity: number;
            private energyDelta: number;
            private graphID: number;
            private static lastGraphID: number;
            public add(
              _build: Packages.mindustry.gen.Building,
            ): void;
            public remove(
              _tile: Packages.mindustry.gen.Building,
            ): void;
            public toString(): string;
            public update(): void;
            public clear(): void;
            public getId(): number;
            public getID(): number;
            public getLastScaledPowerIn(): number;
            public getLastScaledPowerOut(): number;
            public getLastPowerStored(): number;
            public getLastCapacity(): number;
            public checkAdd(): void;
            public addGraph(
              _graph: Packages.mindustry.world.blocks.power.PowerGraph,
            ): void;
            public getPowerProduced(): number;
            public getBatteryStored(): number;
            public chargeBatteries(_excess: number): number;
            public useBatteries(_needed: number): number;
            public getBatteryCapacity(): number;
            public getPowerNeeded(): number;
            public getTotalBatteryCapacity(): number;
            public distributePower(
              _needed: number,
              _produced: number,
              _charged: boolean,
            ): void;
            public getPowerBalance(): number;
            public hasPowerBalanceSamples(): boolean;
            public getLastPowerNeeded(): number;
            public getLastPowerProduced(): number;
            public transferPower(_amount: number): void;
            public getSatisfaction(): number;
            public reflow(
              _tile: Packages.mindustry.gen.Building,
            ): void;
            public removeList(
              _build: Packages.mindustry.gen.Building,
            ): void;
            public constructor();
            public constructor(_noEntity: boolean);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace modules {
        declare class PowerModule extends Packages.mindustry
          .world.modules.BlockModule {
          public status: number;
          public init: boolean;
          public graph: Packages.mindustry.world.blocks.power.PowerGraph;
          public links: Packages.arc.struct.IntSeq;
          public write(
            _write: Packages.arc.util.io.Writes,
          ): void;
          public read(
            _read: Packages.arc.util.io.Reads,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace modules {
        declare class LiquidModule extends Packages
          .mindustry.world.modules.BlockModule {
          public static LiquidConsumer = class {
            public accept(
              _liquid: Packages.mindustry._type.Liquid,
              _amount: number,
            ): void;
          };
          public static LiquidCalculator = class {
            public get(
              _liquid: Packages.mindustry._type.Liquid,
              _amount: number,
            ): number;
          };
          private static windowSize: number;
          private static flowTimer: Packages.arc.util.Interval;
          private static pollScl: number;
          private static cacheFlow: Packages.arc.math.WindowedMean[];
          private static cacheSums: number[];
          private static displayFlow: number[];
          private static cacheBits: Packages.arc.struct.Bits;
          private liquids: number[];
          private flow?: Packages.arc.math.WindowedMean[];
          public add(
            _liquid: Packages.mindustry._type.Liquid,
            _amount: number,
          ): void;
          public remove(
            _liquid: Packages.mindustry._type.Liquid,
            _amount: number,
          ): void;
          public get(
            _liquid: Packages.mindustry._type.Liquid,
          ): number;
          public clear(): void;
          public set(
            _liquid: Packages.mindustry._type.Liquid,
            _amount: number,
          ): void;
          public write(
            _write: Packages.arc.util.io.Writes,
          ): void;
          public current(): Packages.mindustry._type.Liquid;
          public read(
            _read: Packages.arc.util.io.Reads,
            _legacy: boolean,
          ): void;
          public reset(
            _liquid: Packages.mindustry._type.Liquid,
            _amount: number,
          ): void;
          public sum(
            _calc: Packages.mindustry.world.modules.LiquidModule.LiquidCalculator,
          ): number;
          public each(
            _cons: Packages.mindustry.world.modules.LiquidModule.LiquidConsumer,
          ): void;
          public currentAmount(): number;
          public hasFlowLiquid(
            _liquid: Packages.mindustry._type.Liquid,
          ): boolean;
          public getFlowRate(
            _liquid: Packages.mindustry._type.Liquid,
          ): number;
          public updateFlow(): void;
          public stopFlow(): void;
          public handleFlow(
            _liquid: Packages.mindustry._type.Liquid,
            _amount: number,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare class PayloadSeq extends java.lang.Object {
        private payloads: Packages.arc.struct.ObjectIntMap<Packages.mindustry.ctype.UnlockableContent>;
        public add(
          _block: Packages.mindustry.ctype.UnlockableContent,
          _amount: number,
        ): void;
        public add(
          _block: Packages.mindustry.ctype.UnlockableContent,
        ): void;
        public remove(
          _block: Packages.mindustry.ctype.UnlockableContent,
        ): void;
        public remove(
          _block: Packages.mindustry.ctype.UnlockableContent,
          _amount: number,
        ): void;
        public remove(
          _stacks: Packages.arc.struct.Seq<Packages.mindustry._type.PayloadStack>,
        ): void;
        public get(
          _block: Packages.mindustry.ctype.UnlockableContent,
        ): number;
        public clear(): void;
        public isEmpty(): boolean;
        public contains(
          _stacks: Packages.arc.struct.Seq<Packages.mindustry._type.PayloadStack>,
        ): boolean;
        public contains(
          _block: Packages.mindustry.ctype.UnlockableContent,
          _amount: number,
        ): boolean;
        public contains(
          _stack: Packages.mindustry._type.PayloadStack,
        ): boolean;
        public contains(
          _block: Packages.mindustry.ctype.UnlockableContent,
        ): boolean;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public total(): number;
        public removeAll(
          _pred: Packages.arc.func.Boolf<Packages.mindustry.ctype.UnlockableContent>,
        ): Packages.mindustry._type.PayloadSeq;
        public any(): boolean;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Buildingc
        implements
          Packages.mindustry.gen.Posc,
          Packages.mindustry.logic.Senseable,
          Packages.mindustry.entities.Sized,
          Packages.mindustry.gen.Timerc,
          Packages.mindustry.ui.Displayable,
          Packages.mindustry.logic.Controllable,
          Packages.arc.math.geom.QuadTree.QuadTreeObject,
          Packages.mindustry.logic.Settable,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Healthc
      {
        public add(): void;
        public remove(): void;
        public put(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public toString(): string;
        public version(): string;
        public floor(): Packages.mindustry.world.blocks.environment.Floor;
        public update(): void;
        public enabled(): boolean;
        public enabled(_enabled: boolean): void;
        public init(
          _tile: Packages.mindustry.world.Tile,
          _team: Packages.mindustry.game.Team,
          _shouldAdd: boolean,
          _rotation: number,
        ): Packages.mindustry.gen.Building;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public status(): Packages.mindustry.world.meta.BlockStatus;
        public read(
          _read: Packages.arc.util.io.Reads,
          _revision: string,
        ): void;
        public sleep(): void;
        public pos(): number;
        public delta(): number;
        public create(
          _block: Packages.mindustry.world.Block,
          _team: Packages.mindustry.game.Team,
        ): Packages.mindustry.gen.Building;
        public created(): void;
        public collide(
          _other: Packages.mindustry.gen.Bullet,
        ): boolean;
        public block(): Packages.mindustry.world.Block;
        public block(
          _block: Packages.mindustry.world.Block,
        ): void;
        public getPayload(): Packages.mindustry.world.blocks.payloads.Payload;
        public dropped(): void;
        public left(): Packages.mindustry.gen.Building;
        public right(): Packages.mindustry.gen.Building;
        public display(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public front(): Packages.mindustry.gen.Building;
        public back(): Packages.mindustry.gen.Building;
        public getDisplayName(): string;
        public isValid(): boolean;
        public control(
          _type: Packages.mindustry.logic.LAccess,
          _p1: number,
          _p2: number,
          _p3: number,
          _p4: number,
        ): void;
        public control(
          _type: Packages.mindustry.logic.LAccess,
          _p1: Packages.mindustry.logic.LVar,
          _p2: number,
          _p3: number,
          _p4: number,
        ): void;
        public control(
          _type: Packages.mindustry.logic.LAccess,
          _p1: any,
          _p2: number,
          _p3: number,
          _p4: number,
        ): void;
        public control(
          _type: Packages.mindustry.logic.LAccess,
          _p1: Packages.mindustry.logic.LVar,
          _p2: any,
          _p3: number,
          _p4: number,
        ): void;
        public config(): any;
        public consume(): void;
        public items(): Packages.mindustry.world.modules.ItemModule | null;
        public items(
          _items: Packages.mindustry.world.modules.ItemModule | null,
        ): void;
        public power(
          _power: Packages.mindustry.world.modules.PowerModule | null,
        ): void;
        public power(): Packages.mindustry.world.modules.PowerModule | null;
        public draw(): void;
        public rotation(): number;
        public rotation(_rotation: number): void;
        public tapped(): void;
        public hitbox(
          _out: Packages.arc.math.geom.Rect,
        ): void;
        public timeScale(): number;
        public hitSize(): number;
        public inFogTo(
          _viewer: Packages.mindustry.game.Team,
        ): boolean;
        public tile(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public tile(): Packages.mindustry.world.Tile;
        public healSuppressionTime(): number;
        public healSuppressionTime(
          _healSuppressionTime: number,
        ): void;
        public lastHealTime(): number;
        public lastHealTime(_lastHealTime: number): void;
        public proximity(): Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
        public proximity(
          _proximity: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>,
        ): void;
        public suppressColor(
          _suppressColor: Packages.arc.graphics.Color,
        ): void;
        public suppressColor(): Packages.arc.graphics.Color;
        public lastDisabler(
          _lastDisabler: Packages.mindustry.gen.Building | null,
        ): void;
        public lastDisabler(): Packages.mindustry.gen.Building | null;
        public shouldConsumePower(
          _shouldConsumePower: boolean,
        ): void;
        public shouldConsumePower(): boolean;
        public wasDamaged(): boolean;
        public wasDamaged(_wasDamaged: boolean): void;
        public wasVisible(_wasVisible: boolean): void;
        public wasVisible(): boolean;
        public efficiency(_efficiency: number): void;
        public efficiency(): number;
        public optionalEfficiency(): number;
        public optionalEfficiency(
          _optionalEfficiency: number,
        ): void;
        public payloadRotation(): number;
        public payloadRotation(
          _payloadRotation: number,
        ): void;
        public potentialEfficiency(): number;
        public potentialEfficiency(
          _potentialEfficiency: number,
        ): void;
        public visualLiquid(): number;
        public visualLiquid(_visualLiquid: number): void;
        public cdump(): number;
        public cdump(_cdump: number): void;
        public lastAccessed(): string;
        public lastAccessed(_lastAccessed: string): void;
        public visibleFlags(): Packages.long;
        public visibleFlags(
          _visibleFlags: Packages.long,
        ): void;
        public conductsTo(
          _other: Packages.mindustry.gen.Building,
        ): boolean;
        public absorbLasers(): boolean;
        public getMaximumAccepted(
          _item: Packages.mindustry._type.Item,
        ): number;
        public isHealSuppressed(): boolean;
        public damage(
          _source: Packages.mindustry.game.Team,
          _damage: number,
        ): void;
        public damage(
          _bullet: Packages.mindustry.gen.Bullet,
          _source: Packages.mindustry.game.Team,
          _damage: number,
        ): void;
        public damage(_damage: number): void;
        public dump(
          _todump: Packages.mindustry._type.Item,
        ): boolean;
        public dump(): boolean;
        public acceptItem(
          _source: Packages.mindustry.gen.Building,
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public canDump(
          _to: Packages.mindustry.gen.Building,
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public handleItem(
          _source: Packages.mindustry.gen.Building,
          _item: Packages.mindustry._type.Item,
        ): void;
        public incrementDump(_prox: number): void;
        public dumpAccumulate(): boolean;
        public dumpAccumulate(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public acceptPayload(
          _source: Packages.mindustry.gen.Building,
          _payload: Packages.mindustry.world.blocks.payloads.Payload,
        ): boolean;
        public handlePayload(
          _source: Packages.mindustry.gen.Building,
          _payload: Packages.mindustry.world.blocks.payloads.Payload,
        ): void;
        public isDiscovered(
          _viewer: Packages.mindustry.game.Team,
        ): boolean;
        public deselect(): void;
        public configure(_value: any): void;
        public shouldConsume(): boolean;
        public sense(
          _content: Packages.mindustry.ctype.Content,
        ): number;
        public sense(
          _sensor: Packages.mindustry.logic.LAccess,
        ): number;
        public calculateHeat(
          _sideHeat: number[],
          _cameFrom: Packages.arc.struct.IntSet,
        ): number;
        public calculateHeat(_sideHeat: number[]): number;
        public fogRadius(): number;
        public getProgressIncrease(
          _baseTime: number,
        ): number;
        public edelta(): number;
        public getLiquidDestination(
          _from: Packages.mindustry.gen.Building,
          _liquid: Packages.mindustry._type.Liquid,
        ): Packages.mindustry.gen.Building;
        public acceptLiquid(
          _source: Packages.mindustry.gen.Building,
          _liquid: Packages.mindustry._type.Liquid,
        ): boolean;
        public handleLiquid(
          _source: Packages.mindustry.gen.Building,
          _liquid: Packages.mindustry._type.Liquid,
          _amount: number,
        ): void;
        public moveLiquid(
          _next: Packages.mindustry.gen.Building,
          _liquid: Packages.mindustry._type.Liquid,
        ): number;
        public noSleep(): void;
        public productionValid(): boolean;
        public addPlan(
          _checkPrevious: boolean,
          _ignoreConditions: boolean,
        ): void;
        public addPlan(_checkPrevious: boolean): void;
        public applyHealSuppression(
          _amount: number,
          _suppressColor: Packages.arc.graphics.Color,
        ): void;
        public applyHealSuppression(_amount: number): void;
        public updateLastAccess(
          _player: Packages.mindustry.gen.Player,
        ): void;
        public configured(
          _builder: Packages.mindustry.gen.Unit,
          _value: any,
        ): void;
        public handleDamage(_amount: number): number;
        public healthChanged(): void;
        public flowItems(): Packages.mindustry.world.modules.ItemModule;
        public drawrot(): number;
        public drawTeamTop(): void;
        public drawCracks(): void;
        public drawLiquidLight(
          _liquid: Packages.mindustry._type.Liquid,
          _amount: number,
        ): void;
        public dumpLiquid(
          _liquid: Packages.mindustry._type.Liquid,
          _scaling: number,
        ): void;
        public dumpLiquid(
          _liquid: Packages.mindustry._type.Liquid,
        ): void;
        public dumpLiquid(
          _liquid: Packages.mindustry._type.Liquid,
          _scaling: number,
          _outputDir: number,
        ): void;
        public canDumpLiquid(
          _to: Packages.mindustry.gen.Building,
          _liquid: Packages.mindustry._type.Liquid,
        ): boolean;
        public transferLiquid(
          _next: Packages.mindustry.gen.Building,
          _amount: number,
          _liquid: Packages.mindustry._type.Liquid,
        ): void;
        public heal(_amount: number): void;
        public heal(): void;
        public onDestroyed(): void;
        public afterDestroyed(): void;
        public produced(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): void;
        public produced(
          _item: Packages.mindustry._type.Item,
        ): void;
        public explosionItemCap(): number;
        public updatePowerGraph(): void;
        public powerGraphRemoved(): void;
        public readBase(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public moduleBitmask(): number;
        public readAll(
          _read: Packages.arc.util.io.Reads,
          _revision: string,
        ): void;
        public onProximityRemoved(): void;
        public acceptStack(
          _item: Packages.mindustry._type.Item,
          _amount: number,
          _source: Packages.mindustry.gen.Teamc,
        ): number;
        public handleStack(
          _item: Packages.mindustry._type.Item,
          _amount: number,
          _source: Packages.mindustry.gen.Teamc,
        ): void;
        public removeStack(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): number;
        public allowUpdate(): boolean;
        public shouldActiveSound(): boolean;
        public activeSoundVolume(): number;
        public shouldAmbientSound(): boolean;
        public ambientVolume(): number;
        public updateConsumption(): void;
        public updateTile(): void;
        public updateEfficiencyMultiplier(): void;
        public efficiencyScale(): number;
        public getPowerConnections(
          _out: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>,
        ): Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
        public onProximityAdded(): void;
        public writeBase(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public writeAll(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public displayBars(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public configureAny(_value: any): void;
        public liquids(): Packages.mindustry.world.modules.LiquidModule | null;
        public liquids(
          _liquids: Packages.mindustry.world.modules.LiquidModule | null,
        ): void;
        public onProximityUpdate(): void;
        public tileX(): number;
        public tileY(): number;
        public readSync(
          _read: Packages.arc.util.io.Reads,
          _revision: string,
        ): void;
        public writeSync(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public relativeTo(
          _tile: Packages.mindustry.world.Tile,
        ): string;
        public relativeTo(_cx: number, _cy: number): string;
        public relativeTo(
          _build: Packages.mindustry.gen.Building,
        ): string;
        public checkSolid(): boolean;
        public onRemoved(): void;
        public removeFromProximity(): void;
        public updateProximity(): void;
        public changeTeam(
          _next: Packages.mindustry.game.Team,
        ): void;
        public killed(): void;
        public getDisplayIcon(): Packages.arc.graphics.g2d.TextureRegion;
        public nearby(
          _dx: number,
          _dy: number,
        ): Packages.mindustry.gen.Building;
        public nearby(
          _rotation: number,
        ): Packages.mindustry.gen.Building;
        public interactable(
          _team: Packages.mindustry.game.Team,
        ): boolean;
        public placed(): void;
        public playerPlaced(_config: any): void;
        public getCursor(): Packages.arc.Graphics.Cursor;
        public getCommandPosition(): Packages.arc.math.geom.Vec2;
        public canConsume(): boolean;
        public canControlSelect(
          _player: Packages.mindustry.gen.Unit,
        ): boolean;
        public canPickup(): boolean;
        public canResupply(): boolean;
        public canUnload(): boolean;
        public canWithdraw(): boolean;
        public checkSuppression(): boolean;
        public collision(
          _other: Packages.mindustry.gen.Bullet,
        ): boolean;
        public configTapped(): boolean;
        public consumeTriggerValid(): boolean;
        public dumpPayload(
          _todump: Packages.mindustry.world.blocks.payloads.Payload,
        ): boolean;
        public isInsulated(): boolean;
        public isPayload(): boolean;
        public moveForward(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public movePayload(
          _todump: Packages.mindustry.world.blocks.payloads.Payload,
        ): boolean;
        public onConfigureBuildTapped(
          _other: Packages.mindustry.gen.Building,
        ): boolean;
        public onConfigureTapped(
          _x: number,
          _y: number,
        ): boolean;
        public payloadCheck(
          _conveyorRotation: number,
        ): boolean;
        public shouldHideConfigure(
          _player: Packages.mindustry.gen.Player,
        ): boolean;
        public shouldShowConfigure(
          _player: Packages.mindustry.gen.Player,
        ): boolean;
        public wasRecentlyDamaged(): boolean;
        public wasRecentlyHealed(
          _duration: number,
        ): boolean;
        public relativeToEdge(
          _other: Packages.mindustry.world.Tile,
        ): string;
        public getDisplayEfficiency(): number;
        public getPowerProduction(): number;
        public moveLiquidForward(
          _leaks: boolean,
          _liquid: Packages.mindustry._type.Liquid,
        ): number;
        public rotdeg(): number;
        public totalProgress(): number;
        public warmup(): number;
        public senseObject(
          _sensor: Packages.mindustry.logic.LAccess,
        ): any;
        public getPayloads(): Packages.mindustry._type.PayloadSeq;
        public findClosestEdge(
          _to: Packages.arc.math.geom.Position,
          _solid: Packages.arc.func.Boolf<Packages.mindustry.world.Tile>,
        ): Packages.mindustry.world.Tile;
        public takePayload(): Packages.mindustry.world.blocks.payloads.Payload;
        public afterPickedUp(): void;
        public applyBoost(
          _intensity: number,
          _duration: number,
        ): void;
        public applySlowdown(
          _intensity: number,
          _duration: number,
        ): void;
        public buildConfiguration(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public displayConsumption(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public drawConfigure(): void;
        public drawDisabled(): void;
        public drawLight(): void;
        public drawSelect(): void;
        public drawStatus(): void;
        public drawTeam(): void;
        public getStackOffset(
          _item: Packages.mindustry._type.Item,
          _trns: Packages.arc.math.geom.Vec2,
        ): void;
        public handleString(_value: any): void;
        public handleUnitPayload(
          _unit: Packages.mindustry.gen.Unit,
          _grabber: Packages.arc.func.Cons<Packages.mindustry.world.blocks.payloads.Payload>,
        ): void;
        public itemTaken(
          _item: Packages.mindustry._type.Item,
        ): void;
        public kill(): void;
        public offload(
          _item: Packages.mindustry._type.Item,
        ): void;
        public onCommand(
          _target: Packages.arc.math.geom.Vec2,
        ): void;
        public onConfigureClosed(): void;
        public onControlSelect(
          _player: Packages.mindustry.gen.Unit,
        ): void;
        public onDeconstructed(
          _builder: Packages.mindustry.gen.Unit,
        ): void;
        public overwrote(
          _previous: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>,
        ): void;
        public payloadDraw(): void;
        public pickedUp(): void;
        public recentlyHealed(): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: any,
        ): void;
        public setProp(
          _content: Packages.mindustry.ctype.UnlockableContent,
          _value: number,
        ): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: number,
        ): void;
        public unitOn(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public unitRemoved(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public updatePayload(
          _unitHolder: Packages.mindustry.gen.Unit,
          _buildingHolder: Packages.mindustry.gen.Building,
        ): void;
        public updateTableAlign(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public progress(): number;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class IndexableEntity__build {
        public setIndex__build(_index: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class Building
        extends java.lang.Object
        implements
          Packages.mindustry.gen.IndexableEntity__all,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Buildingc,
          Packages.mindustry.gen.Timerc,
          Packages.mindustry.gen.IndexableEntity__build,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Healthc
      {
        public static bulletDamageEvent: Packages.mindustry.game.EventType.BuildDamageEvent;
        public static hitDuration: number;
        public static recentDamageTime: number;
        public static sleepingEntities: number;
        public static teamChangeEvent: Packages.mindustry.game.EventType.BuildTeamChangeEvent;
        public static tempBuilds: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
        public static timeToSleep: number;
        public static tmpTiles: Packages.arc.struct.ObjectSet<Packages.mindustry.gen.Building>;
        protected added: boolean;
        protected dumpAccum: number;
        protected index__all: number;
        protected index__build: number;
        protected initialized: boolean;
        protected lastDamageTime: number;
        protected sleepTime: number;
        protected sleeping: boolean;
        protected sound?: Packages.mindustry.audio.SoundLoop;
        protected timeScaleDuration: number;
        public add(): void;
        public remove(): void;
        public put(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public toString(): string;
        public version(): string;
        public floor(): Packages.mindustry.world.blocks.environment.Floor;
        public update(): void;
        public x(): number;
        public x(_x: number): void;
        public id(_id: number): void;
        public id(): number;
        public enabled(_enabled: boolean): void;
        public enabled(): boolean;
        public set(_x: number, _y: number): void;
        public set(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public init(
          _tile: Packages.mindustry.world.Tile,
          _team: Packages.mindustry.game.Team,
          _shouldAdd: boolean,
          _rotation: number,
        ): Packages.mindustry.gen.Building;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public status(): Packages.mindustry.world.meta.BlockStatus;
        public read(
          _read: Packages.arc.util.io.Reads,
          _revision: string,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public sleep(): void;
        public pos(): number;
        public delta(): number;
        public static create(): Packages.mindustry.gen.Building;
        public create(
          _block: Packages.mindustry.world.Block,
          _team: Packages.mindustry.game.Team,
        ): Packages.mindustry.gen.Building;
        public as<T>(): T | null;
        public created(): void;
        public collide(
          _other: Packages.mindustry.gen.Bullet,
        ): boolean;
        public y(_y: number): void;
        public y(): number;
        public block(
          _block: Packages.mindustry.world.Block,
        ): void;
        public block(): Packages.mindustry.world.Block;
        public getPayload(): Packages.mindustry.world.blocks.payloads.Payload;
        public dropped(): void;
        public left(): Packages.mindustry.gen.Building;
        public right(): Packages.mindustry.gen.Building;
        public display(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public self<
          T extends Packages.mindustry.gen.Entityc,
        >(): T | null;
        public front(): Packages.mindustry.gen.Building;
        public back(): Packages.mindustry.gen.Building;
        public getDisplayName(): string;
        public isValid(): boolean;
        public control(
          _type: Packages.mindustry.logic.LAccess,
          _p1: Packages.mindustry.logic.LVar,
          _p2: any,
          _p3: number,
          _p4: number,
        ): void;
        public control(
          _type: Packages.mindustry.logic.LAccess,
          _p1: Packages.mindustry.logic.LVar,
          _p2: number,
          _p3: number,
          _p4: number,
        ): void;
        public control(
          _type: Packages.mindustry.logic.LAccess,
          _p1: number,
          _p2: number,
          _p3: number,
          _p4: number,
        ): void;
        public control(
          _type: Packages.mindustry.logic.LAccess,
          _p1: any,
          _p2: number,
          _p3: number,
          _p4: number,
        ): void;
        public config(): any;
        public consume(): void;
        public items(): Packages.mindustry.world.modules.ItemModule;
        public items(
          _items: Packages.mindustry.world.modules.ItemModule,
        ): void;
        public power(): Packages.mindustry.world.modules.PowerModule;
        public power(
          _power: Packages.mindustry.world.modules.PowerModule,
        ): void;
        public getX(): number;
        public getY(): number;
        public trns(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public trns(_x: number, _y: number): void;
        public draw(): void;
        public rotation(): number;
        public rotation(_rotation: number): void;
        public tapped(): void;
        public timer(): Packages.arc.util.Interval;
        public timer(
          _index: number,
          _time: number,
        ): boolean;
        public timer(
          _timer: Packages.arc.util.Interval,
        ): void;
        public hitbox(
          _out: Packages.arc.math.geom.Rect,
        ): void;
        public timeScale(): number;
        public team(
          _team: Packages.mindustry.game.Team,
        ): void;
        public team(): Packages.mindustry.game.Team;
        public afterRead(): void;
        public dead(): boolean;
        public dead(_dead: boolean): void;
        public core(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public isLocal(): boolean;
        public isAdded(): boolean;
        public tileOn(): Packages.mindustry.world.Tile;
        public hitSize(): number;
        public closestCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public inFogTo(
          _viewer: Packages.mindustry.game.Team,
        ): boolean;
        public isRemote(): boolean;
        public onSolid(): boolean;
        public classId(): number;
        public setIndex__all(_index: number): void;
        public buildOn(): Packages.mindustry.gen.Building;
        public tile(): Packages.mindustry.world.Tile;
        public tile(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public healSuppressionTime(): number;
        public healSuppressionTime(
          _healSuppressionTime: number,
        ): void;
        public lastHealTime(): number;
        public lastHealTime(_lastHealTime: number): void;
        public maxHealth(_maxHealth: number): void;
        public maxHealth(): number;
        public proximity(
          _proximity: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>,
        ): void;
        public proximity(): Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
        public suppressColor(): Packages.arc.graphics.Color;
        public suppressColor(
          _suppressColor: Packages.arc.graphics.Color,
        ): void;
        public lastDisabler(): Packages.mindustry.gen.Building;
        public lastDisabler(
          _lastDisabler: Packages.mindustry.gen.Building,
        ): void;
        public shouldConsumePower(
          _shouldConsumePower: boolean,
        ): void;
        public shouldConsumePower(): boolean;
        public wasDamaged(): boolean;
        public wasDamaged(_wasDamaged: boolean): void;
        public wasVisible(_wasVisible: boolean): void;
        public wasVisible(): boolean;
        public efficiency(_efficiency: number): void;
        public efficiency(): number;
        public hitTime(_hitTime: number): void;
        public hitTime(): number;
        public optionalEfficiency(): number;
        public optionalEfficiency(
          _optionalEfficiency: number,
        ): void;
        public payloadRotation(
          _payloadRotation: number,
        ): void;
        public payloadRotation(): number;
        public potentialEfficiency(): number;
        public potentialEfficiency(
          _potentialEfficiency: number,
        ): void;
        public visualLiquid(): number;
        public visualLiquid(_visualLiquid: number): void;
        public cdump(_cdump: number): void;
        public cdump(): number;
        public lastAccessed(): string;
        public lastAccessed(_lastAccessed: string): void;
        public visibleFlags(): Packages.long;
        public visibleFlags(
          _visibleFlags: Packages.long,
        ): void;
        public conductsTo(
          _other: Packages.mindustry.gen.Building,
        ): boolean;
        public absorbLasers(): boolean;
        public getMaximumAccepted(
          _item: Packages.mindustry._type.Item,
        ): number;
        public isHealSuppressed(): boolean;
        public damage(
          _bullet: Packages.mindustry.gen.Bullet,
          _source: Packages.mindustry.game.Team,
          _damage: number,
        ): void;
        public damage(_damage: number): void;
        public damage(
          _source: Packages.mindustry.game.Team,
          _damage: number,
        ): void;
        public damage(
          _amount: number,
          _withEffect: boolean,
        ): void;
        public dump(
          _todump: Packages.mindustry._type.Item,
        ): boolean;
        public dump(): boolean;
        public acceptItem(
          _source: Packages.mindustry.gen.Building,
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public canDump(
          _to: Packages.mindustry.gen.Building,
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public handleItem(
          _source: Packages.mindustry.gen.Building,
          _item: Packages.mindustry._type.Item,
        ): void;
        public incrementDump(_prox: number): void;
        public dumpAccumulate(): boolean;
        public dumpAccumulate(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public acceptPayload(
          _source: Packages.mindustry.gen.Building,
          _payload: Packages.mindustry.world.blocks.payloads.Payload,
        ): boolean;
        public handlePayload(
          _source: Packages.mindustry.gen.Building,
          _payload: Packages.mindustry.world.blocks.payloads.Payload,
        ): void;
        public isDiscovered(
          _viewer: Packages.mindustry.game.Team,
        ): boolean;
        public deselect(): void;
        public configure(_value: any): void;
        public shouldConsume(): boolean;
        public sense(
          _sensor: Packages.mindustry.logic.LAccess,
        ): number;
        public sense(
          _content: Packages.mindustry.ctype.Content,
        ): number;
        public calculateHeat(
          _sideHeat: number[],
          _cameFrom: Packages.arc.struct.IntSet,
        ): number;
        public calculateHeat(_sideHeat: number[]): number;
        public fogRadius(): number;
        public getProgressIncrease(
          _baseTime: number,
        ): number;
        public edelta(): number;
        public getLiquidDestination(
          _from: Packages.mindustry.gen.Building,
          _liquid: Packages.mindustry._type.Liquid,
        ): Packages.mindustry.gen.Building;
        public acceptLiquid(
          _source: Packages.mindustry.gen.Building,
          _liquid: Packages.mindustry._type.Liquid,
        ): boolean;
        public handleLiquid(
          _source: Packages.mindustry.gen.Building,
          _liquid: Packages.mindustry._type.Liquid,
          _amount: number,
        ): void;
        public damageContinuous(_amount: number): void;
        public moveLiquid(
          _next: Packages.mindustry.gen.Building,
          _liquid: Packages.mindustry._type.Liquid,
        ): number;
        public noSleep(): void;
        public closestEnemyCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public productionValid(): boolean;
        public addPlan(_checkPrevious: boolean): void;
        public addPlan(
          _checkPrevious: boolean,
          _ignoreConditions: boolean,
        ): void;
        public applyHealSuppression(_amount: number): void;
        public applyHealSuppression(
          _amount: number,
          _suppressColor: Packages.arc.graphics.Color,
        ): void;
        public updateLastAccess(
          _player: Packages.mindustry.gen.Player,
        ): void;
        public configured(
          _builder: Packages.mindustry.gen.Unit,
          _value: any,
        ): void;
        public handleDamage(_amount: number): number;
        public healthChanged(): void;
        public damagePierce(
          _amount: number,
          _withEffect: boolean,
        ): void;
        public damagePierce(_amount: number): void;
        public flowItems(): Packages.mindustry.world.modules.ItemModule;
        public drawrot(): number;
        public drawTeamTop(): void;
        public drawCracks(): void;
        public damaged(): boolean;
        public healthf(): number;
        public drawLiquidLight(
          _liquid: Packages.mindustry._type.Liquid,
          _amount: number,
        ): void;
        public dumpLiquid(
          _liquid: Packages.mindustry._type.Liquid,
          _scaling: number,
          _outputDir: number,
        ): void;
        public dumpLiquid(
          _liquid: Packages.mindustry._type.Liquid,
          _scaling: number,
        ): void;
        public dumpLiquid(
          _liquid: Packages.mindustry._type.Liquid,
        ): void;
        public canDumpLiquid(
          _to: Packages.mindustry.gen.Building,
          _liquid: Packages.mindustry._type.Liquid,
        ): boolean;
        public transferLiquid(
          _next: Packages.mindustry.gen.Building,
          _amount: number,
          _liquid: Packages.mindustry._type.Liquid,
        ): void;
        public clampHealth(): void;
        public heal(): void;
        public heal(_amount: number): void;
        public onDestroyed(): void;
        public afterDestroyed(): void;
        public produced(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): void;
        public produced(
          _item: Packages.mindustry._type.Item,
        ): void;
        public explosionItemCap(): number;
        public updatePowerGraph(): void;
        public powerGraphRemoved(): void;
        public readBase(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public moduleBitmask(): number;
        public readAll(
          _read: Packages.arc.util.io.Reads,
          _revision: string,
        ): void;
        public onProximityRemoved(): void;
        public acceptStack(
          _item: Packages.mindustry._type.Item,
          _amount: number,
          _source: Packages.mindustry.gen.Teamc,
        ): number;
        public handleStack(
          _item: Packages.mindustry._type.Item,
          _amount: number,
          _source: Packages.mindustry.gen.Teamc,
        ): void;
        public removeStack(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): number;
        public allowUpdate(): boolean;
        public shouldActiveSound(): boolean;
        public activeSoundVolume(): number;
        public shouldAmbientSound(): boolean;
        public ambientVolume(): number;
        public updateConsumption(): void;
        public updateTile(): void;
        public cheating(): boolean;
        public updateEfficiencyMultiplier(): void;
        public efficiencyScale(): number;
        public getPowerConnections(
          _out: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>,
        ): Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
        public onProximityAdded(): void;
        public writeBase(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public writeAll(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public displayBars(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public configureAny(_value: any): void;
        public liquids(): Packages.mindustry.world.modules.LiquidModule;
        public liquids(
          _liquids: Packages.mindustry.world.modules.LiquidModule,
        ): void;
        public onProximityUpdate(): void;
        public serialize(): boolean;
        public tileX(): number;
        public tileY(): number;
        public blockOn(): Packages.mindustry.world.Block;
        public floorOn(): Packages.mindustry.world.blocks.environment.Floor;
        public afterAllRead(): void;
        public readSync(
          _read: Packages.arc.util.io.Reads,
          _revision: string,
        ): void;
        public writeSync(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public relativeTo(
          _tile: Packages.mindustry.world.Tile,
        ): string;
        public relativeTo(_cx: number, _cy: number): string;
        public relativeTo(
          _build: Packages.mindustry.gen.Building,
        ): string;
        public checkSolid(): boolean;
        public onRemoved(): void;
        public removeFromProximity(): void;
        public updateProximity(): void;
        public changeTeam(
          _next: Packages.mindustry.game.Team,
        ): void;
        public killed(): void;
        public health(_health: number): void;
        public health(): number;
        public getDisplayIcon(): Packages.arc.graphics.g2d.TextureRegion;
        public nearby(
          _rotation: number,
        ): Packages.mindustry.gen.Building;
        public nearby(
          _dx: number,
          _dy: number,
        ): Packages.mindustry.gen.Building;
        public interactable(
          _team: Packages.mindustry.game.Team,
        ): boolean;
        public setIndex__build(_index: number): void;
        public placed(): void;
        public playerPlaced(_config: any): void;
        public getCursor(): Packages.arc.Graphics.Cursor;
        public getCommandPosition(): Packages.arc.math.geom.Vec2;
        public canConsume(): boolean;
        public canControlSelect(
          _player: Packages.mindustry.gen.Unit,
        ): boolean;
        public canPickup(): boolean;
        public canResupply(): boolean;
        public canUnload(): boolean;
        public canWithdraw(): boolean;
        public checkSuppression(): boolean;
        public collision(
          _other: Packages.mindustry.gen.Bullet,
        ): boolean;
        public configTapped(): boolean;
        public consumeTriggerValid(): boolean;
        public dumpPayload(
          _todump: Packages.mindustry.world.blocks.payloads.Payload,
        ): boolean;
        public isInsulated(): boolean;
        public isPayload(): boolean;
        public moveForward(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public movePayload(
          _todump: Packages.mindustry.world.blocks.payloads.Payload,
        ): boolean;
        public onConfigureBuildTapped(
          _other: Packages.mindustry.gen.Building,
        ): boolean;
        public onConfigureTapped(
          _x: number,
          _y: number,
        ): boolean;
        public payloadCheck(
          _conveyorRotation: number,
        ): boolean;
        public shouldHideConfigure(
          _player: Packages.mindustry.gen.Player,
        ): boolean;
        public shouldShowConfigure(
          _player: Packages.mindustry.gen.Player,
        ): boolean;
        public wasRecentlyDamaged(): boolean;
        public wasRecentlyHealed(
          _duration: number,
        ): boolean;
        public relativeToEdge(
          _other: Packages.mindustry.world.Tile,
        ): string;
        public getDisplayEfficiency(): number;
        public getPowerProduction(): number;
        public moveLiquidForward(
          _leaks: boolean,
          _liquid: Packages.mindustry._type.Liquid,
        ): number;
        public rotdeg(): number;
        public totalProgress(): number;
        public warmup(): number;
        public senseObject(
          _sensor: Packages.mindustry.logic.LAccess,
        ): any;
        public getPayloads(): Packages.mindustry._type.PayloadSeq;
        public findClosestEdge(
          _to: Packages.arc.math.geom.Position,
          _solid: Packages.arc.func.Boolf<Packages.mindustry.world.Tile>,
        ): Packages.mindustry.world.Tile;
        public takePayload(): Packages.mindustry.world.blocks.payloads.Payload;
        public afterPickedUp(): void;
        public applyBoost(
          _intensity: number,
          _duration: number,
        ): void;
        public applySlowdown(
          _intensity: number,
          _duration: number,
        ): void;
        public buildConfiguration(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public damageContinuousPierce(
          _amount: number,
        ): void;
        public displayConsumption(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public drawConfigure(): void;
        public drawDisabled(): void;
        public drawLight(): void;
        public drawSelect(): void;
        public drawStatus(): void;
        public drawTeam(): void;
        public getStackOffset(
          _item: Packages.mindustry._type.Item,
          _trns: Packages.arc.math.geom.Vec2,
        ): void;
        public handleString(_value: any): void;
        public handleUnitPayload(
          _unit: Packages.mindustry.gen.Unit,
          _grabber: Packages.arc.func.Cons<Packages.mindustry.world.blocks.payloads.Payload>,
        ): void;
        public healFract(_amount: number): void;
        public itemTaken(
          _item: Packages.mindustry._type.Item,
        ): void;
        public kill(): void;
        public offload(
          _item: Packages.mindustry._type.Item,
        ): void;
        public onCommand(
          _target: Packages.arc.math.geom.Vec2,
        ): void;
        public onConfigureClosed(): void;
        public onControlSelect(
          _player: Packages.mindustry.gen.Unit,
        ): void;
        public onDeconstructed(
          _builder: Packages.mindustry.gen.Unit,
        ): void;
        public overwrote(
          _previous: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>,
        ): void;
        public payloadDraw(): void;
        public pickedUp(): void;
        public recentlyHealed(): void;
        public setProp(
          _content: Packages.mindustry.ctype.UnlockableContent,
          _value: number,
        ): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: any,
        ): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: number,
        ): void;
        public unitOn(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public unitRemoved(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public updatePayload(
          _unitHolder: Packages.mindustry.gen.Unit,
          _buildingHolder: Packages.mindustry.gen.Building,
        ): void;
        public updateTableAlign(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public progress(): number;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare class Tile
        extends java.lang.Object
        implements
          Packages.mindustry.ui.Displayable,
          Packages.arc.math.geom.Position,
          Packages.arc.math.geom.QuadTree.QuadTreeObject
      {
        private static tileChange: Packages.mindustry.game.EventType.TileChangeEvent;
        private static preChange: Packages.mindustry.game.EventType.TilePreChangeEvent;
        private static tileSet: Packages.arc.struct.ObjectSet<Packages.mindustry.gen.Building>;
        public data: string;
        public build?: Packages.mindustry.gen.Building;
        public x: Packages.short;
        public y: Packages.short;
        protected changing: boolean;
        public remove(): void;
        public toString(): string;
        public floor(): Packages.mindustry.world.blocks.environment.Floor;
        public getBounds(
          _rect: Packages.arc.math.geom.Rect,
        ): Packages.arc.math.geom.Rect;
        public array(): number;
        public pos(): number;
        public block(): Packages.mindustry.world.Block;
        public display(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public synthetic(): boolean;
        protected changed(): void;
        public drop(): Packages.mindustry._type.Item | null;
        public circle(
          _radius: number,
          _cons: Packages.arc.func.Cons<Packages.mindustry.world.Tile>,
        ): void;
        public circle(
          _radius: number,
          _cons: Packages.arc.func.Intc2,
        ): void;
        public getX(): number;
        public getY(): number;
        public centerX(): number;
        public centerY(): number;
        public solid(): boolean;
        public hitbox(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public team(): Packages.mindustry.game.Team;
        public worldx(): number;
        public worldy(): number;
        public setBlock(
          _type: Packages.mindustry.world.Block,
        ): void;
        public setBlock(
          _type: Packages.mindustry.world.Block,
          _team: Packages.mindustry.game.Team,
        ): void;
        public setBlock(
          _type: Packages.mindustry.world.Block,
          _team: Packages.mindustry.game.Team,
          _rotation: number,
          _entityprov: Packages.arc.func.Prov<Packages.mindustry.gen.Building>,
        ): void;
        public setBlock(
          _type: Packages.mindustry.world.Block,
          _team: Packages.mindustry.game.Team,
          _rotation: number,
        ): void;
        public recache(): void;
        public recacheWall(): void;
        protected preChanged(): void;
        public isEditorTile(): boolean;
        public setFloor(
          _type: Packages.mindustry.world.blocks.environment.Floor,
        ): void;
        public static setFloor(
          _tile: Packages.mindustry.world.Tile,
          _floor: Packages.mindustry.world.Block,
          _overlay: Packages.mindustry.world.Block,
        ): void;
        public static setOverlay(
          _tile: Packages.mindustry.world.Tile,
          _overlay: Packages.mindustry.world.Block,
        ): void;
        public setOverlay(
          _block: Packages.mindustry.world.Block,
        ): void;
        public overlay(): Packages.mindustry.world.blocks.environment.Floor;
        protected changeBuild(
          _team: Packages.mindustry.game.Team,
          _entityprov: Packages.arc.func.Prov<Packages.mindustry.gen.Building>,
          _rotation: number,
        ): void;
        public relativeTo(
          _tile: Packages.mindustry.world.Tile,
        ): string;
        public relativeTo(_cx: number, _cy: number): string;
        public static relativeTo(
          _x: number,
          _y: number,
          _cx: number,
          _cy: number,
        ): string;
        public static relativeTo(
          _x: number,
          _y: number,
          _cx: number,
          _cy: number,
        ): number;
        public static removeTile(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public static setTile(
          _tile: Packages.mindustry.world.Tile,
          _block: Packages.mindustry.world.Block,
          _team: Packages.mindustry.game.Team,
          _rotation: number,
        ): void;
        public setFloorNet(
          _floor: Packages.mindustry.world.Block,
          _overlay: Packages.mindustry.world.Block,
        ): void;
        public setFloorNet(
          _floor: Packages.mindustry.world.Block,
        ): void;
        public setOverlayID(_ore: Packages.short): void;
        public breakable(): boolean;
        public getLinkedTiles(
          _cons: Packages.arc.func.Cons<Packages.mindustry.world.Tile>,
        ): void;
        public getLinkedTiles(
          _tmpArray: Packages.arc.struct.Seq<Packages.mindustry.world.Tile>,
        ): Packages.arc.struct.Seq<Packages.mindustry.world.Tile>;
        public getLinkedTilesAs(
          _block: Packages.mindustry.world.Block,
          _tmpArray: Packages.arc.func.Cons<Packages.mindustry.world.Tile>,
        ): void;
        public getLinkedTilesAs(
          _block: Packages.mindustry.world.Block,
          _tmpArray: Packages.arc.struct.Seq<Packages.mindustry.world.Tile>,
        ): Packages.arc.struct.Seq<Packages.mindustry.world.Tile>;
        public drawx(): number;
        public drawy(): number;
        public getHitbox(
          _rect: Packages.arc.math.geom.Rect,
        ): Packages.arc.math.geom.Rect;
        public staticDarkness(): number;
        protected firePreChanged(): void;
        protected fireChanged(): void;
        public wallDrop(): Packages.mindustry._type.Item | null;
        public absoluteRelativeTo(
          _cx: number,
          _cy: number,
        ): string;
        public getFlammability(): number;
        public isDarkened(): boolean;
        public cblock<
          T extends Packages.mindustry.world.Block,
        >(): T | null;
        public setTeam(
          _team: Packages.mindustry.game.Team,
        ): void;
        public static setTeam(
          _build: Packages.mindustry.gen.Building,
          _team: Packages.mindustry.game.Team,
        ): void;
        public isCenter(): boolean;
        public getTeamID(): number;
        public setFloorUnder(
          _floor: Packages.mindustry.world.blocks.environment.Floor,
        ): void;
        public setAir(): void;
        public removeNet(): void;
        public setNet(
          _block: Packages.mindustry.world.Block,
        ): void;
        public setNet(
          _block: Packages.mindustry.world.Block,
          _team: Packages.mindustry.game.Team,
          _rotation: number,
        ): void;
        public setOverlayNet(
          _overlay: Packages.mindustry.world.Block,
        ): void;
        public overlayID(): Packages.short;
        public blockID(): Packages.short;
        public floorID(): Packages.short;
        public setOverlayQuiet(
          _block: Packages.mindustry.world.Block,
        ): void;
        public clearOverlay(): void;
        public passable(): boolean;
        public dangerous(): boolean;
        public nearby(
          _rotation: number,
        ): Packages.mindustry.world.Tile | null;
        public nearby(
          _relative: Packages.arc.math.geom.Point2,
        ): Packages.mindustry.world.Tile | null;
        public nearby(
          _dx: number,
          _dy: number,
        ): Packages.mindustry.world.Tile | null;
        public nearbyBuild(
          _rotation: number,
        ): Packages.mindustry.gen.Building | null;
        public interactable(
          _team: Packages.mindustry.game.Team,
        ): boolean;
        public legSolid(): boolean;
        public adjacentTo(
          _tile: Packages.mindustry.world.Tile,
        ): boolean;
        public static buildDestroyed(
          _build: Packages.mindustry.gen.Building,
        ): void;
        public static buildHealthUpdate(
          _buildings: Packages.arc.struct.IntSeq,
        ): void;
        public constructor(
          _x: number,
          _y: number,
          _floor: number,
          _overlay: number,
          _wall: number,
        );
        public constructor(
          _x: number,
          _y: number,
          _floor: Packages.mindustry.world.Block,
          _overlay: Packages.mindustry.world.Block,
          _wall: Packages.mindustry.world.Block,
        );
        public constructor(_x: number, _y: number);
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Posc
        implements
          Packages.arc.math.geom.Position,
          Packages.mindustry.gen.Entityc
      {
        public x(): number;
        public x(_x: number): void;
        public set(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public set(_x: number, _y: number): void;
        public y(): number;
        public y(_y: number): void;
        public getX(): number;
        public getY(): number;
        public trns(_x: number, _y: number): void;
        public trns(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public tileOn(): Packages.mindustry.world.Tile;
        public onSolid(): boolean;
        public buildOn(): Packages.mindustry.gen.Building;
        public tileX(): number;
        public tileY(): number;
        public blockOn(): Packages.mindustry.world.Block;
        public floorOn(): Packages.mindustry.world.blocks.environment.Floor;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Drawc
        implements
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Entityc
      {
        public draw(): void;
        public clipSize(): number;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class IndexableEntity__player {
        public setIndex__player(_index: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Playerc
        implements
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Timerc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.entities.units.UnitController,
          Packages.mindustry.gen.Entityc
      {
        public name(): string;
        public name(_name: string): void;
        public remove(): void;
        public update(): void;
        public locale(): string;
        public locale(_locale: string): void;
        public con(): Packages.mindustry.net.NetConnection | null;
        public con(
          _con: Packages.mindustry.net.NetConnection | null,
        ): void;
        public reset(): void;
        public color(): Packages.arc.graphics.Color;
        public color(
          _color: Packages.arc.graphics.Color,
        ): void;
        public unit(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public unit(): Packages.mindustry.gen.Unit;
        public ip(): string;
        public draw(): void;
        public mouseX(): number;
        public mouseX(_mouseX: number): void;
        public mouseY(_mouseY: number): void;
        public mouseY(): number;
        public lastText(): string;
        public lastText(_lastText: string): void;
        public icon(): Packages.arc.graphics.g2d.TextureRegion;
        public uuid(): string;
        public itemDepositRate(
          _itemDepositRate: Packages.arc.util.Ratekeeper,
        ): void;
        public itemDepositRate(): Packages.arc.util.Ratekeeper;
        public team(): Packages.mindustry.game.Team;
        public team(
          _team: Packages.mindustry.game.Team,
        ): void;
        public justSwitchFrom(
          _justSwitchFrom: Packages.mindustry.gen.Unit | null,
        ): void;
        public justSwitchFrom(): Packages.mindustry.gen.Unit | null;
        public justSwitchTo(): Packages.mindustry.gen.Unit | null;
        public justSwitchTo(
          _justSwitchTo: Packages.mindustry.gen.Unit | null,
        ): void;
        public admin(_admin: boolean): void;
        public admin(): boolean;
        public boosting(): boolean;
        public boosting(_boosting: boolean): void;
        public shooting(_shooting: boolean): void;
        public shooting(): boolean;
        public typing(_typing: boolean): void;
        public typing(): boolean;
        public deathTimer(): number;
        public deathTimer(_deathTimer: number): void;
        public textFadeTime(_textFadeTime: number): void;
        public textFadeTime(): number;
        public lastCommand(
          _lastCommand: Packages.mindustry.ai.UnitCommand | null,
        ): void;
        public lastCommand(): Packages.mindustry.ai.UnitCommand | null;
        public dead(): boolean;
        public core(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public usid(): string;
        public bestCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public getInfo(): Packages.mindustry.net.Administration.PlayerInfo;
        public closestCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public afterSync(): void;
        public clearUnit(): void;
        public sendMessage(_text: string): void;
        public sendMessage(
          _text: string,
          _from: Packages.mindustry.gen.Player,
        ): void;
        public sendMessage(
          _text: string,
          _from: Packages.mindustry.gen.Player,
          _unformatted: string,
        ): void;
        public sendUnformatted(_unformatted: string): void;
        public sendUnformatted(
          _from: Packages.mindustry.gen.Player,
          _unformatted: string,
        ): void;
        public displayAmmo(): boolean;
        public isBuilder(): boolean;
        public isLogicControllable(): boolean;
        public isValidController(): boolean;
        public kick(
          _reason: Packages.mindustry.net.Packets.KickReason,
        ): void;
        public kick(
          _reason: string,
          _duration: Packages.long,
        ): void;
        public kick(_reason: string): void;
        public kick(
          _reason: Packages.mindustry.net.Packets.KickReason,
          _duration: Packages.long,
        ): void;
        public clipSize(): number;
        public coloredName(): string;
        public plainName(): string;
        public checkSpawn(): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class Player
        extends java.lang.Object
        implements
          Packages.mindustry.gen.IndexableEntity__all,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.IndexableEntity__player,
          Packages.mindustry.gen.Timerc,
          Packages.mindustry.gen.IndexableEntity__sync,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Playerc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.IndexableEntity__draw
      {
        public static deathDelay: number;
        protected added: boolean;
        protected index__all: number;
        protected index__draw: number;
        protected index__player: number;
        protected index__sync: number;
        protected lastReadUnit?: Packages.mindustry.gen.Unit;
        protected wrongReadUnits: number;
        private x_LAST_: number;
        private x_TARGET_: number;
        private y_LAST_: number;
        private y_TARGET_: number;
        public name(): string;
        public name(_name: string): void;
        public add(): void;
        public remove(): void;
        public toString(): string;
        public update(): void;
        public x(_x: number): void;
        public x(): number;
        public locale(): string;
        public locale(_locale: string): void;
        public id(): number;
        public id(_id: number): void;
        public set(_x: number, _y: number): void;
        public set(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public con(): Packages.mindustry.net.NetConnection;
        public con(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public reset(): void;
        public static create(): Packages.mindustry.gen.Player;
        public as<T>(): T | null;
        public y(): number;
        public y(_y: number): void;
        public color(
          _color: Packages.arc.graphics.Color,
        ): void;
        public color(): Packages.arc.graphics.Color;
        public unit(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public unit(): Packages.mindustry.gen.Unit;
        public ip(): string;
        public self<
          T extends Packages.mindustry.gen.Entityc,
        >(): T | null;
        public getX(): number;
        public getY(): number;
        public interpolate(): void;
        public trns(_x: number, _y: number): void;
        public trns(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public draw(): void;
        public mouseX(_mouseX: number): void;
        public mouseX(): number;
        public mouseY(_mouseY: number): void;
        public mouseY(): number;
        public lastText(_lastText: string): void;
        public lastText(): string;
        public icon(): Packages.arc.graphics.g2d.TextureRegion;
        public timer(
          _timer: Packages.arc.util.Interval,
        ): void;
        public timer(
          _index: number,
          _time: number,
        ): boolean;
        public timer(): Packages.arc.util.Interval;
        public uuid(): string;
        public itemDepositRate(
          _itemDepositRate: Packages.arc.util.Ratekeeper,
        ): void;
        public itemDepositRate(): Packages.arc.util.Ratekeeper;
        public team(): Packages.mindustry.game.Team;
        public team(
          _team: Packages.mindustry.game.Team,
        ): void;
        public justSwitchFrom(
          _justSwitchFrom: Packages.mindustry.gen.Unit,
        ): void;
        public justSwitchFrom(): Packages.mindustry.gen.Unit;
        public justSwitchTo(
          _justSwitchTo: Packages.mindustry.gen.Unit,
        ): void;
        public justSwitchTo(): Packages.mindustry.gen.Unit;
        public admin(_admin: boolean): void;
        public admin(): boolean;
        public boosting(): boolean;
        public boosting(_boosting: boolean): void;
        public shooting(): boolean;
        public shooting(_shooting: boolean): void;
        public typing(): boolean;
        public typing(_typing: boolean): void;
        public deathTimer(): number;
        public deathTimer(_deathTimer: number): void;
        public textFadeTime(_textFadeTime: number): void;
        public textFadeTime(): number;
        public lastUpdated(
          _lastUpdated: Packages.long,
        ): void;
        public lastUpdated(): Packages.long;
        public updateSpacing(
          _updateSpacing: Packages.long,
        ): void;
        public updateSpacing(): Packages.long;
        public lastCommand(): Packages.mindustry.ai.UnitCommand;
        public lastCommand(
          _lastCommand: Packages.mindustry.ai.UnitCommand,
        ): void;
        public afterRead(): void;
        public dead(): boolean;
        public core(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public usid(): string;
        public bestCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public isLocal(): boolean;
        public isAdded(): boolean;
        public tileOn(): Packages.mindustry.world.Tile;
        public getInfo(): Packages.mindustry.net.Administration.PlayerInfo;
        public closestCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public afterSync(): void;
        public clearUnit(): void;
        public sendMessage(
          _text: string,
          _from: Packages.mindustry.gen.Player,
        ): void;
        public sendMessage(
          _text: string,
          _from: Packages.mindustry.gen.Player,
          _unformatted: string,
        ): void;
        public sendMessage(_text: string): void;
        public sendUnformatted(
          _from: Packages.mindustry.gen.Player,
          _unformatted: string,
        ): void;
        public sendUnformatted(_unformatted: string): void;
        public isRemote(): boolean;
        public snapInterpolation(): void;
        public onSolid(): boolean;
        public classId(): number;
        public setIndex__all(_index: number): void;
        public setIndex__draw(_index: number): void;
        public setIndex__player(_index: number): void;
        public setIndex__sync(_index: number): void;
        public buildOn(): Packages.mindustry.gen.Building;
        public displayAmmo(): boolean;
        public isBuilder(): boolean;
        public isLogicControllable(): boolean;
        public isSyncHidden(
          _player: Packages.mindustry.gen.Player,
        ): boolean;
        public isValidController(): boolean;
        public kick(
          _reason: Packages.mindustry.net.Packets.KickReason,
        ): void;
        public kick(_reason: string): void;
        public kick(
          _reason: string,
          _duration: Packages.long,
        ): void;
        public kick(
          _reason: Packages.mindustry.net.Packets.KickReason,
          _duration: Packages.long,
        ): void;
        public serialize(): boolean;
        public clipSize(): number;
        public tileX(): number;
        public tileY(): number;
        public coloredName(): string;
        public plainName(): string;
        public blockOn(): Packages.mindustry.world.Block;
        public floorOn(): Packages.mindustry.world.blocks.environment.Floor;
        public afterAllRead(): void;
        public checkSpawn(): void;
        public handleSyncHidden(): void;
        public readSync(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public readSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public snapSync(): void;
        public writeSync(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public writeSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace net {
      declare abstract class Packet extends java.lang
        .Object {
        protected static NODATA: string[];
        protected static BAIS: Packages.arc.util.io.ReusableByteInStream;
        protected static READ: Packages.arc.util.io.Reads;
        public static priorityLow: number;
        public static priorityNormal: number;
        public static priorityHigh: number;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
          _length: number,
        ): void;
        public getPriority(): number;
        public handled(): void;
        public handleClient(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace net {
      declare class Streamable extends Packages.mindustry
        .net.Packet {
        public static StreamBuilder = class extends java
          .lang.Object {
          public id: number;
          public type: string;
          public total: number;
          public stream: Packages.java.io.ByteArrayOutputStream;
          public add(_bytes: string[]): void;
          public build(): Packages.mindustry.net.Streamable;
          public isDone(): boolean;
          public progress(): number;
          public constructor(
            _begin: Packages.mindustry.net.Packets.StreamBegin,
          );
        };
        public stream: Packages.java.io.ByteArrayInputStream;
        public getPriority(): number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace net {
      declare abstract class NetConnection extends java.lang
        .Object {
        public address: string;
        public uuid: string;
        public usid: string;
        public mobile: boolean;
        public modclient: boolean;
        public player?: Packages.mindustry.gen.Player;
        public kicked: boolean;
        public syncTime: Packages.long;
        public connectTime: Packages.long;
        public lastReceivedClientSnapshot: number;
        public snapshotsSent: number;
        public lastReceivedClientTime: Packages.long;
        public rejectedRequests: Packages.arc.struct.Seq<Packages.mindustry.entities.units.BuildPlan>;
        public chatRate: Packages.arc.util.Ratekeeper;
        public packetRate: Packages.arc.util.Ratekeeper;
        public hasConnected: boolean;
        public hasBegunConnecting: boolean;
        public hasDisconnected: boolean;
        public viewWidth: number;
        public viewHeight: number;
        public viewX: number;
        public viewY: number;
        public close(): void;
        public send(_object: any, _reliable: boolean): void;
        public isConnected(): boolean;
        protected kickDisconnect(): void;
        public sendStream(
          _stream: Packages.mindustry.net.Streamable,
        ): void;
        private kick(
          _reason: string,
          _kickType: Packages.mindustry.net.Packets.KickReason | null,
          _kickDuration: Packages.long,
        ): void;
        public kick(
          _reason: Packages.mindustry.net.Packets.KickReason,
        ): void;
        public kick(
          _reason: Packages.mindustry.net.Packets.KickReason,
          _kickDuration: Packages.long,
        ): void;
        public kick(_reason: string): void;
        public kick(
          _reason: string,
          _duration: Packages.long,
        ): void;
        public kick(): void;
        public constructor(_address: string);
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace net {
      declare class Host extends java.lang.Object {
        public name: string;
        public address: string;
        public mapname: string;
        public description: string;
        public wave: number;
        public players: number;
        public playerLimit: number;
        public version: number;
        public versionType: string;
        public mode: Packages.mindustry.game.Gamemode;
        public modeName?: string;
        public ping: number;
        public port: number;
        public constructor(
          _ping: number,
          _name: string,
          _address: string,
          _mapname: string,
          _wave: number,
          _players: number,
          _version: number,
          _versionType: string,
          _mode: Packages.mindustry.game.Gamemode,
          _playerLimit: number,
          _description: string,
          _modeName: string,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace rhino {
    declare namespace module {
      declare namespace provider {
        declare class ModuleSource {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace net {
      declare class URI {}
    }
  }
}
declare namespace Packages {
  declare namespace rhino {
    declare abstract class Scriptable {}
  }
}
declare namespace Packages {
  declare namespace rhino {
    declare namespace module {
      declare namespace provider {
        declare abstract class ModuleSourceProvider {
          public static NOT_MODIFIED: Packages.rhino.module.provider.ModuleSource;
          public loadSource(
            _arg0: Packages.java.net.URI,
            _arg1: Packages.java.net.URI,
            _arg2: any,
          ): Packages.rhino.module.provider.ModuleSource;
          public loadSource(
            _arg0: string,
            _arg1: Packages.rhino.Scriptable,
            _arg2: any,
          ): Packages.rhino.module.provider.ModuleSource;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace rhino {
    declare namespace module {
      declare namespace provider {
        declare abstract class ModuleSourceProviderBase
          extends java.lang.Object
          implements
            Packages.rhino.module.provider
              .ModuleSourceProvider
        {
          public loadSource(
            _arg0: Packages.java.net.URI,
            _arg1: Packages.java.net.URI,
            _arg2: any,
          ): Packages.rhino.module.provider.ModuleSource;
          public loadSource(
            _arg0: string,
            _arg1: Packages.rhino.Scriptable,
            _arg2: any,
          ): Packages.rhino.module.provider.ModuleSource;
          private static ensureTrailingSlash(
            _arg0: string,
          ): string;
          private loadFromPathArray(
            _arg0: string,
            _arg1: Packages.rhino.Scriptable,
            _arg2: any,
          ): Packages.rhino.module.provider.ModuleSource;
          protected loadFromPrivilegedLocations(
            _arg0: string,
            _arg1: any,
          ): Packages.rhino.module.provider.ModuleSource;
          protected loadFromFallbackLocations(
            _arg0: string,
            _arg1: any,
          ): Packages.rhino.module.provider.ModuleSource;
          protected loadFromUri(
            _arg0: Packages.java.net.URI,
            _arg1: Packages.java.net.URI,
            _arg2: any,
          ): Packages.rhino.module.provider.ModuleSource;
          protected entityNeedsRevalidation(
            _arg0: any,
          ): boolean;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace rhino {
    declare namespace module {
      declare namespace provider {
        declare abstract class UrlConnectionExpiryCalculator {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace net {
      declare abstract class URLConnection {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace io {
      declare class IOException {}
    }
  }
}
declare namespace Packages {
  declare namespace rhino {
    declare namespace module {
      declare namespace provider {
        declare class UrlModuleSourceProvider extends Packages
          .rhino.module.provider.ModuleSourceProviderBase {
          private static URLValidator = class {};
          private privilegedUris: Packages.java.lang.Iterable<Packages.java.net.URI>;
          private fallbackUris: Packages.java.lang.Iterable<Packages.java.net.URI>;
          private urlConnectionExpiryCalculator: Packages.rhino.module.provider.UrlConnectionExpiryCalculator;
          private close(
            _arg0: Packages.java.net.URLConnection,
          ): void;
          protected loadFromPrivilegedLocations(
            _arg0: string,
            _arg1: any,
          ): Packages.rhino.module.provider.ModuleSource;
          protected loadFromFallbackLocations(
            _arg0: string,
            _arg1: any,
          ): Packages.rhino.module.provider.ModuleSource;
          private loadFromPathList(
            _arg0: string,
            _arg1: any,
            _arg2: Packages.java.lang.Iterable<Packages.java.net.URI>,
          ): Packages.rhino.module.provider.ModuleSource;
          protected loadFromUri(
            _arg0: Packages.java.net.URI,
            _arg1: Packages.java.net.URI,
            _arg2: any,
          ): Packages.rhino.module.provider.ModuleSource;
          protected loadFromActualUri(
            _arg0: Packages.java.net.URI,
            _arg1: Packages.java.net.URI,
            _arg2: any,
          ): Packages.rhino.module.provider.ModuleSource;
          private static getReader(
            _arg0: Packages.java.net.URLConnection,
          ): Packages.java.io.Reader;
          private static getCharacterEncoding(
            _arg0: Packages.java.net.URLConnection,
          ): string;
          protected onFailedClosingUrlConnection(
            _arg0: Packages.java.net.URLConnection,
            _arg1: Packages.java.io.IOException,
          ): void;
          protected openUrlConnection(
            _arg0: Packages.java.net.URL,
          ): Packages.java.net.URLConnection;
          protected entityNeedsRevalidation(
            _arg0: any,
          ): boolean;
          public constructor(
            _arg0: Packages.java.lang.Iterable<Packages.java.net.URI>,
            _arg1: Packages.java.lang.Iterable<Packages.java.net.URI>,
          );
          public constructor(
            _arg0: Packages.java.lang.Iterable<Packages.java.net.URI>,
            _arg1: Packages.java.lang.Iterable<Packages.java.net.URI>,
            _arg2: Packages.rhino.module.provider.UrlConnectionExpiryCalculator,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace rhino {
    declare class Context {}
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace mod {
      declare class Scripts
        extends java.lang.Object
        implements Packages.arc.util.Disposable
      {
        private ScriptModuleProvider = class extends Packages
          .rhino.module.provider.UrlModuleSourceProvider {
          private directory: Packages.java.util.regex.Pattern;
          this$0: Packages.mindustry.mod.Scripts;
          public loadSource(
            _moduleId: string,
            _paths: Packages.rhino.Scriptable,
            _validator: any,
          ): Packages.rhino.module.provider.ModuleSource;
          private loadSource(
            _moduleId: string,
            _root: Packages.arc.files.Fi,
            _validator: any,
          ): Packages.rhino.module.provider.ModuleSource;
          public constructor(
            _this$0: Packages.mindustry.mod.Scripts,
          );
        };
        public context: Packages.rhino.Context;
        public scope: Packages.rhino.Scriptable;
        private errored: boolean;
        currentMod: Packages.mindustry.mod.Mods.LoadedMod;
        public run(
          _mod: Packages.mindustry.mod.Mods.LoadedMod,
          _file: Packages.arc.files.Fi,
        ): void;
        private run(
          _script: string,
          _file: string,
          _wrap: boolean,
        ): boolean;
        public log(
          _level: Packages.arc.util.Log.LogLevel,
          _source: string,
          _message: string,
        ): void;
        public log(_source: string, _message: string): void;
        public dispose(): void;
        public hasErrored(): boolean;
        private getError(
          _t: Packages.java.lang.Throwable,
          _log: boolean,
        ): string;
        public runConsole(_text: string): string;
        public newFloats(
          _capacity: number,
        ): number[] | null;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace core {
      declare abstract class Platform {
        public static FileWriter = class {
          public write(_file: Packages.arc.files.Fi): void;
        };
        public publish(
          _pub: Packages.mindustry._type.Publishable,
        ): void;
        public export(
          _name: string,
          _extension: string,
          _writer: Packages.mindustry.core.Platform.FileWriter,
        ): void;
        public hide(): void;
        public getNet(): Packages.mindustry.net.Net.NetProvider;
        public showFileChooser(
          _open: boolean,
          _extension: string,
          _cons: Packages.arc.func.Cons<Packages.arc.files.Fi>,
        ): void;
        public showFileChooser(
          _open: boolean,
          _title: string,
          _extension: string,
          _cons: Packages.arc.func.Cons<Packages.arc.files.Fi>,
        ): void;
        public showNativeFileChooser(
          _open: boolean,
          _title: string,
          _cons: Packages.arc.func.Cons<Packages.arc.files.Fi>,
          ..._shownExtensions: string[]
        ): void;
        public static showZenity(
          _open: boolean,
          _title: string,
          _extensions: string[],
          _cons: Packages.arc.func.Cons<Packages.arc.files.Fi>,
          _fallback: Packages.java.lang.Runnable,
        ): void;
        public static defaultFileDialog(
          _open: boolean,
          _title: string,
          _extension: string,
          _cons: Packages.arc.func.Cons<Packages.arc.files.Fi>,
        ): void;
        public static defaultMultiFileChooser(
          _cons: Packages.arc.func.Cons<Packages.arc.files.Fi>,
          ..._extensions: string[]
        ): void;
        public shareFile(
          _file: Packages.arc.files.Fi,
        ): void;
        public loadJar(
          _jar: Packages.arc.files.Fi,
          _parent: Packages.java.lang.ClassLoader,
        ): Packages.java.lang.ClassLoader;
        public updateLobby(): void;
        public inviteFriends(): void;
        public viewListing(
          _pub: Packages.mindustry._type.Publishable,
        ): void;
        public viewListingID(_mapid: string): void;
        public getWorkshopContent(
          _type: Class<any> | Packages.java.lang.Class<any>,
        ): Packages.arc.struct.Seq<Packages.arc.files.Fi>;
        public openWorkshop(): void;
        public createScripts(): Packages.mindustry.mod.Scripts;
        public getScriptContext(): Packages.rhino.Context;
        public updateRPC(): void;
        public getUUID(): string;
        public showMultiFileChooser(
          _cons: Packages.arc.func.Cons<Packages.arc.files.Fi>,
          ..._extensions: string[]
        ): void;
        public beginForceLandscape(): void;
        public endForceLandscape(): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare class LoadRenderer
        extends java.lang.Object
        implements Packages.arc.util.Disposable
      {
        static Bar = class extends java.lang.Object {
          value: Packages.arc.func.Floatp;
          red: Packages.arc.func.Boolp;
          valid: Packages.arc.func.Boolp;
          text: string;
          value(): number;
          red(): boolean;
          valid(): boolean;
          public constructor(
            _text: string,
            _value: number,
            _red: boolean,
          );
          public constructor(
            _text: string,
            _valid: Packages.arc.func.Boolp,
            _value: Packages.arc.func.Floatp,
            _red: Packages.arc.func.Boolp,
          );
        };
        private static color: Packages.arc.graphics.Color;
        private static colorRed: Packages.arc.graphics.Color;
        private static red: string;
        private static orange: string;
        private static floats: Packages.arc.struct.FloatSeq;
        private static preview: boolean;
        private testprogress: number;
        private assetText: Packages.java.lang.StringBuilder;
        private bars: Packages.mindustry.graphics.LoadRenderer.Bar[];
        private mesh: Packages.arc.graphics.Mesh;
        private cam: Packages.arc.graphics.g3d.Camera3D;
        private lastLength: number;
        private fx: Packages.arc.fx.FxProcessor;
        private renderTimes: Packages.arc.math.WindowedMean;
        private bloom: Packages.arc.fx.filters.BloomFilter;
        private renderStencil: boolean;
        private lastFrameTime: Packages.long;
        public dispose(): void;
        public draw(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare abstract class ClientLauncher
      extends Packages.arc.ApplicationCore
      implements Packages.mindustry.core.Platform
    {
      private static loadingFPS: number;
      private nextFrame: Packages.long;
      private beginTime: Packages.long;
      private lastTargetFps: Packages.long;
      private finished: boolean;
      private loader: Packages.mindustry.graphics.LoadRenderer;
      public exit(): void;
      public add(
        _module: Packages.arc.ApplicationListener,
      ): void;
      public update(): void;
      public init(): void;
      public setup(): void;
      public resume(): void;
      public resize(_width: number, _height: number): void;
      public pause(): void;
      public constructor();
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace net {
      declare class ServerGroup extends java.lang.Object {
        public name: string;
        public addresses: string[];
        public prioritized: boolean;
        key(): string;
        public setHidden(_hidden: boolean): void;
        public hidden(): boolean;
        public constructor();
        public constructor(
          _name: string,
          _addresses: string[],
        );
        public constructor(
          _name: string,
          _addresses: string[],
          _prioritized: boolean,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace core {
      declare class FileTree
        extends java.lang.Object
        implements
          Packages.arc.assets.loaders.FileHandleResolver
      {
        private files: Packages.arc.struct.ObjectMap<
          string,
          Packages.arc.files.Fi
        >;
        private loadedSounds: Packages.arc.struct.ObjectMap<
          string,
          Packages.arc.audio.Sound
        >;
        private loadedMusic: Packages.arc.struct.ObjectMap<
          string,
          Packages.arc.audio.Music
        >;
        public get(
          _path: string,
          _safe: boolean,
        ): Packages.arc.files.Fi;
        public get(_path: string): Packages.arc.files.Fi;
        public clear(): void;
        public resolve(
          _fileName: string,
        ): Packages.arc.files.Fi;
        public addFile(
          _path: string,
          _f: Packages.arc.files.Fi,
        ): void;
        public loadSound(
          _soundName: string,
        ): Packages.arc.audio.Sound;
        public loadMusic(
          _musicName: string,
        ): Packages.arc.audio.Music;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace net {
      declare class Net extends java.lang.Object {
        public static NetProvider = class {
          public dispose(): void;
          public setConnectFilter(
            _connectFilter: Packages.arc.net.Server.ServerConnectFilter,
          ): void;
          public getConnectFilter(): Packages.arc.net.Server.ServerConnectFilter | null;
          public getConnections(): Packages.java.lang.Iterable<any>;
          public disconnectClient(): void;
          public closeServer(): void;
          public connectClient(
            _ip: string,
            _port: number,
            _success: Packages.java.lang.Runnable,
          ): void;
          public sendClient(
            _object: any,
            _reliable: boolean,
          ): void;
          public discoverServers(
            _callback: Packages.arc.func.Cons<Packages.mindustry.net.Host>,
            _done: Packages.java.lang.Runnable,
          ): void;
          public pingHost(
            _address: string,
            _port: number,
            _valid: Packages.arc.func.Cons<Packages.mindustry.net.Host>,
            _failed: Packages.arc.func.Cons<Packages.java.lang.Exception>,
          ): void;
          public hostServer(_port: number): void;
        };
        private static packetProvs: Packages.arc.struct.Seq<
          Packages.arc.func.Prov<any>
        >;
        private static packetClasses: Packages.arc.struct.Seq<
          Packages.java.lang.Class<any>
        >;
        private static packetToId: Packages.arc.struct.ObjectIntMap<
          Packages.java.lang.Class<any>
        >;
        private clientLoaded: boolean;
        private currentStream?: Packages.mindustry.net.Streamable.StreamBuilder;
        private packetQueue: Packages.arc.struct.Seq<Packages.mindustry.net.Packet>;
        private clientListeners: Packages.arc.struct.ObjectMap<
          Packages.java.lang.Class<any>,
          Packages.arc.func.Cons<any>
        >;
        private serverListeners: Packages.arc.struct.ObjectMap<
          Packages.java.lang.Class<any>,
          Packages.arc.func.Cons2<
            Packages.mindustry.net.NetConnection,
            any
          >
        >;
        private streams: Packages.arc.struct.IntMap<Packages.mindustry.net.Streamable.StreamBuilder>;
        private pingExecutor: Packages.java.util.concurrent.ExecutorService;
        private provider: Packages.mindustry.net.Net.NetProvider;
        public host(_port: number): void;
        public connect(
          _ip: string,
          _port: number,
          _success: Packages.java.lang.Runnable,
        ): void;
        public reset(): void;
        public active(): boolean;
        public dispose(): void;
        public send(_object: any, _reliable: boolean): void;
        public setConnectFilter(
          _filter: Packages.arc.net.Server.ServerConnectFilter | null,
        ): void;
        public getConnectFilter(): Packages.arc.net.Server.ServerConnectFilter | null;
        public getConnections(): Packages.java.lang.Iterable<Packages.mindustry.net.NetConnection>;
        public closeServer(): void;
        public discoverServers(
          _cons: Packages.arc.func.Cons<Packages.mindustry.net.Host>,
          _done: Packages.java.lang.Runnable,
        ): void;
        public pingHost(
          _address: string,
          _port: number,
          _valid: Packages.arc.func.Cons<Packages.mindustry.net.Host>,
          _failed: Packages.arc.func.Cons<Packages.java.lang.Exception>,
        ): void;
        public client(): boolean;
        public handleClientReceived(
          _object: Packages.mindustry.net.Packet,
        ): void;
        public server(): boolean;
        public showError(
          _e: Packages.java.lang.Throwable,
        ): void;
        public handleClient<T>(
          _type: Class<T> | Packages.java.lang.Class<T>,
          _listener: Packages.arc.func.Cons<T>,
        ): void;
        public handleServer<T>(
          _type: Class<T> | Packages.java.lang.Class<T>,
          _listener: Packages.arc.func.Cons2<
            Packages.mindustry.net.NetConnection,
            T
          >,
        ): void;
        public static registerPacket<
          T extends Packages.mindustry.net.Packet,
        >(_cons: Packages.arc.func.Prov<T>): void;
        public static getPacketId(
          _packet: Packages.mindustry.net.Packet,
        ): string;
        public static newPacket<
          T extends Packages.mindustry.net.Packet,
        >(_id: string): T | null;
        public handleException(
          _e: Packages.java.lang.Throwable,
        ): void;
        public setClientLoaded(_loaded: boolean): void;
        public setClientConnected(): void;
        public sendExcept(
          _except: Packages.mindustry.net.NetConnection,
          _object: any,
          _reliable: boolean,
        ): void;
        public getCurrentStream(): Packages.mindustry.net.Streamable.StreamBuilder | null;
        public handleServerReceived(
          _connection: Packages.mindustry.net.NetConnection,
          _object: Packages.mindustry.net.Packet,
        ): void;
        public disconnect(): void;
        public constructor(
          _provider: Packages.mindustry.net.Net.NetProvider,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace core {
      declare class ContentLoader extends java.lang.Object {
        private contentNameMap: Packages.arc.struct.ObjectMap<
          string,
          Packages.mindustry.ctype.MappableContent
        >[];
        private contentMap: Packages.arc.struct.Seq<Packages.mindustry.ctype.Content>[];
        private temporaryMapper: Packages.mindustry.ctype.MappableContent[][];
        private currentMod?: Packages.mindustry.mod.Mods.LoadedMod;
        private lastAdded?: Packages.mindustry.ctype.Content;
        private initialization: Packages.arc.struct.ObjectSet<
          Packages.arc.func.Cons<Packages.mindustry.ctype.Content>
        >;
        public load(): void;
        private initialize(
          _callable: Packages.arc.func.Cons<Packages.mindustry.ctype.Content>,
        ): void;
        public init(): void;
        public getByName<
          T extends
            Packages.mindustry.ctype.MappableContent,
        >(
          _type: Packages.mindustry.ctype.ContentType,
          _name: string,
        ): T | null;
        public each(
          _cons: Packages.arc.func.Cons<Packages.mindustry.ctype.Content>,
        ): void;
        public block(
          _id: number,
        ): Packages.mindustry.world.Block;
        public block(
          _name: string,
        ): Packages.mindustry.world.Block;
        public unit(
          _id: number,
        ): Packages.mindustry._type.UnitType;
        public unit(
          _name: string,
        ): Packages.mindustry._type.UnitType;
        public removeLast(): void;
        public item(
          _name: string,
        ): Packages.mindustry._type.Item;
        public item(
          _id: number,
        ): Packages.mindustry._type.Item;
        public units(): Packages.arc.struct.Seq<Packages.mindustry._type.UnitType>;
        public items(): Packages.arc.struct.Seq<Packages.mindustry._type.Item>;
        public loadColors(): void;
        public createModContent(): void;
        public createBaseContent(): void;
        public sector(
          _name: string,
        ): Packages.mindustry._type.SectorPreset;
        public liquids(): Packages.arc.struct.Seq<Packages.mindustry._type.Liquid>;
        public blocks(): Packages.arc.struct.Seq<Packages.mindustry.world.Block>;
        public bullet(
          _id: number,
        ): Packages.mindustry.entities.bullet.BulletType;
        public liquid(
          _id: number,
        ): Packages.mindustry._type.Liquid;
        public liquid(
          _name: string,
        ): Packages.mindustry._type.Liquid;
        public getContentMap():
          | Packages.arc.struct.Seq<Packages.mindustry.ctype.Content>[]
          | null;
        public planet(
          _name: string,
        ): Packages.mindustry._type.Planet;
        public transformName(_name: string): string;
        public handleMappableContent(
          _content: Packages.mindustry.ctype.MappableContent,
        ): void;
        public getBy<
          T extends Packages.mindustry.ctype.Content,
        >(
          _type: Packages.mindustry.ctype.ContentType,
        ): Packages.arc.struct.Seq<T>;
        public handleContent(
          _content: Packages.mindustry.ctype.Content,
        ): void;
        public setCurrentMod(
          _mod: Packages.mindustry.mod.Mods.LoadedMod | null,
        ): void;
        public getLastAdded(): Packages.mindustry.ctype.Content | null;
        public weather(
          _name: string,
        ): Packages.mindustry._type.Weather;
        public unitCommand(
          _name: string,
        ): Packages.mindustry.ai.UnitCommand;
        public unitCommand(
          _id: number,
        ): Packages.mindustry.ai.UnitCommand;
        public unitStance(
          _name: string,
        ): Packages.mindustry.ai.UnitStance;
        public unitStance(
          _id: number,
        ): Packages.mindustry.ai.UnitStance;
        public statusEffects(): Packages.arc.struct.Seq<Packages.mindustry._type.StatusEffect>;
        public sectors(): Packages.arc.struct.Seq<Packages.mindustry._type.SectorPreset>;
        public planets(): Packages.arc.struct.Seq<Packages.mindustry._type.Planet>;
        public getByID<
          T extends Packages.mindustry.ctype.Content,
        >(
          _type: Packages.mindustry.ctype.ContentType,
          _id: number,
        ): T | null;
        public statusEffect(
          _name: string,
        ): Packages.mindustry._type.StatusEffect;
        public logContent(): void;
        public setTemporaryMapper(
          _temporaryMapper: Packages.mindustry.ctype.MappableContent[][],
        ): void;
        public bullets(): Packages.arc.struct.Seq<Packages.mindustry.entities.bullet.BulletType>;
        public weathers(): Packages.arc.struct.Seq<Packages.mindustry._type.Weather>;
        public unitStances(): Packages.arc.struct.Seq<Packages.mindustry.ai.UnitStance>;
        public unitCommands(): Packages.arc.struct.Seq<Packages.mindustry.ai.UnitCommand>;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace game {
      declare class GameStats extends java.lang.Object {
        public enemyUnitsDestroyed: number;
        public wavesLasted: number;
        public buildingsBuilt: number;
        public buildingsDeconstructed: number;
        public buildingsDestroyed: number;
        public unitsCreated: number;
        public placedBlockCount: Packages.arc.struct.ObjectIntMap<Packages.mindustry.world.Block>;
        public coreItemCount: Packages.arc.struct.ObjectIntMap<Packages.mindustry._type.Item>;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace game {
      declare class MapMarkers
        extends java.lang.Object
        implements
          Packages.java.lang
            .Iterable<Packages.mindustry.game.MapObjectives.ObjectiveMarker>
      {
        private map: Packages.arc.struct.IntMap<Packages.mindustry.game.MapObjectives.ObjectiveMarker>;
        private all: Packages.arc.struct.Seq<Packages.mindustry.game.MapObjectives.ObjectiveMarker>;
        public add(
          _id: number,
          _marker: Packages.mindustry.game.MapObjectives.ObjectiveMarker,
        ): void;
        public remove(_id: number): void;
        public get(
          _id: number,
        ): Packages.mindustry.game.MapObjectives.ObjectiveMarker | null;
        public size(): number;
        public iterator(): Packages.java.util.Iterator<Packages.mindustry.game.MapObjectives.ObjectiveMarker>;
        public write(
          _stream: Packages.java.io.DataOutput,
        ): void;
        public read(
          _stream: Packages.java.io.DataInput,
        ): void;
        public has(_id: number): boolean;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare class MapLocales
        extends Packages.arc.struct.ObjectMap<
          string,
          Packages.arc.struct.StringMap
        >
        implements
          Packages.arc.util.serialization.Json
            .JsonSerializable
      {
        private getProperty(
          _locale: string,
          _key: string,
        ): string;
        public getProperty(_key: string): string;
        public write(
          _json: Packages.arc.util.serialization.Json,
        ): void;
        public read(
          _json: Packages.arc.util.serialization.Json,
          _jsonData: Packages.arc.util.serialization.JsonValue,
        ): void;
        public copy(): Packages.arc.struct.ObjectMap<anyany>;
        public copy(): Packages.mindustry._type.MapLocales;
        public static currentLocale(): string;
        private containsProperty(
          _locale: string,
          _key: string,
        ): boolean;
        public containsProperty(_key: string): boolean;
        public getFormatted(
          _key: string,
          ..._args: any[]
        ): string;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace game {
      declare class Teams extends java.lang.Object {
        public static TeamData = class extends java.lang
          .Object {
          public team: Packages.mindustry.game.Team;
          public buildAi?: Packages.mindustry.ai.BaseBuilderAI;
          public rtsAi?: Packages.mindustry.ai.RtsAI;
          private presentFlag: boolean;
          public coreEnemies: Packages.mindustry.game.Team[];
          public plans: Packages.arc.struct.Queue<Packages.mindustry.game.Teams.BlockPlan>;
          public cores: Packages.arc.struct.Seq<Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild>;
          public lastCore?: Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
          public buildingTree?: Packages.arc.math.geom.QuadTree<Packages.mindustry.gen.Building>;
          public turretTree?: Packages.arc.math.geom.QuadTree<Packages.mindustry.gen.Building>;
          public unitTree?: Packages.arc.math.geom.QuadTree<Packages.mindustry.gen.Unit>;
          public unitCap: number;
          public unitCount: number;
          public typeCounts?: number[];
          public buildingTypes: Packages.arc.struct.ObjectMap<
            Packages.mindustry.world.Block,
            Packages.arc.struct.Seq<Packages.mindustry.gen.Building>
          >;
          public units: Packages.arc.struct.Seq<Packages.mindustry.gen.Unit>;
          public players: Packages.arc.struct.Seq<Packages.mindustry.gen.Player>;
          public buildings: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
          public unitsByType?: Packages.arc.struct.Seq<Packages.mindustry.gen.Unit>[];
          public toString(): string;
          public getCount(
            _block: Packages.mindustry.world.Block,
          ): number;
          public getUnits(
            _type: Packages.mindustry._type.UnitType,
          ): Packages.arc.struct.Seq<Packages.mindustry.gen.Unit> | null;
          public active(): boolean;
          public tree(): Packages.arc.math.geom.QuadTree<Packages.mindustry.gen.Unit>;
          public core(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild | null;
          private scheduleDerelict(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public unitCache(
            _type: Packages.mindustry._type.UnitType,
          ): Packages.arc.struct.Seq<Packages.mindustry.gen.Unit> | null;
          public getBuildings(
            _block: Packages.mindustry.world.Block,
          ): Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
          public destroyToDerelict(): void;
          public makeDerelict(
            _x: number,
            _y: number,
            _range: number,
          ): void;
          public timeDestroy(
            _x: number,
            _y: number,
            _range: number,
          ): void;
          public updateCount(
            _type: Packages.mindustry._type.UnitType,
            _amount: number,
          ): void;
          public countType(
            _type: Packages.mindustry._type.UnitType,
          ): number;
          public hasCore(): boolean;
          public noCores(): boolean;
          public hasAI(): boolean;
          public constructor(
            _team: Packages.mindustry.game.Team,
          );
        };
        public static BlockPlan = class extends java.lang
          .Object {
          public x: Packages.short;
          public y: Packages.short;
          public rotation: Packages.short;
          public block: Packages.short;
          public config: any;
          public removed: boolean;
          public toString(): string;
          public constructor(
            _x: number,
            _y: number,
            _rotation: Packages.short,
            _block: Packages.short,
            _config: any,
          );
        };
        private map: Packages.mindustry.game.Teams.TeamData[];
        public active: Packages.arc.struct.Seq<Packages.mindustry.game.Teams.TeamData>;
        public present: Packages.arc.struct.Seq<Packages.mindustry.game.Teams.TeamData>;
        public bosses: Packages.arc.struct.Seq<Packages.mindustry.gen.Unit>;
        public get(
          _team: Packages.mindustry.game.Team,
        ): Packages.mindustry.game.Teams.TeamData;
        private count(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public isActive(
          _team: Packages.mindustry.game.Team,
        ): boolean;
        public getOrNull(
          _team: Packages.mindustry.game.Team,
        ): Packages.mindustry.game.Teams.TeamData | null;
        public cores(
          _team: Packages.mindustry.game.Team,
        ): Packages.arc.struct.Seq<Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild>;
        public closestCore(
          _x: number,
          _y: number,
          _team: Packages.mindustry.game.Team,
        ): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild | null;
        public closestEnemyCore(
          _x: number,
          _y: number,
          _team: Packages.mindustry.game.Team,
        ): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild | null;
        public canInteract(
          _team: Packages.mindustry.game.Team,
          _other: Packages.mindustry.game.Team,
        ): boolean;
        public registerCore(
          _core: Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild,
        ): void;
        public unregisterCore(
          _entity: Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild,
        ): void;
        private updateEnemies(): void;
        public anyEnemyCoresWithin(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _radius: number,
        ): boolean;
        public eachEnemyCore(
          _team: Packages.mindustry.game.Team,
          _ret: Packages.arc.func.Cons<Packages.mindustry.gen.Building>,
        ): void;
        public playerCores(): Packages.arc.struct.Seq<Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild>;
        public getActive(): Packages.arc.struct.Seq<Packages.mindustry.game.Teams.TeamData>;
        public updateTeamStats(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace core {
      declare class GameState extends java.lang.Object {
        public static State = class extends Packages.java
          .lang
          .Enum<Packages.mindustry.core.GameState.State> {
          public static paused: Packages.mindustry.core.GameState.State;
          public static playing: Packages.mindustry.core.GameState.State;
          public static menu: Packages.mindustry.core.GameState.State;
          private static $VALUES: Packages.mindustry.core.GameState.State[];
          public static values():
            | Packages.mindustry.core.GameState.State[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.mindustry.core.GameState.State;
        };
        public wave: number;
        public wavetime: number;
        public tick: number;
        public updateId: Packages.long;
        public gameOver: boolean;
        public won: boolean;
        public serverTps: number;
        public map: Packages.mindustry.maps.Map;
        public rules: Packages.mindustry.game.Rules;
        public stats: Packages.mindustry.game.GameStats;
        public markers: Packages.mindustry.game.MapMarkers;
        public mapLocales: Packages.mindustry._type.MapLocales;
        public envAttrs: Packages.mindustry.world.blocks.Attributes;
        public teams: Packages.mindustry.game.Teams;
        public enemies: number;
        public playtestingMap?: Packages.mindustry.maps.Map;
        private state: Packages.mindustry.core.GameState.State;
        public set(
          _astate: Packages.mindustry.core.GameState.State,
        ): void;
        public getState(): Packages.mindustry.core.GameState.State;
        public is(
          _astate: Packages.mindustry.core.GameState.State,
        ): boolean;
        public isPlaying(): boolean;
        public isPaused(): boolean;
        public isCampaign(): boolean;
        public isEditor(): boolean;
        public isMenu(): boolean;
        public getSector(): Packages.mindustry._type.Sector | null;
        public isGame(): boolean;
        public hasSpawns(): boolean;
        public boss(): Packages.mindustry.gen.Unit | null;
        public hasSector(): boolean;
        public getPlanet(): Packages.mindustry._type.Planet | null;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare abstract class EntityIndexer {
        public change(
          _t: Packages.mindustry.gen.Entityc,
          _index: number,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare class EntityGroup<
          T extends Packages.mindustry.gen.Entityc,
        >
        extends java.lang.Object
        implements Packages.java.lang.Iterable<T>
      {
        private static lastId: number;
        private array: Packages.arc.struct.Seq<T>;
        private intersectArray: Packages.arc.struct.Seq<T>;
        private viewport: Packages.arc.math.geom.Rect;
        private intersectRect: Packages.arc.math.geom.Rect;
        private indexer: Packages.mindustry.entities.EntityIndexer;
        private map: Packages.arc.struct.IntMap<T>;
        private clearing: boolean;
        public index(_i: number): T | null;
        public add(_type: T): void;
        public remove(_type: T): void;
        public update(): void;
        public clear(): void;
        public isEmpty(): boolean;
        public size(): number;
        public iterator(): Packages.java.util.Iterator<T>;
        public count(
          _pred: Packages.arc.func.Boolf<T>,
        ): number;
        public contains(
          _pred: Packages.arc.func.Boolf<T>,
        ): boolean;
        public first(): T | null;
        public find(
          _pred: Packages.arc.func.Boolf<T>,
        ): T | null;
        public copy(): Packages.arc.struct.Seq<T>;
        public copy(
          _arr: Packages.arc.struct.Seq<T>,
        ): Packages.arc.struct.Seq<T>;
        public collide(): void;
        public sort(
          _comp: Packages.java.util.Comparator<any>,
        ): void;
        public each(
          _filter: Packages.arc.func.Boolf<T>,
          _cons: Packages.arc.func.Cons<T>,
        ): void;
        public each(_cons: Packages.arc.func.Cons<T>): void;
        public resize(
          _x: number,
          _y: number,
          _w: number,
          _h: number,
        ): void;
        public tree(): Packages.arc.math.geom.QuadTree<any>;
        public removeIndex(
          _type: T,
          _position: number,
        ): void;
        public draw(_cons: Packages.arc.func.Cons<T>): void;
        public intersect(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
          _out: Packages.arc.func.Cons<any>,
        ): void;
        public intersect(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
          _out: Packages.arc.func.Boolf<any>,
        ): boolean;
        public intersect(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
        ): Packages.arc.struct.Seq<T>;
        public static nextId(): number;
        public addIndex(_type: T): number;
        public updatePhysics(): void;
        public getByID(_id: number): T | null;
        public removeByID(_id: number): void;
        public mappingEnabled(): boolean;
        public static checkNextId(_id: number): void;
        public checkIDCollisions(): Packages.arc.struct.Seq<T>;
        public useTree(): boolean;
        public constructor(
          _type: Class<T> | Packages.java.lang.Class<T>,
          _spatial: boolean,
          _mapping: boolean,
          _indexer: Packages.mindustry.entities.EntityIndexer,
        );
        public constructor(
          _type: Class<T> | Packages.java.lang.Class<T>,
          _spatial: boolean,
          _mapping: boolean,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare class EntityCollisions extends java.lang
        .Object {
        public static SolidPred = class {
          public solid(_x: number, _y: number): boolean;
        };
        private static seg: number;
        private vector: Packages.arc.math.geom.Vec2;
        private l1: Packages.arc.math.geom.Vec2;
        private r1: Packages.arc.math.geom.Rect;
        private r2: Packages.arc.math.geom.Rect;
        private tmp: Packages.arc.math.geom.Rect;
        private arrOut: Packages.arc.struct.Seq<Packages.mindustry.gen.Hitboxc>;
        private hitCons: Packages.arc.func.Cons<Packages.mindustry.gen.Hitboxc>;
        private treeCons: Packages.arc.func.Cons<
          Packages.arc.math.geom.QuadTree<any>
        >;
        private collide(
          _x1: number,
          _y1: number,
          _w1: number,
          _h1: number,
          _vx1: number,
          _vy1: number,
          _x2: number,
          _y2: number,
          _w2: number,
          _h2: number,
          _vx2: number,
          _vy2: number,
          _out: Packages.arc.math.geom.Vec2,
        ): boolean;
        public collide<
          T extends Packages.mindustry.gen.Hitboxc,
        >(
          _groupa: Packages.mindustry.entities.EntityGroup<T>,
        ): void;
        public move(
          _entity: Packages.mindustry.gen.Hitboxc,
          _deltax: number,
          _deltay: number,
          _solidCheck: Packages.mindustry.entities.EntityCollisions.SolidPred,
        ): void;
        public move(
          _entity: Packages.mindustry.gen.Hitboxc,
          _deltax: number,
          _deltay: number,
        ): void;
        public static solid(
          _x: number,
          _y: number,
        ): boolean;
        public moveDelta(
          _entity: Packages.mindustry.gen.Hitboxc,
          _deltax: number,
          _deltay: number,
          _r: number,
          _x: boolean,
          _solidCheck: Packages.mindustry.entities.EntityCollisions.SolidPred,
        ): void;
        private checkCollide(
          _a: Packages.mindustry.gen.Hitboxc,
          _b: Packages.mindustry.gen.Hitboxc,
        ): void;
        public moveCheck(
          _entity: Packages.mindustry.gen.Hitboxc,
          _deltax: number,
          _deltay: number,
          _solidCheck: Packages.mindustry.entities.EntityCollisions.SolidPred,
        ): void;
        public overlapsTile(
          _rect: Packages.arc.math.geom.Rect,
          _solidChecker: Packages.mindustry.entities.EntityCollisions.SolidPred | null,
        ): boolean;
        public updatePhysics<
          T extends Packages.mindustry.gen.Hitboxc,
        >(
          _group: Packages.mindustry.entities.EntityGroup<T>,
        ): void;
        public static legsSolid(
          _x: number,
          _y: number,
        ): boolean;
        public static waterSolid(
          _x: number,
          _y: number,
        ): boolean;
        private updateCollision(
          _solid: Packages.mindustry.gen.Hitboxc,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace game {
      declare class Waves extends java.lang.Object {
        public static waveVersion: number;
        private spawns: Packages.arc.struct.Seq<Packages.mindustry.game.SpawnGroup>;
        public get(): Packages.arc.struct.Seq<Packages.mindustry.game.SpawnGroup>;
        public static generate(
          _difficulty: number,
          _rand: Packages.arc.math.Rand,
          _attack: boolean,
          _airOnly: boolean,
        ): Packages.arc.struct.Seq<Packages.mindustry.game.SpawnGroup>;
        public static generate(
          _difficulty: number,
          _rand: Packages.arc.math.Rand,
          _attack: boolean,
          _airOnly: boolean,
          _naval: boolean,
        ): Packages.arc.struct.Seq<Packages.mindustry.game.SpawnGroup>;
        public static generate(
          _difficulty: number,
          _rand: Packages.arc.math.Rand,
          _attack: boolean,
        ): Packages.arc.struct.Seq<Packages.mindustry.game.SpawnGroup>;
        public static generate(
          _difficulty: number,
        ): Packages.arc.struct.Seq<Packages.mindustry.game.SpawnGroup>;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare class TeamEntry extends Packages.mindustry
        .ctype.UnlockableContent {
        public team: Packages.mindustry.game.Team;
        public displayExtra(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public getContentType(): Packages.mindustry.ctype.ContentType;
        public constructor(
          _name: string,
          _team: Packages.mindustry.game.Team,
        );
        public constructor(
          _team: Packages.mindustry.game.Team,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace mod {
      declare class ContentParser extends java.lang.Object {
        private static TypeParser = class<
          T extends Packages.mindustry.ctype.Content,
        > {
          public parse(
            _mod: string,
            _name: string,
            _value: Packages.arc.util.serialization.JsonValue,
          ): T | null;
        };
        private static FieldParser = class {
          public parse(
            _type:
              | Class<any>
              | Packages.java.lang.Class<any>,
            _value: Packages.arc.util.serialization.JsonValue,
          ): any;
        };
        static UnitReq = class extends java.lang.Object {
          public block: Packages.mindustry.world.Block;
          public requirements: Packages.mindustry._type.ItemStack[];
          public previous?: Packages.mindustry._type.UnitType;
          public time: number;
        };
        public static ParseListener = class {
          public parsed(
            _type:
              | Class<any>
              | Packages.java.lang.Class<any>,
            _jsonData: Packages.arc.util.serialization.JsonValue,
            _result: any,
          ): void;
        };
        private static ignoreUnknownFields: boolean;
        private static typesToSearch: Packages.mindustry.ctype.ContentType[];
        contentTypes: Packages.arc.struct.ObjectMap<
          Packages.java.lang.Class<any>,
          Packages.mindustry.ctype.ContentType
        >;
        implicitNullable: Packages.arc.struct.ObjectSet<
          Packages.java.lang.Class<any>
        >;
        listeners: Packages.arc.struct.Seq<Packages.mindustry.mod.ContentParser.ParseListener>;
        classParsers: Packages.arc.struct.ObjectMap<
          Packages.java.lang.Class<any>,
          Packages.mindustry.mod.ContentParser.FieldParser
        >;
        private reads: Packages.arc.struct.Seq<Packages.java.lang.Runnable>;
        private postreads: Packages.arc.struct.Seq<Packages.java.lang.Runnable>;
        private toBeParsed: Packages.arc.struct.ObjectSet<any>;
        currentMod: Packages.mindustry.mod.Mods.LoadedMod;
        currentContent: Packages.mindustry.ctype.Content;
        private parsers: Packages.arc.struct.ObjectMap<
          Packages.mindustry.ctype.ContentType,
          Packages.mindustry.mod.ContentParser.TypeParser<any>
        >;
        make<T>(
          _type: Class<T> | Packages.java.lang.Class<T>,
        ): T | null;
        private make<T>(
          _type: Class<T> | Packages.java.lang.Class<T>,
          _name: string,
        ): T | null;
        field(
          _type: Class<any> | Packages.java.lang.Class<any>,
          _value: Packages.arc.util.serialization.JsonValue,
        ): any;
        private field(
          _type: Class<any> | Packages.java.lang.Class<any>,
          _name: string,
        ): any;
        private find<
          T extends Packages.mindustry.ctype.Content,
        >(
          _type: Packages.mindustry.ctype.ContentType,
          _name: string,
        ): T | null;
        resolve<T>(
          _base: string,
        ): Packages.java.lang.Class<T>;
        resolve<T>(
          _base: string,
          _def: Class<T> | Packages.java.lang.Class<T>,
        ): Packages.java.lang.Class<T>;
        private init(): void;
        private read(
          _run: Packages.java.lang.Runnable,
        ): void;
        private readFields(
          _object: any,
          _jsonMap: Packages.arc.util.serialization.JsonValue,
          _stripType: boolean,
        ): void;
        readFields(
          _object: any,
          _jsonMap: Packages.arc.util.serialization.JsonValue,
        ): void;
        private getType(
          _value: Packages.arc.util.serialization.JsonValue,
        ): string;
        public parse(
          _mod: Packages.mindustry.mod.Mods.LoadedMod,
          _name: string,
          _json: string,
          _file: Packages.arc.files.Fi,
          _type: Packages.mindustry.ctype.ContentType,
        ): Packages.mindustry.ctype.Content;
        private getString(
          _value: Packages.arc.util.serialization.JsonValue,
          _key: string,
        ): string;
        private parser<
          T extends Packages.mindustry.ctype.Content,
        >(
          _type: Packages.mindustry.ctype.ContentType,
          _constructor: Packages.arc.func.Func<string, T>,
        ): Packages.mindustry.mod.ContentParser.TypeParser<T>;
        private attempt(
          _run: Packages.java.lang.Runnable,
        ): void;
        private locate<
          T extends
            Packages.mindustry.ctype.MappableContent,
        >(
          _type: Packages.mindustry.ctype.ContentType,
          _name: string,
        ): T | null;
        private unitType(
          _value: Packages.arc.util.serialization.JsonValue,
        ): Packages.arc.func.Prov<Packages.mindustry.gen.Unit>;
        public markError(
          _content: Packages.mindustry.ctype.Content,
          _mod: Packages.mindustry.mod.Mods.LoadedMod,
          _file: Packages.arc.files.Fi,
          _error: Packages.java.lang.Throwable,
        ): void;
        public markError(
          _content: Packages.mindustry.ctype.Content,
          _error: Packages.java.lang.Throwable,
        ): void;
        public finishParsing(): void;
        private makeError(
          _t: Packages.java.lang.Throwable,
          _file: Packages.arc.files.Fi,
        ): string;
        private parseMesh(
          _planet: Packages.mindustry._type.Planet,
          _data: Packages.arc.util.serialization.JsonValue,
        ): Packages.mindustry.graphics.g3d.GenericMesh;
        private parseMeshes(
          _planet: Packages.mindustry._type.Planet,
          _array: Packages.arc.util.serialization.JsonValue,
        ):
          | Packages.mindustry.graphics.g3d.GenericMesh[]
          | null;
        checkNullFields(_object: any): void;
        private readBundle(
          _type: Packages.mindustry.ctype.ContentType,
          _name: string,
          _value: Packages.arc.util.serialization.JsonValue,
        ): void;
        private supply<T>(
          _type: Class<T> | Packages.java.lang.Class<T>,
        ): Packages.arc.func.Prov<T>;
        fieldOpt(
          _type: Class<any> | Packages.java.lang.Class<any>,
          _value: Packages.arc.util.serialization.JsonValue,
        ): any;
        private parseProgressOp(
          _base: Packages.mindustry.entities.part.DrawPart.PartProgress,
          _op: string,
          _data: Packages.arc.util.serialization.JsonValue,
        ): Packages.mindustry.entities.part.DrawPart.PartProgress;
        private locateAny<
          T extends
            Packages.mindustry.ctype.MappableContent,
        >(_name: string): T | null;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace mod {
      declare class ModClassLoader extends Packages.java
        .lang.ClassLoader {
        private children: Packages.arc.struct.Seq<Packages.java.lang.ClassLoader>;
        private inChild: Packages.java.lang.ThreadLocal<boolean>;
        protected findClass(
          _name: string,
        ): Packages.java.lang.Class<any>;
        public addChild(
          _child: Packages.java.lang.ClassLoader,
        ): void;
        public constructor(
          _parent: Packages.java.lang.ClassLoader,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace mod {
      declare namespace Mods {
        declare class RegionEntry extends java.lang.Object {
          name: string;
          region: Packages.arc.graphics.g2d.PixmapRegion;
          splits: number[];
          pads: number[];
          this$0: Packages.mindustry.mod.Mods;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace mod {
      declare class Mods
        extends java.lang.Object
        implements Packages.arc.assets.Loadable
      {
        public static ModMeta = class extends java.lang
          .Object {
          public name: string;
          public internalName: string;
          public minGameVersion: string;
          public displayName?: string;
          public author?: string;
          public description?: string;
          public subtitle?: string;
          public version?: string;
          public main?: string;
          public repo?: string;
          public dependencies: Packages.arc.struct.Seq<string>;
          public softDependencies: Packages.arc.struct.Seq<string>;
          public hidden: boolean;
          public java: boolean;
          public texturescale: number;
          public pregenerated: boolean;
          public contentOrder: string[];
          public toString(): string;
          public cleanup(): void;
          public displayName(): string;
          public getMinMajor(): number;
          public shortDescription(): string;
          public constructor();
        };
        public static LoadedMod = class
          extends java.lang.Object
          implements
            Packages.arc.util.Disposable,
            Packages.mindustry._type.Publishable
        {
          public file: Packages.arc.files.Fi;
          public root: Packages.arc.files.Fi;
          public main?: Packages.mindustry.mod.Mod;
          public name: string;
          public meta: Packages.mindustry.mod.Mods.ModMeta;
          public dependencies: Packages.arc.struct.Seq<Packages.mindustry.mod.Mods.LoadedMod>;
          public missingDependencies: Packages.arc.struct.Seq<string>;
          public erroredContent: Packages.arc.struct.ObjectSet<Packages.mindustry.ctype.Content>;
          public state: Packages.mindustry.mod.Mods.ModState;
          public iconTexture?: Packages.arc.graphics.Texture;
          public loader?: Packages.java.lang.ClassLoader;
          public toString(): string;
          public enabled(): boolean;
          public isSupported(): boolean;
          public dispose(): void;
          public getSteamID(): string;
          public addSteamID(_id: string): void;
          public removeSteamID(): void;
          public steamTitle(): string;
          public steamDescription(): string;
          public steamTag(): string;
          public createSteamFolder(
            _id: string,
          ): Packages.arc.files.Fi;
          public createSteamPreview(
            _id: string,
          ): Packages.arc.files.Fi;
          public prePublish(): boolean;
          public isOutdated(): boolean;
          public isBlacklisted(): boolean;
          public getMinMajor(): number;
          public isJava(): boolean;
          public getRepo(): string | null;
          public setRepo(_repo: string): void;
          public shouldBeEnabled(): boolean;
          public hasUnmetDependencies(): boolean;
          public hasContentErrors(): boolean;
          public constructor(
            _file: Packages.arc.files.Fi,
            _root: Packages.arc.files.Fi,
            _main: Packages.mindustry.mod.Mod,
            _loader: Packages.java.lang.ClassLoader,
            _meta: Packages.mindustry.mod.Mods.ModMeta,
          );
        };
        public static ModState = class extends Packages.java
          .lang.Enum<Packages.mindustry.mod.Mods.ModState> {
          public static enabled: Packages.mindustry.mod.Mods.ModState;
          public static contentErrors: Packages.mindustry.mod.Mods.ModState;
          public static missingDependencies: Packages.mindustry.mod.Mods.ModState;
          public static incompleteDependencies: Packages.mindustry.mod.Mods.ModState;
          public static circularDependencies: Packages.mindustry.mod.Mods.ModState;
          public static unsupported: Packages.mindustry.mod.Mods.ModState;
          public static disabled: Packages.mindustry.mod.Mods.ModState;
          private static $VALUES: Packages.mindustry.mod.Mods.ModState[];
          public static values():
            | Packages.mindustry.mod.Mods.ModState[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.mindustry.mod.Mods.ModState;
        };
        public static ModResolutionContext = class extends java
          .lang.Object {
          public dependencies: Packages.arc.struct.ObjectMap<
            string,
            Packages.arc.struct.Seq<Packages.mindustry.mod.Mods.ModDependency>
          >;
          public visited: Packages.arc.struct.ObjectSet<string>;
          public ordered: Packages.arc.struct.OrderedSet<string>;
          public invalid: Packages.arc.struct.ObjectMap<
            string,
            Packages.mindustry.mod.Mods.ModState
          >;
          public constructor();
        };
        public static ModDependency = class extends java
          .lang.Object {
          public name: string;
          public required: boolean;
          public constructor(
            _name: string,
            _required: boolean,
          );
        };
        public static ModLoadException = class extends Packages
          .java.lang.RuntimeException {
          public constructor(_message: string);
        };
        private static metaFiles: string[];
        private static blacklistedMods: Packages.arc.struct.ObjectSet<string>;
        private json: Packages.arc.util.serialization.Json;
        private scripts?: Packages.mindustry.mod.Scripts;
        private parser: Packages.mindustry.mod.ContentParser;
        private bundles: Packages.arc.struct.ObjectMap<
          string,
          Packages.arc.struct.Seq<Packages.arc.files.Fi>
        >;
        private specialFolders: Packages.arc.struct.ObjectSet<string>;
        private totalSprites: number;
        private textureResize: Packages.arc.struct.ObjectFloatMap<string>;
        private packer: Packages.mindustry.graphics.MultiPacker;
        private lastOrderedMods?: Packages.arc.struct.Seq<Packages.mindustry.mod.Mods.LoadedMod>;
        mods: Packages.arc.struct.Seq<Packages.mindustry.mod.Mods.LoadedMod>;
        private metas: Packages.arc.struct.ObjectMap<
          Packages.java.lang.Class<any>,
          Packages.mindustry.mod.Mods.ModMeta
        >;
        public load(): void;
        public list(): Packages.arc.struct.Seq<Packages.mindustry.mod.Mods.LoadedMod>;
        private resolve(
          _element: string,
          _context: Packages.mindustry.mod.Mods.ModResolutionContext,
        ): boolean;
        public listFiles(
          _directory: string,
          _cons: Packages.arc.func.Cons2<
            Packages.mindustry.mod.Mods.LoadedMod,
            Packages.arc.files.Fi
          >,
        ): void;
        public loadSync(): void;
        public loadAsync(): void;
        private getPage(
          _file: Packages.arc.files.Fi,
        ): Packages.mindustry.graphics.MultiPacker.PageType;
        public eachClass(
          _cons: Packages.arc.func.Cons<Packages.mindustry.mod.Mod>,
        ): void;
        public loadScripts(): void;
        public mainLoader(): Packages.java.lang.ClassLoader;
        public getConfigFolder(
          _mod: Packages.mindustry.mod.Mod,
        ): Packages.arc.files.Fi;
        public eachEnabled(
          _cons: Packages.arc.func.Cons<Packages.mindustry.mod.Mods.LoadedMod>,
        ): void;
        private loadMod(
          _sourceFile: Packages.arc.files.Fi,
          _overwrite: boolean,
          _initialize: boolean,
        ): Packages.mindustry.mod.Mods.LoadedMod;
        private loadMod(
          _sourceFile: Packages.arc.files.Fi,
        ): Packages.mindustry.mod.Mods.LoadedMod;
        public requiresReload(): boolean;
        private sortMods(): void;
        public importMod(
          _file: Packages.arc.files.Fi,
        ): Packages.mindustry.mod.Mods.LoadedMod;
        private loadIcons(): void;
        public findMeta(
          _file: Packages.arc.files.Fi,
        ): Packages.mindustry.mod.Mods.ModMeta | null;
        private loadIcon(
          _mod: Packages.mindustry.mod.Mods.LoadedMod,
        ): void;
        public hasContentErrors(): boolean;
        public resolveDependencies(
          _metas: Packages.arc.struct.Seq<Packages.mindustry.mod.Mods.ModMeta>,
        ): Packages.arc.struct.OrderedMap<
          string,
          Packages.mindustry.mod.Mods.ModState
        >;
        private buildFiles(): void;
        public orderedMods(): Packages.arc.struct.Seq<Packages.mindustry.mod.Mods.LoadedMod>;
        public loadContent(): void;
        public getModStrings(): Packages.arc.struct.Seq<string>;
        public skipModLoading(): boolean;
        public contextRun(
          _mod: Packages.mindustry.mod.Mods.LoadedMod,
          _run: Packages.java.lang.Runnable,
        ): void;
        private packSprites(
          _sprites: Packages.arc.struct.Seq<Packages.arc.files.Fi>,
          _mod: Packages.mindustry.mod.Mods.LoadedMod,
          _prefix: boolean,
          _tasks: Packages.arc.struct.Seq<
            Packages.java.util.concurrent.Future<Packages.java.lang.Runnable>
          >,
        ): void;
        public getConfig(
          _mod: Packages.mindustry.mod.Mod,
        ): Packages.arc.files.Fi;
        public getMod(
          _type: Class<any> | Packages.java.lang.Class<any>,
        ): Packages.mindustry.mod.Mods.LoadedMod | null;
        public getMod(
          _name: string,
        ): Packages.mindustry.mod.Mods.LoadedMod | null;
        public removeMod(
          _mod: Packages.mindustry.mod.Mods.LoadedMod,
        ): void;
        public getScripts(): Packages.mindustry.mod.Scripts;
        public hasScripts(): boolean;
        private updateDependencies(
          _mod: Packages.mindustry.mod.Mods.LoadedMod,
        ): void;
        public locateMod(
          _name: string,
        ): Packages.mindustry.mod.Mods.LoadedMod;
        private checkWarnings(): void;
        public handleContentError(
          _content: Packages.mindustry.ctype.Content,
          _error: Packages.java.lang.Throwable,
        ): void;
        public addParseListener(
          _hook: Packages.mindustry.mod.ContentParser.ParseListener,
        ): void;
        public setEnabled(
          _mod: Packages.mindustry.mod.Mods.LoadedMod,
          _enabled: boolean,
        ): void;
        public getIncompatibility(
          _out: Packages.arc.struct.Seq<string>,
        ): Packages.arc.struct.Seq<string>;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace game {
      declare class Schematics
        extends java.lang.Object
        implements Packages.arc.assets.Loadable
      {
        private static tmpSchem: Packages.mindustry.game.Schematic;
        private static tmpSchem2: Packages.mindustry.game.Schematic;
        private static header: string[];
        private static version: string;
        private static padding: number;
        private static maxPreviewsMobile: number;
        private static resolution: number;
        private out: Packages.arc.util.io.Streams.OptimizedByteArrayOutputStream;
        private previews: Packages.arc.struct.OrderedMap<
          Packages.mindustry.game.Schematic,
          Packages.arc.graphics.gl.FrameBuffer
        >;
        private errored: Packages.arc.struct.ObjectSet<Packages.mindustry.game.Schematic>;
        private loadouts: Packages.arc.struct.ObjectMap<
          Packages.mindustry.world.blocks.storage.CoreBlock,
          Packages.arc.struct.Seq<Packages.mindustry.game.Schematic>
        >;
        private defaultLoadouts: Packages.arc.struct.ObjectMap<
          Packages.mindustry.world.blocks.storage.CoreBlock,
          Packages.mindustry.game.Schematic
        >;
        private shadowBuffer: Packages.arc.graphics.gl.FrameBuffer;
        private errorTexture: Packages.arc.graphics.Texture;
        private lastClearTime: Packages.long;
        public add(
          _schematic: Packages.mindustry.game.Schematic,
        ): void;
        public remove(
          _s: Packages.mindustry.game.Schematic,
        ): void;
        public load(): void;
        public static write(
          _schematic: Packages.mindustry.game.Schematic,
          _file: Packages.arc.files.Fi,
        ): void;
        public static write(
          _schematic: Packages.mindustry.game.Schematic,
          _output: Packages.java.io.OutputStream,
        ): void;
        public static read(
          _input: Packages.java.io.InputStream,
        ): Packages.mindustry.game.Schematic;
        public static read(
          _file: Packages.arc.files.Fi,
        ): Packages.mindustry.game.Schematic;
        public create(
          _x: number,
          _y: number,
          _x2: number,
          _y2: number,
        ): Packages.mindustry.game.Schematic;
        public static rotate(
          _input: Packages.mindustry.game.Schematic,
          _times: number,
        ): Packages.mindustry.game.Schematic;
        public all(): Packages.arc.struct.Seq<Packages.mindustry.game.Schematic>;
        public getBuffer(
          _schematic: Packages.mindustry.game.Schematic,
        ): Packages.arc.graphics.gl.FrameBuffer;
        public loadSync(): void;
        private loadFile(
          _file: Packages.arc.files.Fi,
        ): Packages.mindustry.game.Schematic | null;
        public saveChanges(
          _s: Packages.mindustry.game.Schematic,
        ): void;
        public savePreview(
          _schematic: Packages.mindustry.game.Schematic,
          _file: Packages.arc.files.Fi,
        ): void;
        public static place(
          _schem: Packages.mindustry.game.Schematic,
          _x: number,
          _y: number,
          _team: Packages.mindustry.game.Team,
        ): void;
        public static place(
          _schem: Packages.mindustry.game.Schematic,
          _x: number,
          _y: number,
          _team: Packages.mindustry.game.Team,
          _overwrite: boolean,
        ): void;
        public overwrite(
          _target: Packages.mindustry.game.Schematic,
          _newSchematic: Packages.mindustry.game.Schematic,
        ): void;
        public static placeLaunchLoadout(
          _x: number,
          _y: number,
        ): void;
        private loadLoadouts(): void;
        private checkLoadout(
          _s: Packages.mindustry.game.Schematic,
          _customSchem: boolean,
        ): void;
        public getMaxLaunchSize(
          _block: Packages.mindustry.world.Block,
        ): number;
        findFile(
          _schematicName: string,
        ): Packages.arc.files.Fi;
        public static placeLoadout(
          _schem: Packages.mindustry.game.Schematic,
          _x: number,
          _y: number,
          _team: Packages.mindustry.game.Team,
        ): void;
        public static placeLoadout(
          _schem: Packages.mindustry.game.Schematic,
          _x: number,
          _y: number,
        ): void;
        public static placeLoadout(
          _schem: Packages.mindustry.game.Schematic,
          _x: number,
          _y: number,
          _team: Packages.mindustry.game.Team,
          _check: boolean,
        ): void;
        private static mapConfig(
          _block: Packages.mindustry.world.Block,
          _value: number,
          _position: number,
        ): any;
        private static rotated(
          _input: Packages.mindustry.game.Schematic,
          _counter: boolean,
        ): Packages.mindustry.game.Schematic;
        public getPreview(
          _schematic: Packages.mindustry.game.Schematic,
        ): Packages.arc.graphics.Texture;
        public hasPreview(
          _schematic: Packages.mindustry.game.Schematic,
        ): boolean;
        public toPlans(
          _schem: Packages.mindustry.game.Schematic,
          _x: number,
          _y: number,
        ): Packages.arc.struct.Seq<Packages.mindustry.entities.units.BuildPlan>;
        public getLoadouts(
          _block: Packages.mindustry.world.blocks.storage.CoreBlock,
        ): Packages.arc.struct.Seq<Packages.mindustry.game.Schematic>;
        public getLoadouts(): Packages.arc.struct.ObjectMap<
          Packages.mindustry.world.blocks.storage.CoreBlock,
          Packages.arc.struct.Seq<Packages.mindustry.game.Schematic>
        >;
        public getDefaultLoadout(
          _block: Packages.mindustry.world.blocks.storage.CoreBlock,
        ): Packages.mindustry.game.Schematic | null;
        public isDefaultLoadout(
          _schem: Packages.mindustry.game.Schematic,
        ): boolean;
        public writeBase64(
          _schematic: Packages.mindustry.game.Schematic,
        ): string;
        public static readBase64(
          _schematic: string,
        ): Packages.mindustry.game.Schematic;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace net {
      declare class BeControl extends java.lang.Object {
        private static updateInterval: number;
        private checkUpdates: boolean;
        private updateAvailable: boolean;
        private updateUrl: string;
        private updateBuild: number;
        public active(): boolean;
        private download(
          _furl: string,
          _dest: Packages.arc.files.Fi,
          _length: Packages.arc.func.Intc,
          _progressor: Packages.arc.func.Floatc,
          _canceled: Packages.arc.func.Boolp,
          _done: Packages.java.lang.Runnable,
          _error: Packages.arc.func.Cons<Packages.java.lang.Throwable>,
        ): void;
        public showUpdateDialog(): void;
        public checkUpdate(
          _done: Packages.arc.func.Boolc,
        ): void;
        public isUpdateAvailable(): boolean;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace async {
      declare abstract class AsyncProcess {
        public end(): void;
        public begin(): void;
        public init(): void;
        public reset(): void;
        public process(): void;
        public shouldProcess(): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace async {
      declare class AsyncCore extends java.lang.Object {
        public processes: Packages.arc.struct.Seq<Packages.mindustry.async.AsyncProcess>;
        private futures: Packages.arc.struct.Seq<
          Packages.java.util.concurrent.Future<any>
        >;
        private executor: Packages.java.util.concurrent.ExecutorService;
        public end(): void;
        public begin(): void;
        private complete(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace environment {
          declare class OverlayFloor extends Packages
            .mindustry.world.blocks.environment.Floor {
            public drawBase(
              _tile: Packages.mindustry.world.Tile,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace environment {
          declare class OreBlock extends Packages.mindustry
            .world.blocks.environment.OverlayFloor {
            public init(): void;
            public setup(
              _ore: Packages.mindustry._type.Item,
            ): void;
            public getDisplayName(
              _tile: Packages.mindustry.world.Tile,
            ): string;
            public createIcons(
              _packer: Packages.mindustry.graphics.MultiPacker,
            ): void;
            public constructor(_name: string);
            public constructor(
              _ore: Packages.mindustry._type.Item,
            );
            public constructor(
              _name: string,
              _ore: Packages.mindustry._type.Item,
            );
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare class BaseRegistry extends java.lang.Object {
        public static BasePart = class
          extends java.lang.Object
          implements
            Packages.java.lang
              .Comparable<Packages.mindustry.ai.BaseRegistry.BasePart>
        {
          public schematic: Packages.mindustry.game.Schematic;
          public centerX: number;
          public centerY: number;
          public required?: Packages.mindustry.ctype.Content;
          public core?: Packages.mindustry.world.Block;
          public tier: number;
          public compareTo(
            _other: Packages.mindustry.ai.BaseRegistry.BasePart,
          ): number;
          public compareTo(_other: any): number;
          public constructor(
            _schematic: Packages.mindustry.game.Schematic,
          );
        };
        public cores: Packages.arc.struct.Seq<Packages.mindustry.ai.BaseRegistry.BasePart>;
        public parts: Packages.arc.struct.Seq<Packages.mindustry.ai.BaseRegistry.BasePart>;
        public reqParts: Packages.arc.struct.ObjectMap<
          Packages.mindustry.ctype.Content,
          Packages.arc.struct.Seq<Packages.mindustry.ai.BaseRegistry.BasePart>
        >;
        public ores: Packages.arc.struct.ObjectMap<
          Packages.mindustry._type.Item,
          Packages.mindustry.world.blocks.environment.OreBlock
        >;
        public oreFloors: Packages.arc.struct.ObjectMap<
          Packages.mindustry._type.Item,
          Packages.mindustry.world.blocks.environment.Floor
        >;
        public load(): void;
        public forResource(
          _item: Packages.mindustry.ctype.Content,
        ): Packages.arc.struct.Seq<Packages.mindustry.ai.BaseRegistry.BasePart>;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare class GlobalVars extends java.lang.Object {
        public static VarEntry = class extends java.lang
          .Object {
          public name: string;
          public description: string;
          public icon: string;
          public privileged: boolean;
          public constructor(
            _name: string,
            _description: string,
            _icon: string,
            _privileged: boolean,
          );
          public constructor();
        };
        public static ctrlProcessor: number;
        public static ctrlPlayer: number;
        public static ctrlCommand: number;
        public static lookableContent: Packages.mindustry.ctype.ContentType[];
        public static rand: Packages.arc.math.Rand;
        private static varTime: Packages.mindustry.logic.LVar;
        private static varTick: Packages.mindustry.logic.LVar;
        private static varSecond: Packages.mindustry.logic.LVar;
        private static varMinute: Packages.mindustry.logic.LVar;
        private static varWave: Packages.mindustry.logic.LVar;
        private static varWaveTime: Packages.mindustry.logic.LVar;
        private static varMapW: Packages.mindustry.logic.LVar;
        private static varMapH: Packages.mindustry.logic.LVar;
        private static varWait: Packages.mindustry.logic.LVar;
        private static varServer: Packages.mindustry.logic.LVar;
        private static varClient: Packages.mindustry.logic.LVar;
        private static varClientLocale: Packages.mindustry.logic.LVar;
        private static varClientUnit: Packages.mindustry.logic.LVar;
        private static varClientName: Packages.mindustry.logic.LVar;
        private static varClientTeam: Packages.mindustry.logic.LVar;
        private static varClientMobile: Packages.mindustry.logic.LVar;
        private vars: Packages.arc.struct.ObjectMap<
          string,
          Packages.mindustry.logic.LVar
        >;
        private varEntries: Packages.arc.struct.Seq<Packages.mindustry.logic.GlobalVars.VarEntry>;
        private privilegedNames: Packages.arc.struct.ObjectSet<string>;
        private logicIdToContent: Packages.mindustry.ctype.UnlockableContent[][];
        private contentIdToLogicId: number[][];
        public static soundNames: Packages.arc.struct.Seq<string>;
        public get(
          _name: string,
        ): Packages.mindustry.logic.LVar;
        public get(
          _name: string,
          _privileged: boolean,
        ): Packages.mindustry.logic.LVar;
        public put(
          _name: string,
          _value: any,
          _privileged: boolean,
        ): Packages.mindustry.logic.LVar;
        public put(
          _name: string,
          _value: any,
        ): Packages.mindustry.logic.LVar;
        public put(
          _name: string,
          _value: any,
          _privileged: boolean,
          _hidden: boolean,
        ): Packages.mindustry.logic.LVar;
        public update(): void;
        public set(_name: string, _value: number): void;
        public init(): void;
        public getEntries(): Packages.arc.struct.Seq<Packages.mindustry.logic.GlobalVars.VarEntry>;
        public lookupLogicId(
          _content: Packages.mindustry.ctype.UnlockableContent,
        ): number;
        public putEntryOnly(_name: string): void;
        public putEntry(
          _name: string,
          _value: any,
          _privileged: boolean,
        ): Packages.mindustry.logic.LVar;
        public putEntry(
          _name: string,
          _value: any,
        ): Packages.mindustry.logic.LVar;
        public waitVar(): Packages.mindustry.logic.LVar;
        public lookupContent(
          _type: Packages.mindustry.ctype.ContentType,
          _id: number,
        ): Packages.mindustry.ctype.Content | null;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare abstract class WorldContext {
        public end(): void;
        public begin(): void;
        public create(
          _x: number,
          _y: number,
          _floorID: number,
          _overlayID: number,
          _wallID: number,
        ): Packages.mindustry.world.Tile;
        public resize(
          _width: number,
          _height: number,
        ): void;
        public isMap(): boolean;
        public tile(
          _index: number,
        ): Packages.mindustry.world.Tile;
        public isGenerating(): boolean;
        public getSector(): Packages.mindustry._type.Sector | null;
        public onReadBuilding(): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare class IndexedRenderer
        extends java.lang.Object
        implements Packages.arc.util.Disposable
      {
        private static vsize: number;
        private static program: Packages.arc.graphics.gl.Shader;
        private static tmpVerts: number[];
        private mesh: Packages.arc.graphics.Mesh;
        private projMatrix: Packages.arc.math.Mat;
        private transMatrix: Packages.arc.math.Mat;
        private combined: Packages.arc.math.Mat;
        private color: number;
        public resize(_sprites: number): void;
        public setColor(
          _color: Packages.arc.graphics.Color,
        ): void;
        public dispose(): void;
        public draw(
          _index: number,
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _x: number,
          _y: number,
          _w: number,
          _h: number,
          _rotation: number,
        ): void;
        public draw(
          _index: number,
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _x: number,
          _y: number,
          _w: number,
          _h: number,
        ): void;
        public render(
          _texture: Packages.arc.graphics.Texture,
        ): void;
        public setProjectionMatrix(
          _matrix: Packages.arc.math.Mat,
        ): void;
        public getTransformMatrix(): Packages.arc.math.Mat;
        private updateMatrix(): void;
        public constructor(_sprites: number);
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace editor {
      declare class MapRenderer
        extends java.lang.Object
        implements Packages.arc.util.Disposable
      {
        private static chunkSize: number;
        private chunks: Packages.mindustry.graphics.IndexedRenderer[][];
        private updates: Packages.arc.struct.IntSet;
        private delayedUpdates: Packages.arc.struct.IntSet;
        private clearEditor: Packages.arc.graphics.g2d.TextureRegion;
        private width: number;
        private height: number;
        public resize(
          _width: number,
          _height: number,
        ): void;
        public dispose(): void;
        public draw(
          _tx: number,
          _ty: number,
          _tw: number,
          _th: number,
        ): void;
        private render(_wx: number, _wy: number): void;
        private getIcon(
          _wall: Packages.mindustry.world.Block,
          _index: number,
        ): Packages.arc.graphics.g2d.TextureRegion;
        public updatePoint(_x: number, _y: number): void;
        public updateAll(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace editor {
      declare class DrawOperation extends java.lang.Object {
        public static OpType = class extends Packages.java
          .lang
          .Enum<Packages.mindustry.editor.DrawOperation.OpType> {
          public static floor: Packages.mindustry.editor.DrawOperation.OpType;
          public static block: Packages.mindustry.editor.DrawOperation.OpType;
          public static rotation: Packages.mindustry.editor.DrawOperation.OpType;
          public static team: Packages.mindustry.editor.DrawOperation.OpType;
          public static overlay: Packages.mindustry.editor.DrawOperation.OpType;
          private static $VALUES: Packages.mindustry.editor.DrawOperation.OpType[];
          public static values():
            | Packages.mindustry.editor.DrawOperation.OpType[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.mindustry.editor.DrawOperation.OpType;
        };
        TileOpStruct = class extends java.lang.Object {
          x: Packages.short;
          y: Packages.short;
          type: string;
          value: Packages.short;
          this$0: Packages.mindustry.editor.DrawOperation;
        };
        private array: Packages.arc.struct.LongSeq;
        public isEmpty(): boolean;
        private updateTile(_i: number): void;
        setTile(
          _tile: Packages.mindustry.world.Tile,
          _type: string,
          _to: Packages.short,
        ): void;
        public undo(): void;
        public redo(): void;
        public addOperation(_op: Packages.long): void;
        getTile(
          _tile: Packages.mindustry.world.Tile,
          _type: string,
        ): Packages.short;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace editor {
      declare class OperationStack extends java.lang
        .Object {
        private static maxSize: number;
        private stack: Packages.arc.struct.Seq<Packages.mindustry.editor.DrawOperation>;
        private index: number;
        public add(
          _action: Packages.mindustry.editor.DrawOperation,
        ): void;
        public clear(): void;
        public canUndo(): boolean;
        public undo(): void;
        public canRedo(): boolean;
        public redo(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace editor {
      declare class MapEditor extends java.lang.Object {
        Context = class
          extends java.lang.Object
          implements Packages.mindustry.world.WorldContext
        {
          this$0: Packages.mindustry.editor.MapEditor;
          public end(): void;
          public begin(): void;
          public create(
            _x: number,
            _y: number,
            _floorID: number,
            _overlayID: number,
            _wallID: number,
          ): Packages.mindustry.world.Tile;
          public resize(
            _width: number,
            _height: number,
          ): void;
          public tile(
            _index: number,
          ): Packages.mindustry.world.Tile;
          public isGenerating(): boolean;
        };
        public static brushSizes: number[];
        public tags: Packages.arc.struct.StringMap;
        public renderer: Packages.mindustry.editor.MapRenderer;
        private context: Packages.mindustry.editor.MapEditor.Context;
        private stack: Packages.mindustry.editor.OperationStack;
        private currentOp: Packages.mindustry.editor.DrawOperation;
        private loading: boolean;
        public brushSize: number;
        public rotation: number;
        public drawBlock: Packages.mindustry.world.Block;
        public drawTeam: Packages.mindustry.game.Team;
        public load(_r: Packages.java.lang.Runnable): void;
        private reset(): void;
        public resize(
          _width: number,
          _height: number,
          _shiftX: number,
          _shiftY: number,
        ): void;
        public createMap(
          _file: Packages.arc.files.Fi,
        ): Packages.mindustry.maps.Map;
        public width(): number;
        public isLoading(): boolean;
        public height(): number;
        public drawCircle(
          _x: number,
          _y: number,
          _drawer: Packages.arc.func.Cons<Packages.mindustry.world.Tile>,
        ): void;
        public tiles(): Packages.mindustry.world.Tiles;
        public tile(
          _x: number,
          _y: number,
        ): Packages.mindustry.world.Tile;
        public clearOp(): void;
        public drawBlocks(
          _x: number,
          _y: number,
          _tester: Packages.arc.func.Boolf<Packages.mindustry.world.Tile>,
        ): void;
        public drawBlocks(
          _x: number,
          _y: number,
          _square: boolean,
          _forceOverlay: boolean,
          _tester: Packages.arc.func.Boolf<Packages.mindustry.world.Tile>,
        ): void;
        public drawBlocks(_x: number, _y: number): void;
        hasOverlap(_x: number, _y: number): boolean;
        public drawSquare(
          _x: number,
          _y: number,
          _drawer: Packages.arc.func.Cons<Packages.mindustry.world.Tile>,
        ): void;
        public canUndo(): boolean;
        public undo(): void;
        public canRedo(): boolean;
        public redo(): void;
        public addTileOp(_data: Packages.long): void;
        public beginEdit(
          _width: number,
          _height: number,
        ): void;
        public beginEdit(
          _map: Packages.mindustry.maps.Map,
        ): void;
        public beginEdit(
          _pixmap: Packages.arc.graphics.Pixmap,
        ): void;
        public updateRenderer(): void;
        public drawBlocksReplace(
          _x: number,
          _y: number,
        ): void;
        public addCliffs(): void;
        public addFloorCliffs(): void;
        public flushOp(): void;
        private createTiles(
          _width: number,
          _height: number,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace service {
      declare class SStat extends Packages.java.lang
        .Enum<Packages.mindustry.service.SStat> {
        public static unitsDestroyed: Packages.mindustry.service.SStat;
        public static attacksWon: Packages.mindustry.service.SStat;
        public static pvpsWon: Packages.mindustry.service.SStat;
        public static timesLaunched: Packages.mindustry.service.SStat;
        public static blocksDestroyed: Packages.mindustry.service.SStat;
        public static itemsLaunched: Packages.mindustry.service.SStat;
        public static reactorsOverheated: Packages.mindustry.service.SStat;
        public static maxUnitActive: Packages.mindustry.service.SStat;
        public static unitTypesBuilt: Packages.mindustry.service.SStat;
        public static unitsBuilt: Packages.mindustry.service.SStat;
        public static bossesDefeated: Packages.mindustry.service.SStat;
        public static maxPlayersServer: Packages.mindustry.service.SStat;
        public static mapsMade: Packages.mindustry.service.SStat;
        public static mapsPublished: Packages.mindustry.service.SStat;
        public static maxWavesSurvived: Packages.mindustry.service.SStat;
        public static blocksBuilt: Packages.mindustry.service.SStat;
        public static maxProduction: Packages.mindustry.service.SStat;
        public static sectorsControlled: Packages.mindustry.service.SStat;
        public static schematicsCreated: Packages.mindustry.service.SStat;
        public static bouldersDeconstructed: Packages.mindustry.service.SStat;
        public static totalCampaignItems: Packages.mindustry.service.SStat;
        private static $VALUES: Packages.mindustry.service.SStat[];
        public add(): void;
        public add(_amount: number): void;
        public get(): number;
        public static values():
          | Packages.mindustry.service.SStat[]
          | null;
        public max(_amount: number): void;
        public static valueOf(
          _name: string,
        ): Packages.mindustry.service.SStat;
        public set(_amount: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace service {
      declare class Achievement extends Packages.java.lang
        .Enum<Packages.mindustry.service.Achievement> {
        public static kill1kEnemies: Packages.mindustry.service.Achievement;
        public static kill100kEnemies: Packages.mindustry.service.Achievement;
        public static launch100kItems: Packages.mindustry.service.Achievement;
        public static produce5kMin: Packages.mindustry.service.Achievement;
        public static produce50kMin: Packages.mindustry.service.Achievement;
        public static win10Attack: Packages.mindustry.service.Achievement;
        public static win10PvP: Packages.mindustry.service.Achievement;
        public static defeatAttack5Waves: Packages.mindustry.service.Achievement;
        public static launch30Times: Packages.mindustry.service.Achievement;
        public static captureBackground: Packages.mindustry.service.Achievement;
        public static survive100Waves: Packages.mindustry.service.Achievement;
        public static researchAll: Packages.mindustry.service.Achievement;
        public static shockWetEnemy: Packages.mindustry.service.Achievement;
        public static killEnemyPhaseWall: Packages.mindustry.service.Achievement;
        public static researchRouter: Packages.mindustry.service.Achievement;
        public static place10kBlocks: Packages.mindustry.service.Achievement;
        public static destroy1kBlocks: Packages.mindustry.service.Achievement;
        public static overheatReactor: Packages.mindustry.service.Achievement;
        public static make10maps: Packages.mindustry.service.Achievement;
        public static downloadMapWorkshop: Packages.mindustry.service.Achievement;
        public static publishMap: Packages.mindustry.service.Achievement;
        public static defeatBoss: Packages.mindustry.service.Achievement;
        public static captureAllSectors: Packages.mindustry.service.Achievement;
        public static control10Sectors: Packages.mindustry.service.Achievement;
        public static drop10kitems: Packages.mindustry.service.Achievement;
        public static powerupImpactReactor: Packages.mindustry.service.Achievement;
        public static obtainThorium: Packages.mindustry.service.Achievement;
        public static obtainTitanium: Packages.mindustry.service.Achievement;
        public static suicideBomb: Packages.mindustry.service.Achievement;
        public static buildGroundFactory: Packages.mindustry.service.Achievement;
        public static issueAttackCommand: Packages.mindustry.service.Achievement;
        public static active100Units: Packages.mindustry.service.Achievement;
        public static build1000Units: Packages.mindustry.service.Achievement;
        public static buildAllUnits: Packages.mindustry.service.Achievement;
        public static buildT5: Packages.mindustry.service.Achievement;
        public static pickupT5: Packages.mindustry.service.Achievement;
        public static active10Polys: Packages.mindustry.service.Achievement;
        public static dieExclusion: Packages.mindustry.service.Achievement;
        public static drown: Packages.mindustry.service.Achievement;
        public static fillCoreAllCampaign: Packages.mindustry.service.Achievement;
        public static hostServer10: Packages.mindustry.service.Achievement;
        public static buildMeltdownSpectre: Packages.mindustry.service.Achievement;
        public static launchItemPad: Packages.mindustry.service.Achievement;
        public static chainRouters: Packages.mindustry.service.Achievement;
        public static circleConveyor: Packages.mindustry.service.Achievement;
        public static becomeRouter: Packages.mindustry.service.Achievement;
        public static create20Schematics: Packages.mindustry.service.Achievement;
        public static create500Schematics: Packages.mindustry.service.Achievement;
        public static survive10WavesNoBlocks: Packages.mindustry.service.Achievement;
        public static captureNoBlocksBroken: Packages.mindustry.service.Achievement;
        public static useFlameAmmo: Packages.mindustry.service.Achievement;
        public static coolTurret: Packages.mindustry.service.Achievement;
        public static enablePixelation: Packages.mindustry.service.Achievement;
        public static openWiki: Packages.mindustry.service.Achievement;
        public static allTransportOneMap: Packages.mindustry.service.Achievement;
        public static buildOverdriveProjector: Packages.mindustry.service.Achievement;
        public static buildMendProjector: Packages.mindustry.service.Achievement;
        public static buildWexWater: Packages.mindustry.service.Achievement;
        public static have10mItems: Packages.mindustry.service.Achievement;
        public static killEclipseDuo: Packages.mindustry.service.Achievement;
        public static completeErekir: Packages.mindustry.service.Achievement;
        public static completeSerpulo: Packages.mindustry.service.Achievement;
        public static launchCoreSchematic: Packages.mindustry.service.Achievement;
        public static nucleusGroundZero: Packages.mindustry.service.Achievement;
        public static neoplasmWater: Packages.mindustry.service.Achievement;
        public static blastFrozenUnit: Packages.mindustry.service.Achievement;
        public static allBlocksSerpulo: Packages.mindustry.service.Achievement;
        public static allBlocksErekir: Packages.mindustry.service.Achievement;
        public static breakForceProjector: Packages.mindustry.service.Achievement;
        public static researchLogic: Packages.mindustry.service.Achievement;
        public static negative10kPower: Packages.mindustry.service.Achievement;
        public static positive100kPower: Packages.mindustry.service.Achievement;
        public static store1milPower: Packages.mindustry.service.Achievement;
        public static blastGenerator: Packages.mindustry.service.Achievement;
        public static neoplasiaExplosion: Packages.mindustry.service.Achievement;
        public static installMod: Packages.mindustry.service.Achievement;
        public static routerLanguage: Packages.mindustry.service.Achievement;
        public static joinCommunityServer: Packages.mindustry.service.Achievement;
        public static openConsole: Packages.mindustry.service.Achievement;
        public static controlTurret: Packages.mindustry.service.Achievement;
        public static dropUnitsCoreZone: Packages.mindustry.service.Achievement;
        public static destroyScatterFlare: Packages.mindustry.service.Achievement;
        public static boostUnit: Packages.mindustry.service.Achievement;
        public static boostBuildingFloor: Packages.mindustry.service.Achievement;
        public static hoverUnitLiquid: Packages.mindustry.service.Achievement;
        public static break100Boulders: Packages.mindustry.service.Achievement;
        public static break10000Boulders: Packages.mindustry.service.Achievement;
        public static shockwaveTowerUse: Packages.mindustry.service.Achievement;
        public static useAnimdustryEmoji: Packages.mindustry.service.Achievement;
        private stat: Packages.mindustry.service.SStat;
        private statGoal: number;
        private completed: boolean;
        public static all: Packages.mindustry.service.Achievement[];
        private static $VALUES: Packages.mindustry.service.Achievement[];
        public static values():
          | Packages.mindustry.service.Achievement[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.mindustry.service.Achievement;
        public complete(): void;
        public isAchieved(): boolean;
        public uncomplete(): void;
        public checkCompletion(): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace service {
      declare class GameService extends java.lang.Object {
        private tmpTiles: Packages.arc.struct.Seq<Packages.mindustry.world.Tile>;
        private blocksBuilt: Packages.arc.struct.ObjectSet<string>;
        private unitsBuilt: Packages.arc.struct.ObjectSet<string>;
        private t5s: Packages.arc.struct.ObjectSet<Packages.mindustry._type.UnitType>;
        private checked: Packages.arc.struct.IntSet;
        private allTransportSerpulo: Packages.mindustry.world.Block[];
        private allTransportErekir: Packages.mindustry.world.Block[];
        private allErekirBlocks: Packages.mindustry.world.Block[];
        private allSerpuloBlocks: Packages.mindustry.world.Block[];
        private trigger(
          _trigger: Packages.mindustry.game.EventType.Trigger,
          _ach: Packages.mindustry.service.Achievement,
        ): void;
        public enabled(): boolean;
        public init(): void;
        private save(): void;
        private registerEvents(): void;
        private checkAllBlocks(
          _ach: Packages.mindustry.service.Achievement,
          _blocks: Packages.mindustry.world.Block[],
        ): void;
        private campaign(): boolean;
        public isAchieved(_name: string): boolean;
        public completeAchievement(_name: string): void;
        public clearAchievement(_name: string): void;
        public getStat(_name: string, _def: number): number;
        public setStat(
          _name: string,
          _amount: number,
        ): void;
        public storeStats(): void;
        private checkUpdate(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace game {
      declare class Universe extends java.lang.Object {
        private netSeconds: number;
        private secondCounter: number;
        private turnCounter: number;
        private lastLoadout?: Packages.mindustry.game.Schematic;
        private lastLaunchResources: Packages.mindustry._type.ItemSeq;
        public update(): void;
        private load(): void;
        private save(): void;
        public seconds(): number;
        public updateGlobal(): void;
        public secondsf(): number;
        public turn(): number;
        public getLastLoadout(): Packages.mindustry.game.Schematic;
        public getLaunchResources(): Packages.mindustry._type.ItemSeq;
        private updatePlanet(
          _planet: Packages.mindustry._type.Planet,
        ): void;
        public runTurn(): void;
        public clearLoadoutInfo(): void;
        public updateLaunchResources(
          _stacks: Packages.mindustry._type.ItemSeq,
        ): void;
        public updateLoadout(
          _block: Packages.mindustry.world.blocks.storage.CoreBlock,
          _schem: Packages.mindustry.game.Schematic,
        ): void;
        public getLoadout(
          _core: Packages.mindustry.world.blocks.storage.CoreBlock,
        ): Packages.mindustry.game.Schematic | null;
        public updateNetSeconds(_value: number): void;
        public secondsMod(
          _mod: number,
          _scale: number,
        ): number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace core {
      declare class World extends java.lang.Object {
        private Context = class
          extends java.lang.Object
          implements Packages.mindustry.world.WorldContext
        {
          this$0: Packages.mindustry.core.World;
          public end(): void;
          public begin(): void;
          public create(
            _x: number,
            _y: number,
            _floorID: number,
            _overlayID: number,
            _wallID: number,
          ): Packages.mindustry.world.Tile;
          public resize(
            _width: number,
            _height: number,
          ): void;
          public tile(
            _index: number,
          ): Packages.mindustry.world.Tile;
          public isGenerating(): boolean;
        };
        public FilterContext = class extends Packages
          .mindustry.core.World.Context {
          map: Packages.mindustry.maps.Map;
          this$0: Packages.mindustry.core.World;
          public end(): void;
          public begin(): void;
          public create(
            _x: number,
            _y: number,
            _floorID: number,
            _overlayID: number,
            _wallID: number,
          ): Packages.mindustry.world.Tile;
          public resize(
            _width: number,
            _height: number,
          ): void;
          public tile(
            _index: number,
          ): Packages.mindustry.world.Tile;
          public isGenerating(): boolean;
          public applyFilters(): void;
          public constructor(
            _this$0: Packages.mindustry.core.World,
            _map: Packages.mindustry.maps.Map,
          );
        };
        public context: Packages.mindustry.core.World.Context;
        public tiles: Packages.mindustry.world.Tiles;
        public tileChanges: number;
        private generating: boolean;
        private invalidMap: boolean;
        private customMapLoaders: Packages.arc.struct.ObjectMap<
          Packages.mindustry.maps.Map,
          Packages.java.lang.Runnable
        >;
        public floor(
          _x: number,
          _y: number,
        ): Packages.mindustry.world.blocks.environment.Floor;
        public isAccessible(
          _x: number,
          _y: number,
        ): boolean;
        public resize(
          _width: number,
          _height: number,
        ): Packages.mindustry.world.Tiles;
        public build(
          _pos: number,
        ): Packages.mindustry.gen.Building | null;
        public build(
          _x: number,
          _y: number,
        ): Packages.mindustry.gen.Building | null;
        public width(): number;
        public static conv(_coord: number): number;
        public height(): number;
        public solid(_x: number, _y: number): boolean;
        public static raycast(
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
          _cons: Packages.arc.math.geom.Geometry.Raycaster,
        ): boolean;
        public buildWorld(
          _x: number,
          _y: number,
        ): Packages.mindustry.gen.Building | null;
        public static toTile(_coord: number): number;
        public tileWorld(
          _x: number,
          _y: number,
        ): Packages.mindustry.world.Tile | null;
        public tile(
          _x: number,
          _y: number,
        ): Packages.mindustry.world.Tile | null;
        public tile(
          _pos: number,
        ): Packages.mindustry.world.Tile | null;
        public getDarkness(_x: number, _y: number): number;
        public isGenerating(): boolean;
        public rawTile(
          _x: number,
          _y: number,
        ): Packages.mindustry.world.Tile;
        public passable(_x: number, _y: number): boolean;
        public packArray(_x: number, _y: number): number;
        public getQuadBounds(
          _in: Packages.arc.math.geom.Rect,
        ): Packages.arc.math.geom.Rect;
        public floorWorld(
          _x: number,
          _y: number,
        ): Packages.mindustry.world.blocks.environment.Floor;
        public unitWidth(): number;
        public unitHeight(): number;
        public setGenerating(_gen: boolean): void;
        public clearBuildings(): void;
        public loadMap(
          _map: Packages.mindustry.maps.Map,
        ): void;
        public loadMap(
          _map: Packages.mindustry.maps.Map,
          _checkRules: Packages.mindustry.game.Rules,
        ): void;
        public wallSolid(_x: number, _y: number): boolean;
        public addDarkness(
          _tiles: Packages.mindustry.world.Tiles,
        ): void;
        public beginMapLoad(): void;
        public endMapLoad(): void;
        public loadSector(
          _sector: Packages.mindustry._type.Sector,
          _seedOffset: number,
          _saveInfo: boolean,
        ): void;
        public loadSector(
          _sector: Packages.mindustry._type.Sector,
        ): void;
        private setSectorRules(
          _sector: Packages.mindustry._type.Sector,
          _saveInfo: boolean,
        ): void;
        public loadGenerator(
          _width: number,
          _height: number,
          _generator: Packages.arc.func.Cons<Packages.mindustry.world.Tiles>,
        ): void;
        public static raycastEach(
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
          _cons: Packages.arc.math.geom.Geometry.Raycaster,
        ): void;
        public addMapLoader(
          _map: Packages.mindustry.maps.Map,
          _loader: Packages.java.lang.Runnable,
        ): void;
        public isInvalidMap(): boolean;
        public wallSolidFull(
          _x: number,
          _y: number,
        ): boolean;
        public tileBuilding(
          _x: number,
          _y: number,
        ): Packages.mindustry.world.Tile | null;
        public static unconv(_coord: number): number;
        public filterContext(
          _map: Packages.mindustry.maps.Map,
        ): Packages.mindustry.core.World.Context;
        public getWallDarkness(
          _tile: Packages.mindustry.world.Tile,
        ): string;
        public checkMapArea(): void;
        public static raycastEachWorld(
          _x0: number,
          _y0: number,
          _x1: number,
          _y1: number,
          _cons: Packages.arc.math.geom.Geometry.Raycaster,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare class Maps extends java.lang.Object {
        public static ShuffleMode = class
          extends Packages.java.lang
            .Enum<Packages.mindustry.maps.Maps.ShuffleMode>
          implements
            Packages.mindustry.maps.Maps.MapProvider
        {
          public static none: Packages.mindustry.maps.Maps.ShuffleMode;
          public static all: Packages.mindustry.maps.Maps.ShuffleMode;
          public static custom: Packages.mindustry.maps.Maps.ShuffleMode;
          public static builtin: Packages.mindustry.maps.Maps.ShuffleMode;
          private provider: Packages.mindustry.maps.Maps.MapProvider;
          private static $VALUES: Packages.mindustry.maps.Maps.ShuffleMode[];
          public static values():
            | Packages.mindustry.maps.Maps.ShuffleMode[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.mindustry.maps.Maps.ShuffleMode;
          private static next(
            _mode: Packages.mindustry.game.Gamemode,
            _prev: Packages.mindustry.maps.Map,
            ..._mapArray: Packages.arc.struct.Seq<Packages.mindustry.maps.Map>[]
          ): Packages.mindustry.maps.Map;
          public next(
            _mode: Packages.mindustry.game.Gamemode,
            _previous: Packages.mindustry.maps.Map | null,
          ): Packages.mindustry.maps.Map;
          private static valid(
            _mode: Packages.mindustry.game.Gamemode,
            _map: Packages.mindustry.maps.Map,
          ): boolean;
        };
        public static MapProvider = class {
          public next(
            _mode: Packages.mindustry.game.Gamemode,
            _previous: Packages.mindustry.maps.Map | null,
          ): Packages.mindustry.maps.Map | null;
        };
        public static allFilterTypes: Packages.arc.func.Prov<Packages.mindustry.maps.filters.GenerateFilter>[];
        private static defaultMapNames: string[];
        private static pvpMaps: string[];
        private maps: Packages.arc.struct.Seq<Packages.mindustry.maps.Map>;
        private shuffleMode: Packages.mindustry.maps.Maps.ShuffleMode;
        private shuffler?: Packages.mindustry.maps.Maps.MapProvider;
        private nextMapOverride?: Packages.mindustry.maps.Map;
        private previewList: Packages.arc.struct.ObjectSet<Packages.mindustry.maps.Map>;
        public load(): void;
        public all(): Packages.arc.struct.Seq<Packages.mindustry.maps.Map>;
        public reload(): void;
        public loadPreviews(): void;
        public byName(
          _name: string,
        ): Packages.mindustry.maps.Map;
        public readFilters(
          _str: string,
        ): Packages.arc.struct.Seq<Packages.mindustry.maps.filters.GenerateFilter>;
        public loadInternalMap(
          _name: string,
        ): Packages.mindustry.maps.Map;
        public queueNewPreview(
          _map: Packages.mindustry.maps.Map,
        ): void;
        private findFile(
          _unsanitizedName: string,
        ): Packages.arc.files.Fi;
        private loadMap(
          _file: Packages.arc.files.Fi,
          _custom: boolean,
        ): Packages.mindustry.maps.Map;
        private writeCache(
          _map: Packages.mindustry.maps.Map,
        ): void;
        private createNewPreview(
          _map: Packages.mindustry.maps.Map,
          _failed: Packages.arc.func.Cons<Packages.java.lang.Exception>,
        ): void;
        public addDefaultOres(
          _filters: Packages.arc.struct.Seq<Packages.mindustry.maps.filters.GenerateFilter>,
        ): void;
        private readCache(
          _map: Packages.mindustry.maps.Map,
        ): void;
        public getShuffleMode(): Packages.mindustry.maps.Maps.ShuffleMode;
        public setShuffleMode(
          _mode: Packages.mindustry.maps.Maps.ShuffleMode,
        ): void;
        public setMapProvider(
          _provider: Packages.mindustry.maps.Maps.MapProvider,
        ): void;
        public setNextMapOverride(
          _nextMapOverride: Packages.mindustry.maps.Map,
        ): void;
        public getNextMap(
          _mode: Packages.mindustry.game.Gamemode,
          _previous: Packages.mindustry.maps.Map | null,
        ): Packages.mindustry.maps.Map | null;
        public customMaps(): Packages.arc.struct.Seq<Packages.mindustry.maps.Map>;
        public defaultMaps(): Packages.arc.struct.Seq<Packages.mindustry.maps.Map>;
        public saveMap(
          _baseTags: Packages.arc.struct.ObjectMap<
            string,
            string
          >,
        ): Packages.mindustry.maps.Map;
        public importMap(
          _file: Packages.arc.files.Fi,
        ): void;
        public tryCatchMapError(
          _run: Packages.arc.util.UnsafeRunnable,
        ): void;
        public removeMap(
          _map: Packages.mindustry.maps.Map,
        ): void;
        public writeWaves(
          _groups: Packages.arc.struct.Seq<Packages.mindustry.game.SpawnGroup>,
        ): string;
        public readWaves(
          _str: string,
        ): Packages.arc.struct.Seq<Packages.mindustry.game.SpawnGroup>;
        private createAllPreviews(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare class WaveSpawner extends java.lang.Object {
        private static SpawnConsumer = class {
          public accept(
            _x: number,
            _y: number,
            _shockwave: boolean,
          ): void;
        };
        private static margin: number;
        private static coreMargin: number;
        private static maxSteps: number;
        private tmpCount: number;
        private spawns: Packages.arc.struct.Seq<Packages.mindustry.world.Tile>;
        private spawning: boolean;
        private any: boolean;
        private firstSpawn: Packages.mindustry.world.Tile;
        public reset(): void;
        public getSpawns(): Packages.arc.struct.Seq<Packages.mindustry.world.Tile>;
        private eachGroundSpawn(
          _filterPos: number,
          _cons: Packages.mindustry.ai.WaveSpawner.SpawnConsumer,
        ): void;
        public eachGroundSpawn(
          _cons: Packages.arc.func.Intc2,
        ): void;
        public countSpawns(): number;
        private eachFlyerSpawn(
          _filterPos: number,
          _cons: Packages.arc.func.Floatc2,
        ): void;
        public spawnEffect(
          _unit: Packages.mindustry.gen.Unit,
          _rotation: number,
        ): void;
        public spawnEffect(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public static spawnEffect(
          _x: number,
          _y: number,
          _rotation: number,
          _u: Packages.mindustry._type.UnitType,
        ): void;
        public doShockwave(_x: number, _y: number): void;
        public getFirstSpawn(): Packages.mindustry.world.Tile | null;
        public playerNear(): boolean;
        public spawnEnemies(): void;
        public countGroundSpawns(): number;
        public countFlyerSpawns(): number;
        public isSpawning(): boolean;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare class BlockIndexer extends java.lang.Object {
        static TurretQuadtree = class extends Packages.arc
          .math.geom
          .QuadTree<Packages.mindustry.gen.Building> {
          protected newChild(
            _rect: Packages.arc.math.geom.Rect,
          ): Packages.arc.math.geom.QuadTree<Packages.mindustry.gen.Building>;
          public hitbox(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public hitbox(
            _build: Packages.arc.math.geom.QuadTree.QuadTreeObject,
          ): void;
          public constructor(
            _bounds: Packages.arc.math.geom.Rect,
          );
        };
        private static quadrantSize: number;
        private static rect: Packages.arc.math.geom.Rect;
        private static returnBool: boolean;
        private quadWidth: number;
        private quadHeight: number;
        private ores: Packages.arc.struct.IntSeq[][][];
        private damagedTiles: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>[];
        private allOres: Packages.arc.struct.ObjectIntMap<Packages.mindustry._type.Item>;
        private activeTeams: Packages.arc.struct.Seq<Packages.mindustry.game.Team>;
        private flagMap: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>[][];
        private blocksPresent: boolean[];
        private breturnArray: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
        private process(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public removeIndex(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public addIndex(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public notifyHealthChanged(
          _build: Packages.mindustry.gen.Building,
        ): void;
        public getEnemy(
          _team: Packages.mindustry.game.Team,
          _type: Packages.mindustry.world.meta.BlockFlag,
        ): Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
        public getFlagged(
          _team: Packages.mindustry.game.Team,
          _type: Packages.mindustry.world.meta.BlockFlag,
        ): Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
        private getFlagged(
          _team: Packages.mindustry.game.Team,
        ):
          | Packages.arc.struct.Seq<Packages.mindustry.gen.Building>[]
          | null;
        public eachBlock(
          _team: Packages.mindustry.game.Team,
          _rect: Packages.arc.math.geom.Rect,
          _pred: Packages.arc.func.Boolf<Packages.mindustry.gen.Building>,
          _cons: Packages.arc.func.Cons<Packages.mindustry.gen.Building>,
        ): boolean;
        public eachBlock(
          _team: Packages.mindustry.game.Team | null,
          _wx: number,
          _wy: number,
          _range: number,
          _pred: Packages.arc.func.Boolf<Packages.mindustry.gen.Building>,
          _cons: Packages.arc.func.Cons<Packages.mindustry.gen.Building>,
        ): boolean;
        public eachBlock(
          _team: Packages.mindustry.gen.Teamc,
          _range: number,
          _pred: Packages.arc.func.Boolf<Packages.mindustry.gen.Building>,
          _cons: Packages.arc.func.Cons<Packages.mindustry.gen.Building>,
        ): boolean;
        public findClosestOre(
          _xp: number,
          _yp: number,
          _item: Packages.mindustry._type.Item,
        ): Packages.mindustry.world.Tile;
        public findClosestOre(
          _unit: Packages.mindustry.gen.Unit,
          _item: Packages.mindustry._type.Item,
        ): Packages.mindustry.world.Tile;
        public hasOre(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        private clearFlags(): void;
        public allBuildings(
          _x: number,
          _y: number,
          _range: number,
          _cons: Packages.arc.func.Cons<Packages.mindustry.gen.Building>,
        ): void;
        public findTile(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _range: number,
          _pred: Packages.arc.func.Boolf<Packages.mindustry.gen.Building>,
          _usePriority: boolean,
        ): Packages.mindustry.gen.Building;
        public findTile(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _range: number,
          _pred: Packages.arc.func.Boolf<Packages.mindustry.gen.Building>,
        ): Packages.mindustry.gen.Building;
        public isBlockPresent(
          _block: Packages.mindustry.world.Block,
        ): boolean;
        public getDamaged(
          _team: Packages.mindustry.game.Team,
        ): Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
        public findClosestFlag(
          _x: number,
          _y: number,
          _team: Packages.mindustry.game.Team,
          _flag: Packages.mindustry.world.meta.BlockFlag,
        ): Packages.mindustry.gen.Building | null;
        public findEnemyTile(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _range: number,
          _pred: Packages.arc.func.Boolf<Packages.mindustry.gen.Building>,
        ): Packages.mindustry.gen.Building;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare class Pathfinder
        extends java.lang.Object
        implements Packages.java.lang.Runnable
      {
        public static Flowfield = class extends java.lang
          .Object {
          protected refreshRate: number;
          protected team: Packages.mindustry.game.Team;
          protected cost: Packages.mindustry.ai.Pathfinder.PathCost;
          protected hasComplete: boolean;
          protected dirty: boolean;
          public weights: number[];
          public searches: number[];
          public completeWeights: number[];
          frontier: Packages.arc.struct.IntQueue;
          targets: Packages.arc.struct.IntSeq;
          search: number;
          lastUpdateTime: Packages.long;
          initialized: boolean;
          setup(_length: number): void;
          protected passable(_pos: number): boolean;
          public hasCompleteWeights(): boolean;
          public updateTargetPositions(): void;
          protected getPositions(
            _out: Packages.arc.struct.IntSeq,
          ): void;
          public constructor();
        };
        public static PathCost = class {
          public getCost(
            _team: number,
            _tile: number,
          ): number;
        };
        PathTileStruct = class extends java.lang.Object {
          health: number;
          team: number;
          solid: boolean;
          liquid: boolean;
          legSolid: boolean;
          nearLiquid: boolean;
          nearGround: boolean;
          nearSolid: boolean;
          nearLegSolid: boolean;
          deep: boolean;
          damages: boolean;
          allDeep: boolean;
          teamPassable: boolean;
          this$0: Packages.mindustry.ai.Pathfinder;
        };
        public static PositionTarget = class extends Packages
          .mindustry.ai.Pathfinder.Flowfield {
          public position: Packages.arc.math.geom.Position;
          public getPositions(
            _out: Packages.arc.struct.IntSeq,
          ): void;
          public constructor(
            _position: Packages.arc.math.geom.Position,
          );
        };
        public static EnemyCoreField = class extends Packages
          .mindustry.ai.Pathfinder.Flowfield {
          protected getPositions(
            _out: Packages.arc.struct.IntSeq,
          ): void;
          public constructor();
        };
        private static maxUpdate: Packages.long;
        private static updateFPS: number;
        private static updateInterval: number;
        static wwidth: number;
        static wheight: number;
        static impassable: number;
        public static fieldCore: number;
        public static fieldTypes: Packages.arc.struct.Seq<
          Packages.arc.func.Prov<Packages.mindustry.ai.Pathfinder.Flowfield>
        >;
        public static costGround: number;
        public static costLegs: number;
        public static costNaval: number;
        public static costTypes: Packages.arc.struct.Seq<Packages.mindustry.ai.Pathfinder.PathCost>;
        tiles: number[];
        cache: Packages.mindustry.ai.Pathfinder.Flowfield[][][];
        threadList: Packages.arc.struct.Seq<Packages.mindustry.ai.Pathfinder.Flowfield>;
        mainList: Packages.arc.struct.Seq<Packages.mindustry.ai.Pathfinder.Flowfield>;
        queue: Packages.arc.util.TaskQueue;
        thread?: Packages.java.lang.Thread;
        tmpArray: Packages.arc.struct.IntSeq;
        public run(): void;
        public get(_x: number, _y: number): number;
        private start(): void;
        public getField(
          _team: Packages.mindustry.game.Team,
          _costType: number,
          _fieldType: number,
        ): Packages.mindustry.ai.Pathfinder.Flowfield;
        private stop(): void;
        private clearCache(): void;
        public updateTile(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        private updateTargets(
          _path: Packages.mindustry.ai.Pathfinder.Flowfield,
        ): void;
        private updateFrontier(
          _path: Packages.mindustry.ai.Pathfinder.Flowfield,
          _nsToRun: Packages.long,
        ): void;
        private registerPath(
          _path: Packages.mindustry.ai.Pathfinder.Flowfield,
        ): void;
        public packTile(
          _tile: Packages.mindustry.world.Tile,
        ): number;
        private preloadPath(
          _path: Packages.mindustry.ai.Pathfinder.Flowfield,
        ): void;
        public getTargetTile(
          _tile: Packages.mindustry.world.Tile,
          _path: Packages.mindustry.ai.Pathfinder.Flowfield,
        ): Packages.mindustry.world.Tile | null;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare class PathfindQueue extends java.lang.Object {
        private static CAPACITY_RATIO_LOW: number;
        private static CAPACITY_RATIO_HI: number;
        public queue: number[];
        public weights: number[];
        public size: number;
        public add(_e: number, _weight: number): boolean;
        public clear(): void;
        public empty(): boolean;
        public poll(): number;
        public peek(): number;
        private growToSize(_minCapacity: number): void;
        private siftUp(
          _k: number,
          _x: number,
          _weight: number,
        ): void;
        private siftDown(
          _k: number,
          _x: number,
          _weight: number,
        ): void;
        public constructor();
        public constructor(_initialCapacity: number);
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare class ControlPathfinder
        extends java.lang.Object
        implements Packages.java.lang.Runnable
      {
        static Cluster = class extends java.lang.Object {
          portals: Packages.arc.struct.IntSeq[];
          portalConnections: Packages.arc.struct.LongSeq[][];
        };
        static PathRequest = class extends java.lang
          .Object {
          unit: Packages.mindustry.gen.Unit;
          destination: number;
          team: number;
          costId: number;
          resultPath: Packages.arc.struct.IntSeq;
          costs?: Packages.arc.struct.IntFloatMap;
          cameFrom?: Packages.arc.struct.IntIntMap;
          frontier?: Packages.mindustry.ai.PathfindQueue;
          lastUpdateId: Packages.long;
          notFound: boolean;
          invalidated: boolean;
          oldCache?: Packages.mindustry.ai.ControlPathfinder.FieldCache;
          lastRaycastResult: boolean;
          lastRaycastTile: number;
          lastWorldUpdate: number;
          lastTile: number;
          lastTargetTile?: Packages.mindustry.world.Tile;
        };
        static FieldCache = class extends java.lang.Object {
          cost: Packages.mindustry.ai.Pathfinder.PathCost;
          costId: number;
          team: number;
          goalPos: number;
          frontier: Packages.arc.struct.IntQueue;
          fields: Packages.arc.struct.IntMap<number[]>;
          mapKey: Packages.long;
          lastUpdateId: Packages.long;
        };
        static NodeIndexStruct = class extends java.lang
          .Object {
          cluster: number;
          dir: number;
          portal: number;
        };
        static IntraEdgeStruct = class extends java.lang
          .Object {
          dir: number;
          portal: number;
          cost: number;
        };
        private static wallImpassableCap: number;
        private static solidCap: number;
        public static showDebug: boolean;
        public static costGround: Packages.mindustry.ai.Pathfinder.PathCost;
        public static costHover: Packages.mindustry.ai.Pathfinder.PathCost;
        public static costLegs: Packages.mindustry.ai.Pathfinder.PathCost;
        public static costNaval: Packages.mindustry.ai.Pathfinder.PathCost;
        public static costIdGround: number;
        public static costIdHover: number;
        public static costIdLegs: number;
        public static costIdNaval: number;
        public static costTypes: Packages.arc.struct.Seq<Packages.mindustry.ai.Pathfinder.PathCost>;
        private static maxUpdate: Packages.long;
        private static updateStepInterval: number;
        private static updateFPS: number;
        private static updateInterval: number;
        private static invalidateCheckInterval: number;
        static clusterSize: number;
        static offsets: number[];
        static moveDirs: number[];
        static nextOffsets: number[];
        clusters: Packages.mindustry.ai.ControlPathfinder.Cluster[][][];
        cwidth: number;
        cheight: number;
        usedEdges: Packages.arc.struct.IntSet;
        queue: Packages.arc.util.TaskQueue;
        unitRequests: Packages.arc.struct.ObjectMap<
          Packages.mindustry.gen.Unit,
          Packages.mindustry.ai.ControlPathfinder.PathRequest
        >;
        threadPathRequests: Packages.arc.struct.Seq<Packages.mindustry.ai.ControlPathfinder.PathRequest>;
        fields: Packages.arc.struct.LongMap<Packages.mindustry.ai.ControlPathfinder.FieldCache>;
        fieldList: Packages.arc.struct.Seq<Packages.mindustry.ai.ControlPathfinder.FieldCache>;
        innerCosts: Packages.arc.struct.IntFloatMap;
        innerFrontier: Packages.mindustry.ai.PathfindQueue;
        clustersToUpdate: Packages.arc.struct.IntSet;
        clustersToInnerUpdate: Packages.arc.struct.IntSet;
        invalidRequests: Packages.arc.struct.ObjectSet<Packages.mindustry.ai.ControlPathfinder.PathRequest>;
        thread?: Packages.java.lang.Thread;
        public run(): void;
        private start(): void;
        private stop(): void;
        private static solid(
          _team: number,
          _type: Packages.mindustry.ai.Pathfinder.PathCost,
          _tilePos: number,
          _checkWall: boolean,
        ): boolean;
        private static solid(
          _team: number,
          _type: Packages.mindustry.ai.Pathfinder.PathCost,
          _x: number,
          _y: number,
        ): boolean;
        private static raycastRect(
          _startX: number,
          _startY: number,
          _endX: number,
          _endY: number,
          _team: number,
          _type: Packages.mindustry.ai.Pathfinder.PathCost,
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
          _rectSize: number,
        ): boolean;
        private static raycast(
          _team: number,
          _type: Packages.mindustry.ai.Pathfinder.PathCost,
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
        ): boolean;
        private static overlap(
          _team: number,
          _type: Packages.mindustry.ai.Pathfinder.PathCost,
          _x: number,
          _y: number,
          _startX: number,
          _startY: number,
          _endX: number,
          _endY: number,
          _rectSize: number,
        ): boolean;
        private static passable(
          _team: number,
          _cost: Packages.mindustry.ai.Pathfinder.PathCost,
          _pos: number,
        ): boolean;
        private static cost(
          _team: number,
          _cost: Packages.mindustry.ai.Pathfinder.PathCost,
          _tilePos: number,
        ): number;
        private getCost(
          _cache: Packages.mindustry.ai.ControlPathfinder.FieldCache,
          _x: number,
          _y: number,
          _requeue: boolean,
        ): number;
        private static avoid(
          _team: number,
          _type: Packages.mindustry.ai.Pathfinder.PathCost,
          _tilePos: number,
        ): boolean;
        public getPathPosition(
          _unit: Packages.mindustry.gen.Unit,
          _pathId: number,
          _destination: Packages.arc.math.geom.Vec2,
          _out: Packages.arc.math.geom.Vec2,
          _noResultFound: boolean[] | null,
        ): boolean;
        public getPathPosition(
          _unit: Packages.mindustry.gen.Unit,
          _pathId: number,
          _destination: Packages.arc.math.geom.Vec2,
          _out: Packages.arc.math.geom.Vec2,
        ): boolean;
        public getPathPosition(
          _unit: Packages.mindustry.gen.Unit,
          _destination: Packages.arc.math.geom.Vec2,
          _mainDestination: Packages.arc.math.geom.Vec2,
          _out: Packages.arc.math.geom.Vec2,
          _noResultFound: boolean[] | null,
        ): boolean;
        public getPathPosition(
          _unit: Packages.mindustry.gen.Unit,
          _destination: Packages.arc.math.geom.Vec2,
          _out: Packages.arc.math.geom.Vec2,
          _noResultFound: boolean[] | null,
        ): boolean;
        public static isNearObstacle(
          _unit: Packages.mindustry.gen.Unit,
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
        ): boolean;
        public static raycastFastAvoid(
          _team: number,
          _type: Packages.mindustry.ai.Pathfinder.PathCost,
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
        ): number;
        getCluster(
          _team: number,
          _pathCost: number,
          _cx: number,
          _cy: number,
        ): Packages.mindustry.ai.ControlPathfinder.Cluster | null;
        getCluster(
          _team: number,
          _pathCost: number,
          _clusterIndex: number,
        ): Packages.mindustry.ai.ControlPathfinder.Cluster | null;
        getCreateCluster(
          _team: number,
          _pathCost: number,
          _cx: number,
          _cy: number,
        ): Packages.mindustry.ai.ControlPathfinder.Cluster;
        getCreateCluster(
          _team: number,
          _pathCost: number,
          _clusterIndex: number,
        ): Packages.mindustry.ai.ControlPathfinder.Cluster;
        updateCluster(
          _team: number,
          _pathCost: number,
          _cx: number,
          _cy: number,
        ): Packages.mindustry.ai.ControlPathfinder.Cluster;
        private idToCost(
          _costId: number,
        ): Packages.mindustry.ai.Pathfinder.PathCost;
        updateInnerEdges(
          _team: number,
          _cost: number,
          _cx: number,
          _cy: number,
          _cluster: Packages.mindustry.ai.ControlPathfinder.Cluster,
        ): void;
        updateInnerEdges(
          _team: number,
          _cost: Packages.mindustry.ai.Pathfinder.PathCost,
          _cx: number,
          _cy: number,
          _cluster: Packages.mindustry.ai.ControlPathfinder.Cluster,
        ): void;
        innerAstar(
          _team: number,
          _cost: Packages.mindustry.ai.Pathfinder.PathCost,
          _minX: number,
          _minY: number,
          _maxX: number,
          _maxY: number,
          _startPos: number,
          _goalPos: number,
          _goalX1: number,
          _goalY1: number,
          _goalX2: number,
          _goalY2: number,
        ): number;
        private static tcost(
          _team: number,
          _cost: Packages.mindustry.ai.Pathfinder.PathCost,
          _tilePos: number,
        ): number;
        private static tileCost(
          _team: number,
          _type: Packages.mindustry.ai.Pathfinder.PathCost,
          _a: number,
          _b: number,
        ): number;
        private static heuristic(
          _a: number,
          _b: number,
        ): number;
        makeNodeIndex(
          _cx: number,
          _cy: number,
          _dir: number,
          _portal: number,
        ): number;
        private checkEdges(
          _request: Packages.mindustry.ai.ControlPathfinder.PathRequest,
          _team: number,
          _pathCost: number,
          _current: number,
          _goal: number,
          _cx: number,
          _cy: number,
          _connections: Packages.arc.struct.LongSeq,
        ): void;
        private clusterNodeHeuristic(
          _team: number,
          _pathCost: number,
          _nodeA: number,
          _nodeB: number,
        ): number;
        private addFlowCluster(
          _cache: Packages.mindustry.ai.ControlPathfinder.FieldCache,
          _cx: number,
          _cy: number,
          _addingFrontier: boolean,
        ): void;
        private addFlowCluster(
          _cache: Packages.mindustry.ai.ControlPathfinder.FieldCache,
          _cluster: number,
          _addingFrontier: boolean,
        ): void;
        private findClosestNode(
          _team: number,
          _pathCost: number,
          _tileX: number,
          _tileY: number,
        ): number;
        clusterAstar(
          _request: Packages.mindustry.ai.ControlPathfinder.PathRequest,
          _pathCost: number,
          _startNodeIndex: number,
          _endNodeIndex: number,
        ): Packages.arc.struct.IntSeq | null;
        private initializePathRequest(
          _request: Packages.mindustry.ai.ControlPathfinder.PathRequest,
          _team: number,
          _costId: number,
          _unitX: number,
          _unitY: number,
          _goalX: number,
          _goalY: number,
        ): void;
        private static nearPassable(
          _team: number,
          _cost: Packages.mindustry.ai.Pathfinder.PathCost,
          _pos: number,
        ): boolean;
        private clusterChanged(
          _team: number,
          _pathCost: number,
          _cx: number,
          _cy: number,
        ): void;
        private updateFields(
          _cache: Packages.mindustry.ai.ControlPathfinder.FieldCache,
          _nsToRun: Packages.long,
        ): void;
        private recalculatePath(
          _request: Packages.mindustry.ai.ControlPathfinder.PathRequest,
        ): void;
        private updateClustersInner(
          _clusterIndex: number,
        ): void;
        private updateClustersComplete(
          _clusterIndex: number,
        ): void;
        portalToVec(
          _cluster: Packages.mindustry.ai.ControlPathfinder.Cluster,
          _cx: number,
          _cy: number,
          _direction: number,
          _portalIndex: number,
          _out: Packages.arc.math.geom.Vec2,
        ): void;
        queueClusterUpdate(_cx: number, _cy: number): void;
        public nextTargetId(): number;
        public static raycastFast(
          _team: number,
          _type: Packages.mindustry.ai.Pathfinder.PathCost,
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
        ): number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace game {
      declare class FogControl
        extends java.lang.Object
        implements
          Packages.mindustry.io.SaveFileReader.CustomChunk
      {
        static FogData = class extends java.lang.Object {
          read: Packages.arc.struct.Bits;
          write: Packages.arc.struct.Bits;
          staticData: Packages.arc.struct.Bits;
          lastDynamicMs: Packages.long;
          dynamicUpdated: boolean;
        };
        StaticFogThread = class extends Packages.java.lang
          .Thread {
          this$0: Packages.mindustry.game.FogControl;
          public run(): void;
        };
        DynamicFogThread = class extends Packages.java.lang
          .Thread {
          cleared: Packages.arc.struct.Bits;
          this$0: Packages.mindustry.game.FogControl;
          public run(): void;
        };
        FogEventStruct = class extends java.lang.Object {
          x: number;
          y: number;
          radius: number;
          team: number;
          this$0: Packages.mindustry.game.FogControl;
        };
        private static ww: number;
        private static wh: number;
        private static dynamicUpdateInterval: number;
        private static notifyStatic: any;
        private static notifyDynamic: any;
        private fog?: Packages.mindustry.game.FogControl.FogData[];
        private staticEvents: Packages.arc.struct.LongSeq;
        private dynamicEventQueue: Packages.arc.struct.LongSeq;
        private unitEventQueue: Packages.arc.struct.LongSeq;
        private dynamicEvents: Packages.arc.struct.LongSeq;
        private staticFogThread?: Packages.java.lang.Thread;
        private dynamicFogThread?: Packages.java.lang.Thread;
        private justLoaded: boolean;
        private loadedStatic: boolean;
        public update(): void;
        data(
          _team: Packages.mindustry.game.Team,
        ): Packages.mindustry.game.FogControl.FogData | null;
        public write(
          _stream: Packages.java.io.DataOutput,
        ): void;
        public read(
          _stream: Packages.java.io.DataInput,
        ): void;
        stop(): void;
        static circle(
          _arr: Packages.arc.struct.Bits,
          _x: number,
          _y: number,
          _radius: number,
        ): void;
        static hline(
          _arr: Packages.arc.struct.Bits,
          _x1: number,
          _x2: number,
          _y: number,
        ): void;
        public isVisible(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
        ): boolean;
        public isDiscovered(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
        ): boolean;
        public isVisibleTile(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
        ): boolean;
        public resetFog(): void;
        public getDiscovered(
          _team: Packages.mindustry.game.Team,
        ): Packages.arc.struct.Bits | null;
        pushEvent(
          _event: Packages.long,
          _skipRender: boolean,
        ): void;
        pushStaticBlocks(_initial: boolean): void;
        updateStatic(): void;
        updateDynamic(
          _cleared: Packages.arc.struct.Bits,
        ): void;
        public forceUpdate(
          _team: Packages.mindustry.game.Team,
          _build: Packages.mindustry.gen.Building,
        ): void;
        public shouldWrite(): boolean;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace audio {
      declare class SoundControl extends java.lang.Object {
        protected static SoundData = class extends java.lang
          .Object {
          volume: number;
          total: number;
          sum: Packages.arc.math.geom.Vec2;
          soundID: number;
          curVolume: number;
        };
        public finTime: number;
        public foutTime: number;
        public musicInterval: number;
        public musicChance: number;
        public musicWaveChance: number;
        public ambientMusic: Packages.arc.struct.Seq<Packages.arc.audio.Music>;
        public darkMusic: Packages.arc.struct.Seq<Packages.arc.audio.Music>;
        public bossMusic: Packages.arc.struct.Seq<Packages.arc.audio.Music>;
        protected lastRandomPlayed: Packages.arc.audio.Music;
        protected timer: Packages.arc.util.Interval;
        protected lastPlayed: Packages.long;
        protected current?: Packages.arc.audio.Music;
        protected fade: number;
        protected silenced: boolean;
        protected uiBus: Packages.arc.audio.AudioBus;
        protected wasPlaying: boolean;
        protected filter: Packages.arc.audio.AudioFilter;
        protected sounds: Packages.arc.struct.ObjectMap<
          Packages.arc.audio.Sound,
          Packages.mindustry.audio.SoundControl.SoundData
        >;
        public update(): void;
        public stop(): void;
        public loop(
          _sound: Packages.arc.audio.Sound,
          _pos: Packages.arc.math.geom.Position,
          _volume: number,
        ): void;
        public loop(
          _sound: Packages.arc.audio.Sound,
          _volume: number,
        ): void;
        protected reload(): void;
        protected play(
          _music: Packages.arc.audio.Music | null,
        ): void;
        protected setupFilters(): void;
        protected silence(): void;
        public playRandom(): void;
        protected updateLoops(): void;
        protected playOnce(
          _music: Packages.arc.audio.Music,
        ): void;
        protected isDark(): boolean;
        protected shouldPlay(): boolean;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace fragments {
        declare class BlockInventoryFragment extends java
          .lang.Object {
          private static holdWithdraw: number;
          private static holdShrink: number;
          table: Packages.arc.scene.ui.layout.Table;
          holdTime: number;
          emptyTime: number;
          holding: boolean;
          held: boolean;
          shrinkHoldTimes: number[];
          lastItem: Packages.mindustry._type.Item;
          private round(_f: number): string;
          public build(
            _parent: Packages.arc.scene.Group,
          ): void;
          public hide(): void;
          private rebuild(_actions: boolean): void;
          private takeItem(_requested: number): void;
          private itemImage(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _text: Packages.arc.func.Prov<Packages.java.lang.CharSequence>,
          ): Packages.arc.scene.Element;
          private updateTablePosition(): void;
          public showFor(
            _t: Packages.mindustry.gen.Building,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace fragments {
        declare class BlockConfigFragment extends java.lang
          .Object {
          table: Packages.arc.scene.ui.layout.Table;
          selected: Packages.mindustry.gen.Building;
          public build(
            _parent: Packages.arc.scene.Group,
          ): void;
          public isShown(): boolean;
          public getSelected(): Packages.mindustry.gen.Building;
          public hideConfig(): void;
          public forceHide(): void;
          public showConfig(
            _tile: Packages.mindustry.gen.Building,
          ): void;
          public hasConfigMouse(): boolean;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace input {
      declare abstract class InputHandler
        extends java.lang.Object
        implements
          Packages.arc.input.GestureDetector
            .GestureListener,
          Packages.arc.input.InputProcessor
      {
        static PlaceLine = class extends java.lang.Object {
          public x: number;
          public y: number;
          public rotation: number;
          public last: boolean;
        };
        static queuedCommands: Packages.arc.struct.ObjectMap<
          Packages.arc.math.geom.Vec2,
          Packages.arc.struct.Seq<Packages.mindustry.gen.Unit>
        >;
        static playerSelectRange: number;
        static removed: Packages.arc.struct.IntSeq;
        static maxLength: number;
        static r1: Packages.arc.math.geom.Rect;
        static r2: Packages.arc.math.geom.Rect;
        static tmpUnits: Packages.arc.struct.Seq<Packages.mindustry.gen.Unit>;
        static controlGroupBindings: Packages.mindustry.input.Binding[];
        public logicCutscene: boolean;
        public logicCamPan: Packages.arc.math.geom.Vec2;
        public logicCamSpeed: number;
        public logicCutsceneZoom: number;
        public inputLocks: Packages.arc.struct.Seq<Packages.arc.func.Boolp>;
        public controlInterval: Packages.arc.util.Interval;
        public block?: Packages.mindustry.world.Block;
        public overrideLineRotation: boolean;
        public rotation: number;
        public droppingItem: boolean;
        public itemDepositCooldown: number;
        public uiGroup: Packages.arc.scene.Group;
        public isBuilding: boolean;
        public buildWasAutoPaused: boolean;
        public wasShooting: boolean;
        public controlledType?: Packages.mindustry._type.UnitType;
        public recentRespawnTimer: number;
        public lastSchematic?: Packages.mindustry.game.Schematic;
        public detector: Packages.arc.input.GestureDetector;
        public line: Packages.mindustry.input.InputHandler.PlaceLine;
        public resultplan: Packages.mindustry.entities.units.BuildPlan;
        public bplan: Packages.mindustry.entities.units.BuildPlan;
        public linePlans: Packages.arc.struct.Seq<Packages.mindustry.entities.units.BuildPlan>;
        public selectPlans: Packages.arc.struct.Seq<Packages.mindustry.entities.units.BuildPlan>;
        public selectedUnits: Packages.arc.struct.Seq<Packages.mindustry.gen.Unit>;
        public commandBuildings: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
        public commandMode: boolean;
        public commandRect: boolean;
        public tappedOne: boolean;
        public commandRectX: number;
        public commandRectY: number;
        public controlGroups: Packages.arc.struct.IntSeq[];
        private plansOut: Packages.arc.struct.Seq<Packages.mindustry.entities.units.BuildPlan>;
        private playerPlanTree: Packages.arc.math.geom.QuadTree<Packages.mindustry.entities.units.BuildPlan>;
        public inv: Packages.mindustry.ui.fragments.BlockInventoryFragment;
        public config: Packages.mindustry.ui.fragments.BlockConfigFragment;
        private group: Packages.arc.scene.ui.layout.WidgetGroup;
        private allSelectLines: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>;
        public add(): void;
        public remove(): void;
        public update(): void;
        protected drawSelection(
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
          _maxLength: number,
          _col1: Packages.arc.graphics.Color,
          _col2: Packages.arc.graphics.Color,
        ): void;
        protected drawSelection(
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
          _maxLength: number,
        ): void;
        public mouseAngle(_x: number, _y: number): number;
        iterateLine(
          _startX: number,
          _startY: number,
          _endX: number,
          _endY: number,
          _cons: Packages.arc.func.Cons<Packages.mindustry.input.InputHandler.PlaceLine>,
        ): void;
        public static tileConfig(
          _player: Packages.mindustry.gen.Player | null,
          _build: Packages.mindustry.gen.Building,
          _value: any | null,
        ): void;
        tileX(_cursorX: number): number;
        tileY(_cursorY: number): number;
        public validPlace(
          _x: number,
          _y: number,
          _type: Packages.mindustry.world.Block,
          _rotation: number,
        ): boolean;
        public validPlace(
          _x: number,
          _y: number,
          _type: Packages.mindustry.world.Block,
          _rotation: number,
          _ignore: Packages.mindustry.entities.units.BuildPlan,
        ): boolean;
        public drawArrow(
          _block: Packages.mindustry.world.Block,
          _x: number,
          _y: number,
          _rotation: number,
        ): void;
        public drawArrow(
          _block: Packages.mindustry.world.Block,
          _x: number,
          _y: number,
          _rotation: number,
          _valid: boolean,
        ): void;
        public breakBlock(_x: number, _y: number): void;
        protected drawPlan(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _valid: boolean,
        ): void;
        protected drawPlan(
          _x: number,
          _y: number,
          _block: Packages.mindustry.world.Block,
          _rotation: number,
        ): void;
        protected drawPlan(
          _plan: Packages.mindustry.entities.units.BuildPlan,
        ): void;
        public locked(): boolean;
        public static rotateBlock(
          _player: Packages.mindustry.gen.Player | null,
          _build: Packages.mindustry.gen.Building,
          _direction: boolean,
        ): void;
        canMine(
          _tile: Packages.mindustry.world.Tile,
        ): boolean;
        public canShoot(): boolean;
        public static transferItemTo(
          _unit: Packages.mindustry.gen.Unit | null,
          _item: Packages.mindustry._type.Item,
          _amount: number,
          _x: number,
          _y: number,
          _build: Packages.mindustry.gen.Building,
        ): void;
        public validBreak(_x: number, _y: number): boolean;
        public tryDropPayload(): void;
        public static payloadDropped(
          _unit: Packages.mindustry.gen.Unit,
          _x: number,
          _y: number,
        ): void;
        public static pickedUnitPayload(
          _unit: Packages.mindustry.gen.Unit,
          _target: Packages.mindustry.gen.Unit,
        ): void;
        public static pickedBuildPayload(
          _unit: Packages.mindustry.gen.Unit,
          _build: Packages.mindustry.gen.Building,
          _onGround: boolean,
        ): void;
        public static unitEnteredPayload(
          _unit: Packages.mindustry.gen.Unit,
          _build: Packages.mindustry.gen.Building,
        ): void;
        public static commandUnits(
          _player: Packages.mindustry.gen.Player,
          _unitIds: number[],
          _buildTarget: Packages.mindustry.gen.Building | null,
          _unitTarget: Packages.mindustry.gen.Unit | null,
          _posTarget: Packages.arc.math.geom.Vec2 | null,
          _queueCommand: boolean,
          _finalBatch: boolean,
        ): void;
        public updateState(): void;
        public checkUnit(): void;
        public drawBottom(): void;
        public drawTop(): void;
        public static removeQueueBlock(
          _x: number,
          _y: number,
          _breaking: boolean,
        ): void;
        public allPlans(): Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>;
        public static createItemTransfer(
          _item: Packages.mindustry._type.Item,
          _amount: number,
          _x: number,
          _y: number,
          _to: Packages.arc.math.geom.Position,
          _done: Packages.java.lang.Runnable,
        ): void;
        public static commandBuilding(
          _player: Packages.mindustry.gen.Player,
          _buildings: number[],
          _target: Packages.arc.math.geom.Vec2,
        ): void;
        public static takeItems(
          _build: Packages.mindustry.gen.Building,
          _item: Packages.mindustry._type.Item,
          _amount: number,
          _to: Packages.mindustry.gen.Unit,
        ): void;
        public static dropItem(
          _player: Packages.mindustry.gen.Player,
          _angle: number,
        ): void;
        public static unitControl(
          _player: Packages.mindustry.gen.Player,
          _unit: Packages.mindustry.gen.Unit | null,
        ): void;
        public static requestUnitPayload(
          _player: Packages.mindustry.gen.Player,
          _target: Packages.mindustry.gen.Unit,
        ): void;
        public static requestBuildPayload(
          _player: Packages.mindustry.gen.Player,
          _build: Packages.mindustry.gen.Building,
        ): void;
        public static requestDropPayload(
          _player: Packages.mindustry.gen.Player,
          _x: number,
          _y: number,
        ): void;
        public selectedCommandUnits(
          _x: number,
          _y: number,
          _w: number,
          _h: number,
          _predicate: Packages.arc.func.Boolf<Packages.mindustry.gen.Unit>,
        ): Packages.arc.struct.Seq<Packages.mindustry.gen.Unit>;
        public selectedCommandUnits(
          _x: number,
          _y: number,
          _w: number,
          _h: number,
        ): Packages.arc.struct.Seq<Packages.mindustry.gen.Unit>;
        public multiUnitSelect(): boolean;
        public selectedCommandUnit(
          _x: number,
          _y: number,
        ): Packages.mindustry.gen.Unit | null;
        public commandTap(
          _screenX: number,
          _screenY: number,
        ): void;
        public commandTap(
          _screenX: number,
          _screenY: number,
          _queue: boolean,
        ): void;
        public selectedEnemyUnit(
          _x: number,
          _y: number,
        ): Packages.mindustry.gen.Unit | null;
        public drawCommand(
          _sel: Packages.mindustry.gen.Unit,
        ): void;
        public drawBreaking(_x: number, _y: number): void;
        public drawBreaking(
          _plan: Packages.mindustry.entities.units.BuildPlan,
        ): void;
        public drawSelected(
          _x: number,
          _y: number,
          _block: Packages.mindustry.world.Block,
          _color: Packages.arc.graphics.Color,
        ): void;
        protected schemOriginX(): number;
        protected schemOriginY(): number;
        rawTileX(): number;
        rawTileY(): number;
        protected getPlan(
          _x: number,
          _y: number,
        ): Packages.mindustry.entities.units.BuildPlan | null;
        protected getPlan(
          _x: number,
          _y: number,
          _size: number,
          _skip: Packages.mindustry.entities.units.BuildPlan,
        ): Packages.mindustry.entities.units.BuildPlan | null;
        protected drawBreakSelection(
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
          _maxLength: number,
        ): void;
        protected drawBreakSelection(
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
          _maxLength: number,
          _useSelectPlans: boolean,
        ): void;
        protected drawBreakSelection(
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
        ): void;
        protected drawOverPlan(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _valid: boolean,
        ): void;
        protected drawOverPlan(
          _plan: Packages.mindustry.entities.units.BuildPlan,
        ): void;
        protected removeSelection(
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
          _flush: boolean,
        ): void;
        protected removeSelection(
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
          _flush: boolean,
          _maxLength: number,
        ): void;
        protected removeSelection(
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
          _maxLength: number,
        ): void;
        protected removeSelection(
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
        ): void;
        public tryBreakBlock(_x: number, _y: number): void;
        public static deletePlans(
          _player: Packages.mindustry.gen.Player,
          _positions: number[],
        ): void;
        public getMouseX(): number;
        public getMouseY(): number;
        protected updateLine(
          _x1: number,
          _y1: number,
        ): void;
        protected updateLine(
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
        ): void;
        canTapPlayer(_x: number, _y: number): boolean;
        public selectedBlock(): boolean;
        public isPlacing(): boolean;
        public buildPlacementUI(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public buildUI(
          _group: Packages.arc.scene.Group,
        ): void;
        public onConfigurable(): boolean;
        public isDroppingItem(): boolean;
        public static transferInventory(
          _player: Packages.mindustry.gen.Player,
          _build: Packages.mindustry.gen.Building,
        ): void;
        public static transferItemEffect(
          _item: Packages.mindustry._type.Item,
          _x: number,
          _y: number,
          _to: Packages.mindustry.gen.Itemsc,
        ): void;
        public static transferItemToUnit(
          _item: Packages.mindustry._type.Item,
          _x: number,
          _y: number,
          _to: Packages.mindustry.gen.Itemsc,
        ): void;
        public static setItem(
          _build: Packages.mindustry.gen.Building,
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): void;
        public static clearItems(
          _build: Packages.mindustry.gen.Building,
        ): void;
        public static setUnitCommand(
          _player: Packages.mindustry.gen.Player,
          _unitIds: number[],
          _command: Packages.mindustry.ai.UnitCommand,
        ): void;
        public static setUnitStance(
          _player: Packages.mindustry.gen.Player,
          _unitIds: number[],
          _stance: Packages.mindustry.ai.UnitStance,
        ): void;
        public static requestItem(
          _player: Packages.mindustry.gen.Player,
          _build: Packages.mindustry.gen.Building,
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): void;
        public static tileTap(
          _player: Packages.mindustry.gen.Player | null,
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public static buildingControlSelect(
          _player: Packages.mindustry.gen.Player,
          _build: Packages.mindustry.gen.Building,
        ): void;
        public static unitBuildingControlSelect(
          _unit: Packages.mindustry.gen.Unit,
          _build: Packages.mindustry.gen.Building,
        ): void;
        public static unitClear(
          _player: Packages.mindustry.gen.Player,
        ): void;
        public addLock(
          _lock: Packages.arc.func.Boolp,
        ): void;
        public isUsingSchematic(): boolean;
        public tryPickupPayload(): void;
        public selectUnitsRect(): void;
        public selectTypedUnits(): void;
        public tapCommandUnit(): void;
        public drawCommanded(): void;
        public drawOverSelect(): void;
        public drawOverlapCheck(
          _block: Packages.mindustry.world.Block,
          _cursorX: number,
          _cursorY: number,
          _valid: boolean,
        ): void;
        public planMatches(
          _plan: Packages.mindustry.entities.units.BuildPlan,
        ): boolean;
        public useSchematic(
          _schem: Packages.mindustry.game.Schematic,
        ): void;
        protected showSchematicSave(): void;
        public rotatePlans(
          _plans: Packages.arc.struct.Seq<Packages.mindustry.entities.units.BuildPlan>,
          _direction: number,
        ): void;
        public flipPlans(
          _plans: Packages.arc.struct.Seq<Packages.mindustry.entities.units.BuildPlan>,
          _x: boolean,
        ): void;
        protected drawRebuildSelection(
          _x: number,
          _y: number,
          _x2: number,
          _y2: number,
        ): void;
        protected flushSelectPlans(
          _plans: Packages.arc.struct.Seq<Packages.mindustry.entities.units.BuildPlan>,
        ): void;
        protected flushPlansReverse(
          _plans: Packages.arc.struct.Seq<Packages.mindustry.entities.units.BuildPlan>,
        ): void;
        protected flushPlans(
          _plans: Packages.arc.struct.Seq<Packages.mindustry.entities.units.BuildPlan>,
        ): void;
        checkConfigTap(): boolean;
        tileTapped(
          _build: Packages.mindustry.gen.Building | null,
        ): boolean;
        tryTapPlayer(_x: number, _y: number): boolean;
        tryBeginMine(
          _tile: Packages.mindustry.world.Tile,
        ): boolean;
        tryStopMine(
          _tile: Packages.mindustry.world.Tile,
        ): boolean;
        tryStopMine(): boolean;
        tryRepairDerelict(
          _selected: Packages.mindustry.world.Tile,
        ): boolean;
        tileAt(
          _x: number,
          _y: number,
        ): Packages.mindustry.world.Tile;
        public panCamera(
          _position: Packages.arc.math.geom.Vec2,
        ): void;
        public isBreaking(): boolean;
        public isRebuildSelecting(): boolean;
        public selectedUnit(): Packages.mindustry.gen.Unit | null;
        public selectedControlBuild(): Packages.mindustry.gen.Building | null;
        public canDropItem(): boolean;
        public tryDropItems(
          _build: Packages.mindustry.gen.Building | null,
          _x: number,
          _y: number,
        ): void;
        public rebuildArea(
          _x: number,
          _y: number,
          _x2: number,
          _y2: number,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace game {
      declare class AttackIndicators extends java.lang
        .Object {
        IndicatorStruct = class extends java.lang.Object {
          pos: number;
          time: number;
          this$0: Packages.mindustry.game.AttackIndicators;
        };
        private static duration: number;
        private indicators: Packages.arc.struct.LongSeq;
        private posToIndex: Packages.arc.struct.IntIntMap;
        public add(_x: number, _y: number): void;
        public update(): void;
        public clear(): void;
        public list(): Packages.arc.struct.LongSeq;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace net {
      declare class WorldReloader extends java.lang.Object {
        players: Packages.arc.struct.Seq<Packages.mindustry.gen.Player>;
        wasServer: boolean;
        began: boolean;
        public end(): void;
        public begin(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace core {
      declare class Control
        extends java.lang.Object
        implements
          Packages.arc.assets.Loadable,
          Packages.arc.ApplicationListener
      {
        public saves: Packages.mindustry.game.Saves;
        public sound: Packages.mindustry.audio.SoundControl;
        public input: Packages.mindustry.input.InputHandler;
        public indicators: Packages.mindustry.game.AttackIndicators;
        private timer: Packages.arc.util.Interval;
        private hiscore: boolean;
        private wasPaused: boolean;
        private backgroundPaused: boolean;
        private toBePlaced: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
        public update(): void;
        public init(): void;
        public resume(): void;
        public dispose(): void;
        public setInput(
          _newInput: Packages.mindustry.input.InputHandler,
        ): void;
        public pause(): void;
        public loadAsync(): void;
        private placeLandBuild(
          _build: Packages.mindustry.gen.Building,
        ): void;
        createPlayer(): void;
        public playMap(
          _map: Packages.mindustry.maps.Map,
          _rules: Packages.mindustry.game.Rules,
          _playtest: boolean,
        ): void;
        public playMap(
          _map: Packages.mindustry.maps.Map,
          _rules: Packages.mindustry.game.Rules,
        ): void;
        playSector(
          _origin: Packages.mindustry._type.Sector | null,
          _sector: Packages.mindustry._type.Sector,
          _reloader: Packages.mindustry.net.WorldReloader,
        ): void;
        public playSector(
          _origin: Packages.mindustry._type.Sector | null,
          _sector: Packages.mindustry._type.Sector,
        ): void;
        public playSector(
          _sector: Packages.mindustry._type.Sector,
        ): void;
        public playNewSector(
          _origin: Packages.mindustry._type.Sector | null,
          _sector: Packages.mindustry._type.Sector,
          _reloader: Packages.mindustry.net.WorldReloader,
        ): void;
        private forcePlaceAll(): void;
        public checkAutoUnlocks(): void;
        public isHighScore(): boolean;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace core {
      declare class Logic
        extends java.lang.Object
        implements Packages.arc.ApplicationListener
      {
        public update(): void;
        public reset(): void;
        public dispose(): void;
        public play(): void;
        public static researched(
          _content: Packages.mindustry.ctype.Content,
        ): void;
        public static gameOver(
          _winner: Packages.mindustry.game.Team,
        ): void;
        public runWave(): void;
        public static sectorCapture(): void;
        protected updateWeather(): void;
        public isWaitingWave(): boolean;
        private checkGameState(): void;
        private checkOverlappingPlans(
          _team: Packages.mindustry.game.Team,
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public skipWave(): void;
        public static updateGameOver(
          _winner: Packages.mindustry.game.Team,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare class FloorRenderer extends java.lang.Object {
        FloorRenderBatch = class extends Packages.arc
          .graphics.g2d.Batch {
          this$0: Packages.mindustry.graphics.FloorRenderer;
          public flush(): void;
          protected draw(
            _region: Packages.arc.graphics.g2d.TextureRegion,
            _x: number,
            _y: number,
            _originX: number,
            _originY: number,
            _width: number,
            _height: number,
            _rotation: number,
          ): void;
          protected draw(
            _texture: Packages.arc.graphics.Texture,
            _spriteVertices: number[],
            _offset: number,
            _count: number,
          ): void;
          public setShader(
            _shader: Packages.arc.graphics.gl.Shader,
            _apply: boolean,
          ): void;
        };
        private static attributes: Packages.arc.graphics.VertexAttribute[];
        private static chunksize: number;
        private static chunkunits: number;
        private static vertexSize: number;
        private static spriteSize: number;
        private static maxSprites: number;
        private static pad: number;
        private static dynamic: boolean;
        private vertices: number[];
        private indices: Packages.short[];
        private vidx: number;
        private batch: Packages.mindustry.graphics.FloorRenderer.FloorRenderBatch;
        private shader: Packages.arc.graphics.gl.Shader;
        private texture: Packages.arc.graphics.Texture;
        private error: Packages.arc.graphics.g2d.TextureRegion;
        private cache: Packages.arc.graphics.Mesh[][][];
        private drawnLayerSet: Packages.arc.struct.IntSet;
        private recacheSet: Packages.arc.struct.IntSet;
        private drawnLayers: Packages.arc.struct.IntSeq;
        private used: Packages.arc.struct.ObjectSet<Packages.mindustry.graphics.CacheLayer>;
        public endc(): void;
        public beginDraw(): void;
        public endDraw(): void;
        public recacheTile(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public beginc(): void;
        public drawLayer(
          _layer: Packages.mindustry.graphics.CacheLayer,
        ): void;
        public checkChanges(): void;
        public drawFloor(): void;
        private cacheChunk(_cx: number, _cy: number): void;
        private cacheChunkLayer(
          _cx: number,
          _cy: number,
          _layer: Packages.mindustry.graphics.CacheLayer,
        ): Packages.arc.graphics.Mesh;
        public clearTiles(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare class BlockRenderer extends java.lang.Object {
        static BlockQuadtree = class extends Packages.arc
          .math.geom
          .QuadTree<Packages.mindustry.world.Tile> {
          protected newChild(
            _rect: Packages.arc.math.geom.Rect,
          ): Packages.arc.math.geom.QuadTree<Packages.mindustry.world.Tile>;
          public hitbox(
            _tile: Packages.mindustry.world.Tile,
          ): void;
          public hitbox(
            _tile: Packages.arc.math.geom.QuadTree.QuadTreeObject,
          ): void;
          public constructor(
            _bounds: Packages.arc.math.geom.Rect,
          );
        };
        static FloorQuadtree = class extends Packages.arc
          .math.geom
          .QuadTree<Packages.mindustry.world.Tile> {
          protected newChild(
            _rect: Packages.arc.math.geom.Rect,
          ): Packages.arc.math.geom.QuadTree<Packages.mindustry.world.Tile>;
          public hitbox(
            _tile: Packages.mindustry.world.Tile,
          ): void;
          public hitbox(
            _tile: Packages.arc.math.geom.QuadTree.QuadTreeObject,
          ): void;
          public constructor(
            _bounds: Packages.arc.math.geom.Rect,
          );
        };
        public static crackRegions: number;
        public static maxCrackSize: number;
        public static drawQuadtreeDebug: boolean;
        public static shadowColor: Packages.arc.graphics.Color;
        public static blendShadowColor: Packages.arc.graphics.Color;
        private static initialRequests: number;
        public floor: Packages.mindustry.graphics.FloorRenderer;
        public cracks: Packages.arc.graphics.g2d.TextureRegion[][];
        private tileview: Packages.arc.struct.Seq<Packages.mindustry.world.Tile>;
        private lightview: Packages.arc.struct.Seq<Packages.mindustry.world.Tile>;
        private updateFloors: Packages.arc.struct.Seq<Packages.mindustry.world.blocks.environment.Floor.UpdateRenderState>;
        private hadMapLimit: boolean;
        private lastCamX: number;
        private lastCamY: number;
        private lastRangeX: number;
        private lastRangeY: number;
        private brokenFade: number;
        private shadows: Packages.arc.graphics.gl.FrameBuffer;
        private dark: Packages.arc.graphics.gl.FrameBuffer;
        private outArray2: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
        private shadowEvents: Packages.arc.struct.Seq<Packages.mindustry.world.Tile>;
        private darkEvents: Packages.arc.struct.IntSet;
        private procLinks: Packages.arc.struct.IntSet;
        private procLights: Packages.arc.struct.IntSet;
        private blockTree: Packages.mindustry.graphics.BlockRenderer.BlockQuadtree;
        private floorTree: Packages.mindustry.graphics.BlockRenderer.FloorQuadtree;
        public processBlocks(): void;
        public updateShadow(
          _build: Packages.mindustry.gen.Building,
        ): void;
        public recacheWall(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public removeFloorIndex(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public invalidateTile(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public addFloorIndex(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public drawBlocks(): void;
        public updateDarkness(): void;
        public checkChanges(): void;
        public drawShadows(): void;
        public drawDarkness(): void;
        indexFloor(
          _tile: Packages.mindustry.world.Tile,
        ): boolean;
        indexBlock(
          _tile: Packages.mindustry.world.Tile,
        ): boolean;
        drawTree(
          _tree: Packages.arc.math.geom.QuadTree<Packages.mindustry.world.Tile>,
        ): void;
        public drawDestroyed(): void;
        recordIndex(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare class FogRenderer extends java.lang.Object {
        private staticFog: Packages.arc.graphics.gl.FrameBuffer;
        private dynamicFog: Packages.arc.graphics.gl.FrameBuffer;
        private events: Packages.arc.struct.LongSeq;
        private rect: Packages.arc.math.geom.Rect;
        private lastTeam?: Packages.mindustry.game.Team;
        poly(_x: number, _y: number, _rad: number): void;
        public handleEvent(_event: Packages.long): void;
        public drawFog(): void;
        public copyFromCpu(): void;
        renderEvent(_e: Packages.long): void;
        public getStaticTexture(): Packages.arc.graphics.Texture;
        public getDynamicTexture(): Packages.arc.graphics.Texture;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare class MinimapRenderer extends java.lang
        .Object {
        private static baseSize: number;
        private static updateInterval: number;
        private units: Packages.arc.struct.Seq<Packages.mindustry.gen.Unit>;
        private pixmap: Packages.arc.graphics.Pixmap;
        private texture: Packages.arc.graphics.Texture;
        private region: Packages.arc.graphics.g2d.TextureRegion;
        private rect: Packages.arc.math.geom.Rect;
        private zoom: number;
        private lastX: number;
        private lastY: number;
        private lastW: number;
        private lastH: number;
        private lastScl: number;
        private worldSpace: boolean;
        private updates: Packages.arc.struct.IntSet;
        private updateCounter: number;
        public update(): void;
        public update(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public reset(): void;
        public getRegion(): Packages.arc.graphics.g2d.TextureRegion | null;
        public getPixmap(): Packages.arc.graphics.Pixmap;
        public getTexture(): Packages.arc.graphics.Texture | null;
        private realBlock(
          _tile: Packages.mindustry.world.Tile,
        ): Packages.mindustry.world.Block;
        public updateAll(): void;
        public setZoom(_amount: number): void;
        public updateUnitArray(): void;
        public drawLabel(
          _x: number,
          _y: number,
          _text: string,
          _color: Packages.arc.graphics.Color,
        ): void;
        public drawSpawns(): void;
        private colorFor(
          _tile: Packages.mindustry.world.Tile,
        ): number;
        updatePixel(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public zoomBy(_amount: number): void;
        public getZoom(): number;
        public drawEntities(
          _x: number,
          _y: number,
          _w: number,
          _h: number,
          _scaling: number,
          _fullView: boolean,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare class OverlayRenderer extends java.lang
        .Object {
        private static CoreEdge = class extends java.lang
          .Object {
          x1: number;
          y1: number;
          x2: number;
          y2: number;
          t1: Packages.mindustry.game.Team;
          t2: Packages.mindustry.game.Team;
          displayed(): Packages.mindustry.game.Team | null;
          public constructor(
            _x1: number,
            _y1: number,
            _x2: number,
            _y2: number,
            _t1: Packages.mindustry.game.Team,
            _t2: Packages.mindustry.game.Team,
          );
        };
        private static indicatorLength: number;
        private static spawnerMargin: number;
        private static rect: Packages.arc.math.geom.Rect;
        private buildFade: number;
        private unitFade: number;
        private lastSelect: Packages.mindustry.entities.Sized;
        private cedges: Packages.arc.struct.Seq<Packages.mindustry.graphics.OverlayRenderer.CoreEdge>;
        private updatedCores: boolean;
        public checkApplySelection(
          _u: Packages.mindustry.gen.Unit,
        ): void;
        public drawBottom(): void;
        public drawTop(): void;
        private updateCoreEdges(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare class LightRenderer extends java.lang.Object {
        static CircleLight = class extends java.lang
          .Object {
          x: number;
          y: number;
          color: number;
          radius: number;
          public set(
            _x: number,
            _y: number,
            _color: number,
            _radius: number,
          ): void;
        };
        private static scaling: number;
        private vertices: number[];
        private buffer: Packages.arc.graphics.gl.FrameBuffer;
        private lights: Packages.arc.struct.Seq<Packages.java.lang.Runnable>;
        private circles: Packages.arc.struct.Seq<Packages.mindustry.graphics.LightRenderer.CircleLight>;
        private circleIndex: number;
        private circleRegion: Packages.arc.graphics.g2d.TextureRegion;
        public add(
          _x: number,
          _y: number,
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _rotation: number,
          _color: Packages.arc.graphics.Color,
          _opacity: number,
        ): void;
        public add(
          _x: number,
          _y: number,
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _color: Packages.arc.graphics.Color,
          _opacity: number,
        ): void;
        public add(
          _x: number,
          _y: number,
          _radius: number,
          _color: Packages.arc.graphics.Color,
          _opacity: number,
        ): void;
        public add(_run: Packages.java.lang.Runnable): void;
        public line(
          _x: number,
          _y: number,
          _x2: number,
          _y2: number,
          _stroke: number,
          _tint: Packages.arc.graphics.Color,
          _alpha: number,
        ): void;
        public enabled(): boolean;
        public draw(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare class Pixelator
        extends java.lang.Object
        implements Packages.arc.util.Disposable
      {
        private buffer: Packages.arc.graphics.gl.FrameBuffer;
        private px: number;
        private py: number;
        private pre: number;
        public register(): void;
        public enabled(): boolean;
        public dispose(): void;
        public drawPixelate(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare class CubemapMesh
        extends java.lang.Object
        implements Packages.arc.util.Disposable
      {
        private static vertices: number[];
        private mesh: Packages.arc.graphics.Mesh;
        private shader: Packages.arc.graphics.gl.Shader;
        private map: Packages.arc.graphics.Cubemap;
        public dispose(): void;
        public render(
          _projection: Packages.arc.math.geom.Mat3D,
        ): void;
        public setCubemap(
          _map: Packages.arc.graphics.Cubemap,
        ): void;
        public constructor(
          _map: Packages.arc.graphics.Cubemap,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare namespace g3d {
        declare class PlanetRenderer
          extends java.lang.Object
          implements Packages.arc.util.Disposable
        {
          public static PlanetInterfaceRenderer = class {
            public renderProjections(
              _planet: Packages.mindustry._type.Planet,
            ): void;
            public renderSectors(
              _planet: Packages.mindustry._type.Planet,
            ): void;
          };
          public static outlineRad: number;
          public static camLength: number;
          public static outlineColor: Packages.arc.graphics.Color;
          public static hoverColor: Packages.arc.graphics.Color;
          public static borderColor: Packages.arc.graphics.Color;
          public static shadowColor: Packages.arc.graphics.Color;
          public cam: Packages.arc.graphics.g3d.Camera3D;
          public batch: Packages.arc.graphics.g3d.VertexBatch3D;
          public projector: Packages.arc.graphics.g3d.PlaneBatch3D;
          public mat: Packages.arc.math.geom.Mat3D;
          public bloom: Packages.arc.graphics.g2d.Bloom;
          public atmosphere: Packages.arc.graphics.Mesh;
          public skybox: Packages.mindustry.graphics.CubemapMesh;
          public fill(
            _sector: Packages.mindustry._type.Sector,
            _color: Packages.arc.graphics.Color,
            _offset: number,
          ): void;
          public dispose(): void;
          public drawSelection(
            _sector: Packages.mindustry._type.Sector,
            _alpha: number,
          ): void;
          public drawSelection(
            _sector: Packages.mindustry._type.Sector,
            _color: Packages.arc.graphics.Color,
            _stroke: number,
            _length: number,
          ): void;
          public render(
            _params: Packages.mindustry.graphics.g3d.PlanetParams,
          ): void;
          public setPlane(
            _sector: Packages.mindustry._type.Sector,
          ): void;
          public renderPlanet(
            _planet: Packages.mindustry._type.Planet,
            _params: Packages.mindustry.graphics.g3d.PlanetParams,
          ): void;
          public renderTransparent(
            _planet: Packages.mindustry._type.Planet,
            _params: Packages.mindustry.graphics.g3d.PlanetParams,
          ): void;
          public renderOrbit(
            _planet: Packages.mindustry._type.Planet,
            _params: Packages.mindustry.graphics.g3d.PlanetParams,
          ): void;
          public drawPlane(
            _sector: Packages.mindustry._type.Sector,
            _run: Packages.java.lang.Runnable,
          ): void;
          public renderSectors(
            _planet: Packages.mindustry._type.Planet,
            _params: Packages.mindustry.graphics.g3d.PlanetParams,
          ): void;
          public drawBorders(
            _sector: Packages.mindustry._type.Sector,
            _base: Packages.arc.graphics.Color,
            _alpha: number,
          ): void;
          public drawArc(
            _planet: Packages.mindustry._type.Planet,
            _a: Packages.arc.math.geom.Vec3,
            _b: Packages.arc.math.geom.Vec3,
          ): void;
          public drawArc(
            _planet: Packages.mindustry._type.Planet,
            _a: Packages.arc.math.geom.Vec3,
            _b: Packages.arc.math.geom.Vec3,
            _from: Packages.arc.graphics.Color,
            _to: Packages.arc.graphics.Color,
            _length: number,
            _timeScale: number,
            _pointCount: number,
          ): void;
          public drawArc(
            _planet: Packages.mindustry._type.Planet,
            _a: Packages.arc.math.geom.Vec3,
            _b: Packages.arc.math.geom.Vec3,
            _from: Packages.arc.graphics.Color,
            _to: Packages.arc.graphics.Color,
            _length: number,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace core {
      declare class Renderer
        extends java.lang.Object
        implements Packages.arc.ApplicationListener
      {
        public static EnvRenderer = class extends java.lang
          .Object {
          public env: number;
          public renderer: Packages.java.lang.Runnable;
          public constructor(
            _env: number,
            _renderer: Packages.java.lang.Runnable,
          );
        };
        public static laserOpacity: number;
        public static bridgeOpacity: number;
        public blocks: Packages.mindustry.graphics.BlockRenderer;
        public fog: Packages.mindustry.graphics.FogRenderer;
        public minimap: Packages.mindustry.graphics.MinimapRenderer;
        public overlays: Packages.mindustry.graphics.OverlayRenderer;
        public lights: Packages.mindustry.graphics.LightRenderer;
        public pixelator: Packages.mindustry.graphics.Pixelator;
        public planets: Packages.mindustry.graphics.g3d.PlanetRenderer;
        public bloom?: Packages.arc.graphics.g2d.Bloom;
        public backgroundBuffer?: Packages.arc.graphics.gl.FrameBuffer;
        public effectBuffer: Packages.arc.graphics.gl.FrameBuffer;
        public animateShields: boolean;
        public drawWeather: boolean;
        public drawStatus: boolean;
        public enableEffects: boolean;
        public drawDisplays: boolean;
        public drawLight: boolean;
        public pixelate: boolean;
        public weatherAlpha: number;
        public minZoom: number;
        public maxZoom: number;
        public envRenderers: Packages.arc.struct.Seq<Packages.mindustry.core.Renderer.EnvRenderer>;
        public customBackgrounds: Packages.arc.struct.ObjectMap<
          string,
          Packages.java.lang.Runnable
        >;
        public bubbles: Packages.arc.graphics.g2d.TextureRegion[];
        public splashes: Packages.arc.graphics.g2d.TextureRegion[];
        public fluidFrames: Packages.arc.graphics.g2d.TextureRegion[][];
        private landCore?: Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        private launchCoreType?: Packages.mindustry.world.blocks.storage.CoreBlock;
        private clearColor: Packages.arc.graphics.Color;
        private targetscale: number;
        private camerascale: number;
        private landTime: number;
        private landPTimer: number;
        private shakeIntensity: number;
        private shakeReduction: number;
        private shakeTime: number;
        private launching: boolean;
        private camShakeOffset: Packages.arc.math.geom.Vec2;
        public update(): void;
        public init(): void;
        public resume(): void;
        public setScale(_scl: number): void;
        public dispose(): void;
        public getScale(): number;
        public draw(): void;
        protected drawBackground(): void;
        public shake(
          _intensity: number,
          _duration: number,
        ): void;
        public getLandPTimer(): number;
        public setLandPTimer(_landPTimer: number): void;
        public getLandTime(): number;
        public isLaunching(): boolean;
        public getLandTimeIn(): number;
        public getDisplayScale(): number;
        public minScale(): number;
        public isCutscene(): boolean;
        public takeMapScreenshot(): void;
        public showLanding(): void;
        public showLanding(
          _landCore: Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild,
        ): void;
        setupBloom(): void;
        public loadFluidFrames(): void;
        public maxScale(): number;
        public clampScale(): void;
        public showLaunch(
          _coreType: Packages.mindustry.world.blocks.storage.CoreBlock,
        ): void;
        public showLaunch(
          _landCore: Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild,
          _coreType: Packages.mindustry.world.blocks.storage.CoreBlock,
        ): void;
        public addEnvRenderer(
          _mask: number,
          _render: Packages.java.lang.Runnable,
        ): void;
        public addCustomBackground(
          _name: string,
          _render: Packages.java.lang.Runnable,
        ): void;
        public getFluidFrames():
          | Packages.arc.graphics.g2d.TextureRegion[][]
          | null;
        public updateAllDarkness(): void;
        public landScale(): number;
        public toggleBloom(_enabled: boolean): void;
        public scaleCamera(_amount: number): void;
        public getLaunchCoreType(): Packages.mindustry.world.blocks.storage.CoreBlock;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare class MenuRenderer
        extends java.lang.Object
        implements Packages.arc.util.Disposable
      {
        private static darkness: number;
        private width: number;
        private height: number;
        private cacheFloor: number;
        private cacheWall: number;
        private camera: Packages.arc.graphics.Camera;
        private mat: Packages.arc.math.Mat;
        private shadows: Packages.arc.graphics.gl.FrameBuffer;
        private batch: Packages.arc.graphics.g2d.CacheBatch;
        private time: number;
        private flyerRot: number;
        private flyerType: Packages.mindustry._type.UnitType;
        private cache(): void;
        private generate(): void;
        public dispose(): void;
        public render(): void;
        private flyers(
          _cons: Packages.arc.func.Floatc2,
        ): void;
        private drawFlyers(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare class MobileButton extends Packages.arc.scene
        .ui.ImageButton {
        public constructor(
          _icon: Packages.arc.scene.style.Drawable,
          _text: string,
          _listener: Packages.java.lang.Runnable,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace fragments {
        declare class MenuFragment extends java.lang
          .Object {
          public static MenuButton = class extends java.lang
            .Object {
            public icon: Packages.arc.scene.style.Drawable;
            public text: string;
            public runnable: Packages.java.lang.Runnable;
            public submenu?: Packages.mindustry.ui.fragments.MenuFragment.MenuButton[];
            public constructor(
              _text: string,
              _icon: Packages.arc.scene.style.Drawable,
              _runnable: Packages.java.lang.Runnable,
              ..._submenu: Packages.mindustry.ui.fragments.MenuFragment.MenuButton[]
            );
            public constructor(
              _text: string,
              _icon: Packages.arc.scene.style.Drawable,
              _runnable: Packages.java.lang.Runnable,
            );
          };
          private container: Packages.arc.scene.ui.layout.Table;
          private submenu: Packages.arc.scene.ui.layout.Table;
          private currentMenu: Packages.arc.scene.ui.Button;
          private renderer: Packages.mindustry.graphics.MenuRenderer;
          private customButtons: Packages.arc.struct.Seq<Packages.mindustry.ui.fragments.MenuFragment.MenuButton>;
          public build(
            _parent: Packages.arc.scene.Group,
          ): void;
          private buttons(
            _t: Packages.arc.scene.ui.layout.Table,
            ..._buttons: Packages.mindustry.ui.fragments.MenuFragment.MenuButton[]
          ): void;
          public addButton(
            _button: Packages.mindustry.ui.fragments.MenuFragment.MenuButton,
          ): void;
          public addButton(
            _text: string,
            _callback: Packages.java.lang.Runnable,
          ): void;
          public addButton(
            _text: string,
            _icon: Packages.arc.scene.style.Drawable,
            _callback: Packages.java.lang.Runnable,
          ): void;
          private fadeOutMenu(): void;
          private fadeInMenu(): void;
          private checkPlay(
            _run: Packages.java.lang.Runnable,
          ): void;
          private buildDesktop(): void;
          private buildMobile(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare class ItemImage extends Packages.arc.scene.ui
        .layout.Stack {
        public constructor(
          _stack: Packages.mindustry._type.PayloadStack,
        );
        public constructor(
          _stack: Packages.mindustry._type.ItemStack,
        );
        public constructor(
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _amount: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace fragments {
        declare class PlacementFragment extends java.lang
          .Object {
          rowWidth: number;
          public currentCategory: Packages.mindustry._type.Category;
          returnArray: Packages.arc.struct.Seq<Packages.mindustry.world.Block>;
          returnArray2: Packages.arc.struct.Seq<Packages.mindustry.world.Block>;
          returnCatArray: Packages.arc.struct.Seq<Packages.mindustry._type.Category>;
          categoryEmpty: boolean[];
          selectedBlocks: Packages.arc.struct.ObjectMap<
            Packages.mindustry._type.Category,
            Packages.mindustry.world.Block
          >;
          scrollPositions: Packages.arc.struct.ObjectFloatMap<Packages.mindustry._type.Category>;
          menuHoverBlock?: Packages.mindustry.world.Block;
          lastFlowBuild?: Packages.mindustry.gen.Building;
          nextFlowBuild?: Packages.mindustry.gen.Building;
          lastDisplayState?: any;
          lastTeam?: Packages.mindustry.game.Team;
          wasHovered: boolean;
          blockTable: Packages.arc.scene.ui.layout.Table;
          toggler: Packages.arc.scene.ui.layout.Table;
          topTable: Packages.arc.scene.ui.layout.Table;
          blockCatTable: Packages.arc.scene.ui.layout.Table;
          commandTable: Packages.arc.scene.ui.layout.Table;
          mainStack: Packages.arc.scene.ui.layout.Stack;
          blockPane: Packages.arc.scene.ui.ScrollPane;
          rebuildCommand: Packages.java.lang.Runnable;
          blockSelectEnd: boolean;
          wasCommandMode: boolean;
          blockSelectSeq: number;
          blockSelectSeqMillis: Packages.long;
          blockSelect: Packages.mindustry.input.Binding[];
          public build(
            _parent: Packages.arc.scene.Group,
          ): void;
          hovered(): Packages.mindustry.ui.Displayable | null;
          public hover(): Packages.mindustry.ui.Displayable;
          public rebuild(): void;
          unlocked(
            _block: Packages.mindustry.world.Block,
          ): boolean;
          getCategories(): Packages.arc.struct.Seq<Packages.mindustry._type.Category>;
          getUnlockedByCategory(
            _cat: Packages.mindustry._type.Category,
          ): Packages.arc.struct.Seq<Packages.mindustry.world.Block>;
          getSelectedBlock(
            _cat: Packages.mindustry._type.Category,
          ): Packages.mindustry.world.Block;
          getByCategory(
            _cat: Packages.mindustry._type.Category,
          ): Packages.arc.struct.Seq<Packages.mindustry.world.Block>;
          gridUpdate(
            _input: Packages.mindustry.input.InputHandler,
          ): boolean;
          hasInfoBox(): boolean;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare class CoreItemsDisplay extends Packages.arc
        .scene.ui.layout.Table {
        private usedItems: Packages.arc.struct.ObjectSet<Packages.mindustry._type.Item>;
        private core: Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        rebuild(): void;
        public resetUsed(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare class IntFormat extends java.lang.Object {
        private builder: Packages.java.lang.StringBuilder;
        private text: string;
        private lastValue: number;
        private lastValue2: number;
        private converter: Packages.arc.func.Func<
          number,
          string
        >;
        public get(
          _value1: number,
          _value2: number,
        ): Packages.java.lang.CharSequence;
        public get(
          _value: number,
        ): Packages.java.lang.CharSequence;
        public constructor(_text: string);
        public constructor(
          _text: string,
          _converter: Packages.arc.func.Func<
            number,
            string
          >,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace fragments {
        declare namespace HudFragment {
          declare class SideBar extends Packages.arc.scene
            .Element {
            public amount: Packages.arc.func.Floatp;
            public flip: boolean;
            public flash: Packages.arc.func.Boolp;
            last: number;
            blink: number;
            value: number;
            this$0: Packages.mindustry.ui.fragments.HudFragment;
            public draw(): void;
            drawInner(
              _color: Packages.arc.graphics.Color,
              _fract: number,
            ): void;
            public constructor(
              _this$0: Packages.mindustry.ui.fragments.HudFragment,
              _amount: Packages.arc.func.Floatp,
              _flash: Packages.arc.func.Boolp,
              _flip: boolean,
            );
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace fragments {
        declare class HudFragment extends java.lang.Object {
          private static dsize: number;
          private static pauseHeight: number;
          public blockfrag: Packages.mindustry.ui.fragments.PlacementFragment;
          public shown: boolean;
          private flip: Packages.arc.scene.ui.ImageButton;
          private coreItems: Packages.mindustry.ui.CoreItemsDisplay;
          private hudText: string;
          private showHudText: boolean;
          private lastUnlockTable: Packages.arc.scene.ui.layout.Table;
          private lastUnlockLayout: Packages.arc.scene.ui.layout.Table;
          private lastToast: Packages.long;
          public build(
            _parent: Packages.arc.scene.Group,
          ): void;
          public showUnlock(
            _content: Packages.mindustry.ctype.UnlockableContent,
          ): void;
          public showToast(
            _icon: Packages.arc.scene.style.Drawable,
            _text: string,
          ): void;
          public showToast(_text: string): void;
          public showToast(
            _icon: Packages.arc.scene.style.Drawable,
            _size: number,
            _text: string,
          ): void;
          public showLaunch(): void;
          private scheduleToast(
            _run: Packages.java.lang.Runnable,
          ): void;
          private canSkipWave(): boolean;
          private addInfoTable(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public static setPlayerTeamEditor(
            _player: Packages.mindustry.gen.Player,
            _team: Packages.mindustry.game.Team,
          ): void;
          private makeStatusTable(): Packages.arc.scene.ui.layout.Table;
          private toggleMenus(): void;
          public setHudText(_text: string): void;
          public toggleHudText(_shown: boolean): void;
          public hasToast(): boolean;
          public showLand(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace fragments {
        declare class ChatFragment extends Packages.arc
          .scene.ui.layout.Table {
          private static ChatMode = class extends Packages
            .java.lang
            .Enum<Packages.mindustry.ui.fragments.ChatFragment.ChatMode> {
            public static normal: Packages.mindustry.ui.fragments.ChatFragment.ChatMode;
            public static team: Packages.mindustry.ui.fragments.ChatFragment.ChatMode;
            public static admin: Packages.mindustry.ui.fragments.ChatFragment.ChatMode;
            public prefix: string;
            public valid: Packages.arc.func.Boolp;
            public static all: Packages.mindustry.ui.fragments.ChatFragment.ChatMode[];
            private static $VALUES: Packages.mindustry.ui.fragments.ChatFragment.ChatMode[];
            public static values():
              | Packages.mindustry.ui.fragments.ChatFragment.ChatMode[]
              | null;
            public static valueOf(
              _name: string,
            ): Packages.mindustry.ui.fragments.ChatFragment.ChatMode;
            public next(): Packages.mindustry.ui.fragments.ChatFragment.ChatMode;
            public isValid(): boolean;
            public normalizedPrefix(): string;
          };
          private static messagesShown: number;
          private messages: Packages.arc.struct.Seq<string>;
          private fadetime: number;
          private chatfield: Packages.arc.scene.ui.TextField;
          private fieldlabel: Packages.arc.scene.ui.Label;
          private mode: Packages.mindustry.ui.fragments.ChatFragment.ChatMode;
          private font: Packages.arc.graphics.g2d.Font;
          private layout: Packages.arc.graphics.g2d.GlyphLayout;
          private offsetx: number;
          private offsety: number;
          private fontoffsetx: number;
          private chatspace: number;
          private shadowColor: Packages.arc.graphics.Color;
          private textspacing: number;
          private history: Packages.arc.struct.Seq<string>;
          private historyPos: number;
          private scrollPos: number;
          private setup(): void;
          public build(
            _parent: Packages.arc.scene.Group,
          ): void;
          public draw(): void;
          protected rect(
            _x: number,
            _y: number,
            _w: number,
            _h: number,
          ): void;
          public toggle(): void;
          public shown(): boolean;
          public hide(): void;
          private sendMessage(): void;
          public addMessage(_message: string): void;
          public clearMessages(): void;
          public clearChatInput(): void;
          public updateCursor(): void;
          public updateChat(): void;
          public nextMode(): void;
          private handleType(_c: string): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace fragments {
        declare class ConsoleFragment extends Packages.arc
          .scene.ui.layout.Table {
          private static messagesShown: number;
          private messages: Packages.arc.struct.Seq<string>;
          private chatfield: Packages.arc.scene.ui.TextField;
          private fieldlabel: Packages.arc.scene.ui.Label;
          private font: Packages.arc.graphics.g2d.Font;
          private layout: Packages.arc.graphics.g2d.GlyphLayout;
          private offsetx: number;
          private offsety: number;
          private fontoffsetx: number;
          private chatspace: number;
          private shadowColor: Packages.arc.graphics.Color;
          private textspacing: number;
          private history: Packages.arc.struct.Seq<string>;
          private historyPos: number;
          private scrollPos: number;
          private setup(): void;
          public open(): boolean;
          public build(
            _parent: Packages.arc.scene.Group,
          ): void;
          public draw(): void;
          protected rect(
            _x: number,
            _y: number,
            _w: number,
            _h: number,
          ): void;
          public toggle(): void;
          public shown(): boolean;
          public hide(): void;
          private sendMessage(): void;
          public addMessage(_message: string): void;
          public clearMessages(): void;
          public clearChatInput(): void;
          public updateChat(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace fragments {
        declare class MinimapFragment extends java.lang
          .Object {
          panx: number;
          pany: number;
          zoom: number;
          lastZoom: number;
          private baseSize: number;
          public elem: Packages.arc.scene.Element;
          public build(
            _parent: Packages.arc.scene.Group,
          ): void;
          public toggle(): void;
          public shown(): boolean;
          public hide(): void;
          protected getRectBounds(): Packages.arc.math.geom.Rect;
          public panTo(
            _relativeX: number,
            _relativeY: number,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace fragments {
        declare class PlayerListFragment extends java.lang
          .Object {
          public content: Packages.arc.scene.ui.layout.Table;
          private visible: boolean;
          private timer: Packages.arc.util.Interval;
          private search: Packages.arc.scene.ui.TextField;
          private players: Packages.arc.struct.Seq<Packages.mindustry.gen.Player>;
          public build(
            _parent: Packages.arc.scene.Group,
          ): void;
          public toggle(): void;
          public rebuild(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace fragments {
        declare class LoadingFragment extends java.lang
          .Object {
          private table: Packages.arc.scene.ui.layout.Table;
          private button: Packages.arc.scene.ui.TextButton;
          private bar: Packages.mindustry.ui.Bar;
          private nameLabel: Packages.arc.scene.ui.Label;
          private progValue: number;
          public build(
            _parent: Packages.arc.scene.Group,
          ): void;
          private text(_text: string): void;
          public setText(_text: string): void;
          public setButton(
            _listener: Packages.java.lang.Runnable,
          ): void;
          public toFront(): void;
          public hide(): void;
          public show(_text: string): void;
          public show(): void;
          public setProgress(_progress: number): void;
          public setProgress(
            _progress: Packages.arc.func.Floatp,
          ): void;
          public snapProgress(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace fragments {
        declare class HintsFragment extends java.lang
          .Object {
          public static DefaultHint = class
            extends Packages.java.lang
              .Enum<Packages.mindustry.ui.fragments.HintsFragment.DefaultHint>
            implements
              Packages.mindustry.ui.fragments.HintsFragment
                .Hint
          {
            public static desktopMove: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            public static zoom: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            public static breaking: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            public static desktopShoot: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            public static depositItems: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            public static desktopPause: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            public static unitControl: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            public static unitSelectControl: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            public static respawn: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            public static launch: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            public static schematicSelect: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            public static conveyorPathfind: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            public static boost: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            public static blockInfo: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            public static derelict: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            public static payloadPickup: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            public static payloadDrop: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            public static waveFire: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            public static generator: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            public static rebuildSelect: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            public static guardian: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            public static factoryControl: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            public static coreUpgrade: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            public static presetLaunch: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            public static presetDifficulty: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            public static coreIncinerate: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            text?: string;
            visibility: number;
            dependencies: Packages.mindustry.ui.fragments.HintsFragment.Hint[];
            finished: boolean;
            cached: boolean;
            complete: Packages.arc.func.Boolp;
            shown: Packages.arc.func.Boolp;
            private static $VALUES: Packages.mindustry.ui.fragments.HintsFragment.DefaultHint[];
            public static values():
              | Packages.mindustry.ui.fragments.HintsFragment.DefaultHint[]
              | null;
            public static valueOf(
              _name: string,
            ): Packages.mindustry.ui.fragments.HintsFragment.DefaultHint;
            public order(): number;
            public valid(): boolean;
            public text(): string;
            public finish(): void;
            public complete(): boolean;
            public finished(): boolean;
            public show(): boolean;
          };
          public static Hint = class {
            public static visibleDesktop: number;
            public static visibleMobile: number;
            public static visibleAll: number;
            public name(): string;
            public order(): number;
            public valid(): boolean;
            public text(): string;
            public finish(): void;
            public complete(): boolean;
            public finished(): boolean;
            public show(): boolean;
          };
          private static isTutorial: Packages.arc.func.Boolp;
          private static foutTime: number;
          public hints: Packages.arc.struct.Seq<Packages.mindustry.ui.fragments.HintsFragment.Hint>;
          current?: Packages.mindustry.ui.fragments.HintsFragment.Hint;
          group: Packages.arc.scene.Group;
          events: Packages.arc.struct.ObjectSet<string>;
          placedBlocks: Packages.arc.struct.ObjectSet<Packages.mindustry.world.Block>;
          last: Packages.arc.scene.ui.layout.Table;
          public build(
            _parent: Packages.arc.scene.Group,
          ): void;
          display(
            _hint: Packages.mindustry.ui.fragments.HintsFragment.Hint,
          ): void;
          complete(): void;
          public shown(): boolean;
          hide(): void;
          checkNext(): void;
          static isSerpulo(): boolean;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class AboutDialog extends Packages.mindustry
          .ui.dialogs.BaseDialog {
          contributors: Packages.arc.struct.Seq<string>;
          static bannedItems: Packages.arc.struct.ObjectSet<string>;
          setup(): void;
          public showCredits(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class GameOverDialog extends Packages
          .mindustry.ui.dialogs.BaseDialog {
          private static StatLabel = class extends Packages
            .arc.scene.ui.layout.Table {
            private progress: number;
            public constructor(
              _stat: string,
              _value: number,
              _delay: number,
            );
          };
          private winner: Packages.mindustry.game.Team;
          private hudShown: boolean;
          public show(
            _winner: Packages.mindustry.game.Team,
          ): void;
          rebuild(): void;
          private addStat(
            _parent: Packages.arc.scene.ui.layout.Table,
            _stat: string,
            _value: number,
            _delay: number,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare abstract class MapListDialog extends Packages
          .mindustry.ui.dialogs.BaseDialog {
          activeDialog: Packages.mindustry.ui.dialogs.BaseDialog;
          private searchString: string;
          private modes: Packages.arc.struct.Seq<Packages.mindustry.game.Gamemode>;
          private mapTable: Packages.arc.scene.ui.layout.Table;
          private searchField: Packages.arc.scene.ui.TextField;
          private showBuiltIn: boolean;
          private showCustom: boolean;
          private searchAuthor: boolean;
          private searchDescription: boolean;
          private displayType: boolean;
          setup(): void;
          public show(): Packages.arc.scene.ui.Dialog;
          showMap(_map: Packages.mindustry.maps.Map): void;
          buildButtons(): void;
          rebuildMaps(): void;
          showMapFilters(): void;
          public constructor(
            _title: string,
            _displayType: boolean,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class LoadoutDialog extends Packages
          .mindustry.ui.dialogs.BaseDialog {
          private hider: Packages.java.lang.Runnable;
          private resetter: Packages.java.lang.Runnable;
          private updater: Packages.java.lang.Runnable;
          private stacks: Packages.arc.struct.Seq<Packages.mindustry._type.ItemStack>;
          private originalStacks: Packages.arc.struct.Seq<Packages.mindustry._type.ItemStack>;
          private validator: Packages.arc.func.Boolf<Packages.mindustry._type.Item>;
          private items: Packages.arc.scene.ui.layout.Table;
          private capacity: number;
          private total?: Packages.mindustry._type.ItemSeq;
          setup(): void;
          private step(_amount: number): number;
          public show(
            _capacity: number,
            _total: Packages.mindustry._type.ItemSeq,
            _stacks: Packages.arc.struct.Seq<Packages.mindustry._type.ItemStack>,
            _validator: Packages.arc.func.Boolf<Packages.mindustry._type.Item>,
            _reseter: Packages.java.lang.Runnable,
            _updater: Packages.java.lang.Runnable,
            _hider: Packages.java.lang.Runnable,
          ): void;
          public show(
            _capacity: number,
            _stacks: Packages.arc.struct.Seq<Packages.mindustry._type.ItemStack>,
            _validator: Packages.arc.func.Boolf<Packages.mindustry._type.Item>,
            _reseter: Packages.java.lang.Runnable,
            _updater: Packages.java.lang.Runnable,
            _hider: Packages.java.lang.Runnable,
          ): void;
          private reseed(): void;
          public maxItems(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class CustomRulesDialog extends Packages
          .mindustry.ui.dialogs.BaseDialog {
          rules: Packages.mindustry.game.Rules;
          private main: Packages.arc.scene.ui.layout.Table;
          private resetter: Packages.arc.func.Prov<Packages.mindustry.game.Rules>;
          private loadoutDialog: Packages.mindustry.ui.dialogs.LoadoutDialog;
          public showRuleEditRule: boolean;
          public categories: Packages.arc.struct.Seq<Packages.arc.scene.ui.layout.Table>;
          public current: Packages.arc.scene.ui.layout.Table;
          public categoryNames: Packages.arc.struct.Seq<string>;
          public currentName: string;
          public ruleSearch: string;
          public additionalSetup: Packages.arc.struct.Seq<Packages.java.lang.Runnable>;
          field(
            _table: Packages.arc.scene.ui.layout.Table,
            _value: number,
            _setter: Packages.arc.func.Floatc,
          ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.TextField>;
          setup(): void;
          public check(
            _text: string,
            _cons: Packages.arc.func.Boolc,
            _prov: Packages.arc.func.Boolp,
          ): void;
          public check(
            _text: string,
            _cons: Packages.arc.func.Boolc,
            _prov: Packages.arc.func.Boolp,
            _condition: Packages.arc.func.Boolp,
          ): void;
          public number(
            _text: string,
            _cons: Packages.arc.func.Floatc,
            _prov: Packages.arc.func.Floatp,
          ): void;
          public number(
            _text: string,
            _cons: Packages.arc.func.Floatc,
            _prov: Packages.arc.func.Floatp,
            _min: number,
            _max: number,
          ): void;
          public number(
            _text: string,
            _integer: boolean,
            _cons: Packages.arc.func.Floatc,
            _prov: Packages.arc.func.Floatp,
            _condition: Packages.arc.func.Boolp,
          ): void;
          public number(
            _text: string,
            _cons: Packages.arc.func.Floatc,
            _prov: Packages.arc.func.Floatp,
            _condition: Packages.arc.func.Boolp,
          ): void;
          public number(
            _text: string,
            _integer: boolean,
            _cons: Packages.arc.func.Floatc,
            _prov: Packages.arc.func.Floatp,
            _condition: Packages.arc.func.Boolp,
            _min: number,
            _max: number,
          ): void;
          public category(_name: string): void;
          public show(
            _rules: Packages.mindustry.game.Rules,
            _resetter: Packages.arc.func.Prov<Packages.mindustry.game.Rules>,
          ): void;
          public team(
            _text: string,
            _cons: Packages.arc.func.Cons<Packages.mindustry.game.Team>,
            _prov: Packages.arc.func.Prov<Packages.mindustry.game.Team>,
          ): void;
          refresh(): void;
          public numberi(
            _text: string,
            _cons: Packages.arc.func.Intc,
            _prov: Packages.arc.func.Intp,
            _condition: Packages.arc.func.Boolp,
            _min: number,
            _max: number,
          ): void;
          public numberi(
            _text: string,
            _cons: Packages.arc.func.Intc,
            _prov: Packages.arc.func.Intp,
            _min: number,
            _max: number,
          ): void;
          addToMain(
            _category: Packages.arc.scene.ui.layout.Table,
            _title: string,
          ): void;
          private showBanned<
            T extends
              Packages.mindustry.ctype.UnlockableContent,
          >(
            _title: string,
            _type: Packages.mindustry.ctype.ContentType,
            _set: Packages.arc.struct.ObjectSet<T>,
            _pred: Packages.arc.func.Boolf<T>,
          ): void;
          weatherDialog(): void;
          public constructor();
          public constructor(_showRuleEditRule: boolean);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class MapPlayDialog extends Packages
          .mindustry.ui.dialogs.BaseDialog {
          public playListener?: Packages.java.lang.Runnable;
          dialog: Packages.mindustry.ui.dialogs.CustomRulesDialog;
          rules: Packages.mindustry.game.Rules;
          selectedGamemode: Packages.mindustry.game.Gamemode;
          lastMap: Packages.mindustry.maps.Map;
          public show(
            _map: Packages.mindustry.maps.Map,
            _playtesting: boolean,
          ): void;
          public show(
            _map: Packages.mindustry.maps.Map,
          ): void;
          private displayGameModeHelp(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class CustomGameDialog extends Packages
          .mindustry.ui.dialogs.MapListDialog {
          private dialog: Packages.mindustry.ui.dialogs.MapPlayDialog;
          showMap(_map: Packages.mindustry.maps.Map): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class EditorMapsDialog extends Packages
          .mindustry.ui.dialogs.MapListDialog {
          showMap(_map: Packages.mindustry.maps.Map): void;
          buildButtons(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare class BorderImage extends Packages.arc.scene
        .ui.Image {
        public thickness: number;
        public pad: number;
        public borderColor: Packages.arc.graphics.Color;
        public draw(): void;
        public border(
          _color: Packages.arc.graphics.Color,
        ): Packages.mindustry.ui.BorderImage;
        public constructor(
          _region: Packages.arc.scene.style.Drawable,
        );
        public constructor(
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _thick: number,
        );
        public constructor(
          _texture: Packages.arc.graphics.Texture,
          _thick: number,
        );
        public constructor(
          _texture: Packages.arc.graphics.Texture,
        );
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class LoadDialog extends Packages.mindustry
          .ui.dialogs.BaseDialog {
          slots: Packages.arc.scene.ui.layout.Table;
          searchString: string;
          hidden: Packages.arc.struct.Seq<Packages.mindustry.game.Gamemode>;
          searchField: Packages.arc.scene.ui.TextField;
          pane: Packages.arc.scene.ui.ScrollPane;
          protected setup(): void;
          public show(): Packages.arc.scene.ui.Dialog;
          public rebuild(): void;
          public addSetup(): void;
          public modifyButton(
            _button: Packages.arc.scene.ui.TextButton,
            _slot: Packages.mindustry.game.Saves.SaveSlot,
          ): void;
          public runLoadSave(
            _slot: Packages.mindustry.game.Saves.SaveSlot,
          ): void;
          public constructor();
          public constructor(_title: string);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class DiscordDialog extends Packages.arc
          .scene.ui.Dialog {
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class JoinDialog extends Packages.mindustry
          .ui.dialogs.BaseDialog {
          public static Server = class extends java.lang
            .Object {
            public ip: string;
            public port: number;
            content: Packages.arc.scene.ui.layout.Table;
            lastHost: Packages.mindustry.net.Host;
            displayIP(): string;
            setIP(_ip: string): void;
            public constructor();
          };
          servers: Packages.arc.struct.Seq<Packages.mindustry.ui.dialogs.JoinDialog.Server>;
          add: Packages.arc.scene.ui.Dialog;
          renaming: Packages.mindustry.ui.dialogs.JoinDialog.Server;
          local: Packages.arc.scene.ui.layout.Table;
          remote: Packages.arc.scene.ui.layout.Table;
          global: Packages.arc.scene.ui.layout.Table;
          hosts: Packages.arc.scene.ui.layout.Table;
          totalHosts: number;
          refreshes: number;
          showHidden: boolean;
          style: Packages.arc.scene.ui.TextButton.TextButtonStyle;
          fontIgnoreDirtyTask: Packages.arc.util.Timer.Task;
          lastIp: string;
          lastPort: number;
          lastColumns: number;
          ping: Packages.arc.util.Timer.Task;
          serverSearch: string;
          setup(): void;
          public connect(_ip: string, _port: number): void;
          section(
            _label: string,
            _servers: Packages.arc.scene.ui.layout.Table,
            _eye: boolean,
          ): void;
          columns(): number;
          targetWidth(): number;
          public reconnect(): void;
          private loadServers(): void;
          refreshLocal(): void;
          refreshRemote(): void;
          refreshCommunity(): void;
          private saveServers(): void;
          setupRemote(): void;
          setupServer(
            _server: Packages.mindustry.ui.dialogs.JoinDialog.Server,
            _host: Packages.mindustry.net.Host,
          ): void;
          refreshServer(
            _server: Packages.mindustry.ui.dialogs.JoinDialog.Server,
          ): void;
          buildServer(
            _host: Packages.mindustry.net.Host,
            _content: Packages.arc.scene.ui.layout.Table,
            _local: boolean,
            _addName: boolean,
          ): void;
          private getVersionString(
            _host: Packages.mindustry.net.Host,
          ): string;
          addHeader(
            _groupTable: Packages.arc.scene.ui.layout.Table[],
            _group: Packages.mindustry.net.ServerGroup,
            _hidden: boolean,
            _doInit: boolean,
          ): void;
          safeConnect(
            _ip: string,
            _port: number,
            _version: number,
          ): void;
          addCommunityHost(
            _host: Packages.mindustry.net.Host,
            _container: Packages.arc.scene.ui.layout.Table,
          ): void;
          moveRemote(
            _server: Packages.mindustry.ui.dialogs.JoinDialog.Server,
            _sign: number,
          ): void;
          refreshAll(): void;
          finishLocalHosts(): void;
          addLocalHost(
            _host: Packages.mindustry.net.Host,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class HostDialog extends Packages.mindustry
          .ui.dialogs.BaseDialog {
          w: number;
          public runHost(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class IconSelectDialog extends Packages.arc
          .scene.ui.Dialog {
          private consumer: Packages.arc.func.Intc;
          public show(
            _listener: Packages.arc.func.Intc,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare class MessageType extends Packages.java.lang
        .Enum<Packages.mindustry.logic.MessageType> {
        public static notify: Packages.mindustry.logic.MessageType;
        public static announce: Packages.mindustry.logic.MessageType;
        public static toast: Packages.mindustry.logic.MessageType;
        public static mission: Packages.mindustry.logic.MessageType;
        public static all: Packages.mindustry.logic.MessageType[];
        private static $VALUES: Packages.mindustry.logic.MessageType[];
        public static values():
          | Packages.mindustry.logic.MessageType[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.mindustry.logic.MessageType;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare class LogicRule extends Packages.java.lang
        .Enum<Packages.mindustry.logic.LogicRule> {
        public static currentWaveTime: Packages.mindustry.logic.LogicRule;
        public static waveTimer: Packages.mindustry.logic.LogicRule;
        public static waves: Packages.mindustry.logic.LogicRule;
        public static wave: Packages.mindustry.logic.LogicRule;
        public static waveSpacing: Packages.mindustry.logic.LogicRule;
        public static waveSending: Packages.mindustry.logic.LogicRule;
        public static attackMode: Packages.mindustry.logic.LogicRule;
        public static enemyCoreBuildRadius: Packages.mindustry.logic.LogicRule;
        public static dropZoneRadius: Packages.mindustry.logic.LogicRule;
        public static unitCap: Packages.mindustry.logic.LogicRule;
        public static mapArea: Packages.mindustry.logic.LogicRule;
        public static lighting: Packages.mindustry.logic.LogicRule;
        public static ambientLight: Packages.mindustry.logic.LogicRule;
        public static solarMultiplier: Packages.mindustry.logic.LogicRule;
        public static dragMultiplier: Packages.mindustry.logic.LogicRule;
        public static ban: Packages.mindustry.logic.LogicRule;
        public static unban: Packages.mindustry.logic.LogicRule;
        public static buildSpeed: Packages.mindustry.logic.LogicRule;
        public static unitHealth: Packages.mindustry.logic.LogicRule;
        public static unitBuildSpeed: Packages.mindustry.logic.LogicRule;
        public static unitCost: Packages.mindustry.logic.LogicRule;
        public static unitDamage: Packages.mindustry.logic.LogicRule;
        public static blockHealth: Packages.mindustry.logic.LogicRule;
        public static blockDamage: Packages.mindustry.logic.LogicRule;
        public static rtsMinWeight: Packages.mindustry.logic.LogicRule;
        public static rtsMinSquad: Packages.mindustry.logic.LogicRule;
        public static all: Packages.mindustry.logic.LogicRule[];
        private static $VALUES: Packages.mindustry.logic.LogicRule[];
        public static values():
          | Packages.mindustry.logic.LogicRule[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.mindustry.logic.LogicRule;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare class TileLayer extends Packages.java.lang
        .Enum<Packages.mindustry.logic.TileLayer> {
        public static floor: Packages.mindustry.logic.TileLayer;
        public static ore: Packages.mindustry.logic.TileLayer;
        public static block: Packages.mindustry.logic.TileLayer;
        public static building: Packages.mindustry.logic.TileLayer;
        public static all: Packages.mindustry.logic.TileLayer[];
        public static settable: Packages.mindustry.logic.TileLayer[];
        private static $VALUES: Packages.mindustry.logic.TileLayer[];
        public static values():
          | Packages.mindustry.logic.TileLayer[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.mindustry.logic.TileLayer;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare class FetchType extends Packages.java.lang
        .Enum<Packages.mindustry.logic.FetchType> {
        public static unit: Packages.mindustry.logic.FetchType;
        public static unitCount: Packages.mindustry.logic.FetchType;
        public static player: Packages.mindustry.logic.FetchType;
        public static playerCount: Packages.mindustry.logic.FetchType;
        public static core: Packages.mindustry.logic.FetchType;
        public static coreCount: Packages.mindustry.logic.FetchType;
        public static build: Packages.mindustry.logic.FetchType;
        public static buildCount: Packages.mindustry.logic.FetchType;
        public static all: Packages.mindustry.logic.FetchType[];
        private static $VALUES: Packages.mindustry.logic.FetchType[];
        public static values():
          | Packages.mindustry.logic.FetchType[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.mindustry.logic.FetchType;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare class CutsceneAction extends Packages.java
        .lang
        .Enum<Packages.mindustry.logic.CutsceneAction> {
        public static pan: Packages.mindustry.logic.CutsceneAction;
        public static zoom: Packages.mindustry.logic.CutsceneAction;
        public static stop: Packages.mindustry.logic.CutsceneAction;
        public static all: Packages.mindustry.logic.CutsceneAction[];
        private static $VALUES: Packages.mindustry.logic.CutsceneAction[];
        public static values():
          | Packages.mindustry.logic.CutsceneAction[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.mindustry.logic.CutsceneAction;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare class ConditionOp extends Packages.java.lang
        .Enum<Packages.mindustry.logic.ConditionOp> {
        static CondOpLambda = class {
          public get(_a: number, _b: number): boolean;
        };
        static CondObjOpLambda = class {
          public get(_a: any, _b: any): boolean;
        };
        public static equal: Packages.mindustry.logic.ConditionOp;
        public static notEqual: Packages.mindustry.logic.ConditionOp;
        public static lessThan: Packages.mindustry.logic.ConditionOp;
        public static lessThanEq: Packages.mindustry.logic.ConditionOp;
        public static greaterThan: Packages.mindustry.logic.ConditionOp;
        public static greaterThanEq: Packages.mindustry.logic.ConditionOp;
        public static strictEqual: Packages.mindustry.logic.ConditionOp;
        public static always: Packages.mindustry.logic.ConditionOp;
        public static all: Packages.mindustry.logic.ConditionOp[];
        public objFunction: Packages.mindustry.logic.ConditionOp.CondObjOpLambda;
        public function: Packages.mindustry.logic.ConditionOp.CondOpLambda;
        public symbol: string;
        private static $VALUES: Packages.mindustry.logic.ConditionOp[];
        public toString(): string;
        public static values():
          | Packages.mindustry.logic.ConditionOp[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.mindustry.logic.ConditionOp;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare class LogicOp extends Packages.java.lang
        .Enum<Packages.mindustry.logic.LogicOp> {
        static OpLambda2 = class {
          public get(_a: number, _b: number): number;
        };
        static OpObjLambda2 = class {
          public get(_a: any, _b: any): number;
        };
        static OpLambda1 = class {
          public get(_a: number): number;
        };
        public static add: Packages.mindustry.logic.LogicOp;
        public static sub: Packages.mindustry.logic.LogicOp;
        public static mul: Packages.mindustry.logic.LogicOp;
        public static div: Packages.mindustry.logic.LogicOp;
        public static idiv: Packages.mindustry.logic.LogicOp;
        public static mod: Packages.mindustry.logic.LogicOp;
        public static pow: Packages.mindustry.logic.LogicOp;
        public static equal: Packages.mindustry.logic.LogicOp;
        public static notEqual: Packages.mindustry.logic.LogicOp;
        public static land: Packages.mindustry.logic.LogicOp;
        public static lessThan: Packages.mindustry.logic.LogicOp;
        public static lessThanEq: Packages.mindustry.logic.LogicOp;
        public static greaterThan: Packages.mindustry.logic.LogicOp;
        public static greaterThanEq: Packages.mindustry.logic.LogicOp;
        public static strictEqual: Packages.mindustry.logic.LogicOp;
        public static shl: Packages.mindustry.logic.LogicOp;
        public static shr: Packages.mindustry.logic.LogicOp;
        public static or: Packages.mindustry.logic.LogicOp;
        public static and: Packages.mindustry.logic.LogicOp;
        public static xor: Packages.mindustry.logic.LogicOp;
        public static not: Packages.mindustry.logic.LogicOp;
        public static max: Packages.mindustry.logic.LogicOp;
        public static min: Packages.mindustry.logic.LogicOp;
        public static angle: Packages.mindustry.logic.LogicOp;
        public static angleDiff: Packages.mindustry.logic.LogicOp;
        public static len: Packages.mindustry.logic.LogicOp;
        public static noise: Packages.mindustry.logic.LogicOp;
        public static abs: Packages.mindustry.logic.LogicOp;
        public static log: Packages.mindustry.logic.LogicOp;
        public static log10: Packages.mindustry.logic.LogicOp;
        public static floor: Packages.mindustry.logic.LogicOp;
        public static ceil: Packages.mindustry.logic.LogicOp;
        public static sqrt: Packages.mindustry.logic.LogicOp;
        public static rand: Packages.mindustry.logic.LogicOp;
        public static sin: Packages.mindustry.logic.LogicOp;
        public static cos: Packages.mindustry.logic.LogicOp;
        public static tan: Packages.mindustry.logic.LogicOp;
        public static asin: Packages.mindustry.logic.LogicOp;
        public static acos: Packages.mindustry.logic.LogicOp;
        public static atan: Packages.mindustry.logic.LogicOp;
        public static all: Packages.mindustry.logic.LogicOp[];
        public objFunction2: Packages.mindustry.logic.LogicOp.OpObjLambda2;
        public function2: Packages.mindustry.logic.LogicOp.OpLambda2;
        public function1: Packages.mindustry.logic.LogicOp.OpLambda1;
        public unary: boolean;
        public func: boolean;
        public symbol: string;
        private static $VALUES: Packages.mindustry.logic.LogicOp[];
        public toString(): string;
        public static values():
          | Packages.mindustry.logic.LogicOp[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.mindustry.logic.LogicOp;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare class RadarTarget extends Packages.java.lang
        .Enum<Packages.mindustry.logic.RadarTarget> {
        public static RadarTargetFunc = class {
          public get(
            _team: Packages.mindustry.game.Team,
            _other: Packages.mindustry.gen.Unit,
          ): boolean;
        };
        public static any: Packages.mindustry.logic.RadarTarget;
        public static enemy: Packages.mindustry.logic.RadarTarget;
        public static ally: Packages.mindustry.logic.RadarTarget;
        public static player: Packages.mindustry.logic.RadarTarget;
        public static attacker: Packages.mindustry.logic.RadarTarget;
        public static flying: Packages.mindustry.logic.RadarTarget;
        public static boss: Packages.mindustry.logic.RadarTarget;
        public static ground: Packages.mindustry.logic.RadarTarget;
        public func: Packages.mindustry.logic.RadarTarget.RadarTargetFunc;
        public static all: Packages.mindustry.logic.RadarTarget[];
        private static $VALUES: Packages.mindustry.logic.RadarTarget[];
        public static values():
          | Packages.mindustry.logic.RadarTarget[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.mindustry.logic.RadarTarget;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare class RadarSort extends Packages.java.lang
        .Enum<Packages.mindustry.logic.RadarSort> {
        public static RadarSortFunc = class {
          public get(
            _pos: Packages.arc.math.geom.Position,
            _other: Packages.mindustry.gen.Unit,
          ): number;
        };
        public static distance: Packages.mindustry.logic.RadarSort;
        public static health: Packages.mindustry.logic.RadarSort;
        public static shield: Packages.mindustry.logic.RadarSort;
        public static armor: Packages.mindustry.logic.RadarSort;
        public static maxHealth: Packages.mindustry.logic.RadarSort;
        public func: Packages.mindustry.logic.RadarSort.RadarSortFunc;
        public static all: Packages.mindustry.logic.RadarSort[];
        private static $VALUES: Packages.mindustry.logic.RadarSort[];
        public static values():
          | Packages.mindustry.logic.RadarSort[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.mindustry.logic.RadarSort;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare class LUnitControl extends Packages.java.lang
        .Enum<Packages.mindustry.logic.LUnitControl> {
        public static idle: Packages.mindustry.logic.LUnitControl;
        public static stop: Packages.mindustry.logic.LUnitControl;
        public static move: Packages.mindustry.logic.LUnitControl;
        public static approach: Packages.mindustry.logic.LUnitControl;
        public static pathfind: Packages.mindustry.logic.LUnitControl;
        public static autoPathfind: Packages.mindustry.logic.LUnitControl;
        public static boost: Packages.mindustry.logic.LUnitControl;
        public static target: Packages.mindustry.logic.LUnitControl;
        public static targetp: Packages.mindustry.logic.LUnitControl;
        public static itemDrop: Packages.mindustry.logic.LUnitControl;
        public static itemTake: Packages.mindustry.logic.LUnitControl;
        public static payDrop: Packages.mindustry.logic.LUnitControl;
        public static payTake: Packages.mindustry.logic.LUnitControl;
        public static payEnter: Packages.mindustry.logic.LUnitControl;
        public static mine: Packages.mindustry.logic.LUnitControl;
        public static flag: Packages.mindustry.logic.LUnitControl;
        public static build: Packages.mindustry.logic.LUnitControl;
        public static getBlock: Packages.mindustry.logic.LUnitControl;
        public static within: Packages.mindustry.logic.LUnitControl;
        public static unbind: Packages.mindustry.logic.LUnitControl;
        public params: string[];
        public static all: Packages.mindustry.logic.LUnitControl[];
        private static $VALUES: Packages.mindustry.logic.LUnitControl[];
        public static values():
          | Packages.mindustry.logic.LUnitControl[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.mindustry.logic.LUnitControl;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class PosTeam
        extends java.lang.Object
        implements
          Packages.mindustry.gen.IndexableEntity__all,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Teamc
      {
        protected added: boolean;
        protected index__all: number;
        public add(): void;
        public remove(): void;
        public toString(): string;
        public update(): void;
        public x(): number;
        public x(_x: number): void;
        public id(_id: number): void;
        public id(): number;
        public set(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public set(_x: number, _y: number): void;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public static create(): Packages.mindustry.gen.PosTeam;
        public as<T>(): T | null;
        public y(_y: number): void;
        public y(): number;
        public self<
          T extends Packages.mindustry.gen.Entityc,
        >(): T | null;
        public getX(): number;
        public getY(): number;
        public trns(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public trns(_x: number, _y: number): void;
        public team(): Packages.mindustry.game.Team;
        public team(
          _team: Packages.mindustry.game.Team,
        ): void;
        public afterRead(): void;
        public core(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public isLocal(): boolean;
        public isAdded(): boolean;
        public tileOn(): Packages.mindustry.world.Tile;
        public closestCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public inFogTo(
          _viewer: Packages.mindustry.game.Team,
        ): boolean;
        public isRemote(): boolean;
        public onSolid(): boolean;
        public classId(): number;
        public setIndex__all(_index: number): void;
        public buildOn(): Packages.mindustry.gen.Building;
        public closestEnemyCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public cheating(): boolean;
        public serialize(): boolean;
        public tileX(): number;
        public tileY(): number;
        public blockOn(): Packages.mindustry.world.Block;
        public floorOn(): Packages.mindustry.world.blocks.environment.Floor;
        public afterAllRead(): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare namespace _types {
        declare class LogicAI extends Packages.mindustry
          .entities.units.AIController {
          public static transferDelay: number;
          public static logicControlTimeout: number;
          public control: Packages.mindustry.logic.LUnitControl;
          public moveX: number;
          public moveY: number;
          public moveRad: number;
          public controlTimer: number;
          public targetTimer: number;
          public controller?: Packages.mindustry.gen.Building;
          public plan: Packages.mindustry.entities.units.BuildPlan;
          public execCache: Packages.arc.struct.ObjectMap<
            any,
            any
          >;
          public aimControl: Packages.mindustry.logic.LUnitControl;
          public boost: boolean;
          public mainTarget: Packages.mindustry.gen.Teamc;
          public shoot: boolean;
          public posTarget: Packages.mindustry.gen.PosTeam;
          private radars: Packages.arc.struct.ObjectSet<any>;
          public target(
            _x: number,
            _y: number,
            _range: number,
            _air: boolean,
            _ground: boolean,
          ): Packages.mindustry.gen.Teamc;
          public invalid(
            _target: Packages.mindustry.gen.Teamc,
          ): boolean;
          public checkTarget(
            _target: Packages.mindustry.gen.Teamc,
            _x: number,
            _y: number,
            _range: number,
          ): boolean;
          public retarget(): boolean;
          public updateMovement(): void;
          public shouldShoot(): boolean;
          public keepState(): boolean;
          public checkTargetTimer(_radar: any): boolean;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare class LLocate extends Packages.java.lang
        .Enum<Packages.mindustry.logic.LLocate> {
        public static ore: Packages.mindustry.logic.LLocate;
        public static building: Packages.mindustry.logic.LLocate;
        public static spawn: Packages.mindustry.logic.LLocate;
        public static damaged: Packages.mindustry.logic.LLocate;
        public static all: Packages.mindustry.logic.LLocate[];
        private static $VALUES: Packages.mindustry.logic.LLocate[];
        public static values():
          | Packages.mindustry.logic.LLocate[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.mindustry.logic.LLocate;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare class LCanvas extends Packages.arc.scene.ui
        .layout.Table {
        public DragLayout = class extends Packages.arc.scene
          .ui.layout.WidgetGroup {
          space: number;
          prefWidth: number;
          prefHeight: number;
          seq: Packages.arc.struct.Seq<Packages.arc.scene.Element>;
          insertPosition: number;
          invalidated: boolean;
          this$0: Packages.mindustry.logic.LCanvas;
          public draw(): void;
          public getPrefWidth(): number;
          public getPrefHeight(): number;
          public layout(): void;
          finishLayout(): void;
          public constructor(
            _this$0: Packages.mindustry.logic.LCanvas,
          );
        };
        public StatementElem = class extends Packages.arc
          .scene.ui.layout.Table {
          public st: Packages.mindustry.logic.LStatement;
          public index: number;
          addressLabel: Packages.arc.scene.ui.Label;
          this$0: Packages.mindustry.logic.LCanvas;
          public copy(): void;
          public draw(): void;
          public updateAddress(_index: number): void;
          public constructor(
            _this$0: Packages.mindustry.logic.LCanvas,
            _st: Packages.mindustry.logic.LStatement,
          );
        };
        public static JumpCurve = class extends Packages.arc
          .scene.Element {
          public button: Packages.mindustry.logic.LCanvas.JumpButton;
          public draw(): void;
          public act(_delta: number): void;
          public drawCurve(
            _x: number,
            _y: number,
            _x2: number,
            _y2: number,
          ): void;
          public constructor(
            _button: Packages.mindustry.logic.LCanvas.JumpButton,
          );
        };
        public static JumpButton = class extends Packages
          .arc.scene.ui.ImageButton {
          hoverColor: Packages.arc.graphics.Color;
          defaultColor: Packages.arc.graphics.Color;
          to: Packages.arc.func.Prov<Packages.mindustry.logic.LCanvas.StatementElem>;
          selecting: boolean;
          mx: number;
          my: number;
          listener: Packages.arc.scene.event.ClickListener;
          public curve: Packages.mindustry.logic.LCanvas.JumpCurve;
          protected setScene(
            _stage: Packages.arc.scene.Scene,
          ): void;
          public constructor(
            _getter: Packages.arc.func.Prov<Packages.mindustry.logic.LCanvas.StatementElem>,
            _setter: Packages.arc.func.Cons<Packages.mindustry.logic.LCanvas.StatementElem>,
          );
        };
        public static maxJumpsDrawn: number;
        static canvas: Packages.mindustry.logic.LCanvas;
        public statements: Packages.mindustry.logic.LCanvas.DragLayout;
        public pane: Packages.arc.scene.ui.ScrollPane;
        public jumps: Packages.arc.scene.Group;
        dragging: Packages.mindustry.logic.LCanvas.StatementElem;
        hovered: Packages.mindustry.logic.LCanvas.StatementElem;
        targetWidth: number;
        jumpCount: number;
        privileged: boolean;
        tooltips: Packages.arc.struct.Seq<Packages.arc.scene.ui.Tooltip>;
        public add(
          _statement: Packages.mindustry.logic.LStatement,
        ): void;
        public load(_asm: string): void;
        public save(): string;
        public static tooltip(
          _cell: Packages.arc.scene.ui.layout.Cell<any>,
          _key: string,
        ): void;
        public static tooltip(
          _cell: Packages.arc.scene.ui.layout.Cell<any>,
          _key: Packages.java.lang.Enum<any>,
        ): void;
        public draw(): void;
        public act(_delta: number): void;
        public rebuild(): void;
        public clearStatements(): void;
        public static useRows(): boolean;
        checkHovered(): Packages.mindustry.logic.LCanvas.StatementElem;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare class LCategory
        extends java.lang.Object
        implements
          Packages.java.lang
            .Comparable<Packages.mindustry.logic.LCategory>
      {
        public static all: Packages.arc.struct.Seq<Packages.mindustry.logic.LCategory>;
        public static unknown: Packages.mindustry.logic.LCategory;
        public static io: Packages.mindustry.logic.LCategory;
        public static block: Packages.mindustry.logic.LCategory;
        public static operation: Packages.mindustry.logic.LCategory;
        public static control: Packages.mindustry.logic.LCategory;
        public static unit: Packages.mindustry.logic.LCategory;
        public static world: Packages.mindustry.logic.LCategory;
        public name: string;
        public id: number;
        public color: Packages.arc.graphics.Color;
        public icon?: Packages.arc.scene.style.Drawable;
        public compareTo(_o: any): number;
        public compareTo(
          _o: Packages.mindustry.logic.LCategory,
        ): number;
        public localized(): string;
        public description(): string;
        public constructor(
          _name: string,
          _color: Packages.arc.graphics.Color,
        );
        public constructor(
          _name: string,
          _color: Packages.arc.graphics.Color,
          _icon: Packages.arc.scene.style.Drawable,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare abstract class LStatement extends java.lang
        .Object {
        public elem?: Packages.mindustry.logic.LCanvas.StatementElem;
        public name(): string;
        protected field(
          _table: Packages.arc.scene.ui.layout.Table,
          _value: string,
          _setter: Packages.arc.func.Cons<string>,
        ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.TextField>;
        protected fields(
          _table: Packages.arc.scene.ui.layout.Table,
          _desc: string,
          _value: string,
          _setter: Packages.arc.func.Cons<string>,
        ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.TextField>;
        protected fields(
          _table: Packages.arc.scene.ui.layout.Table,
          _value: string,
          _setter: Packages.arc.func.Cons<string>,
        ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.TextField>;
        public write(
          _builder: Packages.java.lang.StringBuilder,
        ): void;
        public copy(): Packages.mindustry.logic.LStatement;
        protected param(
          _label: Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.Label>,
        ): void;
        public build(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public build(
          _builder: Packages.mindustry.logic.LAssembler,
        ): Packages.mindustry.logic.LExecutor.LInstruction;
        public category(): Packages.mindustry.logic.LCategory;
        protected col(
          _table: Packages.arc.scene.ui.layout.Table,
          _value: string,
          _setter: Packages.arc.func.Cons<Packages.arc.graphics.Color>,
        ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.Button>;
        protected row(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public hidden(): boolean;
        public afterRead(): void;
        public privileged(): boolean;
        public nonPrivileged(): boolean;
        protected showSelect<T>(
          _b: Packages.arc.scene.ui.Button,
          _values: T[],
          _current: T,
          _getter: Packages.arc.func.Cons<T>,
          _cols: number,
          _sizer: Packages.arc.func.Cons<
            Packages.arc.scene.ui.layout.Cell<any>
          >,
        ): void;
        protected showSelect<T>(
          _b: Packages.arc.scene.ui.Button,
          _values: T[],
          _current: T,
          _getter: Packages.arc.func.Cons<T>,
        ): void;
        protected showSelectTable(
          _b: Packages.arc.scene.ui.Button,
          _hideCons: Packages.arc.func.Cons2<
            Packages.arc.scene.ui.layout.Table,
            Packages.java.lang.Runnable
          >,
        ): void;
        protected sanitize(_value: string): string;
        protected fieldst(
          _table: Packages.arc.scene.ui.layout.Table,
          _desc: string,
          _value: string,
          _setter: Packages.arc.func.Cons<string>,
        ): Packages.arc.scene.ui.layout.Cell<Packages.arc.scene.ui.TextField>;
        public setupUI(): void;
        public saveUI(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare class LAssembler extends java.lang.Object {
        public static customParsers: Packages.arc.struct.ObjectMap<
          string,
          Packages.arc.func.Func<
            string[],
            Packages.mindustry.logic.LStatement
          >
        >;
        private static invalidNum: number;
        private privileged: boolean;
        public vars: Packages.arc.struct.OrderedMap<
          string,
          Packages.mindustry.logic.LVar
        >;
        public instructions: Packages.mindustry.logic.LExecutor.LInstruction[];
        public static write(
          _statements: Packages.arc.struct.Seq<Packages.mindustry.logic.LStatement>,
        ): string;
        public static read(
          _text: string,
          _privileged: boolean,
        ): Packages.arc.struct.Seq<Packages.mindustry.logic.LStatement>;
        parseDouble(_symbol: string): number;
        public var(
          _symbol: string,
        ): Packages.mindustry.logic.LVar;
        public static assemble(
          _data: string,
          _privileged: boolean,
        ): Packages.mindustry.logic.LAssembler;
        public putConst(
          _name: string,
          _value: any,
        ): Packages.mindustry.logic.LVar;
        public getVar(
          _name: string,
        ): Packages.mindustry.logic.LVar | null;
        public putVar(
          _name: string,
        ): Packages.mindustry.logic.LVar;
        parseColor(_symbol: string): number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare class LExecutor extends java.lang.Object {
        public static LInstruction = class {
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
        };
        public static LocalePrintI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public name: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _name: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static MakeMarkerI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public static maxMarkers: number;
          public type: string;
          public id: Packages.mindustry.logic.LVar;
          public x: Packages.mindustry.logic.LVar;
          public y: Packages.mindustry.logic.LVar;
          public replace: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _type: string,
            _id: Packages.mindustry.logic.LVar,
            _x: Packages.mindustry.logic.LVar,
            _y: Packages.mindustry.logic.LVar,
            _replace: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static SetMarkerI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public type: Packages.mindustry.logic.LMarkerControl;
          public id: Packages.mindustry.logic.LVar;
          public p1: Packages.mindustry.logic.LVar;
          public p2: Packages.mindustry.logic.LVar;
          public p3: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _type: Packages.mindustry.logic.LMarkerControl,
            _id: Packages.mindustry.logic.LVar,
            _p1: Packages.mindustry.logic.LVar,
            _p2: Packages.mindustry.logic.LVar,
            _p3: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static PlaySoundI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public positional: boolean;
          public id: Packages.mindustry.logic.LVar;
          public volume: Packages.mindustry.logic.LVar;
          public pitch: Packages.mindustry.logic.LVar;
          public pan: Packages.mindustry.logic.LVar;
          public x: Packages.mindustry.logic.LVar;
          public y: Packages.mindustry.logic.LVar;
          public limit: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor();
          public constructor(
            _positional: boolean,
            _id: Packages.mindustry.logic.LVar,
            _volume: Packages.mindustry.logic.LVar,
            _pitch: Packages.mindustry.logic.LVar,
            _pan: Packages.mindustry.logic.LVar,
            _x: Packages.mindustry.logic.LVar,
            _y: Packages.mindustry.logic.LVar,
            _limit: Packages.mindustry.logic.LVar,
          );
        };
        public static SetPropI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public type: Packages.mindustry.logic.LVar;
          public of: Packages.mindustry.logic.LVar;
          public value: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _type: Packages.mindustry.logic.LVar,
            _of: Packages.mindustry.logic.LVar,
            _value: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static SpawnWaveI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public natural: Packages.mindustry.logic.LVar;
          public x: Packages.mindustry.logic.LVar;
          public y: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor();
          public constructor(
            _natural: Packages.mindustry.logic.LVar,
            _x: Packages.mindustry.logic.LVar,
            _y: Packages.mindustry.logic.LVar,
          );
        };
        public static SetFlagI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public flag: Packages.mindustry.logic.LVar;
          public value: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _flag: Packages.mindustry.logic.LVar,
            _value: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static GetFlagI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public result: Packages.mindustry.logic.LVar;
          public flag: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _result: Packages.mindustry.logic.LVar,
            _flag: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static ClientDataI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public channel: Packages.mindustry.logic.LVar;
          public value: Packages.mindustry.logic.LVar;
          public reliable: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _channel: Packages.mindustry.logic.LVar,
            _value: Packages.mindustry.logic.LVar,
            _reliable: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static SyncI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public static syncInterval: Packages.long;
          public variable: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _variable: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static SetRateI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public amount: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _amount: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static ExplosionI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public team: Packages.mindustry.logic.LVar;
          public x: Packages.mindustry.logic.LVar;
          public y: Packages.mindustry.logic.LVar;
          public radius: Packages.mindustry.logic.LVar;
          public damage: Packages.mindustry.logic.LVar;
          public air: Packages.mindustry.logic.LVar;
          public ground: Packages.mindustry.logic.LVar;
          public pierce: Packages.mindustry.logic.LVar;
          public effect: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _team: Packages.mindustry.logic.LVar,
            _x: Packages.mindustry.logic.LVar,
            _y: Packages.mindustry.logic.LVar,
            _radius: Packages.mindustry.logic.LVar,
            _damage: Packages.mindustry.logic.LVar,
            _air: Packages.mindustry.logic.LVar,
            _ground: Packages.mindustry.logic.LVar,
            _pierce: Packages.mindustry.logic.LVar,
            _effect: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static EffectI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public type: Packages.mindustry.logic.LogicFx.EffectEntry;
          public x: Packages.mindustry.logic.LVar;
          public y: Packages.mindustry.logic.LVar;
          public rotation: Packages.mindustry.logic.LVar;
          public color: Packages.mindustry.logic.LVar;
          public data: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _type: Packages.mindustry.logic.LogicFx.EffectEntry,
            _x: Packages.mindustry.logic.LVar,
            _y: Packages.mindustry.logic.LVar,
            _rotation: Packages.mindustry.logic.LVar,
            _color: Packages.mindustry.logic.LVar,
            _data: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static FlushMessageI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public type: Packages.mindustry.logic.MessageType;
          public duration: Packages.mindustry.logic.LVar;
          public outSuccess: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _type: Packages.mindustry.logic.MessageType,
            _duration: Packages.mindustry.logic.LVar,
            _outSuccess: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static SetRuleI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public rule: Packages.mindustry.logic.LogicRule;
          public value: Packages.mindustry.logic.LVar;
          public p1: Packages.mindustry.logic.LVar;
          public p2: Packages.mindustry.logic.LVar;
          public p3: Packages.mindustry.logic.LVar;
          public p4: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _rule: Packages.mindustry.logic.LogicRule,
            _value: Packages.mindustry.logic.LVar,
            _p1: Packages.mindustry.logic.LVar,
            _p2: Packages.mindustry.logic.LVar,
            _p3: Packages.mindustry.logic.LVar,
            _p4: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static ApplyEffectI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public clear: boolean;
          public effect: string;
          public unit: Packages.mindustry.logic.LVar;
          public duration: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _clear: boolean,
            _effect: string,
            _unit: Packages.mindustry.logic.LVar,
            _duration: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static SetWeatherI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public type: Packages.mindustry.logic.LVar;
          public state: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _type: Packages.mindustry.logic.LVar,
            _state: Packages.mindustry.logic.LVar,
          );
        };
        public static SenseWeatherI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public type: Packages.mindustry.logic.LVar;
          public to: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _type: Packages.mindustry.logic.LVar,
            _to: Packages.mindustry.logic.LVar,
          );
        };
        public static SpawnUnitI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public type: Packages.mindustry.logic.LVar;
          public x: Packages.mindustry.logic.LVar;
          public y: Packages.mindustry.logic.LVar;
          public rotation: Packages.mindustry.logic.LVar;
          public team: Packages.mindustry.logic.LVar;
          public result: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _type: Packages.mindustry.logic.LVar,
            _x: Packages.mindustry.logic.LVar,
            _y: Packages.mindustry.logic.LVar,
            _rotation: Packages.mindustry.logic.LVar,
            _team: Packages.mindustry.logic.LVar,
            _result: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static SetBlockI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public x: Packages.mindustry.logic.LVar;
          public y: Packages.mindustry.logic.LVar;
          public block: Packages.mindustry.logic.LVar;
          public team: Packages.mindustry.logic.LVar;
          public rotation: Packages.mindustry.logic.LVar;
          public layer: Packages.mindustry.logic.TileLayer;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _x: Packages.mindustry.logic.LVar,
            _y: Packages.mindustry.logic.LVar,
            _block: Packages.mindustry.logic.LVar,
            _team: Packages.mindustry.logic.LVar,
            _rotation: Packages.mindustry.logic.LVar,
            _layer: Packages.mindustry.logic.TileLayer,
          );
          public constructor();
        };
        public static GetBlockI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public x: Packages.mindustry.logic.LVar;
          public y: Packages.mindustry.logic.LVar;
          public dest: Packages.mindustry.logic.LVar;
          public layer: Packages.mindustry.logic.TileLayer;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _x: Packages.mindustry.logic.LVar,
            _y: Packages.mindustry.logic.LVar,
            _dest: Packages.mindustry.logic.LVar,
            _layer: Packages.mindustry.logic.TileLayer,
          );
          public constructor();
        };
        public static FetchI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public type: Packages.mindustry.logic.FetchType;
          public result: Packages.mindustry.logic.LVar;
          public team: Packages.mindustry.logic.LVar;
          public extra: Packages.mindustry.logic.LVar;
          public index: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _type: Packages.mindustry.logic.FetchType,
            _result: Packages.mindustry.logic.LVar,
            _team: Packages.mindustry.logic.LVar,
            _extra: Packages.mindustry.logic.LVar,
            _index: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static CutsceneI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public action: Packages.mindustry.logic.CutsceneAction;
          public p1: Packages.mindustry.logic.LVar;
          public p2: Packages.mindustry.logic.LVar;
          public p3: Packages.mindustry.logic.LVar;
          public p4: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _action: Packages.mindustry.logic.CutsceneAction,
            _p1: Packages.mindustry.logic.LVar,
            _p2: Packages.mindustry.logic.LVar,
            _p3: Packages.mindustry.logic.LVar,
            _p4: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static PackColorI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public result: Packages.mindustry.logic.LVar;
          public r: Packages.mindustry.logic.LVar;
          public g: Packages.mindustry.logic.LVar;
          public b: Packages.mindustry.logic.LVar;
          public a: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _result: Packages.mindustry.logic.LVar,
            _r: Packages.mindustry.logic.LVar,
            _g: Packages.mindustry.logic.LVar,
            _b: Packages.mindustry.logic.LVar,
            _a: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static LookupI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public dest: Packages.mindustry.logic.LVar;
          public from: Packages.mindustry.logic.LVar;
          public type: Packages.mindustry.ctype.ContentType;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _dest: Packages.mindustry.logic.LVar,
            _from: Packages.mindustry.logic.LVar,
            _type: Packages.mindustry.ctype.ContentType,
          );
          public constructor();
        };
        public static StopI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor();
        };
        public static WaitI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public value: Packages.mindustry.logic.LVar;
          public curTime: number;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _value: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static JumpI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public op: Packages.mindustry.logic.ConditionOp;
          public value: Packages.mindustry.logic.LVar;
          public compare: Packages.mindustry.logic.LVar;
          public address: number;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _op: Packages.mindustry.logic.ConditionOp,
            _value: Packages.mindustry.logic.LVar,
            _compare: Packages.mindustry.logic.LVar,
            _address: number,
          );
          public constructor();
        };
        public static PrintFlushI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public target: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _target: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static FormatI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public value: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _value: Packages.mindustry.logic.LVar,
          );
        };
        public static PrintI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public value: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public static toString(_obj: any): string;
          public constructor(
            _value: Packages.mindustry.logic.LVar,
          );
        };
        public static DrawFlushI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public target: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _target: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static DrawI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public type: string;
          public x: Packages.mindustry.logic.LVar;
          public y: Packages.mindustry.logic.LVar;
          public p1: Packages.mindustry.logic.LVar;
          public p2: Packages.mindustry.logic.LVar;
          public p3: Packages.mindustry.logic.LVar;
          public p4: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          static pack(_value: number): number;
          static packSign(_value: number): number;
          public constructor(
            _type: string,
            _x: Packages.mindustry.logic.LVar,
            _y: Packages.mindustry.logic.LVar,
            _p1: Packages.mindustry.logic.LVar,
            _p2: Packages.mindustry.logic.LVar,
            _p3: Packages.mindustry.logic.LVar,
            _p4: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static NoopI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor();
        };
        public static EndI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor();
        };
        public static OpI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public op: Packages.mindustry.logic.LogicOp;
          public a: Packages.mindustry.logic.LVar;
          public b: Packages.mindustry.logic.LVar;
          public dest: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _op: Packages.mindustry.logic.LogicOp,
            _a: Packages.mindustry.logic.LVar,
            _b: Packages.mindustry.logic.LVar,
            _dest: Packages.mindustry.logic.LVar,
          );
        };
        public static SetI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public from: Packages.mindustry.logic.LVar;
          public to: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _from: Packages.mindustry.logic.LVar,
            _to: Packages.mindustry.logic.LVar,
          );
        };
        public static RadarI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public target1: Packages.mindustry.logic.RadarTarget;
          public target2: Packages.mindustry.logic.RadarTarget;
          public target3: Packages.mindustry.logic.RadarTarget;
          public sort: Packages.mindustry.logic.RadarSort;
          public radar: Packages.mindustry.logic.LVar;
          public sortOrder: Packages.mindustry.logic.LVar;
          public output: Packages.mindustry.logic.LVar;
          public lastTarget: Packages.mindustry.gen.Healthc;
          public lastSourceBuild: any;
          public timer: Packages.arc.util.Interval;
          static bestValue: number;
          static best: Packages.mindustry.gen.Unit;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          find(
            _b: Packages.mindustry.logic.Ranged,
            _range: number,
            _sortDir: number,
            _team: Packages.mindustry.game.Team,
          ): void;
          public constructor(
            _target1: Packages.mindustry.logic.RadarTarget,
            _target2: Packages.mindustry.logic.RadarTarget,
            _target3: Packages.mindustry.logic.RadarTarget,
            _sort: Packages.mindustry.logic.RadarSort,
            _radar: Packages.mindustry.logic.LVar,
            _sortOrder: Packages.mindustry.logic.LVar,
            _output: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static SenseI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public from: Packages.mindustry.logic.LVar;
          public to: Packages.mindustry.logic.LVar;
          public type: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _from: Packages.mindustry.logic.LVar,
            _to: Packages.mindustry.logic.LVar,
            _type: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static WriteI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public target: Packages.mindustry.logic.LVar;
          public position: Packages.mindustry.logic.LVar;
          public value: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _target: Packages.mindustry.logic.LVar,
            _position: Packages.mindustry.logic.LVar,
            _value: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static ReadI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public target: Packages.mindustry.logic.LVar;
          public position: Packages.mindustry.logic.LVar;
          public output: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _target: Packages.mindustry.logic.LVar,
            _position: Packages.mindustry.logic.LVar,
            _output: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static GetLinkI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public output: Packages.mindustry.logic.LVar;
          public index: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _output: Packages.mindustry.logic.LVar,
            _index: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static ControlI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public target: Packages.mindustry.logic.LVar;
          public type: Packages.mindustry.logic.LAccess;
          public p1: Packages.mindustry.logic.LVar;
          public p2: Packages.mindustry.logic.LVar;
          public p3: Packages.mindustry.logic.LVar;
          public p4: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _type: Packages.mindustry.logic.LAccess,
            _target: Packages.mindustry.logic.LVar,
            _p1: Packages.mindustry.logic.LVar,
            _p2: Packages.mindustry.logic.LVar,
            _p3: Packages.mindustry.logic.LVar,
            _p4: Packages.mindustry.logic.LVar,
          );
        };
        public static UnitControlI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public type: Packages.mindustry.logic.LUnitControl;
          public p1: Packages.mindustry.logic.LVar;
          public p2: Packages.mindustry.logic.LVar;
          public p3: Packages.mindustry.logic.LVar;
          public p4: Packages.mindustry.logic.LVar;
          public p5: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public static checkLogicAI(
            _exec: Packages.mindustry.logic.LExecutor,
            _unitObj: any,
          ): Packages.mindustry.ai._types.LogicAI | null;
          public constructor(
            _type: Packages.mindustry.logic.LUnitControl,
            _p1: Packages.mindustry.logic.LVar,
            _p2: Packages.mindustry.logic.LVar,
            _p3: Packages.mindustry.logic.LVar,
            _p4: Packages.mindustry.logic.LVar,
            _p5: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static UnitLocateI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          static Cache = class extends java.lang.Object {
            x: number;
            y: number;
            found: boolean;
            build: Packages.mindustry.gen.Building;
          };
          public locate: Packages.mindustry.logic.LLocate;
          public flag: Packages.mindustry.world.meta.BlockFlag;
          public enemy: Packages.mindustry.logic.LVar;
          public ore: Packages.mindustry.logic.LVar;
          public outX: Packages.mindustry.logic.LVar;
          public outY: Packages.mindustry.logic.LVar;
          public outFound: Packages.mindustry.logic.LVar;
          public outBuild: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _locate: Packages.mindustry.logic.LLocate,
            _flag: Packages.mindustry.world.meta.BlockFlag,
            _enemy: Packages.mindustry.logic.LVar,
            _ore: Packages.mindustry.logic.LVar,
            _outX: Packages.mindustry.logic.LVar,
            _outY: Packages.mindustry.logic.LVar,
            _outFound: Packages.mindustry.logic.LVar,
            _outBuild: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static UnitBindI = class
          extends java.lang.Object
          implements
            Packages.mindustry.logic.LExecutor.LInstruction
        {
          public type: Packages.mindustry.logic.LVar;
          public run(
            _exec: Packages.mindustry.logic.LExecutor,
          ): void;
          public constructor(
            _type: Packages.mindustry.logic.LVar,
          );
          public constructor();
        };
        public static maxInstructions: number;
        public static maxGraphicsBuffer: number;
        public static maxDisplayBuffer: number;
        public static maxTextBuffer: number;
        public instructions: Packages.mindustry.logic.LExecutor.LInstruction[];
        public vars: Packages.mindustry.logic.LVar[];
        public counter: Packages.mindustry.logic.LVar;
        public unit: Packages.mindustry.logic.LVar;
        public thisv: Packages.mindustry.logic.LVar;
        public ipt: Packages.mindustry.logic.LVar;
        public binds: number[];
        public yield: boolean;
        public graphicsBuffer: Packages.arc.struct.LongSeq;
        public textBuffer: Packages.java.lang.StringBuilder;
        public links: Packages.mindustry.gen.Building[];
        public build?: Packages.mindustry.world.blocks.logic.LogicBlock.LogicBuild;
        public linkIds: Packages.arc.struct.IntSet;
        public team: Packages.mindustry.game.Team;
        public privileged: boolean;
        protected static unitTimeouts: Packages.arc.struct.IntFloatMap;
        public load(
          _builder: Packages.mindustry.logic.LAssembler,
        ): void;
        public initialized(): boolean;
        static checkMapArea(
          _x: number,
          _y: number,
          _w: number,
          _h: number,
          _set: boolean,
        ): boolean;
        public optionalVar(
          _index: number,
        ): Packages.mindustry.logic.LVar | null;
        timeoutDone(
          _unit: Packages.mindustry.gen.Unit,
          _delay: number,
        ): boolean;
        updateTimeout(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public runOnce(): void;
        public static setMapArea(
          _x: number,
          _y: number,
          _w: number,
          _h: number,
        ): void;
        public static logicExplosion(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _radius: number,
          _damage: number,
          _air: boolean,
          _ground: boolean,
          _pierce: boolean,
          _effect: boolean,
        ): void;
        public static syncVariable(
          _building: Packages.mindustry.gen.Building,
          _variable: number,
          _value: any,
        ): void;
        public static setFlag(
          _flag: string,
          _add: boolean,
        ): void;
        public static createMarker(
          _id: number,
          _marker: Packages.mindustry.game.MapObjectives.ObjectiveMarker,
        ): void;
        public static removeMarker(_id: number): void;
        public static updateMarker(
          _id: number,
          _control: Packages.mindustry.logic.LMarkerControl,
          _p1: number,
          _p2: number,
          _p3: number,
        ): void;
        public static updateMarkerText(
          _id: number,
          _type: Packages.mindustry.logic.LMarkerControl,
          _fetch: boolean,
          _text: string,
        ): void;
        public static updateMarkerTexture(
          _id: number,
          _textureName: string,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace logic {
          declare class LogicBlock extends Packages
            .mindustry.world.Block {
            public static LogicLink = class extends java
              .lang.Object {
              public active: boolean;
              public valid: boolean;
              public x: number;
              public y: number;
              public name: string;
              public lastBuild: Packages.mindustry.gen.Building;
              public copy(): Packages.mindustry.world.blocks.logic.LogicBlock.LogicLink;
              public constructor(
                _x: number,
                _y: number,
                _name: string,
                _valid: boolean,
              );
            };
            public LogicBuild = class
              extends Packages.mindustry.gen.Building
              implements Packages.mindustry.logic.Ranged
            {
              public code: string;
              public executor: Packages.mindustry.logic.LExecutor;
              public accumulator: number;
              public links: Packages.arc.struct.Seq<Packages.mindustry.world.blocks.logic.LogicBlock.LogicLink>;
              public checkedDuplicates: boolean;
              public ipt: number;
              public tag?: string;
              public iconTag: string;
              public loadBlock?: Packages.java.lang.Runnable;
              this$0: Packages.mindustry.world.blocks.logic.LogicBlock;
              public version(): string;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public collide(
                _other: Packages.mindustry.gen.Bullet,
              ): boolean;
              public range(): number;
              public config(): any;
              public config(): string[] | null;
              public damage(_damage: number): void;
              public updateTile(): void;
              public removeFromProximity(): void;
              public displayable(): boolean;
              public getCursor(): Packages.arc.Graphics.Cursor;
              public canPickup(): boolean;
              public onConfigureBuildTapped(
                _other: Packages.mindustry.gen.Building,
              ): boolean;
              public shouldShowConfigure(
                _player: Packages.mindustry.gen.Player,
              ): boolean;
              public buildConfiguration(
                _table: Packages.arc.scene.ui.layout.Table,
              ): void;
              public drawConfigure(): void;
              public drawSelect(): void;
              public findLinkName(
                _block: Packages.mindustry.world.Block,
              ): string;
              public updateCode(_str: string): void;
              public updateCode(
                _str: string,
                _keep: boolean,
                _assemble: Packages.arc.func.Cons<Packages.mindustry.logic.LAssembler>,
              ): void;
              public validLink(
                _other: Packages.mindustry.gen.Building,
              ): boolean;
              public relativeConnections(): Packages.arc.struct.Seq<Packages.mindustry.world.blocks.logic.LogicBlock.LogicLink>;
              public readCompressed(
                _data: string[],
                _relative: boolean,
              ): void;
              public showEditDialog(): void;
              public showEditDialog(
                _forceEditor: boolean,
              ): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.logic.LogicBlock,
              );
            };
            private static maxByteLen: number;
            public static maxNameLength: number;
            public maxInstructionScale: number;
            public instructionsPerTick: number;
            public maxInstructionsPerTick: number;
            public range: number;
            public static compress(
              _code: string,
              _links: Packages.arc.struct.Seq<Packages.mindustry.world.blocks.logic.LogicBlock.LogicLink>,
            ): string[] | null;
            public static compress(
              _bytes: string[],
              _links: Packages.arc.struct.Seq<Packages.mindustry.world.blocks.logic.LogicBlock.LogicLink>,
            ): string[] | null;
            public checkForceDark(
              _tile: Packages.mindustry.world.Tile,
            ): boolean;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public canBreak(
              _tile: Packages.mindustry.world.Tile,
            ): boolean;
            public pointConfig(
              _config: any,
              _transformer: Packages.arc.func.Cons<Packages.arc.math.geom.Point2>,
            ): any;
            public setStats(): void;
            public accessible(): boolean;
            public static getLinkName(
              _block: Packages.mindustry.world.Block,
            ): string;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace editor {
      declare class MapProcessorsDialog extends Packages
        .mindustry.ui.dialogs.BaseDialog {
        private iconSelect: Packages.mindustry.ui.dialogs.IconSelectDialog;
        private search: Packages.arc.scene.ui.TextField;
        private processors: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
        private list: Packages.arc.scene.ui.layout.Table;
        private setup(): void;
        private rebuild(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class SaveDialog extends Packages.mindustry
          .ui.dialogs.LoadDialog {
          save(
            _slot: Packages.mindustry.game.Saves.SaveSlot,
          ): void;
          public addSetup(): void;
          public modifyButton(
            _button: Packages.arc.scene.ui.TextButton,
            _slot: Packages.mindustry.game.Saves.SaveSlot,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class PausedDialog extends Packages
          .mindustry.ui.dialogs.BaseDialog {
          private processors: Packages.mindustry.editor.MapProcessorsDialog;
          private save: Packages.mindustry.ui.dialogs.SaveDialog;
          private load: Packages.mindustry.ui.dialogs.LoadDialog;
          private rulesDialog: Packages.mindustry.ui.dialogs.CustomRulesDialog;
          rebuild(): void;
          public checkPlaytest(): boolean;
          public runExitSave(): void;
          showQuitConfirm(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class SettingsMenuDialog extends Packages
          .mindustry.ui.dialogs.BaseDialog {
          public static SettingsTable = class extends Packages
            .arc.scene.ui.layout.Table {
            public static SliderSetting = class extends Packages
              .mindustry.ui.dialogs.SettingsMenuDialog
              .SettingsTable.Setting {
              def: number;
              min: number;
              max: number;
              step: number;
              sp: Packages.mindustry.ui.dialogs.SettingsMenuDialog.StringProcessor;
              public add(
                _table: Packages.mindustry.ui.dialogs.SettingsMenuDialog.SettingsTable,
              ): void;
              public constructor(
                _name: string,
                _def: number,
                _min: number,
                _max: number,
                _step: number,
                _s: Packages.mindustry.ui.dialogs.SettingsMenuDialog.StringProcessor,
              );
            };
            public static CheckSetting = class extends Packages
              .mindustry.ui.dialogs.SettingsMenuDialog
              .SettingsTable.Setting {
              def: boolean;
              changed: Packages.arc.func.Boolc;
              public add(
                _table: Packages.mindustry.ui.dialogs.SettingsMenuDialog.SettingsTable,
              ): void;
              public constructor(
                _name: string,
                _def: boolean,
                _changed: Packages.arc.func.Boolc,
              );
            };
            public static TextSetting = class extends Packages
              .mindustry.ui.dialogs.SettingsMenuDialog
              .SettingsTable.Setting {
              def: string;
              changed: Packages.arc.func.Cons<string>;
              public add(
                _table: Packages.mindustry.ui.dialogs.SettingsMenuDialog.SettingsTable,
              ): void;
              public constructor(
                _name: string,
                _def: string,
                _changed: Packages.arc.func.Cons<string>,
              );
            };
            public static AreaTextSetting = class extends Packages
              .mindustry.ui.dialogs.SettingsMenuDialog
              .SettingsTable.TextSetting {
              public add(
                _table: Packages.mindustry.ui.dialogs.SettingsMenuDialog.SettingsTable,
              ): void;
              public constructor(
                _name: string,
                _def: string,
                _changed: Packages.arc.func.Cons<string>,
              );
            };
            public static Setting = class extends java.lang
              .Object {
              public name: string;
              public title: string;
              public description?: string;
              public add(
                _table: Packages.mindustry.ui.dialogs.SettingsMenuDialog.SettingsTable,
              ): void;
              public addDesc(
                _elem: Packages.arc.scene.Element,
              ): void;
              public constructor(_name: string);
            };
            protected list: Packages.arc.struct.Seq<Packages.mindustry.ui.dialogs.SettingsMenuDialog.SettingsTable.Setting>;
            public rebuild(): void;
            public checkPref(
              _name: string,
              _def: boolean,
            ): void;
            public checkPref(
              _name: string,
              _def: boolean,
              _changed: Packages.arc.func.Boolc,
            ): void;
            public sliderPref(
              _name: string,
              _def: number,
              _min: number,
              _max: number,
              _step: number,
              _s: Packages.mindustry.ui.dialogs.SettingsMenuDialog.StringProcessor,
            ): Packages.mindustry.ui.dialogs.SettingsMenuDialog.SettingsTable.SliderSetting;
            public sliderPref(
              _name: string,
              _def: number,
              _min: number,
              _max: number,
              _s: Packages.mindustry.ui.dialogs.SettingsMenuDialog.StringProcessor,
            ): Packages.mindustry.ui.dialogs.SettingsMenuDialog.SettingsTable.SliderSetting;
            public getSettings(): Packages.arc.struct.Seq<Packages.mindustry.ui.dialogs.SettingsMenuDialog.SettingsTable.Setting>;
            public pref(
              _setting: Packages.mindustry.ui.dialogs.SettingsMenuDialog.SettingsTable.Setting,
            ): void;
            public textPref(
              _name: string,
              _def: string,
              _changed: Packages.arc.func.Cons<string>,
            ): void;
            public textPref(
              _name: string,
              _def: string,
            ): void;
            public areaTextPref(
              _name: string,
              _def: string,
            ): void;
            public areaTextPref(
              _name: string,
              _def: string,
              _changed: Packages.arc.func.Cons<string>,
            ): void;
            public constructor();
          };
          public static SettingsCategory = class extends java
            .lang.Object {
            public name: string;
            public icon?: Packages.arc.scene.style.Drawable;
            public builder: Packages.arc.func.Cons<Packages.mindustry.ui.dialogs.SettingsMenuDialog.SettingsTable>;
            public table: Packages.mindustry.ui.dialogs.SettingsMenuDialog.SettingsTable;
            public constructor(
              _name: string,
              _icon: Packages.arc.scene.style.Drawable,
              _builder: Packages.arc.func.Cons<Packages.mindustry.ui.dialogs.SettingsMenuDialog.SettingsTable>,
            );
          };
          public static StringProcessor = class {
            public get(_i: number): string;
          };
          public graphics: Packages.mindustry.ui.dialogs.SettingsMenuDialog.SettingsTable;
          public game: Packages.mindustry.ui.dialogs.SettingsMenuDialog.SettingsTable;
          public sound: Packages.mindustry.ui.dialogs.SettingsMenuDialog.SettingsTable;
          public main: Packages.mindustry.ui.dialogs.SettingsMenuDialog.SettingsTable;
          private prefs: Packages.arc.scene.ui.layout.Table;
          private menu: Packages.arc.scene.ui.layout.Table;
          private dataDialog: Packages.mindustry.ui.dialogs.BaseDialog;
          private categories: Packages.arc.struct.Seq<Packages.mindustry.ui.dialogs.SettingsMenuDialog.SettingsCategory>;
          private back(): void;
          private visible(_index: number): void;
          public addCloseButton(): void;
          rebuildMenu(): void;
          addSettings(): void;
          public addCategory(
            _name: string,
            _region: string | null,
            _builder: Packages.arc.func.Cons<Packages.mindustry.ui.dialogs.SettingsMenuDialog.SettingsTable>,
          ): void;
          public addCategory(
            _name: string,
            _builder: Packages.arc.func.Cons<Packages.mindustry.ui.dialogs.SettingsMenuDialog.SettingsTable>,
          ): void;
          public addCategory(
            _name: string,
            _icon: Packages.arc.scene.style.Drawable | null,
            _builder: Packages.arc.func.Cons<Packages.mindustry.ui.dialogs.SettingsMenuDialog.SettingsTable>,
          ): void;
          getLogs(): string;
          public importData(
            _file: Packages.arc.files.Fi,
          ): void;
          public exportData(
            _file: Packages.arc.files.Fi,
          ): void;
          public getCategories(): Packages.arc.struct.Seq<Packages.mindustry.ui.dialogs.SettingsMenuDialog.SettingsCategory>;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class KeybindDialog extends Packages.arc
          .scene.ui.Dialog {
          protected section: Packages.arc.KeyBinds.Section;
          protected rebindKey: Packages.arc.KeyBinds.KeyBind;
          protected rebindAxis: boolean;
          protected rebindMin: boolean;
          protected minKey: Packages.arc.input.KeyCode;
          protected rebindDialog: Packages.arc.scene.ui.Dialog;
          protected scroll: number;
          protected sectionControls: Packages.arc.struct.ObjectIntMap<Packages.arc.KeyBinds.Section>;
          private setup(): void;
          rebind(
            _section: Packages.arc.KeyBinds.Section,
            _bind: Packages.arc.KeyBinds.KeyBind,
            _newKey: Packages.arc.input.KeyCode,
          ): void;
          public addCloseButton(): void;
          private openDialog(
            _section: Packages.arc.KeyBinds.Section,
            _name: Packages.arc.KeyBinds.KeyBind,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace editor {
      declare class EditorTool extends Packages.java.lang
        .Enum<Packages.mindustry.editor.EditorTool> {
        public static zoom: Packages.mindustry.editor.EditorTool;
        public static pick: Packages.mindustry.editor.EditorTool;
        public static line: Packages.mindustry.editor.EditorTool;
        public static pencil: Packages.mindustry.editor.EditorTool;
        public static eraser: Packages.mindustry.editor.EditorTool;
        public static fill: Packages.mindustry.editor.EditorTool;
        public static spray: Packages.mindustry.editor.EditorTool;
        public static all: Packages.mindustry.editor.EditorTool[];
        public altModes: string[];
        public key: Packages.arc.input.KeyCode;
        public mode: number;
        public edit: boolean;
        public draggable: boolean;
        private static $VALUES: Packages.mindustry.editor.EditorTool[];
        public static values():
          | Packages.mindustry.editor.EditorTool[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.mindustry.editor.EditorTool;
        public touched(_x: number, _y: number): void;
        public touchedLine(
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare class GridImage extends Packages.arc.scene
        .Element {
        private imageWidth: number;
        private imageHeight: number;
        public draw(): void;
        public setImageSize(_w: number, _h: number): void;
        public constructor(_w: number, _h: number);
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace editor {
      declare class MapView
        extends Packages.arc.scene.Element
        implements
          Packages.arc.input.GestureDetector.GestureListener
      {
        tool: Packages.mindustry.editor.EditorTool;
        private offsetx: number;
        private offsety: number;
        private grid: boolean;
        private image: Packages.mindustry.ui.GridImage;
        private vec: Packages.arc.math.geom.Vec2;
        private rect: Packages.arc.math.geom.Rect;
        private brushPolygons: Packages.arc.math.geom.Vec2[][];
        drawing: boolean;
        lastx: number;
        lasty: number;
        startx: number;
        starty: number;
        mousex: number;
        mousey: number;
        lastTool: Packages.mindustry.editor.EditorTool;
        private active(): boolean;
        public draw(): void;
        public pan(
          _x: number,
          _y: number,
          _deltaX: number,
          _deltaY: number,
        ): boolean;
        private unproject(
          _x: number,
          _y: number,
        ): Packages.arc.math.geom.Vec2;
        project(
          _x: number,
          _y: number,
        ): Packages.arc.math.geom.Point2;
        public act(_delta: number): void;
        public center(): void;
        public zoom(
          _initialDistance: number,
          _distance: number,
        ): boolean;
        public pinch(
          _initialPointer1: Packages.arc.math.geom.Vec2,
          _initialPointer2: Packages.arc.math.geom.Vec2,
          _pointer1: Packages.arc.math.geom.Vec2,
          _pointer2: Packages.arc.math.geom.Vec2,
        ): boolean;
        public pinchStop(): void;
        public getTool(): Packages.mindustry.editor.EditorTool;
        public setTool(
          _tool: Packages.mindustry.editor.EditorTool,
        ): void;
        public isGrid(): boolean;
        public setGrid(_grid: boolean): void;
        private clampZoom(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace editor {
      declare class WaveGraph extends Packages.arc.scene.ui
        .layout.Table {
        static Mode = class extends Packages.java.lang
          .Enum<Packages.mindustry.editor.WaveGraph.Mode> {
          public static counts: Packages.mindustry.editor.WaveGraph.Mode;
          public static totals: Packages.mindustry.editor.WaveGraph.Mode;
          public static health: Packages.mindustry.editor.WaveGraph.Mode;
          static all: Packages.mindustry.editor.WaveGraph.Mode[];
          private static $VALUES: Packages.mindustry.editor.WaveGraph.Mode[];
          public static values():
            | Packages.mindustry.editor.WaveGraph.Mode[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.mindustry.editor.WaveGraph.Mode;
        };
        public groups: Packages.arc.struct.Seq<Packages.mindustry.game.SpawnGroup>;
        public from: number;
        public to: number;
        private mode: Packages.mindustry.editor.WaveGraph.Mode;
        private values: number[][];
        private used: Packages.arc.struct.OrderedSet<Packages.mindustry._type.UnitType>;
        private max: number;
        private maxTotal: number;
        private maxHealth: number;
        private colors: Packages.arc.scene.ui.layout.Table;
        private hidden: Packages.arc.struct.ObjectSet<Packages.mindustry._type.UnitType>;
        color(
          _type: Packages.mindustry._type.UnitType,
        ): Packages.arc.graphics.Color;
        public rebuild(): void;
        nextStep(_value: number): number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace editor {
      declare class WaveInfoDialog extends Packages
        .mindustry.ui.dialogs.BaseDialog {
        static Sort = class extends Packages.java.lang
          .Enum<Packages.mindustry.editor.WaveInfoDialog.Sort> {
          public static begin: Packages.mindustry.editor.WaveInfoDialog.Sort;
          public static health: Packages.mindustry.editor.WaveInfoDialog.Sort;
          public static type: Packages.mindustry.editor.WaveInfoDialog.Sort;
          static all: Packages.mindustry.editor.WaveInfoDialog.Sort[];
          sort: Packages.arc.func.Floatf<Packages.mindustry.game.SpawnGroup>;
          secondary: Packages.arc.func.Floatf<Packages.mindustry.game.SpawnGroup>;
          private static $VALUES: Packages.mindustry.editor.WaveInfoDialog.Sort[];
          public static values():
            | Packages.mindustry.editor.WaveInfoDialog.Sort[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.mindustry.editor.WaveInfoDialog.Sort;
        };
        private start: number;
        private displayed: number;
        groups: Packages.arc.struct.Seq<Packages.mindustry.game.SpawnGroup>;
        private expandedGroup?: Packages.mindustry.game.SpawnGroup;
        private table: Packages.arc.scene.ui.layout.Table;
        private search: number;
        private filterType?: Packages.mindustry._type.UnitType;
        private sort: Packages.mindustry.editor.WaveInfoDialog.Sort;
        private reverseSort: boolean;
        private updateTimer: number;
        private updatePeriod: number;
        private checkedSpawns: boolean;
        private graph: Packages.mindustry.editor.WaveGraph;
        setup(): void;
        shift(_amount: number): void;
        view(_amount: number): void;
        updateWaves(): void;
        buildGroups(): void;
        showUnits(
          _cons: Packages.arc.func.Cons<Packages.mindustry._type.UnitType>,
          _reset: boolean,
        ): void;
        showEffects(
          _group: Packages.mindustry.game.SpawnGroup,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare class CachedTile extends Packages.mindustry
        .world.Tile {
        protected preChanged(): void;
        protected changeBuild(
          _team: Packages.mindustry.game.Team,
          _entityprov: Packages.arc.func.Prov<Packages.mindustry.gen.Building>,
          _rotation: number,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace editor {
      declare class MapGenerateDialog extends Packages
        .mindustry.ui.dialogs.BaseDialog {
        applied: boolean;
        pixmap: Packages.arc.graphics.Pixmap;
        texture: Packages.arc.graphics.Texture;
        input: Packages.mindustry.maps.filters.GenerateFilter.GenerateInput;
        filters: Packages.arc.struct.Seq<Packages.mindustry.maps.filters.GenerateFilter>;
        scaling: number;
        filterTable: Packages.arc.scene.ui.layout.Table;
        result: Packages.java.util.concurrent.Future<any>;
        generating: boolean;
        buffer1: Packages.long[];
        buffer2: Packages.long[];
        applier: Packages.arc.func.Cons<
          Packages.arc.struct.Seq<Packages.mindustry.maps.filters.GenerateFilter>
        >;
        ctile: Packages.mindustry.world.CachedTile;
        update(): void;
        apply(): void;
        setup(): void;
        create(): Packages.long[] | null;
        pack(
          _tile: Packages.mindustry.world.Tile,
        ): Packages.long;
        public show(
          _applier: Packages.arc.func.Cons<
            Packages.arc.struct.Seq<Packages.mindustry.maps.filters.GenerateFilter>
          >,
        ): void;
        public show(
          _filters: Packages.arc.struct.Seq<Packages.mindustry.maps.filters.GenerateFilter>,
          _applier: Packages.arc.func.Cons<
            Packages.arc.struct.Seq<Packages.mindustry.maps.filters.GenerateFilter>
          >,
        ): void;
        unpack(
          _tile: Packages.long,
        ): Packages.mindustry.world.Tile;
        public applyToEditor(
          _filters: Packages.arc.struct.Seq<Packages.mindustry.maps.filters.GenerateFilter>,
        ): void;
        showAdd(): void;
        rebuildFilters(): void;
        public constructor(_applied: boolean);
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace editor {
      declare class MapObjectivesCanvas extends Packages.arc
        .scene.ui.layout.WidgetGroup {
        public ObjectiveTilemap = class extends Packages.arc
          .scene.ui.layout.WidgetGroup {
          public ObjectiveTile = class extends Packages.arc
            .scene.ui.layout.Table {
            public Connector = class extends Packages.arc
              .scene.ui.Button {
              public pointX: number;
              public pointY: number;
              public findParent: boolean;
              this$2: Packages.mindustry.editor.MapObjectivesCanvas.ObjectiveTilemap.ObjectiveTile;
              public draw(): void;
              public isPressed(): boolean;
              public isOver(): boolean;
              public tile(): Packages.mindustry.editor.MapObjectivesCanvas.ObjectiveTilemap.ObjectiveTile;
              public canConnectTo(
                _other: Packages.mindustry.editor.MapObjectivesCanvas.ObjectiveTilemap.ObjectiveTile.Connector,
              ): boolean;
              public constructor(
                _this$2: Packages.mindustry.editor.MapObjectivesCanvas.ObjectiveTilemap.ObjectiveTile,
                _findParent: boolean,
              );
            };
            public Mover = class extends Packages.arc.scene
              .event.InputListener {
              public prevX: number;
              public prevY: number;
              public lastX: number;
              public lastY: number;
              this$2: Packages.mindustry.editor.MapObjectivesCanvas.ObjectiveTilemap.ObjectiveTile;
              public touchDown(
                _event: Packages.arc.scene.event.InputEvent,
                _x: number,
                _y: number,
                _pointer: number,
                _button: Packages.arc.input.KeyCode,
              ): boolean;
              public touchDragged(
                _event: Packages.arc.scene.event.InputEvent,
                _x: number,
                _y: number,
                _pointer: number,
              ): void;
              public touchUp(
                _event: Packages.arc.scene.event.InputEvent,
                _x: number,
                _y: number,
                _pointer: number,
                _button: Packages.arc.input.KeyCode,
              ): void;
              public constructor(
                _this$2: Packages.mindustry.editor.MapObjectivesCanvas.ObjectiveTilemap.ObjectiveTile,
              );
            };
            public obj: Packages.mindustry.game.MapObjectives.MapObjective;
            public tx: number;
            public ty: number;
            public mover: Packages.mindustry.editor.MapObjectivesCanvas.ObjectiveTilemap.ObjectiveTile.Mover;
            public conParent: Packages.mindustry.editor.MapObjectivesCanvas.ObjectiveTilemap.ObjectiveTile.Connector;
            public conChildren: Packages.mindustry.editor.MapObjectivesCanvas.ObjectiveTilemap.ObjectiveTile.Connector;
            this$1: Packages.mindustry.editor.MapObjectivesCanvas.ObjectiveTilemap;
            public remove(): boolean;
            public pos(_x: number, _y: number): void;
            public getPrefWidth(): number;
            public getPrefHeight(): number;
            public constructor(
              _this$1: Packages.mindustry.editor.MapObjectivesCanvas.ObjectiveTilemap,
              _obj: Packages.mindustry.game.MapObjectives.MapObjective,
              _x: number,
              _y: number,
            );
          };
          protected connecting?: Packages.mindustry.editor.MapObjectivesCanvas.ObjectiveTilemap.ObjectiveTile.Connector;
          protected moving?: Packages.mindustry.editor.MapObjectivesCanvas.ObjectiveTilemap.ObjectiveTile;
          this$0: Packages.mindustry.editor.MapObjectivesCanvas;
          public draw(): void;
          public getPrefWidth(): number;
          public getPrefHeight(): number;
          public removeTile(
            _tile: Packages.mindustry.editor.MapObjectivesCanvas.ObjectiveTilemap.ObjectiveTile,
          ): void;
          public validPlace(
            _x: number,
            _y: number,
            _ignore: Packages.mindustry.editor.MapObjectivesCanvas.ObjectiveTilemap.ObjectiveTile | null,
          ): boolean;
          public clearTiles(): void;
          protected drawCurve(
            _remove: boolean,
            _x1: number,
            _y1: number,
            _x2: number,
            _y2: number,
          ): void;
          public createTile(
            _obj: Packages.mindustry.game.MapObjectives.MapObjective,
          ): boolean;
          public createTile(
            _x: number,
            _y: number,
            _obj: Packages.mindustry.game.MapObjectives.MapObjective,
          ): boolean;
          public moveTile(
            _tile: Packages.mindustry.editor.MapObjectivesCanvas.ObjectiveTilemap.ObjectiveTile,
            _newX: number,
            _newY: number,
          ): boolean;
          public constructor(
            _this$0: Packages.mindustry.editor.MapObjectivesCanvas,
          );
        };
        public static objWidth: number;
        public static objHeight: number;
        public static bounds: number;
        public unitSize: number;
        public objectives: Packages.arc.struct.Seq<Packages.mindustry.game.MapObjectives.MapObjective>;
        public tilemap: Packages.mindustry.editor.MapObjectivesCanvas.ObjectiveTilemap;
        private pressed: boolean;
        private visualPressed: Packages.long;
        private queryX: number;
        private queryY: number;
        public query(
          _obj: Packages.mindustry.game.MapObjectives.MapObjective,
        ): void;
        public isVisualPressed(): boolean;
        public clearObjectives(): void;
        protected stopQuery(): void;
        public isQuerying(): boolean;
        public placeQuery(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace editor {
      declare class MapObjectivesDialog extends Packages
        .mindustry.ui.dialogs.BaseDialog {
        public static FieldInterpreter = class<T> {
          public build(
            _cont: Packages.arc.scene.ui.layout.Table,
            _name: Packages.java.lang.CharSequence,
            _type: Packages.mindustry.editor.MapObjectivesDialog.TypeInfo,
            _field: Packages.java.lang.reflect.Field | null,
            _remover: Packages.java.lang.Runnable | null,
            _indexer: Packages.arc.func.Boolc | null,
            _get: Packages.arc.func.Prov<T>,
            _set: Packages.arc.func.Cons<T>,
          ): void;
        };
        public static FieldProvider = class<T> {
          public get(
            _type: Packages.mindustry.editor.MapObjectivesDialog.TypeInfo,
            _cons: Packages.arc.func.Cons<T>,
          ): void;
        };
        public static TypeInfo = class extends java.lang
          .Object {
          public raw: Packages.java.lang.Class<any>;
          public element: Packages.mindustry.editor.MapObjectivesDialog.TypeInfo;
          public key: Packages.mindustry.editor.MapObjectivesDialog.TypeInfo;
          public static raw(
            _type: Packages.java.lang.reflect.Type,
          ): Packages.java.lang.Class<any>;
          public static getParam(
            _generic: Packages.java.lang.reflect.Type,
            _index: number,
          ): Packages.mindustry.editor.MapObjectivesDialog.TypeInfo;
          public constructor(
            _raw:
              | Class<any>
              | Packages.java.lang.Class<any>,
            _generic: Packages.java.lang.reflect.Type,
          );
          public constructor(
            _raw:
              | Class<any>
              | Packages.java.lang.Class<any>,
            _element: Packages.mindustry.editor.MapObjectivesDialog.TypeInfo,
          );
          public constructor(
            _raw:
              | Class<any>
              | Packages.java.lang.Class<any>,
          );
          public constructor(
            _field: Packages.java.lang.reflect.Field,
          );
        };
        public canvas: Packages.mindustry.editor.MapObjectivesCanvas;
        protected out: Packages.arc.func.Cons<
          Packages.arc.struct.Seq<Packages.mindustry.game.MapObjectives.MapObjective>
        >;
        private static providers: Packages.arc.struct.ObjectMap<
          Packages.java.lang.Class<any>,
          Packages.mindustry.editor.MapObjectivesDialog.FieldProvider<any>
        >;
        private static interpreters: Packages.arc.struct.ObjectMap<
          Packages.java.lang.Class<any>,
          Packages.arc.struct.ObjectMap<
            Packages.java.lang.Class<any>,
            Packages.mindustry.editor.MapObjectivesDialog.FieldInterpreter<any>
          >
        >;
        public static name(
          _cont: Packages.arc.scene.ui.layout.Table,
          _name: Packages.java.lang.CharSequence,
          _remover: Packages.java.lang.Runnable | null,
          _indexer: Packages.arc.func.Boolc | null,
        ): void;
        public static unbox(
          _boxed:
            | Class<any>
            | Packages.java.lang.Class<any>,
        ): Packages.java.lang.Class<any>;
        public static getProvider<T>(
          _type: Class<T> | Packages.java.lang.Class<T>,
        ): Packages.mindustry.editor.MapObjectivesDialog.FieldProvider<T>;
        public show(
          _objectives: Packages.arc.struct.Seq<Packages.mindustry.game.MapObjectives.MapObjective>,
          _out: Packages.arc.func.Cons<
            Packages.arc.struct.Seq<Packages.mindustry.game.MapObjectives.MapObjective>
          >,
        ): void;
        public static setInterpreter<T>(
          _anno: Class<any> | Packages.java.lang.Class<any>,
          _type: Class<T> | Packages.java.lang.Class<T>,
          _interpreter: Packages.mindustry.editor.MapObjectivesDialog.FieldInterpreter<any>,
        ): void;
        public static setInterpreter<T>(
          _type: Class<T> | Packages.java.lang.Class<T>,
          _interpreter: Packages.mindustry.editor.MapObjectivesDialog.FieldInterpreter<any>,
        ): void;
        public static hasInterpreter(
          _type: Class<any> | Packages.java.lang.Class<any>,
        ): boolean;
        public static hasInterpreter(
          _anno: Class<any> | Packages.java.lang.Class<any>,
          _type: Class<any> | Packages.java.lang.Class<any>,
        ): boolean;
        public static getInterpreter<T>(
          _type: Class<T> | Packages.java.lang.Class<T>,
        ): Packages.mindustry.editor.MapObjectivesDialog.FieldInterpreter<T>;
        public static getInterpreter<T>(
          _anno: Class<any> | Packages.java.lang.Class<any>,
          _type: Class<T> | Packages.java.lang.Class<T>,
        ): Packages.mindustry.editor.MapObjectivesDialog.FieldInterpreter<T>;
        public static showTeamSelect(
          _cons: Packages.arc.func.Cons<Packages.mindustry.game.Team>,
        ): void;
        public static showContentSelect<
          T extends
            Packages.mindustry.ctype.UnlockableContent,
        >(
          _type: Packages.mindustry.ctype.ContentType | null,
          _cons: Packages.arc.func.Cons<T>,
          _check: Packages.arc.func.Boolf<T>,
        ): void;
        public static setProvider<T>(
          _type: Class<T> | Packages.java.lang.Class<T>,
          _provider: Packages.mindustry.editor.MapObjectivesDialog.FieldProvider<T>,
        ): void;
        public static defaultInterpreter<
          T,
        >(): Packages.mindustry.editor.MapObjectivesDialog.FieldInterpreter<T>;
        public static hasProvider(
          _type: Class<any> | Packages.java.lang.Class<any>,
        ): boolean;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace editor {
      declare class MapLocalesDialog extends Packages
        .mindustry.ui.dialogs.BaseDialog {
        private static PropertyStatus = class extends Packages
          .java.lang
          .Enum<Packages.mindustry.editor.MapLocalesDialog.PropertyStatus> {
          public static correct: Packages.mindustry.editor.MapLocalesDialog.PropertyStatus;
          public static missing: Packages.mindustry.editor.MapLocalesDialog.PropertyStatus;
          public static same: Packages.mindustry.editor.MapLocalesDialog.PropertyStatus;
          private static $VALUES: Packages.mindustry.editor.MapLocalesDialog.PropertyStatus[];
          public static values():
            | Packages.mindustry.editor.MapLocalesDialog.PropertyStatus[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.mindustry.editor.MapLocalesDialog.PropertyStatus;
        };
        private static cardWidth: number;
        private static filterStyle: Packages.arc.scene.ui.TextButton.TextButtonStyle;
        private static contentIcons: Packages.mindustry.ctype.ContentType[];
        private locales: Packages.mindustry._type.MapLocales;
        private lastSaved: Packages.mindustry._type.MapLocales;
        private saved: boolean;
        private langs: Packages.arc.scene.ui.layout.Table;
        private main: Packages.arc.scene.ui.layout.Table;
        private propView: Packages.arc.scene.ui.layout.Table;
        private selectedLocale: string;
        private applytoall: boolean;
        private collapsed: boolean;
        private searchString: string;
        private searchByValue: boolean;
        private showCorrect: boolean;
        private showMissing: boolean;
        private showSame: boolean;
        private setup(): void;
        public show(
          _locales: Packages.mindustry._type.MapLocales,
        ): void;
        private buildTables(): void;
        private buildLocalesTable(): void;
        private buildMain(): void;
        private updateCard(
          _table: Packages.arc.scene.ui.layout.Table,
          _propKey: string,
          _propValue: string,
        ): void;
        private updateCard(
          _table: Packages.arc.scene.ui.layout.Table,
          _propKey: string,
          _propValue: string,
          _locale: string,
          _viewCard: boolean,
        ): void;
        private getPropertyStatus(
          _propKey: string,
          _propValue: string,
          _locale: string,
          _forView: boolean,
        ): Packages.mindustry.editor.MapLocalesDialog.PropertyStatus;
        private buildPropView(_key: string): void;
        private writeLocale(_key: string): string;
        private iconsTable(
          _table: Packages.arc.scene.ui.layout.Table,
          _search: string,
          _dialog: Packages.arc.scene.ui.Dialog,
          _cons: Packages.arc.func.Cons<string>,
        ): void;
        private filterDialog(
          _hidden: Packages.java.lang.Runnable,
        ): void;
        private readBundles(
          _data: string,
        ): Packages.mindustry._type.MapLocales;
        private writeBundles(): string;
        private readLocale(
          _data: string,
        ): Packages.arc.struct.StringMap;
        private addIconDialog(
          _cons: Packages.arc.func.Cons<string>,
        ): void;
        private viewPropertyDialog(_key: string): void;
        private propEditDialog(
          _card: Packages.arc.scene.ui.layout.Table,
          _key: string,
          _value: string,
        ): void;
        private localeEditDialog(_locale: string): void;
        private addLocaleDialog(): void;
        private editDialog(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace editor {
      declare class MapInfoDialog extends Packages.mindustry
        .ui.dialogs.BaseDialog {
        private waveInfo: Packages.mindustry.editor.WaveInfoDialog;
        private generate: Packages.mindustry.editor.MapGenerateDialog;
        private ruleInfo: Packages.mindustry.ui.dialogs.CustomRulesDialog;
        private objectives: Packages.mindustry.editor.MapObjectivesDialog;
        private locales: Packages.mindustry.editor.MapLocalesDialog;
        private processors: Packages.mindustry.editor.MapProcessorsDialog;
        private setup(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace editor {
      declare class MapLoadDialog extends Packages.mindustry
        .ui.dialogs.BaseDialog {
        private selected?: Packages.mindustry.maps.Map;
        public rebuild(): void;
        public constructor(
          _loader: Packages.arc.func.Cons<Packages.mindustry.maps.Map>,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace editor {
      declare class MapResizeDialog extends Packages
        .mindustry.ui.dialogs.BaseDialog {
        public static ResizeListener = class {
          public get(
            _width: number,
            _height: number,
            _shiftX: number,
            _shiftY: number,
          ): void;
        };
        public static minSize: number;
        public static maxSize: number;
        public static increment: number;
        width: number;
        height: number;
        shiftX: number;
        shiftY: number;
        public constructor(
          _cons: Packages.mindustry.editor.MapResizeDialog.ResizeListener,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace editor {
      declare class SectorGenerateDialog extends Packages
        .mindustry.ui.dialogs.BaseDialog {
        planet: Packages.mindustry._type.Planet;
        sector: number;
        seed: number;
        apply(): void;
        setup(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace editor {
      declare class MapEditorDialog
        extends Packages.arc.scene.ui.Dialog
        implements Packages.arc.util.Disposable
      {
        private view: Packages.mindustry.editor.MapView;
        private infoDialog: Packages.mindustry.editor.MapInfoDialog;
        private loadDialog: Packages.mindustry.editor.MapLoadDialog;
        private resizeDialog: Packages.mindustry.editor.MapResizeDialog;
        private generateDialog: Packages.mindustry.editor.MapGenerateDialog;
        private sectorGenDialog: Packages.mindustry.editor.SectorGenerateDialog;
        private playtestDialog: Packages.mindustry.ui.dialogs.MapPlayDialog;
        private pane: Packages.arc.scene.ui.ScrollPane;
        private menu: Packages.mindustry.ui.dialogs.BaseDialog;
        private blockSelection: Packages.arc.scene.ui.layout.Table;
        private lastSavedRules: Packages.mindustry.game.Rules;
        private saved: boolean;
        private shownWithMap: boolean;
        private blocksOut: Packages.arc.struct.Seq<Packages.mindustry.world.Block>;
        public save(): Packages.mindustry.maps.Map | null;
        public build(): void;
        public dispose(): void;
        public hide(): void;
        public show(): Packages.arc.scene.ui.Dialog;
        public resumeAfterPlaytest(
          _map: Packages.mindustry.maps.Map,
        ): void;
        private playtest(): void;
        public beginEditMap(
          _file: Packages.arc.files.Fi,
        ): void;
        public resumeEditing(): void;
        private createDialog(
          _title: string,
          ..._arguments: any[]
        ): void;
        private editInGame(): void;
        public getView(): Packages.mindustry.editor.MapView;
        public getGenerateDialog(): Packages.mindustry.editor.MapGenerateDialog;
        public resetSaved(): void;
        public hasPane(): boolean;
        private addBlockSelection(
          _cont: Packages.arc.scene.ui.layout.Table,
        ): void;
        protected handleSaveBuiltin(
          _map: Packages.mindustry.maps.Map,
        ): void;
        private rebuildBlockSelection(
          _searchText: string,
        ): void;
        private tryExit(): void;
        private doInput(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class LanguageDialog extends Packages
          .mindustry.ui.dialogs.BaseDialog {
          public static displayNames: Packages.arc.struct.ObjectMap<
            string,
            string
          >;
          private lastLocale: Packages.java.util.Locale;
          private setup(): void;
          public static getDisplayName(
            _locale: Packages.java.util.Locale,
          ): string;
          public getLocale(): Packages.java.util.Locale;
          findClosestLocale(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class BansDialog extends Packages.mindustry
          .ui.dialogs.BaseDialog {
          private setup(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class AdminsDialog extends Packages
          .mindustry.ui.dialogs.BaseDialog {
          private setup(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class TraceDialog extends Packages.mindustry
          .ui.dialogs.BaseDialog {
          private copy(_content: string): void;
          public show(
            _player: Packages.mindustry.gen.Player,
            _info: Packages.mindustry.net.Administration.TraceInfo,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class DatabaseDialog extends Packages
          .mindustry.ui.dialogs.BaseDialog {
          private search: Packages.arc.scene.ui.TextField;
          private all: Packages.arc.scene.ui.layout.Table;
          rebuild(): void;
          unlocked(
            _content: Packages.mindustry.ctype.UnlockableContent,
          ): boolean;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class ContentInfoDialog extends Packages
          .mindustry.ui.dialogs.BaseDialog {
          public show(
            _content: Packages.mindustry.ctype.UnlockableContent,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class LaunchLoadoutDialog extends Packages
          .mindustry.ui.dialogs.BaseDialog {
          loadout: Packages.mindustry.ui.dialogs.LoadoutDialog;
          total: Packages.mindustry._type.ItemSeq;
          selected: Packages.mindustry.game.Schematic;
          valid: boolean;
          lastCapacity: number;
          getMax(): boolean;
          public show(
            _core: Packages.mindustry.world.blocks.storage.CoreBlock,
            _sector: Packages.mindustry._type.Sector,
            _destination: Packages.mindustry._type.Sector,
            _confirm: Packages.java.lang.Runnable,
          ): void;
          setMax(_max: boolean): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class PlanetDialog
          extends Packages.mindustry.ui.dialogs.BaseDialog
          implements
            Packages.mindustry.graphics.g3d.PlanetRenderer
              .PlanetInterfaceRenderer
        {
          public static Mode = class extends Packages.java
            .lang
            .Enum<Packages.mindustry.ui.dialogs.PlanetDialog.Mode> {
            public static look: Packages.mindustry.ui.dialogs.PlanetDialog.Mode;
            public static select: Packages.mindustry.ui.dialogs.PlanetDialog.Mode;
            public static planetLaunch: Packages.mindustry.ui.dialogs.PlanetDialog.Mode;
            private static $VALUES: Packages.mindustry.ui.dialogs.PlanetDialog.Mode[];
            public static values():
              | Packages.mindustry.ui.dialogs.PlanetDialog.Mode[]
              | null;
            public static valueOf(
              _name: string,
            ): Packages.mindustry.ui.dialogs.PlanetDialog.Mode;
          };
          public static debugSelect: boolean;
          public static sectorShowDuration: number;
          public buffer: Packages.arc.graphics.gl.FrameBuffer;
          public loadouts: Packages.mindustry.ui.dialogs.LaunchLoadoutDialog;
          public planets: Packages.mindustry.graphics.g3d.PlanetRenderer;
          public state: Packages.mindustry.graphics.g3d.PlanetParams;
          public zoom: number;
          public selected?: Packages.mindustry._type.Sector;
          public hovered?: Packages.mindustry._type.Sector;
          public launchSector?: Packages.mindustry._type.Sector;
          public mode: Packages.mindustry.ui.dialogs.PlanetDialog.Mode;
          public launching: boolean;
          public listener: Packages.arc.func.Cons<Packages.mindustry._type.Sector>;
          public newPresets: Packages.arc.struct.Seq<Packages.mindustry._type.Sector>;
          public presetShow: number;
          public showed: boolean;
          public sectorsShown: boolean;
          public searchText: string;
          public sectorTop: Packages.arc.scene.ui.layout.Table;
          public notifs: Packages.arc.scene.ui.layout.Table;
          public expandTable: Packages.arc.scene.ui.layout.Table;
          public hoverLabel: Packages.arc.scene.ui.Label;
          private planetTextures: Packages.arc.graphics.Texture[];
          setup(): void;
          public draw(): void;
          public act(_delta: number): void;
          public show(): Packages.arc.scene.ui.Dialog;
          public lookAt(
            _sector: Packages.mindustry._type.Sector,
            _alpha: number,
          ): void;
          public lookAt(
            _sector: Packages.mindustry._type.Sector,
          ): void;
          selectable(
            _planet: Packages.mindustry._type.Planet,
          ): boolean;
          public renderProjections(
            _planet: Packages.mindustry._type.Planet,
          ): void;
          public renderSectors(
            _planet: Packages.mindustry._type.Planet,
          ): void;
          public abandonSectorConfirm(
            _sector: Packages.mindustry._type.Sector,
            _listener: Packages.java.lang.Runnable,
          ): void;
          rebuildButtons(): void;
          updateSelected(): void;
          addBack(): void;
          addTech(): void;
          rebuildExpand(): void;
          canSelect(
            _sector: Packages.mindustry._type.Sector,
          ): boolean;
          findLauncher(
            _to: Packages.mindustry._type.Sector,
          ): Packages.mindustry._type.Sector;
          showing(): boolean;
          displayItems(
            _c: Packages.arc.scene.ui.layout.Table,
            _scl: number,
            _stats: Packages.arc.struct.ObjectMap<
              Packages.mindustry._type.Item,
              Packages.mindustry.game.SectorInfo.ExportStat
            >,
            _name: string,
            _builder: Packages.arc.func.Cons<Packages.arc.scene.ui.layout.Table>,
          ): void;
          displayItems(
            _c: Packages.arc.scene.ui.layout.Table,
            _scl: number,
            _stats: Packages.arc.struct.ObjectMap<
              Packages.mindustry._type.Item,
              Packages.mindustry.game.SectorInfo.ExportStat
            >,
            _name: string,
          ): void;
          addSurvivedInfo(
            _sector: Packages.mindustry._type.Sector,
            _table: Packages.arc.scene.ui.layout.Table,
            _wrap: boolean,
          ): void;
          selectSector(
            _sector: Packages.mindustry._type.Sector,
          ): void;
          showStats(
            _sector: Packages.mindustry._type.Sector,
          ): void;
          rebuildList(): void;
          public showOverview(): void;
          public showPlanetLaunch(
            _sector: Packages.mindustry._type.Sector,
            _listener: Packages.arc.func.Cons<Packages.mindustry._type.Sector>,
          ): void;
          public showSelect(
            _sector: Packages.mindustry._type.Sector,
            _listener: Packages.arc.func.Cons<Packages.mindustry._type.Sector>,
          ): void;
          playSelected(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare class ItemsDisplay extends Packages.arc.scene
        .ui.layout.Table {
        collapsed: boolean;
        public rebuild(
          _items: Packages.mindustry._type.ItemSeq,
          _shine: boolean[] | null,
        ): void;
        public rebuild(
          _items: Packages.mindustry._type.ItemSeq,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class ResearchDialog extends Packages
          .mindustry.ui.dialogs.BaseDialog {
          public TechTreeNode = class extends Packages
            .mindustry.ui.layout.TreeLayout
            .TreeNode<Packages.mindustry.ui.dialogs.ResearchDialog.TechTreeNode> {
            public node: Packages.mindustry.content.TechTree.TechNode;
            public visible: boolean;
            public selectable: boolean;
            this$0: Packages.mindustry.ui.dialogs.ResearchDialog;
            public constructor(
              _this$0: Packages.mindustry.ui.dialogs.ResearchDialog,
              _node: Packages.mindustry.content.TechTree.TechNode,
              _parent: Packages.mindustry.ui.dialogs.ResearchDialog.TechTreeNode,
            );
          };
          public View = class extends Packages.arc.scene
            .Group {
            public panX: number;
            public panY: number;
            public lastZoom: number;
            public moved: boolean;
            public hoverNode: Packages.arc.scene.ui.ImageButton;
            public infoTable: Packages.arc.scene.ui.layout.Table;
            this$0: Packages.mindustry.ui.dialogs.ResearchDialog;
            unlock(
              _node: Packages.mindustry.content.TechTree.TechNode,
            ): void;
            clamp(): void;
            public drawChildren(): void;
            rebuild(_shine: boolean[] | null): void;
            rebuild(): void;
            public rebuildAll(): void;
            canSpend(
              _node: Packages.mindustry.content.TechTree.TechNode,
            ): boolean;
            spend(
              _node: Packages.mindustry.content.TechTree.TechNode,
            ): void;
            public constructor(
              _this$0: Packages.mindustry.ui.dialogs.ResearchDialog,
            );
          };
          LayoutNode = class extends Packages.mindustry.ui
            .layout.TreeLayout
            .TreeNode<Packages.mindustry.ui.dialogs.ResearchDialog.LayoutNode> {
            node: Packages.mindustry.ui.dialogs.ResearchDialog.TechTreeNode;
            this$0: Packages.mindustry.ui.dialogs.ResearchDialog;
          };
          public static debugShowRequirements: boolean;
          public nodeSize: number;
          public nodes: Packages.arc.struct.ObjectSet<Packages.mindustry.ui.dialogs.ResearchDialog.TechTreeNode>;
          public root: Packages.mindustry.ui.dialogs.ResearchDialog.TechTreeNode;
          public lastNode: Packages.mindustry.content.TechTree.TechNode;
          public bounds: Packages.arc.math.geom.Rect;
          public itemDisplay: Packages.mindustry.ui.ItemsDisplay;
          public view: Packages.mindustry.ui.dialogs.ResearchDialog.View;
          public items: Packages.mindustry._type.ItemSeq;
          private showTechSelect: boolean;
          shift(
            _children: Packages.mindustry.ui.dialogs.ResearchDialog.LayoutNode[],
            _amount: number,
          ): void;
          public show(): Packages.arc.scene.ui.Dialog;
          selectable(
            _node: Packages.mindustry.content.TechTree.TechNode,
          ): boolean;
          locked(
            _node: Packages.mindustry.content.TechTree.TechNode,
          ): boolean;
          public rebuildItems(): void;
          public switchTree(
            _node: Packages.mindustry.content.TechTree.TechNode,
          ): void;
          checkNodes(
            _node: Packages.mindustry.ui.dialogs.ResearchDialog.TechTreeNode,
          ): void;
          treeLayout(): void;
          copyInfo(
            _node: Packages.mindustry.ui.dialogs.ResearchDialog.LayoutNode,
          ): void;
          checkMargin(): void;
          public getPrefRoot(): Packages.mindustry.content.TechTree.TechNode | null;
          public rebuildTree(
            _node: Packages.mindustry.content.TechTree.TechNode,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class SchematicsDialog extends Packages
          .mindustry.ui.dialogs.BaseDialog {
          public SchematicInfoDialog = class extends Packages
            .mindustry.ui.dialogs.BaseDialog {
            this$0: Packages.mindustry.ui.dialogs.SchematicsDialog;
            public show(
              _schem: Packages.mindustry.game.Schematic,
            ): void;
          };
          public static SchematicImage = class extends Packages
            .arc.scene.ui.Image {
            public scaling: number;
            public thickness: number;
            public borderColor: Packages.arc.graphics.Color;
            private schematic: Packages.mindustry.game.Schematic;
            private lastTexture: Packages.arc.graphics.Texture;
            set: boolean;
            public draw(): void;
            private setPreview(): void;
            public constructor(
              _s: Packages.mindustry.game.Schematic,
            );
          };
          private static tagh: number;
          private info: Packages.mindustry.ui.dialogs.SchematicsDialog.SchematicInfoDialog;
          private firstSchematic: Packages.mindustry.game.Schematic;
          private search: string;
          private searchField: Packages.arc.scene.ui.TextField;
          private rebuildPane: Packages.java.lang.Runnable;
          private rebuildTags: Packages.java.lang.Runnable;
          private ignoreSymbols: Packages.java.util.regex.Pattern;
          private tags: Packages.arc.struct.Seq<string>;
          private selectedTags: Packages.arc.struct.Seq<string>;
          private checkedTags: boolean;
          setup(): void;
          public show(): Packages.arc.scene.ui.Dialog;
          public showInfo(
            _schematic: Packages.mindustry.game.Schematic,
          ): void;
          tagsChanged(): void;
          buildTags(
            _schem: Packages.mindustry.game.Schematic,
            _t: Packages.arc.scene.ui.layout.Table,
            _name: boolean,
          ): void;
          buildTags(
            _schem: Packages.mindustry.game.Schematic,
            _t: Packages.arc.scene.ui.layout.Table,
          ): void;
          showNewIconTag(
            _cons: Packages.arc.func.Cons<string>,
          ): void;
          showNewTag(
            _result: Packages.arc.func.Cons<string>,
          ): void;
          addTag(
            _s: Packages.mindustry.game.Schematic,
            _tag: string,
          ): void;
          removeTag(
            _s: Packages.mindustry.game.Schematic,
            _tag: string,
          ): void;
          public showEdit(
            _s: Packages.mindustry.game.Schematic,
          ): void;
          public showExport(
            _s: Packages.mindustry.game.Schematic,
          ): void;
          public showImport(): void;
          showAllTags(): void;
          checkTags(): void;
          checkTags(
            _s: Packages.mindustry.game.Schematic,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace mod {
      declare class ModListing extends java.lang.Object {
        public repo: string;
        public name: string;
        public subtitle: string;
        public author: string;
        public lastUpdated: string;
        public description: string;
        public minGameVersion: string;
        public hasScripts: boolean;
        public hasJava: boolean;
        public contentTypes: string[];
        public stars: number;
        public toString(): string;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare class Date {}
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace text {
      declare class SimpleDateFormat {}
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class ModsDialog extends Packages.mindustry
          .ui.dialogs.BaseDialog {
          private textureCache: Packages.arc.struct.ObjectMap<
            string,
            Packages.arc.graphics.g2d.TextureRegion
          >;
          private modImportProgress: number;
          private searchtxt: string;
          private modList?: Packages.arc.struct.Seq<Packages.mindustry.mod.ModListing>;
          private orderDate: boolean;
          private currentContent: Packages.mindustry.ui.dialogs.BaseDialog;
          private browser: Packages.mindustry.ui.dialogs.BaseDialog;
          private browserTable: Packages.arc.scene.ui.layout.Table;
          private scroll: number;
          setup(): void;
          private reload(): void;
          private rebuildBrowser(): void;
          getModList(
            _listener: Packages.arc.func.Cons<
              Packages.arc.struct.Seq<Packages.mindustry.mod.ModListing>
            >,
          ): void;
          modError(
            _error: Packages.java.lang.Throwable,
          ): void;
          public githubImportMod(
            _repo: string,
            _isJava: boolean,
            _release: string | null,
          ): void;
          public githubImportMod(
            _repo: string,
            _isJava: boolean,
          ): void;
          private githubImportJavaMod(
            _repo: string,
            _release: string | null,
          ): void;
          private handleMod(
            _repo: string,
            _result: Packages.arc.util.Http.HttpResponse,
          ): void;
          private githubImportBranch(
            _branch: string,
            _repo: string,
            _release: string | null,
          ): void;
          private getStateDetails(
            _item: Packages.mindustry.mod.Mods.LoadedMod,
          ): string | null;
          private showMod(
            _mod: Packages.mindustry.mod.Mods.LoadedMod,
          ): void;
          private getStateText(
            _item: Packages.mindustry.mod.Mods.LoadedMod,
          ): string | null;
          private showModBrowser(): void;
          private importFail(
            _t: Packages.java.lang.Throwable,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class ColorPicker extends Packages.mindustry
          .ui.dialogs.BaseDialog {
          private static hueTex: Packages.arc.graphics.Texture;
          private cons: Packages.arc.func.Cons<Packages.arc.graphics.Color>;
          current: Packages.arc.graphics.Color;
          h: number;
          s: number;
          v: number;
          a: number;
          hexField: Packages.arc.scene.ui.TextField;
          hSlider: Packages.arc.scene.ui.Slider;
          sSlider: Packages.arc.scene.ui.Slider;
          vSlider: Packages.arc.scene.ui.Slider;
          aSlider: Packages.arc.scene.ui.Slider;
          public show(
            _color: Packages.arc.graphics.Color,
            _alpha: boolean,
            _consumer: Packages.arc.func.Cons<Packages.arc.graphics.Color>,
          ): void;
          public show(
            _color: Packages.arc.graphics.Color,
            _consumer: Packages.arc.func.Cons<Packages.arc.graphics.Color>,
          ): void;
          updateColor(): void;
          updateColor(_updateField: boolean): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class EffectsDialog extends Packages
          .mindustry.ui.dialogs.BaseDialog {
          static BoundsBatch = class extends Packages.arc
            .graphics.g2d.Batch {
            max: number;
            max(..._xs: number[]): void;
            protected flush(): void;
            reset(): void;
            protected draw(
              _region: Packages.arc.graphics.g2d.TextureRegion,
              _x: number,
              _y: number,
              _originX: number,
              _originY: number,
              _width: number,
              _height: number,
              _rotation: number,
            ): void;
            protected draw(
              _texture: Packages.arc.graphics.Texture,
              _spriteVertices: number[],
              _offset: number,
              _count: number,
            ): void;
          };
          EffectCell = class extends Packages.arc.scene
            .Element {
            effect: Packages.mindustry.logic.LogicFx.EffectEntry;
            size: number;
            id: number;
            time: number;
            lifetime: number;
            rotation: number;
            data: any;
            cl: Packages.arc.scene.event.ClickListener;
            this$0: Packages.mindustry.ui.dialogs.EffectsDialog;
            public draw(): void;
            public act(_delta: number): void;
            public constructor(
              _this$0: Packages.mindustry.ui.dialogs.EffectsDialog,
              _effect: Packages.mindustry.logic.LogicFx.EffectEntry,
              _cl: Packages.arc.scene.event.ClickListener,
            );
          };
          static bounds: Packages.mindustry.ui.dialogs.EffectsDialog.BoundsBatch;
          entries: Packages.java.lang.Iterable<Packages.mindustry.logic.LogicFx.EffectEntry>;
          listener?: Packages.arc.func.Cons<Packages.mindustry.logic.LogicFx.EffectEntry>;
          setup(): void;
          static getData(
            _type:
              | Class<any>
              | Packages.java.lang.Class<any>,
          ): any;
          public show(
            _listener: Packages.arc.func.Cons<Packages.mindustry.logic.LogicFx.EffectEntry>,
          ): Packages.arc.scene.ui.Dialog;
          public show(): Packages.arc.scene.ui.Dialog;
          static calculateSize(
            _entry: Packages.mindustry.logic.LogicFx.EffectEntry,
          ): number;
          public static withAllEffects(): Packages.mindustry.ui.dialogs.EffectsDialog;
          public constructor(
            _entries: Packages.java.lang.Iterable<Packages.mindustry.logic.LogicFx.EffectEntry>,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare class GlobalVarsDialog extends Packages
        .mindustry.ui.dialogs.BaseDialog {
        setup(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare class LogicDialog extends Packages.mindustry
        .ui.dialogs.BaseDialog {
        public canvas: Packages.mindustry.logic.LCanvas;
        consumer: Packages.arc.func.Cons<string>;
        privileged: boolean;
        executor?: Packages.mindustry.logic.LExecutor;
        globalsDialog: Packages.mindustry.logic.GlobalVarsDialog;
        private setup(): void;
        public static typeName(
          _s: Packages.mindustry.logic.LVar,
        ): string;
        public show(
          _code: string,
          _executor: Packages.mindustry.logic.LExecutor,
          _privileged: boolean,
          _modified: Packages.arc.func.Cons<string>,
        ): void;
        public static typeColor(
          _s: Packages.mindustry.logic.LVar,
          _color: Packages.arc.graphics.Color,
        ): Packages.arc.graphics.Color;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class FullTextDialog extends Packages
          .mindustry.ui.dialogs.BaseDialog {
          public show(
            _titleText: string,
            _text: string,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class CampaignCompleteDialog extends Packages
          .mindustry.ui.dialogs.BaseDialog {
          public show(
            _planet: Packages.mindustry._type.Planet,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace core {
      declare class UI
        extends java.lang.Object
        implements
          Packages.arc.assets.Loadable,
          Packages.arc.ApplicationListener
      {
        public static billions: string;
        public static millions: string;
        public static thousands: string;
        public static packer: Packages.arc.graphics.g2d.PixmapPacker;
        public menufrag: Packages.mindustry.ui.fragments.MenuFragment;
        public hudfrag: Packages.mindustry.ui.fragments.HudFragment;
        public chatfrag: Packages.mindustry.ui.fragments.ChatFragment;
        public consolefrag: Packages.mindustry.ui.fragments.ConsoleFragment;
        public minimapfrag: Packages.mindustry.ui.fragments.MinimapFragment;
        public listfrag: Packages.mindustry.ui.fragments.PlayerListFragment;
        public loadfrag: Packages.mindustry.ui.fragments.LoadingFragment;
        public hints: Packages.mindustry.ui.fragments.HintsFragment;
        public menuGroup: Packages.arc.scene.ui.layout.WidgetGroup;
        public hudGroup: Packages.arc.scene.ui.layout.WidgetGroup;
        public about: Packages.mindustry.ui.dialogs.AboutDialog;
        public restart: Packages.mindustry.ui.dialogs.GameOverDialog;
        public custom: Packages.mindustry.ui.dialogs.CustomGameDialog;
        public maps: Packages.mindustry.ui.dialogs.EditorMapsDialog;
        public load: Packages.mindustry.ui.dialogs.LoadDialog;
        public discord: Packages.mindustry.ui.dialogs.DiscordDialog;
        public join: Packages.mindustry.ui.dialogs.JoinDialog;
        public host: Packages.mindustry.ui.dialogs.HostDialog;
        public paused: Packages.mindustry.ui.dialogs.PausedDialog;
        public settings: Packages.mindustry.ui.dialogs.SettingsMenuDialog;
        public controls: Packages.mindustry.ui.dialogs.KeybindDialog;
        public editor: Packages.mindustry.editor.MapEditorDialog;
        public language: Packages.mindustry.ui.dialogs.LanguageDialog;
        public bans: Packages.mindustry.ui.dialogs.BansDialog;
        public admins: Packages.mindustry.ui.dialogs.AdminsDialog;
        public traces: Packages.mindustry.ui.dialogs.TraceDialog;
        public database: Packages.mindustry.ui.dialogs.DatabaseDialog;
        public content: Packages.mindustry.ui.dialogs.ContentInfoDialog;
        public planet: Packages.mindustry.ui.dialogs.PlanetDialog;
        public research: Packages.mindustry.ui.dialogs.ResearchDialog;
        public schematics: Packages.mindustry.ui.dialogs.SchematicsDialog;
        public mods: Packages.mindustry.ui.dialogs.ModsDialog;
        public picker: Packages.mindustry.ui.dialogs.ColorPicker;
        public effects: Packages.mindustry.ui.dialogs.EffectsDialog;
        public logic: Packages.mindustry.logic.LogicDialog;
        public fullText: Packages.mindustry.ui.dialogs.FullTextDialog;
        public campaignComplete: Packages.mindustry.ui.dialogs.CampaignCompleteDialog;
        public followUpMenus: Packages.arc.struct.IntMap<Packages.arc.scene.ui.Dialog>;
        public drillCursor: Packages.arc.Graphics.Cursor;
        public unloadCursor: Packages.arc.Graphics.Cursor;
        public targetCursor: Packages.arc.Graphics.Cursor;
        public repairCursor: Packages.arc.Graphics.Cursor;
        private lastAnnouncement?: Packages.arc.scene.Element;
        public update(): void;
        public init(): void;
        public resize(
          _width: number,
          _height: number,
        ): void;
        public getDependencies(): Packages.arc.struct.Seq<
          Packages.arc.assets.AssetDescriptor<any>
        >;
        public loadSync(): void;
        public loadAsync(): void;
        public getIcon(
          _name: string,
          _def: string,
        ): Packages.arc.scene.style.TextureRegionDrawable;
        public getIcon(
          _name: string,
        ): Packages.arc.scene.style.TextureRegionDrawable;
        public static loadColors(): void;
        public loadAnd(
          _text: string,
          _call: Packages.java.lang.Runnable,
        ): void;
        public loadAnd(
          _call: Packages.java.lang.Runnable,
        ): void;
        public showException(
          _text: string,
          _exc: Packages.java.lang.Throwable,
        ): void;
        public showException(
          _t: Packages.java.lang.Throwable,
        ): void;
        public showText(
          _titleText: string,
          _text: string,
        ): void;
        public showText(
          _titleText: string,
          _text: string,
          _align: number,
        ): void;
        public showErrorMessage(_text: string): void;
        public showLabel(
          _info: string,
          _duration: number,
          _worldx: number,
          _worldy: number,
        ): void;
        public announce(_text: string): void;
        public announce(
          _text: string,
          _duration: number,
        ): void;
        public static roundAmount(_number: number): number;
        public static formatAmount(
          _number: Packages.long,
        ): string;
        public showConfirm(
          _title: string,
          _text: string,
          _hide: Packages.arc.func.Boolp,
          _confirmed: Packages.java.lang.Runnable,
        ): void;
        public showConfirm(
          _text: string,
          _confirmed: Packages.java.lang.Runnable,
        ): void;
        public showConfirm(
          _title: string,
          _text: string,
          _confirmed: Packages.java.lang.Runnable,
        ): void;
        public showInfoFade(
          _info: string,
          _duration: number,
        ): void;
        public showInfoFade(_info: string): void;
        public showInfo(_info: string): void;
        public showCustomConfirm(
          _title: string,
          _text: string,
          _yes: string,
          _no: string,
          _confirmed: Packages.java.lang.Runnable,
          _denied: Packages.java.lang.Runnable,
        ): void;
        public showTextInput(
          _titleText: string,
          _text: string,
          _textLength: number,
          _def: string,
          _numbers: boolean,
          _confirmed: Packages.arc.func.Cons<string>,
          _closed: Packages.java.lang.Runnable,
        ): void;
        public showTextInput(
          _titleText: string,
          _text: string,
          _textLength: number,
          _def: string,
          _numbers: boolean,
          _allowEmpty: boolean,
          _confirmed: Packages.arc.func.Cons<string>,
          _closed: Packages.java.lang.Runnable,
        ): void;
        public showTextInput(
          _title: string,
          _text: string,
          _textLength: number,
          _def: string,
          _confirmed: Packages.arc.func.Cons<string>,
        ): void;
        public showTextInput(
          _title: string,
          _text: string,
          _def: string,
          _confirmed: Packages.arc.func.Cons<string>,
        ): void;
        public showTextInput(
          _title: string,
          _text: string,
          _textLength: number,
          _def: string,
          _numeric: boolean,
          _confirmed: Packages.arc.func.Cons<string>,
        ): void;
        public newMenuDialog(
          _title: string,
          _message: string,
          _options: string[][],
          _buttonListener: Packages.arc.func.Cons2<
            number,
            Packages.arc.scene.ui.Dialog
          >,
        ): Packages.arc.scene.ui.Dialog;
        public addDescTooltip(
          _elem: Packages.arc.scene.Element,
          _description: string,
        ): void;
        public showInfoToast(
          _info: string,
          _duration: number,
        ): void;
        public showInfoPopup(
          _info: string,
          _duration: number,
          _align: number,
          _top: number,
          _left: number,
          _bottom: number,
          _right: number,
        ): void;
        public showInfoOnHidden(
          _info: string,
          _listener: Packages.java.lang.Runnable,
        ): void;
        public showStartupInfo(_info: string): void;
        public showInfoText(
          _titleText: string,
          _text: string,
        ): void;
        public showSmall(
          _titleText: string,
          _text: string,
        ): void;
        public hasAnnouncement(): boolean;
        public showOkText(
          _title: string,
          _text: string,
          _confirmed: Packages.java.lang.Runnable,
        ): void;
        public showMenu(
          _title: string,
          _message: string,
          _options: string[][],
          _callback: Packages.arc.func.Intc,
        ): void;
        public showFollowUpMenu(
          _menuId: number,
          _title: string,
          _message: string,
          _options: string[][],
          _callback: Packages.arc.func.Intc,
        ): void;
        public hideFollowUpMenu(_menuId: number): void;
        public static formatTime(_ticks: number): string;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace net {
      declare class Administration extends java.lang
        .Object {
        public static ChatFilter = class {
          public filter(
            _player: Packages.mindustry.gen.Player,
            _message: string,
          ): string | null;
        };
        public static ActionFilter = class {
          public allow(
            _action: Packages.mindustry.net.Administration.PlayerAction,
          ): boolean;
        };
        public static PlayerInfo = class extends java.lang
          .Object {
          public id: string;
          public lastName: string;
          public lastIP: string;
          public ips: Packages.arc.struct.Seq<string>;
          public names: Packages.arc.struct.Seq<string>;
          public adminUsid: string;
          public timesKicked: number;
          public timesJoined: number;
          public banned: boolean;
          public admin: boolean;
          public lastKicked: Packages.long;
          public lastMessageTime: Packages.long;
          public lastSyncTime: Packages.long;
          public lastSentMessage: string;
          public messageInfractions: number;
          public rate: Packages.arc.util.Ratekeeper;
          public messageTimer: Packages.arc.util.Interval;
          public plainLastName(): string;
          public constructor();
        };
        public static ActionType = class extends Packages
          .java.lang
          .Enum<Packages.mindustry.net.Administration.ActionType> {
          public static breakBlock: Packages.mindustry.net.Administration.ActionType;
          public static placeBlock: Packages.mindustry.net.Administration.ActionType;
          public static rotate: Packages.mindustry.net.Administration.ActionType;
          public static configure: Packages.mindustry.net.Administration.ActionType;
          public static withdrawItem: Packages.mindustry.net.Administration.ActionType;
          public static depositItem: Packages.mindustry.net.Administration.ActionType;
          public static control: Packages.mindustry.net.Administration.ActionType;
          public static buildSelect: Packages.mindustry.net.Administration.ActionType;
          public static command: Packages.mindustry.net.Administration.ActionType;
          public static removePlanned: Packages.mindustry.net.Administration.ActionType;
          public static commandUnits: Packages.mindustry.net.Administration.ActionType;
          public static commandBuilding: Packages.mindustry.net.Administration.ActionType;
          public static respawn: Packages.mindustry.net.Administration.ActionType;
          public static pickupBlock: Packages.mindustry.net.Administration.ActionType;
          public static dropPayload: Packages.mindustry.net.Administration.ActionType;
          private static $VALUES: Packages.mindustry.net.Administration.ActionType[];
          public static values():
            | Packages.mindustry.net.Administration.ActionType[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.mindustry.net.Administration.ActionType;
        };
        public static PlayerAction = class
          extends java.lang.Object
          implements Packages.arc.util.pooling.Pool.Poolable
        {
          public player: Packages.mindustry.gen.Player;
          public type: Packages.mindustry.net.Administration.ActionType;
          public tile?: Packages.mindustry.world.Tile;
          public block?: Packages.mindustry.world.Block;
          public rotation: number;
          public config: any;
          public item?: Packages.mindustry._type.Item;
          public itemAmount: number;
          public unit?: Packages.mindustry.gen.Unit;
          public payload?: Packages.mindustry.world.blocks.payloads.Payload;
          public plans?: number[];
          public unitIDs?: number[];
          public buildingPositions?: number[];
          public set(
            _player: Packages.mindustry.gen.Player,
            _type: Packages.mindustry.net.Administration.ActionType,
            _unit: Packages.mindustry.gen.Unit,
          ): Packages.mindustry.net.Administration.PlayerAction;
          public set(
            _player: Packages.mindustry.gen.Player,
            _type: Packages.mindustry.net.Administration.ActionType,
            _tile: Packages.mindustry.world.Tile,
          ): Packages.mindustry.net.Administration.PlayerAction;
          public reset(): void;
          public constructor();
        };
        public static Config = class extends java.lang
          .Object {
          public static all: Packages.arc.struct.Seq<Packages.mindustry.net.Administration.Config>;
          public static serverName: Packages.mindustry.net.Administration.Config;
          public static desc: Packages.mindustry.net.Administration.Config;
          public static port: Packages.mindustry.net.Administration.Config;
          public static autoUpdate: Packages.mindustry.net.Administration.Config;
          public static showConnectMessages: Packages.mindustry.net.Administration.Config;
          public static enableVotekick: Packages.mindustry.net.Administration.Config;
          public static startCommands: Packages.mindustry.net.Administration.Config;
          public static logging: Packages.mindustry.net.Administration.Config;
          public static strict: Packages.mindustry.net.Administration.Config;
          public static antiSpam: Packages.mindustry.net.Administration.Config;
          public static interactRateWindow: Packages.mindustry.net.Administration.Config;
          public static interactRateLimit: Packages.mindustry.net.Administration.Config;
          public static interactRateKick: Packages.mindustry.net.Administration.Config;
          public static messageRateLimit: Packages.mindustry.net.Administration.Config;
          public static messageSpamKick: Packages.mindustry.net.Administration.Config;
          public static packetSpamLimit: Packages.mindustry.net.Administration.Config;
          public static chatSpamLimit: Packages.mindustry.net.Administration.Config;
          public static socketInput: Packages.mindustry.net.Administration.Config;
          public static socketInputPort: Packages.mindustry.net.Administration.Config;
          public static socketInputAddress: Packages.mindustry.net.Administration.Config;
          public static allowCustomClients: Packages.mindustry.net.Administration.Config;
          public static whitelist: Packages.mindustry.net.Administration.Config;
          public static motd: Packages.mindustry.net.Administration.Config;
          public static autosave: Packages.mindustry.net.Administration.Config;
          public static autosaveAmount: Packages.mindustry.net.Administration.Config;
          public static autosaveSpacing: Packages.mindustry.net.Administration.Config;
          public static debug: Packages.mindustry.net.Administration.Config;
          public static snapshotInterval: Packages.mindustry.net.Administration.Config;
          public static autoPause: Packages.mindustry.net.Administration.Config;
          public static roundExtraTime: Packages.mindustry.net.Administration.Config;
          public static maxLogLength: Packages.mindustry.net.Administration.Config;
          public defaultValue: any;
          public name: string;
          public key: string;
          public description: string;
          changed: Packages.java.lang.Runnable;
          public get(): any;
          public set(_value: any): void;
          private static debug(): boolean;
          public isDefault(): boolean;
          public num(): number;
          public string(): string;
          public bool(): boolean;
          public isString(): boolean;
          public isNum(): boolean;
          public isBool(): boolean;
          public constructor(
            _name: string,
            _description: string,
            _def: any,
            _key: string,
            _changed: Packages.java.lang.Runnable,
          );
          public constructor(
            _name: string,
            _description: string,
            _def: any,
            _changed: Packages.java.lang.Runnable,
          );
          public constructor(
            _name: string,
            _description: string,
            _def: any,
            _key: string,
          );
          public constructor(
            _name: string,
            _description: string,
            _def: any,
          );
        };
        public static TraceInfo = class extends java.lang
          .Object {
          public ip: string;
          public uuid: string;
          public modded: boolean;
          public mobile: boolean;
          public timesJoined: number;
          public timesKicked: number;
          public ips: string[];
          public names: string[];
          public constructor(
            _ip: string,
            _uuid: string,
            _modded: boolean,
            _mobile: boolean,
            _timesJoined: number,
            _timesKicked: number,
            _ips: string[],
            _names: string[],
          );
        };
        public bannedIPs: Packages.arc.struct.Seq<string>;
        public chatFilters: Packages.arc.struct.Seq<Packages.mindustry.net.Administration.ChatFilter>;
        public actionFilters: Packages.arc.struct.Seq<Packages.mindustry.net.Administration.ActionFilter>;
        public subnetBans: Packages.arc.struct.Seq<string>;
        public dosBlacklist: Packages.arc.struct.ObjectSet<string>;
        public kickedIPs: Packages.arc.struct.ObjectMap<
          string,
          Packages.java.lang.Long
        >;
        private modified: boolean;
        private loaded: boolean;
        public playerInfo: Packages.arc.struct.ObjectMap<
          string,
          Packages.mindustry.net.Administration.PlayerInfo
        >;
        private load(): void;
        public save(): void;
        public isStrict(): boolean;
        public findByName(
          _name: string,
        ): Packages.arc.struct.ObjectSet<Packages.mindustry.net.Administration.PlayerInfo>;
        public forceSave(): void;
        public handleKicked(
          _uuid: string,
          _ip: string,
          _duration: Packages.long,
        ): void;
        public getInfo(
          _id: string,
        ): Packages.mindustry.net.Administration.PlayerInfo;
        public whitelist(_id: string): boolean;
        public addChatFilter(
          _filter: Packages.mindustry.net.Administration.ChatFilter,
        ): void;
        public addActionFilter(
          _filter: Packages.mindustry.net.Administration.ActionFilter,
        ): void;
        public allowAction(
          _player: Packages.mindustry.gen.Player,
          _type: Packages.mindustry.net.Administration.ActionType,
          _setter: Packages.arc.func.Cons<Packages.mindustry.net.Administration.PlayerAction>,
        ): boolean;
        public allowAction(
          _player: Packages.mindustry.gen.Player,
          _type: Packages.mindustry.net.Administration.ActionType,
          _tile: Packages.mindustry.world.Tile,
          _setter: Packages.arc.func.Cons<Packages.mindustry.net.Administration.PlayerAction>,
        ): boolean;
        private getCreateInfo(
          _id: string,
        ): Packages.mindustry.net.Administration.PlayerInfo;
        public banPlayerID(_id: string): boolean;
        public banPlayerIP(_ip: string): boolean;
        public isWhitelistEnabled(): boolean;
        public findByIP(
          _ip: string,
        ): Packages.mindustry.net.Administration.PlayerInfo;
        public isWhitelisted(
          _id: string,
          _usid: string,
        ): boolean;
        public blacklistDos(_address: string): void;
        public isDosBlacklisted(_address: string): boolean;
        public getKickTime(
          _uuid: string,
          _ip: string,
        ): Packages.long;
        public getSubnetBans(): Packages.arc.struct.Seq<string>;
        public removeSubnetBan(_ip: string): void;
        public addSubnetBan(_ip: string): void;
        public isSubnetBanned(_ip: string): boolean;
        public filterMessage(
          _player: Packages.mindustry.gen.Player,
          _message: string,
        ): string | null;
        public getPlayerLimit(): number;
        public setPlayerLimit(_limit: number): void;
        public allowsCustomClients(): boolean;
        public updatePlayerJoined(
          _id: string,
          _ip: string,
          _name: string,
        ): void;
        public banPlayer(_uuid: string): boolean;
        public unbanPlayerIP(_ip: string): boolean;
        public unbanPlayerID(_id: string): boolean;
        public getAdmins(): Packages.arc.struct.Seq<Packages.mindustry.net.Administration.PlayerInfo>;
        public getBanned(): Packages.arc.struct.Seq<Packages.mindustry.net.Administration.PlayerInfo>;
        public getBannedIPs(): Packages.arc.struct.Seq<string>;
        public adminPlayer(
          _id: string,
          _usid: string,
        ): boolean;
        public unAdminPlayer(_id: string): boolean;
        public unwhitelist(_id: string): boolean;
        public isIPBanned(_ip: string): boolean;
        public isIDBanned(_uuid: string): boolean;
        public isAdmin(_id: string, _usid: string): boolean;
        public searchNames(
          _name: string,
        ): Packages.arc.struct.ObjectSet<Packages.mindustry.net.Administration.PlayerInfo>;
        public findByIPs(
          _ip: string,
        ): Packages.arc.struct.Seq<Packages.mindustry.net.Administration.PlayerInfo>;
        public getInfoOptional(
          _id: string,
        ): Packages.mindustry.net.Administration.PlayerInfo;
        public getWhitelisted(): Packages.arc.struct.Seq<Packages.mindustry.net.Administration.PlayerInfo>;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace core {
      declare class NetServer
        extends java.lang.Object
        implements Packages.arc.ApplicationListener
      {
        public static TeamAssigner = class {
          public assign(
            _player: Packages.mindustry.gen.Player,
            _players: Packages.java.lang.Iterable<Packages.mindustry.gen.Player>,
          ): Packages.mindustry.game.Team;
        };
        public static ChatFormatter = class {
          public format(
            _player: Packages.mindustry.gen.Player | null,
            _message: string,
          ): string;
        };
        public static InvalidCommandHandler = class {
          public handle(
            _player: Packages.mindustry.gen.Player,
            _response: Packages.arc.util.CommandHandler.CommandResponse,
          ): string;
        };
        public VoteSession = class extends java.lang
          .Object {
          target: Packages.mindustry.gen.Player;
          voted: Packages.arc.struct.ObjectIntMap<string>;
          task: Packages.arc.util.Timer.Task;
          votes: number;
          this$0: Packages.mindustry.core.NetServer;
          vote(
            _player: Packages.mindustry.gen.Player,
            _d: number,
          ): void;
          checkPass(): boolean;
          public constructor(
            _this$0: Packages.mindustry.core.NetServer,
            _target: Packages.mindustry.gen.Player,
          );
        };
        private static maxSnapshotSize: number;
        private static timerBlockSync: number;
        private static timerHealthSync: number;
        private static blockSyncTime: number;
        private static healthSyncTime: number;
        private static fbuffer: Packages.java.nio.FloatBuffer;
        private static dataWrites: Packages.arc.util.io.Writes;
        private static hiddenIds: Packages.arc.struct.IntSeq;
        private static healthSeq: Packages.arc.struct.IntSeq;
        private static vector: Packages.arc.math.geom.Vec2;
        private static correctDist: number;
        public admins: Packages.mindustry.net.Administration;
        public clientCommands: Packages.arc.util.CommandHandler;
        public assigner: Packages.mindustry.core.NetServer.TeamAssigner;
        public chatFormatter: Packages.mindustry.core.NetServer.ChatFormatter;
        public invalidHandler: Packages.mindustry.core.NetServer.InvalidCommandHandler;
        private closing: boolean;
        private pvpAutoPaused: boolean;
        private timer: Packages.arc.util.Interval;
        private buildHealthChanged: Packages.arc.struct.IntSet;
        public currentlyKicking?: Packages.mindustry.core.NetServer.VoteSession;
        public static kickDuration: number;
        public static voteDuration: number;
        public static voteCooldown: number;
        private writeBuffer: Packages.arc.util.io.ReusableByteOutStream;
        private outputBuffer: Packages.arc.util.io.Writes;
        private syncStream: Packages.arc.util.io.ReusableByteOutStream;
        private dataStream: Packages.java.io.DataOutputStream;
        private customPacketHandlers: Packages.arc.struct.ObjectMap<
          string,
          Packages.arc.struct.Seq<
            Packages.arc.func.Cons2<
              Packages.mindustry.gen.Player,
              string
            >
          >
        >;
        private logicClientDataHandlers: Packages.arc.struct.ObjectMap<
          string,
          Packages.arc.struct.Seq<
            Packages.arc.func.Cons2<
              Packages.mindustry.gen.Player,
              any
            >
          >
        >;
        public update(): void;
        public init(): void;
        sync(): void;
        private static invalid(_f: number): boolean;
        public buildHealthUpdate(
          _build: Packages.mindustry.gen.Building,
        ): void;
        public kickAll(
          _reason: Packages.mindustry.net.Packets.KickReason,
        ): void;
        public assignTeam(
          _current: Packages.mindustry.gen.Player,
        ): Packages.mindustry.game.Team;
        public assignTeam(
          _current: Packages.mindustry.gen.Player,
          _players: Packages.java.lang.Iterable<Packages.mindustry.gen.Player>,
        ): Packages.mindustry.game.Team;
        private registerCommands(): void;
        public static debugStatusClient(
          _value: number,
          _lastClientSnapshot: number,
          _snapshotsSent: number,
        ): void;
        public static debugStatusClientUnreliable(
          _value: number,
          _lastClientSnapshot: number,
          _snapshotsSent: number,
        ): void;
        static logClientStatus(
          _reliable: boolean,
          _value: number,
          _lastClientSnapshot: number,
          _snapshotsSent: number,
        ): void;
        public static serverPacketReliable(
          _player: Packages.mindustry.gen.Player,
          _type: string,
          _contents: string,
        ): void;
        public static clientLogicDataReliable(
          _player: Packages.mindustry.gen.Player,
          _channel: string,
          _value: any,
        ): void;
        public isWaitingForPlayers(): boolean;
        public checkColor(_str: string): string;
        public writeBlockSnapshots(): void;
        public static onDisconnect(
          _player: Packages.mindustry.gen.Player,
          _reason: string,
        ): void;
        public writeEntitySnapshot(
          _player: Packages.mindustry.gen.Player,
        ): void;
        public sendWorldData(
          _player: Packages.mindustry.gen.Player,
        ): void;
        public fixName(_name: string): string;
        public votesRequired(): number;
        public addPacketHandler(
          _type: string,
          _handler: Packages.arc.func.Cons2<
            Packages.mindustry.gen.Player,
            string
          >,
        ): void;
        public getPacketHandlers(
          _type: string,
        ): Packages.arc.struct.Seq<
          Packages.arc.func.Cons2<
            Packages.mindustry.gen.Player,
            string
          >
        >;
        public addLogicDataHandler(
          _type: string,
          _handler: Packages.arc.func.Cons2<
            Packages.mindustry.gen.Player,
            any
          >,
        ): void;
        public static requestDebugStatus(
          _player: Packages.mindustry.gen.Player,
        ): void;
        public static serverPacketUnreliable(
          _player: Packages.mindustry.gen.Player,
          _type: string,
          _contents: string,
        ): void;
        public static clientLogicDataUnreliable(
          _player: Packages.mindustry.gen.Player,
          _channel: string,
          _value: any,
        ): void;
        public static clientSnapshot(
          _player: Packages.mindustry.gen.Player,
          _snapshotID: number,
          _unitID: number,
          _dead: boolean,
          _x: number,
          _y: number,
          _pointerX: number,
          _pointerY: number,
          _rotation: number,
          _baseRotation: number,
          _xVelocity: number,
          _yVelocity: number,
          _mining: Packages.mindustry.world.Tile,
          _boosting: boolean,
          _shooting: boolean,
          _chatting: boolean,
          _building: boolean,
          _plans: Packages.arc.struct.Queue<Packages.mindustry.entities.units.BuildPlan> | null,
          _viewX: number,
          _viewY: number,
          _viewWidth: number,
          _viewHeight: number,
        ): void;
        public static adminRequest(
          _player: Packages.mindustry.gen.Player,
          _other: Packages.mindustry.gen.Player,
          _action: Packages.mindustry.net.Packets.AdminAction,
          _params: any,
        ): void;
        public static connectConfirm(
          _player: Packages.mindustry.gen.Player,
        ): void;
        public openServer(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace core {
      declare class NetClient
        extends java.lang.Object
        implements Packages.arc.ApplicationListener
      {
        private static dataTimeout: number;
        private static playerSyncTime: number;
        private static dataReads: Packages.arc.util.io.Reads;
        private timer: Packages.arc.util.Interval;
        private connecting: boolean;
        private quiet: boolean;
        private quietReset: boolean;
        private timeoutTime: number;
        private lastSent: number;
        private removed: Packages.arc.struct.IntSet;
        private byteStream: Packages.arc.util.io.ReusableByteInStream;
        private dataStream: Packages.java.io.DataInputStream;
        private customPacketHandlers: Packages.arc.struct.ObjectMap<
          string,
          Packages.arc.struct.Seq<
            Packages.arc.func.Cons<string>
          >
        >;
        public update(): void;
        public static connect(
          _ip: string,
          _port: number,
        ): void;
        private reset(): void;
        sync(): void;
        public static setPosition(
          _x: number,
          _y: number,
        ): void;
        public static sound(
          _sound: Packages.arc.audio.Sound,
          _volume: number,
          _pitch: number,
          _pan: number,
        ): void;
        public static effect(
          _effect: Packages.mindustry.entities.Effect,
          _x: number,
          _y: number,
          _rotation: number,
          _color: Packages.arc.graphics.Color,
        ): void;
        public static effect(
          _effect: Packages.mindustry.entities.Effect,
          _x: number,
          _y: number,
          _rotation: number,
          _color: Packages.arc.graphics.Color,
          _data: any,
        ): void;
        public static ping(
          _player: Packages.mindustry.gen.Player,
          _time: Packages.long,
        ): void;
        public addRemovedEntity(_id: number): void;
        public static sendMessage(
          _message: string,
          _unformatted: string | null,
          _playersender: Packages.mindustry.gen.Player | null,
        ): void;
        public static sendMessage(_message: string): void;
        public disconnectQuietly(): void;
        public static kick(_reason: string): void;
        public static kick(
          _reason: Packages.mindustry.net.Packets.KickReason,
        ): void;
        public disconnectNoReset(): void;
        public resetTimeout(): void;
        public static completeObjective(
          _index: number,
        ): void;
        public static setRules(
          _rules: Packages.mindustry.game.Rules,
        ): void;
        public static playerDisconnect(
          _playerid: number,
        ): void;
        public static clearObjectives(): void;
        public setQuiet(): void;
        public static clientPacketReliable(
          _type: string,
          _contents: string,
        ): void;
        public static pingResponse(
          _time: Packages.long,
        ): void;
        public isEntityUsed(_id: number): boolean;
        public static readSyncEntity(
          _input: Packages.java.io.DataInputStream,
          _read: Packages.arc.util.io.Reads,
        ): void;
        private finishConnecting(): void;
        getUsid(_ip: string): string;
        public static clientPacketUnreliable(
          _type: string,
          _contents: string,
        ): void;
        public static soundAt(
          _sound: Packages.arc.audio.Sound,
          _x: number,
          _y: number,
          _volume: number,
          _pitch: number,
        ): void;
        public static effectReliable(
          _effect: Packages.mindustry.entities.Effect,
          _x: number,
          _y: number,
          _rotation: number,
          _color: Packages.arc.graphics.Color,
        ): void;
        public static sendChatMessage(
          _player: Packages.mindustry.gen.Player,
          _message: string,
        ): void;
        public static setObjectives(
          _executor: Packages.mindustry.game.MapObjectives,
        ): void;
        public static setCameraPosition(
          _x: number,
          _y: number,
        ): void;
        public isConnecting(): boolean;
        public getPing(): number;
        public beginConnecting(): void;
        public clearRemovedEntity(_id: number): void;
        public static traceInfo(
          _player: Packages.mindustry.gen.Player,
          _info: Packages.mindustry.net.Administration.TraceInfo,
        ): void;
        public static blockSnapshot(
          _amount: Packages.short,
          _data: string[],
        ): void;
        public static stateSnapshot(
          _waveTime: number,
          _wave: number,
          _enemies: number,
          _paused: boolean,
          _gameOver: boolean,
          _timeData: number,
          _tps: string,
          _rand0: Packages.long,
          _rand1: Packages.long,
          _coreData: string[],
        ): void;
        public static entitySnapshot(
          _amount: Packages.short,
          _data: string[],
        ): void;
        public static hiddenSnapshot(
          _ids: Packages.arc.struct.IntSeq,
        ): void;
        public static worldDataBegin(): void;
        public addPacketHandler(
          _type: string,
          _handler: Packages.arc.func.Cons<string>,
        ): void;
        public getPacketHandlers(
          _type: string,
        ): Packages.arc.struct.Seq<
          Packages.arc.func.Cons<string>
        >;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare class Vars
      extends java.lang.Object
      implements Packages.arc.assets.Loadable
    {
      public static failedToLaunch: boolean;
      public static loadLocales: boolean;
      public static loadedLogger: boolean;
      public static loadedFileLogger: boolean;
      public static experimental: boolean;
      public static steamPlayerName: string;
      public static defaultContentIcons: Packages.mindustry.ctype.ContentType[];
      public static defaultEnv: number;
      public static darkRadius: number;
      public static maxLoadoutSchematicPad: number;
      public static schematicBaseStart: string;
      public static bufferSize: number;
      public static charset: Packages.java.nio.charset.Charset;
      public static appName: string;
      public static ghApi: string;
      public static discordURL: string;
      public static modGuideURL: string;
      public static serverJsonBeURL: string;
      public static serverJsonURL: string;
      public static reportIssueURL: string;
      public static defaultServers: Packages.arc.struct.Seq<Packages.mindustry.net.ServerGroup>;
      public static maxBlockSize: number;
      public static mineTransferRange: number;
      public static maxTextLength: number;
      public static maxNameLength: number;
      public static itemSize: number;
      public static finalWorldBounds: number;
      public static buildingRange: number;
      public static itemTransferRange: number;
      public static logicItemTransferRange: number;
      public static turnDuration: number;
      public static baseInvasionChance: number;
      public static invasionGracePeriod: number;
      public static minArmorDamage: number;
      public static coreLandDuration: number;
      public static tilesize: number;
      public static tilePayload: number;
      public static iconXLarge: number;
      public static iconLarge: number;
      public static iconMed: number;
      public static iconSmall: number;
      public static macNotchHeight: number;
      public static updateEditorOnChange: boolean;
      public static playerColors: Packages.arc.graphics.Color[];
      public static accessibleIcons: string[];
      public static maxTcpSize: number;
      public static port: number;
      public static multicastPort: number;
      public static maxModSubtitleLength: number;
      public static multicastGroup: string;
      public static maxDeltaClient: number;
      public static maxDeltaServer: number;
      public static clientLoaded: boolean;
      public static maxTextureSize: number;
      public static maxSchematicSize: number;
      public static showSectorLandInfo: boolean;
      public static checkScreenshotMemory: boolean;
      public static confirmExit: boolean;
      public static disableUI: boolean;
      public static testMobile: boolean;
      public static mobile: boolean;
      public static ios: boolean;
      public static android: boolean;
      public static headless: boolean;
      public static steam: boolean;
      public static clearSectors: boolean;
      public static enableLight: boolean;
      public static enableDarkness: boolean;
      public static dataDirectory: Packages.arc.files.Fi;
      public static screenshotDirectory: Packages.arc.files.Fi;
      public static customMapDirectory: Packages.arc.files.Fi;
      public static mapPreviewDirectory: Packages.arc.files.Fi;
      public static tmpDirectory: Packages.arc.files.Fi;
      public static saveDirectory: Packages.arc.files.Fi;
      public static modDirectory: Packages.arc.files.Fi;
      public static schematicDirectory: Packages.arc.files.Fi;
      public static bebuildDirectory: Packages.arc.files.Fi;
      public static launchIDFile: Packages.arc.files.Fi;
      public static emptyMap: Packages.mindustry.maps.Map;
      public static emptyTile: Packages.mindustry.world.Tile;
      public static mapExtension: string;
      public static saveExtension: string;
      public static schematicExtension: string;
      public static javaPath: string;
      public static locales: Packages.java.util.Locale[];
      public static mainExecutor: Packages.java.util.concurrent.ExecutorService;
      public static tree: Packages.mindustry.core.FileTree;
      public static net: Packages.mindustry.net.Net;
      public static content: Packages.mindustry.core.ContentLoader;
      public static state: Packages.mindustry.core.GameState;
      public static collisions: Packages.mindustry.entities.EntityCollisions;
      public static waves: Packages.mindustry.game.Waves;
      public static platform: Packages.mindustry.core.Platform;
      public static mods: Packages.mindustry.mod.Mods;
      public static schematics: Packages.mindustry.game.Schematics;
      public static becontrol: Packages.mindustry.net.BeControl;
      public static asyncCore: Packages.mindustry.async.AsyncCore;
      public static bases: Packages.mindustry.ai.BaseRegistry;
      public static logicVars: Packages.mindustry.logic.GlobalVars;
      public static editor: Packages.mindustry.editor.MapEditor;
      public static service: Packages.mindustry.service.GameService;
      public static universe: Packages.mindustry.game.Universe;
      public static world: Packages.mindustry.core.World;
      public static maps: Packages.mindustry.maps.Maps;
      public static spawner: Packages.mindustry.ai.WaveSpawner;
      public static indexer: Packages.mindustry.ai.BlockIndexer;
      public static pathfinder: Packages.mindustry.ai.Pathfinder;
      public static controlPath: Packages.mindustry.ai.ControlPathfinder;
      public static fogControl: Packages.mindustry.game.FogControl;
      public static control: Packages.mindustry.core.Control;
      public static logic: Packages.mindustry.core.Logic;
      public static renderer: Packages.mindustry.core.Renderer;
      public static ui: Packages.mindustry.core.UI;
      public static netServer: Packages.mindustry.core.NetServer;
      public static netClient: Packages.mindustry.core.NetClient;
      public static player: Packages.mindustry.gen.Player;
      public static init(): void;
      public loadAsync(): void;
      public static checkLaunch(): void;
      public static loadLogger(): void;
      public static loadFileLogger(): void;
      public static finishLaunch(): void;
      public static loadSettings(): void;
      public constructor();
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare class Astar extends java.lang.Object {
        public static DistanceHeuristic = class {
          public cost(
            _x1: number,
            _y1: number,
            _x2: number,
            _y2: number,
          ): number;
        };
        public static TileHueristic = class {
          public cost(
            _tile: Packages.mindustry.world.Tile,
          ): number;
          public cost(
            _from: Packages.mindustry.world.Tile,
            _tile: Packages.mindustry.world.Tile,
          ): number;
        };
        public static manhattan: Packages.mindustry.ai.Astar.DistanceHeuristic;
        private static out: Packages.arc.struct.Seq<Packages.mindustry.world.Tile>;
        private static queue: Packages.arc.struct.PQueue<Packages.mindustry.world.Tile>;
        private static costs: number[];
        private static rotations: string[][];
        public static pathfind(
          _startX: number,
          _startY: number,
          _endX: number,
          _endY: number,
          _th: Packages.mindustry.ai.Astar.TileHueristic,
          _passable: Packages.arc.func.Boolf<Packages.mindustry.world.Tile>,
        ): Packages.arc.struct.Seq<Packages.mindustry.world.Tile>;
        public static pathfind(
          _from: Packages.mindustry.world.Tile,
          _to: Packages.mindustry.world.Tile,
          _th: Packages.mindustry.ai.Astar.TileHueristic,
          _passable: Packages.arc.func.Boolf<Packages.mindustry.world.Tile>,
        ): Packages.arc.struct.Seq<Packages.mindustry.world.Tile>;
        public static pathfind(
          _startX: number,
          _startY: number,
          _endX: number,
          _endY: number,
          _th: Packages.mindustry.ai.Astar.TileHueristic,
          _dh: Packages.mindustry.ai.Astar.DistanceHeuristic,
          _passable: Packages.arc.func.Boolf<Packages.mindustry.world.Tile>,
        ): Packages.arc.struct.Seq<Packages.mindustry.world.Tile>;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace async {
      declare class PhysicsProcess
        extends java.lang.Object
        implements Packages.mindustry.async.AsyncProcess
      {
        public static PhysicsWorld = class extends java.lang
          .Object {
          public static PhysicsBody = class
            extends java.lang.Object
            implements
              Packages.arc.math.geom.QuadTree.QuadTreeObject
          {
            public x: number;
            public y: number;
            public radius: number;
            public mass: number;
            public layer: number;
            public collided: boolean;
            public local: boolean;
            public hitbox(
              _out: Packages.arc.math.geom.Rect,
            ): void;
            public constructor();
          };
          private static scl: number;
          private trees: Packages.arc.math.geom.QuadTree<Packages.mindustry.async.PhysicsProcess.PhysicsWorld.PhysicsBody>[];
          private bodies: Packages.arc.struct.Seq<Packages.mindustry.async.PhysicsProcess.PhysicsWorld.PhysicsBody>;
          private seq: Packages.arc.struct.Seq<Packages.mindustry.async.PhysicsProcess.PhysicsWorld.PhysicsBody>;
          private rect: Packages.arc.math.geom.Rect;
          private vec: Packages.arc.math.geom.Vec2;
          public add(
            _body: Packages.mindustry.async.PhysicsProcess.PhysicsWorld.PhysicsBody,
          ): void;
          public remove(
            _body: Packages.mindustry.async.PhysicsProcess.PhysicsWorld.PhysicsBody,
          ): void;
          public update(): void;
          public constructor(
            _bounds: Packages.arc.math.geom.Rect,
          );
        };
        public static PhysicRef = class extends java.lang
          .Object {
          public entity: Packages.mindustry.gen.Physicsc;
          public body: Packages.mindustry.async.PhysicsProcess.PhysicsWorld.PhysicsBody;
          public x: number;
          public y: number;
          public constructor(
            _entity: Packages.mindustry.gen.Physicsc,
            _body: Packages.mindustry.async.PhysicsProcess.PhysicsWorld.PhysicsBody,
          );
        };
        public static layers: number;
        public static layerGround: number;
        public static layerLegs: number;
        public static layerFlying: number;
        private physics: Packages.mindustry.async.PhysicsProcess.PhysicsWorld;
        private refs: Packages.arc.struct.Seq<Packages.mindustry.async.PhysicsProcess.PhysicRef>;
        private group: Packages.mindustry.entities.EntityGroup<Packages.mindustry.gen.Unit>;
        public end(): void;
        public begin(): void;
        public init(): void;
        public reset(): void;
        public process(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace content {
      declare class Blocks extends java.lang.Object {
        public static air: Packages.mindustry.world.Block;
        public static spawn: Packages.mindustry.world.Block;
        public static cliff: Packages.mindustry.world.Block;
        public static deepwater: Packages.mindustry.world.Block;
        public static water: Packages.mindustry.world.Block;
        public static taintedWater: Packages.mindustry.world.Block;
        public static deepTaintedWater: Packages.mindustry.world.Block;
        public static tar: Packages.mindustry.world.Block;
        public static slag: Packages.mindustry.world.Block;
        public static cryofluid: Packages.mindustry.world.Block;
        public static stone: Packages.mindustry.world.Block;
        public static craters: Packages.mindustry.world.Block;
        public static charr: Packages.mindustry.world.Block;
        public static sand: Packages.mindustry.world.Block;
        public static darksand: Packages.mindustry.world.Block;
        public static dirt: Packages.mindustry.world.Block;
        public static mud: Packages.mindustry.world.Block;
        public static ice: Packages.mindustry.world.Block;
        public static snow: Packages.mindustry.world.Block;
        public static darksandTaintedWater: Packages.mindustry.world.Block;
        public static space: Packages.mindustry.world.Block;
        public static empty: Packages.mindustry.world.Block;
        public static dacite: Packages.mindustry.world.Block;
        public static rhyolite: Packages.mindustry.world.Block;
        public static rhyoliteCrater: Packages.mindustry.world.Block;
        public static roughRhyolite: Packages.mindustry.world.Block;
        public static regolith: Packages.mindustry.world.Block;
        public static yellowStone: Packages.mindustry.world.Block;
        public static redIce: Packages.mindustry.world.Block;
        public static redStone: Packages.mindustry.world.Block;
        public static denseRedStone: Packages.mindustry.world.Block;
        public static arkyciteFloor: Packages.mindustry.world.Block;
        public static arkyicStone: Packages.mindustry.world.Block;
        public static redmat: Packages.mindustry.world.Block;
        public static bluemat: Packages.mindustry.world.Block;
        public static stoneWall: Packages.mindustry.world.Block;
        public static dirtWall: Packages.mindustry.world.Block;
        public static sporeWall: Packages.mindustry.world.Block;
        public static iceWall: Packages.mindustry.world.Block;
        public static daciteWall: Packages.mindustry.world.Block;
        public static sporePine: Packages.mindustry.world.Block;
        public static snowPine: Packages.mindustry.world.Block;
        public static pine: Packages.mindustry.world.Block;
        public static shrubs: Packages.mindustry.world.Block;
        public static whiteTree: Packages.mindustry.world.Block;
        public static whiteTreeDead: Packages.mindustry.world.Block;
        public static sporeCluster: Packages.mindustry.world.Block;
        public static redweed: Packages.mindustry.world.Block;
        public static purbush: Packages.mindustry.world.Block;
        public static yellowCoral: Packages.mindustry.world.Block;
        public static rhyoliteVent: Packages.mindustry.world.Block;
        public static carbonVent: Packages.mindustry.world.Block;
        public static arkyicVent: Packages.mindustry.world.Block;
        public static yellowStoneVent: Packages.mindustry.world.Block;
        public static redStoneVent: Packages.mindustry.world.Block;
        public static crystallineVent: Packages.mindustry.world.Block;
        public static regolithWall: Packages.mindustry.world.Block;
        public static yellowStoneWall: Packages.mindustry.world.Block;
        public static rhyoliteWall: Packages.mindustry.world.Block;
        public static carbonWall: Packages.mindustry.world.Block;
        public static redIceWall: Packages.mindustry.world.Block;
        public static ferricStoneWall: Packages.mindustry.world.Block;
        public static beryllicStoneWall: Packages.mindustry.world.Block;
        public static arkyicWall: Packages.mindustry.world.Block;
        public static crystallineStoneWall: Packages.mindustry.world.Block;
        public static redStoneWall: Packages.mindustry.world.Block;
        public static redDiamondWall: Packages.mindustry.world.Block;
        public static ferricStone: Packages.mindustry.world.Block;
        public static ferricCraters: Packages.mindustry.world.Block;
        public static carbonStone: Packages.mindustry.world.Block;
        public static beryllicStone: Packages.mindustry.world.Block;
        public static crystallineStone: Packages.mindustry.world.Block;
        public static crystalFloor: Packages.mindustry.world.Block;
        public static yellowStonePlates: Packages.mindustry.world.Block;
        public static iceSnow: Packages.mindustry.world.Block;
        public static sandWater: Packages.mindustry.world.Block;
        public static darksandWater: Packages.mindustry.world.Block;
        public static duneWall: Packages.mindustry.world.Block;
        public static sandWall: Packages.mindustry.world.Block;
        public static moss: Packages.mindustry.world.Block;
        public static sporeMoss: Packages.mindustry.world.Block;
        public static shale: Packages.mindustry.world.Block;
        public static shaleWall: Packages.mindustry.world.Block;
        public static grass: Packages.mindustry.world.Block;
        public static salt: Packages.mindustry.world.Block;
        public static coreZone: Packages.mindustry.world.Block;
        public static shaleBoulder: Packages.mindustry.world.Block;
        public static sandBoulder: Packages.mindustry.world.Block;
        public static daciteBoulder: Packages.mindustry.world.Block;
        public static boulder: Packages.mindustry.world.Block;
        public static snowBoulder: Packages.mindustry.world.Block;
        public static basaltBoulder: Packages.mindustry.world.Block;
        public static carbonBoulder: Packages.mindustry.world.Block;
        public static ferricBoulder: Packages.mindustry.world.Block;
        public static beryllicBoulder: Packages.mindustry.world.Block;
        public static yellowStoneBoulder: Packages.mindustry.world.Block;
        public static arkyicBoulder: Packages.mindustry.world.Block;
        public static crystalCluster: Packages.mindustry.world.Block;
        public static vibrantCrystalCluster: Packages.mindustry.world.Block;
        public static crystalBlocks: Packages.mindustry.world.Block;
        public static crystalOrbs: Packages.mindustry.world.Block;
        public static crystallineBoulder: Packages.mindustry.world.Block;
        public static redIceBoulder: Packages.mindustry.world.Block;
        public static rhyoliteBoulder: Packages.mindustry.world.Block;
        public static redStoneBoulder: Packages.mindustry.world.Block;
        public static metalFloor: Packages.mindustry.world.Block;
        public static metalFloorDamaged: Packages.mindustry.world.Block;
        public static metalFloor2: Packages.mindustry.world.Block;
        public static metalFloor3: Packages.mindustry.world.Block;
        public static metalFloor4: Packages.mindustry.world.Block;
        public static metalFloor5: Packages.mindustry.world.Block;
        public static basalt: Packages.mindustry.world.Block;
        public static magmarock: Packages.mindustry.world.Block;
        public static hotrock: Packages.mindustry.world.Block;
        public static snowWall: Packages.mindustry.world.Block;
        public static saltWall: Packages.mindustry.world.Block;
        public static darkPanel1: Packages.mindustry.world.Block;
        public static darkPanel2: Packages.mindustry.world.Block;
        public static darkPanel3: Packages.mindustry.world.Block;
        public static darkPanel4: Packages.mindustry.world.Block;
        public static darkPanel5: Packages.mindustry.world.Block;
        public static darkPanel6: Packages.mindustry.world.Block;
        public static darkMetal: Packages.mindustry.world.Block;
        public static pebbles: Packages.mindustry.world.Block;
        public static tendrils: Packages.mindustry.world.Block;
        public static oreCopper: Packages.mindustry.world.Block;
        public static oreLead: Packages.mindustry.world.Block;
        public static oreScrap: Packages.mindustry.world.Block;
        public static oreCoal: Packages.mindustry.world.Block;
        public static oreTitanium: Packages.mindustry.world.Block;
        public static oreThorium: Packages.mindustry.world.Block;
        public static oreBeryllium: Packages.mindustry.world.Block;
        public static oreTungsten: Packages.mindustry.world.Block;
        public static oreCrystalThorium: Packages.mindustry.world.Block;
        public static wallOreThorium: Packages.mindustry.world.Block;
        public static wallOreBeryllium: Packages.mindustry.world.Block;
        public static graphiticWall: Packages.mindustry.world.Block;
        public static wallOreTungsten: Packages.mindustry.world.Block;
        public static siliconSmelter: Packages.mindustry.world.Block;
        public static siliconCrucible: Packages.mindustry.world.Block;
        public static kiln: Packages.mindustry.world.Block;
        public static graphitePress: Packages.mindustry.world.Block;
        public static plastaniumCompressor: Packages.mindustry.world.Block;
        public static multiPress: Packages.mindustry.world.Block;
        public static phaseWeaver: Packages.mindustry.world.Block;
        public static surgeSmelter: Packages.mindustry.world.Block;
        public static pyratiteMixer: Packages.mindustry.world.Block;
        public static blastMixer: Packages.mindustry.world.Block;
        public static cryofluidMixer: Packages.mindustry.world.Block;
        public static melter: Packages.mindustry.world.Block;
        public static separator: Packages.mindustry.world.Block;
        public static disassembler: Packages.mindustry.world.Block;
        public static sporePress: Packages.mindustry.world.Block;
        public static pulverizer: Packages.mindustry.world.Block;
        public static incinerator: Packages.mindustry.world.Block;
        public static coalCentrifuge: Packages.mindustry.world.Block;
        public static siliconArcFurnace: Packages.mindustry.world.Block;
        public static electrolyzer: Packages.mindustry.world.Block;
        public static oxidationChamber: Packages.mindustry.world.Block;
        public static atmosphericConcentrator: Packages.mindustry.world.Block;
        public static electricHeater: Packages.mindustry.world.Block;
        public static slagHeater: Packages.mindustry.world.Block;
        public static phaseHeater: Packages.mindustry.world.Block;
        public static heatRedirector: Packages.mindustry.world.Block;
        public static heatRouter: Packages.mindustry.world.Block;
        public static slagIncinerator: Packages.mindustry.world.Block;
        public static carbideCrucible: Packages.mindustry.world.Block;
        public static slagCentrifuge: Packages.mindustry.world.Block;
        public static surgeCrucible: Packages.mindustry.world.Block;
        public static cyanogenSynthesizer: Packages.mindustry.world.Block;
        public static phaseSynthesizer: Packages.mindustry.world.Block;
        public static heatReactor: Packages.mindustry.world.Block;
        public static powerSource: Packages.mindustry.world.Block;
        public static powerVoid: Packages.mindustry.world.Block;
        public static itemSource: Packages.mindustry.world.Block;
        public static itemVoid: Packages.mindustry.world.Block;
        public static liquidSource: Packages.mindustry.world.Block;
        public static liquidVoid: Packages.mindustry.world.Block;
        public static payloadSource: Packages.mindustry.world.Block;
        public static payloadVoid: Packages.mindustry.world.Block;
        public static illuminator: Packages.mindustry.world.Block;
        public static heatSource: Packages.mindustry.world.Block;
        public static copperWall: Packages.mindustry.world.Block;
        public static copperWallLarge: Packages.mindustry.world.Block;
        public static titaniumWall: Packages.mindustry.world.Block;
        public static titaniumWallLarge: Packages.mindustry.world.Block;
        public static plastaniumWall: Packages.mindustry.world.Block;
        public static plastaniumWallLarge: Packages.mindustry.world.Block;
        public static thoriumWall: Packages.mindustry.world.Block;
        public static thoriumWallLarge: Packages.mindustry.world.Block;
        public static door: Packages.mindustry.world.Block;
        public static doorLarge: Packages.mindustry.world.Block;
        public static phaseWall: Packages.mindustry.world.Block;
        public static phaseWallLarge: Packages.mindustry.world.Block;
        public static surgeWall: Packages.mindustry.world.Block;
        public static surgeWallLarge: Packages.mindustry.world.Block;
        public static berylliumWall: Packages.mindustry.world.Block;
        public static berylliumWallLarge: Packages.mindustry.world.Block;
        public static tungstenWall: Packages.mindustry.world.Block;
        public static tungstenWallLarge: Packages.mindustry.world.Block;
        public static blastDoor: Packages.mindustry.world.Block;
        public static reinforcedSurgeWall: Packages.mindustry.world.Block;
        public static reinforcedSurgeWallLarge: Packages.mindustry.world.Block;
        public static carbideWall: Packages.mindustry.world.Block;
        public static carbideWallLarge: Packages.mindustry.world.Block;
        public static shieldedWall: Packages.mindustry.world.Block;
        public static mender: Packages.mindustry.world.Block;
        public static mendProjector: Packages.mindustry.world.Block;
        public static overdriveProjector: Packages.mindustry.world.Block;
        public static overdriveDome: Packages.mindustry.world.Block;
        public static forceProjector: Packages.mindustry.world.Block;
        public static shockMine: Packages.mindustry.world.Block;
        public static scrapWall: Packages.mindustry.world.Block;
        public static scrapWallLarge: Packages.mindustry.world.Block;
        public static scrapWallHuge: Packages.mindustry.world.Block;
        public static scrapWallGigantic: Packages.mindustry.world.Block;
        public static thruster: Packages.mindustry.world.Block;
        public static radar: Packages.mindustry.world.Block;
        public static buildTower: Packages.mindustry.world.Block;
        public static regenProjector: Packages.mindustry.world.Block;
        public static barrierProjector: Packages.mindustry.world.Block;
        public static shockwaveTower: Packages.mindustry.world.Block;
        public static shieldProjector: Packages.mindustry.world.Block;
        public static largeShieldProjector: Packages.mindustry.world.Block;
        public static shieldBreaker: Packages.mindustry.world.Block;
        public static conveyor: Packages.mindustry.world.Block;
        public static titaniumConveyor: Packages.mindustry.world.Block;
        public static plastaniumConveyor: Packages.mindustry.world.Block;
        public static armoredConveyor: Packages.mindustry.world.Block;
        public static distributor: Packages.mindustry.world.Block;
        public static junction: Packages.mindustry.world.Block;
        public static itemBridge: Packages.mindustry.world.Block;
        public static phaseConveyor: Packages.mindustry.world.Block;
        public static sorter: Packages.mindustry.world.Block;
        public static invertedSorter: Packages.mindustry.world.Block;
        public static router: Packages.mindustry.world.Block;
        public static overflowGate: Packages.mindustry.world.Block;
        public static underflowGate: Packages.mindustry.world.Block;
        public static massDriver: Packages.mindustry.world.Block;
        public static duct: Packages.mindustry.world.Block;
        public static armoredDuct: Packages.mindustry.world.Block;
        public static ductRouter: Packages.mindustry.world.Block;
        public static overflowDuct: Packages.mindustry.world.Block;
        public static underflowDuct: Packages.mindustry.world.Block;
        public static ductBridge: Packages.mindustry.world.Block;
        public static ductUnloader: Packages.mindustry.world.Block;
        public static surgeConveyor: Packages.mindustry.world.Block;
        public static surgeRouter: Packages.mindustry.world.Block;
        public static unitCargoLoader: Packages.mindustry.world.Block;
        public static unitCargoUnloadPoint: Packages.mindustry.world.Block;
        public static mechanicalPump: Packages.mindustry.world.Block;
        public static rotaryPump: Packages.mindustry.world.Block;
        public static impulsePump: Packages.mindustry.world.Block;
        public static conduit: Packages.mindustry.world.Block;
        public static pulseConduit: Packages.mindustry.world.Block;
        public static platedConduit: Packages.mindustry.world.Block;
        public static liquidRouter: Packages.mindustry.world.Block;
        public static liquidContainer: Packages.mindustry.world.Block;
        public static liquidTank: Packages.mindustry.world.Block;
        public static liquidJunction: Packages.mindustry.world.Block;
        public static bridgeConduit: Packages.mindustry.world.Block;
        public static phaseConduit: Packages.mindustry.world.Block;
        public static reinforcedPump: Packages.mindustry.world.Block;
        public static reinforcedConduit: Packages.mindustry.world.Block;
        public static reinforcedLiquidJunction: Packages.mindustry.world.Block;
        public static reinforcedBridgeConduit: Packages.mindustry.world.Block;
        public static reinforcedLiquidRouter: Packages.mindustry.world.Block;
        public static reinforcedLiquidContainer: Packages.mindustry.world.Block;
        public static reinforcedLiquidTank: Packages.mindustry.world.Block;
        public static combustionGenerator: Packages.mindustry.world.Block;
        public static thermalGenerator: Packages.mindustry.world.Block;
        public static steamGenerator: Packages.mindustry.world.Block;
        public static differentialGenerator: Packages.mindustry.world.Block;
        public static rtgGenerator: Packages.mindustry.world.Block;
        public static solarPanel: Packages.mindustry.world.Block;
        public static largeSolarPanel: Packages.mindustry.world.Block;
        public static thoriumReactor: Packages.mindustry.world.Block;
        public static impactReactor: Packages.mindustry.world.Block;
        public static battery: Packages.mindustry.world.Block;
        public static batteryLarge: Packages.mindustry.world.Block;
        public static powerNode: Packages.mindustry.world.Block;
        public static powerNodeLarge: Packages.mindustry.world.Block;
        public static surgeTower: Packages.mindustry.world.Block;
        public static diode: Packages.mindustry.world.Block;
        public static turbineCondenser: Packages.mindustry.world.Block;
        public static ventCondenser: Packages.mindustry.world.Block;
        public static chemicalCombustionChamber: Packages.mindustry.world.Block;
        public static pyrolysisGenerator: Packages.mindustry.world.Block;
        public static fluxReactor: Packages.mindustry.world.Block;
        public static neoplasiaReactor: Packages.mindustry.world.Block;
        public static beamNode: Packages.mindustry.world.Block;
        public static beamTower: Packages.mindustry.world.Block;
        public static beamLink: Packages.mindustry.world.Block;
        public static mechanicalDrill: Packages.mindustry.world.Block;
        public static pneumaticDrill: Packages.mindustry.world.Block;
        public static laserDrill: Packages.mindustry.world.Block;
        public static blastDrill: Packages.mindustry.world.Block;
        public static waterExtractor: Packages.mindustry.world.Block;
        public static oilExtractor: Packages.mindustry.world.Block;
        public static cultivator: Packages.mindustry.world.Block;
        public static cliffCrusher: Packages.mindustry.world.Block;
        public static plasmaBore: Packages.mindustry.world.Block;
        public static largePlasmaBore: Packages.mindustry.world.Block;
        public static impactDrill: Packages.mindustry.world.Block;
        public static eruptionDrill: Packages.mindustry.world.Block;
        public static coreShard: Packages.mindustry.world.Block;
        public static coreFoundation: Packages.mindustry.world.Block;
        public static coreNucleus: Packages.mindustry.world.Block;
        public static vault: Packages.mindustry.world.Block;
        public static container: Packages.mindustry.world.Block;
        public static unloader: Packages.mindustry.world.Block;
        public static coreBastion: Packages.mindustry.world.Block;
        public static coreCitadel: Packages.mindustry.world.Block;
        public static coreAcropolis: Packages.mindustry.world.Block;
        public static reinforcedContainer: Packages.mindustry.world.Block;
        public static reinforcedVault: Packages.mindustry.world.Block;
        public static duo: Packages.mindustry.world.Block;
        public static scatter: Packages.mindustry.world.Block;
        public static scorch: Packages.mindustry.world.Block;
        public static hail: Packages.mindustry.world.Block;
        public static arc: Packages.mindustry.world.Block;
        public static wave: Packages.mindustry.world.Block;
        public static lancer: Packages.mindustry.world.Block;
        public static swarmer: Packages.mindustry.world.Block;
        public static salvo: Packages.mindustry.world.Block;
        public static fuse: Packages.mindustry.world.Block;
        public static ripple: Packages.mindustry.world.Block;
        public static cyclone: Packages.mindustry.world.Block;
        public static foreshadow: Packages.mindustry.world.Block;
        public static spectre: Packages.mindustry.world.Block;
        public static meltdown: Packages.mindustry.world.Block;
        public static segment: Packages.mindustry.world.Block;
        public static parallax: Packages.mindustry.world.Block;
        public static tsunami: Packages.mindustry.world.Block;
        public static breach: Packages.mindustry.world.Block;
        public static diffuse: Packages.mindustry.world.Block;
        public static sublimate: Packages.mindustry.world.Block;
        public static titan: Packages.mindustry.world.Block;
        public static disperse: Packages.mindustry.world.Block;
        public static afflict: Packages.mindustry.world.Block;
        public static lustre: Packages.mindustry.world.Block;
        public static scathe: Packages.mindustry.world.Block;
        public static smite: Packages.mindustry.world.Block;
        public static malign: Packages.mindustry.world.Block;
        public static groundFactory: Packages.mindustry.world.Block;
        public static airFactory: Packages.mindustry.world.Block;
        public static navalFactory: Packages.mindustry.world.Block;
        public static additiveRe_constructor: Packages.mindustry.world.Block;
        public static multiplicativeRe_constructor: Packages.mindustry.world.Block;
        public static exponentialRe_constructor: Packages.mindustry.world.Block;
        public static tetrativeRe_constructor: Packages.mindustry.world.Block;
        public static repairPoint: Packages.mindustry.world.Block;
        public static repairTurret: Packages.mindustry.world.Block;
        public static tankFabricator: Packages.mindustry.world.Block;
        public static shipFabricator: Packages.mindustry.world.Block;
        public static mechFabricator: Packages.mindustry.world.Block;
        public static tankRefabricator: Packages.mindustry.world.Block;
        public static shipRefabricator: Packages.mindustry.world.Block;
        public static mechRefabricator: Packages.mindustry.world.Block;
        public static primeRefabricator: Packages.mindustry.world.Block;
        public static tankAssembler: Packages.mindustry.world.Block;
        public static shipAssembler: Packages.mindustry.world.Block;
        public static mechAssembler: Packages.mindustry.world.Block;
        public static basicAssemblerModule: Packages.mindustry.world.Block;
        public static unitRepairTower: Packages.mindustry.world.Block;
        public static payloadConveyor: Packages.mindustry.world.Block;
        public static payloadRouter: Packages.mindustry.world.Block;
        public static reinforcedPayloadConveyor: Packages.mindustry.world.Block;
        public static reinforcedPayloadRouter: Packages.mindustry.world.Block;
        public static payloadMassDriver: Packages.mindustry.world.Block;
        public static largePayloadMassDriver: Packages.mindustry.world.Block;
        public static smallDe_constructor: Packages.mindustry.world.Block;
        public static de_constructor: Packages.mindustry.world.Block;
        public static _constructor: Packages.mindustry.world.Block;
        public static largeConstructor: Packages.mindustry.world.Block;
        public static payloadLoader: Packages.mindustry.world.Block;
        public static payloadUnloader: Packages.mindustry.world.Block;
        public static message: Packages.mindustry.world.Block;
        public static switchBlock: Packages.mindustry.world.Block;
        public static microProcessor: Packages.mindustry.world.Block;
        public static logicProcessor: Packages.mindustry.world.Block;
        public static hyperProcessor: Packages.mindustry.world.Block;
        public static largeLogicDisplay: Packages.mindustry.world.Block;
        public static logicDisplay: Packages.mindustry.world.Block;
        public static memoryCell: Packages.mindustry.world.Block;
        public static memoryBank: Packages.mindustry.world.Block;
        public static canvas: Packages.mindustry.world.Block;
        public static reinforcedMessage: Packages.mindustry.world.Block;
        public static worldProcessor: Packages.mindustry.world.Block;
        public static worldCell: Packages.mindustry.world.Block;
        public static worldMessage: Packages.mindustry.world.Block;
        public static worldSwitch: Packages.mindustry.world.Block;
        public static launchPad: Packages.mindustry.world.Block;
        public static interplanetaryAccelerator: Packages.mindustry.world.Block;
        public static load(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace content {
      declare class Bullets extends java.lang.Object {
        public static placeholder: Packages.mindustry.entities.bullet.BulletType;
        public static spaceLiquid: Packages.mindustry.entities.bullet.BulletType;
        public static damageLightning: Packages.mindustry.entities.bullet.BulletType;
        public static damageLightningGround: Packages.mindustry.entities.bullet.BulletType;
        public static fireball: Packages.mindustry.entities.bullet.BulletType;
        public static load(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace content {
      declare class ErekirTechTree extends java.lang
        .Object {
        static balanced: Packages.arc.struct.IntSet;
        public static load(): void;
        static rebalanceBullet(
          _bullet: Packages.mindustry.entities.bullet.BulletType,
        ): void;
        public static rebalance(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace content {
      declare class Fx extends java.lang.Object {
        public static rand: Packages.arc.math.Rand;
        public static v: Packages.arc.math.geom.Vec2;
        public static none: Packages.mindustry.entities.Effect;
        public static blockCrash: Packages.mindustry.entities.Effect;
        public static trailFade: Packages.mindustry.entities.Effect;
        public static unitSpawn: Packages.mindustry.entities.Effect;
        public static unitCapKill: Packages.mindustry.entities.Effect;
        public static unitEnvKill: Packages.mindustry.entities.Effect;
        public static unitControl: Packages.mindustry.entities.Effect;
        public static unitDespawn: Packages.mindustry.entities.Effect;
        public static unitSpirit: Packages.mindustry.entities.Effect;
        public static itemTransfer: Packages.mindustry.entities.Effect;
        public static pointBeam: Packages.mindustry.entities.Effect;
        public static pointHit: Packages.mindustry.entities.Effect;
        public static lightning: Packages.mindustry.entities.Effect;
        public static coreBuildShockwave: Packages.mindustry.entities.Effect;
        public static coreBuildBlock: Packages.mindustry.entities.Effect;
        public static pointShockwave: Packages.mindustry.entities.Effect;
        public static moveCommand: Packages.mindustry.entities.Effect;
        public static attackCommand: Packages.mindustry.entities.Effect;
        public static commandSend: Packages.mindustry.entities.Effect;
        public static upgradeCore: Packages.mindustry.entities.Effect;
        public static upgradeCoreBloom: Packages.mindustry.entities.Effect;
        public static placeBlock: Packages.mindustry.entities.Effect;
        public static coreLaunchConstruct: Packages.mindustry.entities.Effect;
        public static tapBlock: Packages.mindustry.entities.Effect;
        public static breakBlock: Packages.mindustry.entities.Effect;
        public static payloadDeposit: Packages.mindustry.entities.Effect;
        public static select: Packages.mindustry.entities.Effect;
        public static smoke: Packages.mindustry.entities.Effect;
        public static fallSmoke: Packages.mindustry.entities.Effect;
        public static unitWreck: Packages.mindustry.entities.Effect;
        public static rocketSmoke: Packages.mindustry.entities.Effect;
        public static rocketSmokeLarge: Packages.mindustry.entities.Effect;
        public static magmasmoke: Packages.mindustry.entities.Effect;
        public static spawn: Packages.mindustry.entities.Effect;
        public static unitAssemble: Packages.mindustry.entities.Effect;
        public static padlaunch: Packages.mindustry.entities.Effect;
        public static breakProp: Packages.mindustry.entities.Effect;
        public static unitDrop: Packages.mindustry.entities.Effect;
        public static unitLand: Packages.mindustry.entities.Effect;
        public static unitDust: Packages.mindustry.entities.Effect;
        public static unitLandSmall: Packages.mindustry.entities.Effect;
        public static unitPickup: Packages.mindustry.entities.Effect;
        public static crawlDust: Packages.mindustry.entities.Effect;
        public static landShock: Packages.mindustry.entities.Effect;
        public static pickup: Packages.mindustry.entities.Effect;
        public static sparkExplosion: Packages.mindustry.entities.Effect;
        public static titanExplosion: Packages.mindustry.entities.Effect;
        public static titanSmoke: Packages.mindustry.entities.Effect;
        public static missileTrailSmoke: Packages.mindustry.entities.Effect;
        public static neoplasmSplat: Packages.mindustry.entities.Effect;
        public static scatheExplosion: Packages.mindustry.entities.Effect;
        public static scatheLight: Packages.mindustry.entities.Effect;
        public static scatheSlash: Packages.mindustry.entities.Effect;
        public static dynamicSpikes: Packages.mindustry.entities.Effect;
        public static greenBomb: Packages.mindustry.entities.Effect;
        public static greenLaserCharge: Packages.mindustry.entities.Effect;
        public static greenLaserChargeSmall: Packages.mindustry.entities.Effect;
        public static greenCloud: Packages.mindustry.entities.Effect;
        public static healWaveDynamic: Packages.mindustry.entities.Effect;
        public static healWave: Packages.mindustry.entities.Effect;
        public static heal: Packages.mindustry.entities.Effect;
        public static dynamicWave: Packages.mindustry.entities.Effect;
        public static shieldWave: Packages.mindustry.entities.Effect;
        public static shieldApply: Packages.mindustry.entities.Effect;
        public static disperseTrail: Packages.mindustry.entities.Effect;
        public static hitBulletSmall: Packages.mindustry.entities.Effect;
        public static hitBulletColor: Packages.mindustry.entities.Effect;
        public static hitSquaresColor: Packages.mindustry.entities.Effect;
        public static hitFuse: Packages.mindustry.entities.Effect;
        public static hitBulletBig: Packages.mindustry.entities.Effect;
        public static hitFlameSmall: Packages.mindustry.entities.Effect;
        public static hitFlamePlasma: Packages.mindustry.entities.Effect;
        public static hitLiquid: Packages.mindustry.entities.Effect;
        public static hitLaserBlast: Packages.mindustry.entities.Effect;
        public static hitEmpSpark: Packages.mindustry.entities.Effect;
        public static hitLancer: Packages.mindustry.entities.Effect;
        public static hitBeam: Packages.mindustry.entities.Effect;
        public static hitFlameBeam: Packages.mindustry.entities.Effect;
        public static hitMeltdown: Packages.mindustry.entities.Effect;
        public static hitMeltHeal: Packages.mindustry.entities.Effect;
        public static instBomb: Packages.mindustry.entities.Effect;
        public static instTrail: Packages.mindustry.entities.Effect;
        public static instShoot: Packages.mindustry.entities.Effect;
        public static instHit: Packages.mindustry.entities.Effect;
        public static hitLaser: Packages.mindustry.entities.Effect;
        public static hitLaserColor: Packages.mindustry.entities.Effect;
        public static despawn: Packages.mindustry.entities.Effect;
        public static airBubble: Packages.mindustry.entities.Effect;
        public static flakExplosion: Packages.mindustry.entities.Effect;
        public static plasticExplosion: Packages.mindustry.entities.Effect;
        public static plasticExplosionFlak: Packages.mindustry.entities.Effect;
        public static blastExplosion: Packages.mindustry.entities.Effect;
        public static sapExplosion: Packages.mindustry.entities.Effect;
        public static massiveExplosion: Packages.mindustry.entities.Effect;
        public static artilleryTrail: Packages.mindustry.entities.Effect;
        public static incendTrail: Packages.mindustry.entities.Effect;
        public static missileTrail: Packages.mindustry.entities.Effect;
        public static missileTrailShort: Packages.mindustry.entities.Effect;
        public static colorTrail: Packages.mindustry.entities.Effect;
        public static absorb: Packages.mindustry.entities.Effect;
        public static forceShrink: Packages.mindustry.entities.Effect;
        public static flakExplosionBig: Packages.mindustry.entities.Effect;
        public static burning: Packages.mindustry.entities.Effect;
        public static fireRemove: Packages.mindustry.entities.Effect;
        public static fire: Packages.mindustry.entities.Effect;
        public static fireHit: Packages.mindustry.entities.Effect;
        public static fireSmoke: Packages.mindustry.entities.Effect;
        public static neoplasmHeal: Packages.mindustry.entities.Effect;
        public static steam: Packages.mindustry.entities.Effect;
        public static ventSteam: Packages.mindustry.entities.Effect;
        public static drillSteam: Packages.mindustry.entities.Effect;
        public static fluxVapor: Packages.mindustry.entities.Effect;
        public static vapor: Packages.mindustry.entities.Effect;
        public static vaporSmall: Packages.mindustry.entities.Effect;
        public static fireballsmoke: Packages.mindustry.entities.Effect;
        public static ballfire: Packages.mindustry.entities.Effect;
        public static freezing: Packages.mindustry.entities.Effect;
        public static melting: Packages.mindustry.entities.Effect;
        public static wet: Packages.mindustry.entities.Effect;
        public static muddy: Packages.mindustry.entities.Effect;
        public static sapped: Packages.mindustry.entities.Effect;
        public static electrified: Packages.mindustry.entities.Effect;
        public static sporeSlowed: Packages.mindustry.entities.Effect;
        public static oily: Packages.mindustry.entities.Effect;
        public static overdriven: Packages.mindustry.entities.Effect;
        public static overclocked: Packages.mindustry.entities.Effect;
        public static dropItem: Packages.mindustry.entities.Effect;
        public static shockwave: Packages.mindustry.entities.Effect;
        public static bigShockwave: Packages.mindustry.entities.Effect;
        public static spawnShockwave: Packages.mindustry.entities.Effect;
        public static explosion: Packages.mindustry.entities.Effect;
        public static dynamicExplosion: Packages.mindustry.entities.Effect;
        public static reactorExplosion: Packages.mindustry.entities.Effect;
        public static impactReactorExplosion: Packages.mindustry.entities.Effect;
        public static blockExplosionSmoke: Packages.mindustry.entities.Effect;
        public static smokePuff: Packages.mindustry.entities.Effect;
        public static shootSmall: Packages.mindustry.entities.Effect;
        public static shootSmallColor: Packages.mindustry.entities.Effect;
        public static shootHeal: Packages.mindustry.entities.Effect;
        public static shootHealYellow: Packages.mindustry.entities.Effect;
        public static shootSmallSmoke: Packages.mindustry.entities.Effect;
        public static shootBig: Packages.mindustry.entities.Effect;
        public static shootBig2: Packages.mindustry.entities.Effect;
        public static shootBigColor: Packages.mindustry.entities.Effect;
        public static shootTitan: Packages.mindustry.entities.Effect;
        public static shootBigSmoke: Packages.mindustry.entities.Effect;
        public static shootBigSmoke2: Packages.mindustry.entities.Effect;
        public static shootSmokeDisperse: Packages.mindustry.entities.Effect;
        public static shootSmokeSquare: Packages.mindustry.entities.Effect;
        public static shootSmokeSquareSparse: Packages.mindustry.entities.Effect;
        public static shootSmokeSquareBig: Packages.mindustry.entities.Effect;
        public static shootSmokeTitan: Packages.mindustry.entities.Effect;
        public static shootSmokeSmite: Packages.mindustry.entities.Effect;
        public static shootSmokeMissile: Packages.mindustry.entities.Effect;
        public static regenParticle: Packages.mindustry.entities.Effect;
        public static regenSuppressParticle: Packages.mindustry.entities.Effect;
        public static regenSuppressSeek: Packages.mindustry.entities.Effect;
        public static surgeCruciSmoke: Packages.mindustry.entities.Effect;
        public static neoplasiaSmoke: Packages.mindustry.entities.Effect;
        public static heatReactorSmoke: Packages.mindustry.entities.Effect;
        public static circleColorSpark: Packages.mindustry.entities.Effect;
        public static colorSpark: Packages.mindustry.entities.Effect;
        public static colorSparkBig: Packages.mindustry.entities.Effect;
        public static randLifeSpark: Packages.mindustry.entities.Effect;
        public static shootPayloadDriver: Packages.mindustry.entities.Effect;
        public static shootSmallFlame: Packages.mindustry.entities.Effect;
        public static shootPyraFlame: Packages.mindustry.entities.Effect;
        public static shootLiquid: Packages.mindustry.entities.Effect;
        public static casing1: Packages.mindustry.entities.Effect;
        public static casing2: Packages.mindustry.entities.Effect;
        public static casing3: Packages.mindustry.entities.Effect;
        public static casing4: Packages.mindustry.entities.Effect;
        public static casing2Double: Packages.mindustry.entities.Effect;
        public static casing3Double: Packages.mindustry.entities.Effect;
        public static railShoot: Packages.mindustry.entities.Effect;
        public static railTrail: Packages.mindustry.entities.Effect;
        public static railHit: Packages.mindustry.entities.Effect;
        public static lancerLaserShoot: Packages.mindustry.entities.Effect;
        public static lancerLaserShootSmoke: Packages.mindustry.entities.Effect;
        public static lancerLaserCharge: Packages.mindustry.entities.Effect;
        public static lancerLaserChargeBegin: Packages.mindustry.entities.Effect;
        public static lightningCharge: Packages.mindustry.entities.Effect;
        public static sparkShoot: Packages.mindustry.entities.Effect;
        public static lightningShoot: Packages.mindustry.entities.Effect;
        public static thoriumShoot: Packages.mindustry.entities.Effect;
        public static reactorsmoke: Packages.mindustry.entities.Effect;
        public static redgeneratespark: Packages.mindustry.entities.Effect;
        public static turbinegenerate: Packages.mindustry.entities.Effect;
        public static generatespark: Packages.mindustry.entities.Effect;
        public static fuelburn: Packages.mindustry.entities.Effect;
        public static incinerateSlag: Packages.mindustry.entities.Effect;
        public static coreBurn: Packages.mindustry.entities.Effect;
        public static plasticburn: Packages.mindustry.entities.Effect;
        public static conveyorPoof: Packages.mindustry.entities.Effect;
        public static pulverize: Packages.mindustry.entities.Effect;
        public static pulverizeRed: Packages.mindustry.entities.Effect;
        public static pulverizeSmall: Packages.mindustry.entities.Effect;
        public static pulverizeMedium: Packages.mindustry.entities.Effect;
        public static producesmoke: Packages.mindustry.entities.Effect;
        public static artilleryTrailSmoke: Packages.mindustry.entities.Effect;
        public static smokeCloud: Packages.mindustry.entities.Effect;
        public static smeltsmoke: Packages.mindustry.entities.Effect;
        public static coalSmeltsmoke: Packages.mindustry.entities.Effect;
        public static formsmoke: Packages.mindustry.entities.Effect;
        public static blastsmoke: Packages.mindustry.entities.Effect;
        public static lava: Packages.mindustry.entities.Effect;
        public static dooropen: Packages.mindustry.entities.Effect;
        public static doorclose: Packages.mindustry.entities.Effect;
        public static dooropenlarge: Packages.mindustry.entities.Effect;
        public static doorcloselarge: Packages.mindustry.entities.Effect;
        public static generate: Packages.mindustry.entities.Effect;
        public static mineWallSmall: Packages.mindustry.entities.Effect;
        public static mineSmall: Packages.mindustry.entities.Effect;
        public static mine: Packages.mindustry.entities.Effect;
        public static mineBig: Packages.mindustry.entities.Effect;
        public static mineHuge: Packages.mindustry.entities.Effect;
        public static mineImpact: Packages.mindustry.entities.Effect;
        public static mineImpactWave: Packages.mindustry.entities.Effect;
        public static payloadReceive: Packages.mindustry.entities.Effect;
        public static teleportActivate: Packages.mindustry.entities.Effect;
        public static teleport: Packages.mindustry.entities.Effect;
        public static teleportOut: Packages.mindustry.entities.Effect;
        public static ripple: Packages.mindustry.entities.Effect;
        public static bubble: Packages.mindustry.entities.Effect;
        public static launch: Packages.mindustry.entities.Effect;
        public static launchPod: Packages.mindustry.entities.Effect;
        public static healWaveMend: Packages.mindustry.entities.Effect;
        public static overdriveWave: Packages.mindustry.entities.Effect;
        public static healBlock: Packages.mindustry.entities.Effect;
        public static healBlockFull: Packages.mindustry.entities.Effect;
        public static rotateBlock: Packages.mindustry.entities.Effect;
        public static lightBlock: Packages.mindustry.entities.Effect;
        public static overdriveBlockFull: Packages.mindustry.entities.Effect;
        public static shieldBreak: Packages.mindustry.entities.Effect;
        public static arcShieldBreak: Packages.mindustry.entities.Effect;
        public static coreLandDust: Packages.mindustry.entities.Effect;
        public static unitShieldBreak: Packages.mindustry.entities.Effect;
        public static chainLightning: Packages.mindustry.entities.Effect;
        public static chainEmp: Packages.mindustry.entities.Effect;
        public static legDestroy: Packages.mindustry.entities.Effect;
        public static debugLine: Packages.mindustry.entities.Effect;
        public static debugRect: Packages.mindustry.entities.Effect;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace content {
      declare class Items extends java.lang.Object {
        public static scrap: Packages.mindustry._type.Item;
        public static copper: Packages.mindustry._type.Item;
        public static lead: Packages.mindustry._type.Item;
        public static graphite: Packages.mindustry._type.Item;
        public static coal: Packages.mindustry._type.Item;
        public static titanium: Packages.mindustry._type.Item;
        public static thorium: Packages.mindustry._type.Item;
        public static silicon: Packages.mindustry._type.Item;
        public static plastanium: Packages.mindustry._type.Item;
        public static phaseFabric: Packages.mindustry._type.Item;
        public static surgeAlloy: Packages.mindustry._type.Item;
        public static sporePod: Packages.mindustry._type.Item;
        public static sand: Packages.mindustry._type.Item;
        public static blastCompound: Packages.mindustry._type.Item;
        public static pyratite: Packages.mindustry._type.Item;
        public static metaglass: Packages.mindustry._type.Item;
        public static beryllium: Packages.mindustry._type.Item;
        public static tungsten: Packages.mindustry._type.Item;
        public static oxide: Packages.mindustry._type.Item;
        public static carbide: Packages.mindustry._type.Item;
        public static fissileMatter: Packages.mindustry._type.Item;
        public static dormantCyst: Packages.mindustry._type.Item;
        public static serpuloItems: Packages.arc.struct.Seq<Packages.mindustry._type.Item>;
        public static erekirItems: Packages.arc.struct.Seq<Packages.mindustry._type.Item>;
        public static erekirOnlyItems: Packages.arc.struct.Seq<Packages.mindustry._type.Item>;
        public static load(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace content {
      declare class Liquids extends java.lang.Object {
        public static water: Packages.mindustry._type.Liquid;
        public static slag: Packages.mindustry._type.Liquid;
        public static oil: Packages.mindustry._type.Liquid;
        public static cryofluid: Packages.mindustry._type.Liquid;
        public static arkycite: Packages.mindustry._type.Liquid;
        public static gallium: Packages.mindustry._type.Liquid;
        public static neoplasm: Packages.mindustry._type.Liquid;
        public static ozone: Packages.mindustry._type.Liquid;
        public static hydrogen: Packages.mindustry._type.Liquid;
        public static nitrogen: Packages.mindustry._type.Liquid;
        public static cyanogen: Packages.mindustry._type.Liquid;
        public static load(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace content {
      declare class Loadouts extends java.lang.Object {
        public static basicShard: Packages.mindustry.game.Schematic;
        public static basicFoundation: Packages.mindustry.game.Schematic;
        public static basicNucleus: Packages.mindustry.game.Schematic;
        public static basicBastion: Packages.mindustry.game.Schematic;
        public static load(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace generators {
        declare class BlankPlanetGenerator extends Packages
          .mindustry.maps.generators.PlanetGenerator {
          public generate(
            _tiles: Packages.mindustry.world.Tiles,
            _sec: Packages.mindustry._type.Sector,
            _seed: number,
          ): void;
          public getHeight(
            _position: Packages.arc.math.geom.Vec3,
          ): number;
          public getColor(
            _position: Packages.arc.math.geom.Vec3,
          ): Packages.arc.graphics.Color;
          public addWeather(
            _sector: Packages.mindustry._type.Sector,
            _rules: Packages.mindustry.game.Rules,
          ): void;
          public generateSector(
            _sector: Packages.mindustry._type.Sector,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace planet {
        declare class AsteroidGenerator extends Packages
          .mindustry.maps.generators.BlankPlanetGenerator {
          public min: number;
          public max: number;
          public octaves: number;
          public foct: number;
          public radMin: number;
          public radMax: number;
          public persistence: number;
          public scale: number;
          public mag: number;
          public thresh: number;
          public fmag: number;
          public fscl: number;
          public fper: number;
          public stoneChance: number;
          public iceChance: number;
          public carbonChance: number;
          public berylChance: number;
          public ferricChance: number;
          public thoriumScl: number;
          public copperScale: number;
          public leadScale: number;
          public graphiteScale: number;
          public berylliumScale: number;
          rand?: Packages.arc.math.Rand;
          seed: number;
          public generate(): void;
          public getSectorSize(
            _sector: Packages.mindustry._type.Sector,
          ): number;
          asteroid(
            _ax: number,
            _ay: number,
            _radius: number,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace content {
      declare class Planets extends java.lang.Object {
        public static sun: Packages.mindustry._type.Planet;
        public static erekir: Packages.mindustry._type.Planet;
        public static tantros: Packages.mindustry._type.Planet;
        public static serpulo: Packages.mindustry._type.Planet;
        public static gier: Packages.mindustry._type.Planet;
        public static notva: Packages.mindustry._type.Planet;
        public static verilus: Packages.mindustry._type.Planet;
        public static load(): void;
        private static makeAsteroid(
          _name: string,
          _parent: Packages.mindustry._type.Planet,
          _base: Packages.mindustry.world.Block,
          _tint: Packages.mindustry.world.Block,
          _tintThresh: number,
          _pieces: number,
          _scale: number,
          _cgen: Packages.arc.func.Cons<Packages.mindustry.maps.planet.AsteroidGenerator>,
        ): Packages.mindustry._type.Planet;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace content {
      declare class SectorPresets extends java.lang.Object {
        public static groundZero: Packages.mindustry._type.SectorPreset;
        public static craters: Packages.mindustry._type.SectorPreset;
        public static biomassFacility: Packages.mindustry._type.SectorPreset;
        public static frozenForest: Packages.mindustry._type.SectorPreset;
        public static ruinousShores: Packages.mindustry._type.SectorPreset;
        public static windsweptIslands: Packages.mindustry._type.SectorPreset;
        public static stainedMountains: Packages.mindustry._type.SectorPreset;
        public static tarFields: Packages.mindustry._type.SectorPreset;
        public static fungalPass: Packages.mindustry._type.SectorPreset;
        public static extractionOutpost: Packages.mindustry._type.SectorPreset;
        public static saltFlats: Packages.mindustry._type.SectorPreset;
        public static overgrowth: Packages.mindustry._type.SectorPreset;
        public static impact0078: Packages.mindustry._type.SectorPreset;
        public static desolateRift: Packages.mindustry._type.SectorPreset;
        public static nuclearComplex: Packages.mindustry._type.SectorPreset;
        public static planetaryTerminal: Packages.mindustry._type.SectorPreset;
        public static coastline: Packages.mindustry._type.SectorPreset;
        public static navalFortress: Packages.mindustry._type.SectorPreset;
        public static onset: Packages.mindustry._type.SectorPreset;
        public static aegis: Packages.mindustry._type.SectorPreset;
        public static lake: Packages.mindustry._type.SectorPreset;
        public static intersect: Packages.mindustry._type.SectorPreset;
        public static basin: Packages.mindustry._type.SectorPreset;
        public static atlas: Packages.mindustry._type.SectorPreset;
        public static split: Packages.mindustry._type.SectorPreset;
        public static marsh: Packages.mindustry._type.SectorPreset;
        public static peaks: Packages.mindustry._type.SectorPreset;
        public static ravine: Packages.mindustry._type.SectorPreset;
        public static caldera: Packages.mindustry._type.SectorPreset;
        public static stronghold: Packages.mindustry._type.SectorPreset;
        public static crevice: Packages.mindustry._type.SectorPreset;
        public static siege: Packages.mindustry._type.SectorPreset;
        public static crossroads: Packages.mindustry._type.SectorPreset;
        public static karst: Packages.mindustry._type.SectorPreset;
        public static origin: Packages.mindustry._type.SectorPreset;
        public static load(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace content {
      declare class SerpuloTechTree extends java.lang
        .Object {
        public static load(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace content {
      declare class StatusEffects extends java.lang.Object {
        public static none: Packages.mindustry._type.StatusEffect;
        public static burning: Packages.mindustry._type.StatusEffect;
        public static freezing: Packages.mindustry._type.StatusEffect;
        public static unmoving: Packages.mindustry._type.StatusEffect;
        public static slow: Packages.mindustry._type.StatusEffect;
        public static fast: Packages.mindustry._type.StatusEffect;
        public static wet: Packages.mindustry._type.StatusEffect;
        public static muddy: Packages.mindustry._type.StatusEffect;
        public static melting: Packages.mindustry._type.StatusEffect;
        public static sapped: Packages.mindustry._type.StatusEffect;
        public static tarred: Packages.mindustry._type.StatusEffect;
        public static overdrive: Packages.mindustry._type.StatusEffect;
        public static overclock: Packages.mindustry._type.StatusEffect;
        public static shielded: Packages.mindustry._type.StatusEffect;
        public static shocked: Packages.mindustry._type.StatusEffect;
        public static blasted: Packages.mindustry._type.StatusEffect;
        public static corroded: Packages.mindustry._type.StatusEffect;
        public static boss: Packages.mindustry._type.StatusEffect;
        public static sporeSlowed: Packages.mindustry._type.StatusEffect;
        public static disarmed: Packages.mindustry._type.StatusEffect;
        public static electrified: Packages.mindustry._type.StatusEffect;
        public static invincible: Packages.mindustry._type.StatusEffect;
        public static dynamic: Packages.mindustry._type.StatusEffect;
        public static load(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace content {
      declare class TeamEntries extends java.lang.Object {
        public static load(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace content {
      declare class TechTree extends java.lang.Object {
        public static TechNode = class extends java.lang
          .Object {
          public depth: number;
          public icon?: Packages.arc.scene.style.Drawable;
          public name?: string;
          public requiresUnlock: boolean;
          public parent?: Packages.mindustry.content.TechTree.TechNode;
          public researchCostMultipliers?: Packages.arc.struct.ObjectFloatMap<Packages.mindustry._type.Item>;
          public content: Packages.mindustry.ctype.UnlockableContent;
          public requirements: Packages.mindustry._type.ItemStack[];
          public finishedRequirements: Packages.mindustry._type.ItemStack[];
          public objectives: Packages.arc.struct.Seq<Packages.mindustry.game.Objectives.Objective>;
          public children: Packages.arc.struct.Seq<Packages.mindustry.content.TechTree.TechNode>;
          public planet?: Packages.mindustry._type.Planet;
          public remove(): void;
          public save(): void;
          public reset(): void;
          public each(
            _consumer: Packages.arc.func.Cons<Packages.mindustry.content.TechTree.TechNode>,
          ): void;
          public localizedName(): string;
          public icon(): Packages.arc.scene.style.Drawable;
          public setupRequirements(
            _requirements: Packages.mindustry._type.ItemStack[],
          ): void;
          public constructor(
            _parent: Packages.mindustry.content.TechTree.TechNode | null,
            _content: Packages.mindustry.ctype.UnlockableContent,
            _requirements: Packages.mindustry._type.ItemStack[],
          );
        };
        public static all: Packages.arc.struct.Seq<Packages.mindustry.content.TechTree.TechNode>;
        public static roots: Packages.arc.struct.Seq<Packages.mindustry.content.TechTree.TechNode>;
        public static context(): Packages.mindustry.content.TechTree.TechNode | null;
        public static node(
          _content: Packages.mindustry.ctype.UnlockableContent,
          _objectives: Packages.arc.struct.Seq<Packages.mindustry.game.Objectives.Objective>,
          _children: Packages.java.lang.Runnable,
        ): Packages.mindustry.content.TechTree.TechNode;
        public static node(
          _content: Packages.mindustry.ctype.UnlockableContent,
          _requirements: Packages.mindustry._type.ItemStack[],
          _objectives: Packages.arc.struct.Seq<Packages.mindustry.game.Objectives.Objective>,
          _children: Packages.java.lang.Runnable,
        ): Packages.mindustry.content.TechTree.TechNode;
        public static node(
          _content: Packages.mindustry.ctype.UnlockableContent,
          _children: Packages.java.lang.Runnable,
        ): Packages.mindustry.content.TechTree.TechNode;
        public static node(
          _block: Packages.mindustry.ctype.UnlockableContent,
        ): Packages.mindustry.content.TechTree.TechNode;
        public static node(
          _content: Packages.mindustry.ctype.UnlockableContent,
          _requirements: Packages.mindustry._type.ItemStack[],
          _children: Packages.java.lang.Runnable,
        ): Packages.mindustry.content.TechTree.TechNode;
        public static nodeRoot(
          _name: string,
          _content: Packages.mindustry.ctype.UnlockableContent,
          _requireUnlock: boolean,
          _children: Packages.java.lang.Runnable,
        ): Packages.mindustry.content.TechTree.TechNode;
        public static nodeRoot(
          _name: string,
          _content: Packages.mindustry.ctype.UnlockableContent,
          _children: Packages.java.lang.Runnable,
        ): Packages.mindustry.content.TechTree.TechNode;
        public static nodeProduce(
          _content: Packages.mindustry.ctype.UnlockableContent,
          _children: Packages.java.lang.Runnable,
        ): Packages.mindustry.content.TechTree.TechNode;
        public static nodeProduce(
          _content: Packages.mindustry.ctype.UnlockableContent,
          _objectives: Packages.arc.struct.Seq<Packages.mindustry.game.Objectives.Objective>,
          _children: Packages.java.lang.Runnable,
        ): Packages.mindustry.content.TechTree.TechNode;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace content {
      declare class UnitTypes extends java.lang.Object {
        public static mace: Packages.mindustry._type.UnitType;
        public static dagger: Packages.mindustry._type.UnitType;
        public static crawler: Packages.mindustry._type.UnitType;
        public static fortress: Packages.mindustry._type.UnitType;
        public static scepter: Packages.mindustry._type.UnitType;
        public static reign: Packages.mindustry._type.UnitType;
        public static vela: Packages.mindustry._type.UnitType;
        public static nova: Packages.mindustry._type.UnitType;
        public static pulsar: Packages.mindustry._type.UnitType;
        public static quasar: Packages.mindustry._type.UnitType;
        public static corvus: Packages.mindustry._type.UnitType;
        public static atrax: Packages.mindustry._type.UnitType;
        public static merui: Packages.mindustry._type.UnitType;
        public static cleroi: Packages.mindustry._type.UnitType;
        public static anthicus: Packages.mindustry._type.UnitType;
        public static tecta: Packages.mindustry._type.UnitType;
        public static collaris: Packages.mindustry._type.UnitType;
        public static spiroct: Packages.mindustry._type.UnitType;
        public static arkyid: Packages.mindustry._type.UnitType;
        public static toxopid: Packages.mindustry._type.UnitType;
        public static elude: Packages.mindustry._type.UnitType;
        public static flare: Packages.mindustry._type.UnitType;
        public static eclipse: Packages.mindustry._type.UnitType;
        public static horizon: Packages.mindustry._type.UnitType;
        public static zenith: Packages.mindustry._type.UnitType;
        public static antumbra: Packages.mindustry._type.UnitType;
        public static avert: Packages.mindustry._type.UnitType;
        public static obviate: Packages.mindustry._type.UnitType;
        public static mono: Packages.mindustry._type.UnitType;
        public static poly: Packages.mindustry._type.UnitType;
        public static mega: Packages.mindustry._type.UnitType;
        public static evoke: Packages.mindustry._type.UnitType;
        public static incite: Packages.mindustry._type.UnitType;
        public static emanate: Packages.mindustry._type.UnitType;
        public static quell: Packages.mindustry._type.UnitType;
        public static disrupt: Packages.mindustry._type.UnitType;
        public static quad: Packages.mindustry._type.UnitType;
        public static oct: Packages.mindustry._type.UnitType;
        public static alpha: Packages.mindustry._type.UnitType;
        public static beta: Packages.mindustry._type.UnitType;
        public static gamma: Packages.mindustry._type.UnitType;
        public static risso: Packages.mindustry._type.UnitType;
        public static minke: Packages.mindustry._type.UnitType;
        public static bryde: Packages.mindustry._type.UnitType;
        public static sei: Packages.mindustry._type.UnitType;
        public static omura: Packages.mindustry._type.UnitType;
        public static retusa: Packages.mindustry._type.UnitType;
        public static oxynoe: Packages.mindustry._type.UnitType;
        public static cyerce: Packages.mindustry._type.UnitType;
        public static aegires: Packages.mindustry._type.UnitType;
        public static navanax: Packages.mindustry._type.UnitType;
        public static block: Packages.mindustry._type.UnitType;
        public static manifold: Packages.mindustry._type.UnitType;
        public static assemblyDrone: Packages.mindustry._type.UnitType;
        public static stell: Packages.mindustry._type.UnitType;
        public static locus: Packages.mindustry._type.UnitType;
        public static precept: Packages.mindustry._type.UnitType;
        public static vanquish: Packages.mindustry._type.UnitType;
        public static conquer: Packages.mindustry._type.UnitType;
        public static missile: Packages.mindustry._type.UnitType;
        public static latum: Packages.mindustry._type.UnitType;
        public static renale: Packages.mindustry._type.UnitType;
        public static load(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace content {
      declare class Weathers extends java.lang.Object {
        public static rain: Packages.mindustry._type.Weather;
        public static snow: Packages.mindustry._type.Weather;
        public static sandstorm: Packages.mindustry._type.Weather;
        public static sporestorm: Packages.mindustry._type.Weather;
        public static fog: Packages.mindustry._type.Weather;
        public static suspendParticles: Packages.mindustry._type.Weather;
        public static load(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace core {
      declare class Version extends java.lang.Object {
        public static type: string;
        public static modifier: string;
        public static number: number;
        public static build: number;
        public static revision: number;
        public static enabled: boolean;
        public static init(): void;
        public static combined(): string;
        public static isAtLeast(
          _build: number,
          _revision: number,
          _str: string,
        ): boolean;
        public static isAtLeast(_str: string): boolean;
        public static buildString(): string;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace editor {
      declare class EditorTile extends Packages.mindustry
        .world.Tile {
        private update(): void;
        private skip(): boolean;
        private op(
          _type: Packages.mindustry.editor.DrawOperation.OpType,
          _value: Packages.short,
        ): void;
        protected changed(): void;
        public setBlock(
          _type: Packages.mindustry.world.Block,
          _team: Packages.mindustry.game.Team,
          _rotation: number,
          _entityprov: Packages.arc.func.Prov<Packages.mindustry.gen.Building>,
        ): void;
        public recache(): void;
        public isEditorTile(): boolean;
        public setFloor(
          _type: Packages.mindustry.world.blocks.environment.Floor,
        ): void;
        public setOverlay(
          _overlay: Packages.mindustry.world.Block,
        ): void;
        protected changeBuild(
          _team: Packages.mindustry.game.Team,
          _entityprov: Packages.arc.func.Prov<Packages.mindustry.gen.Building>,
          _rotation: number,
        ): void;
        protected firePreChanged(): void;
        protected fireChanged(): void;
        public setTeam(
          _team: Packages.mindustry.game.Team,
        ): void;
        public constructor(
          _x: number,
          _y: number,
          _floor: number,
          _overlay: number,
          _wall: number,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare class Damage extends java.lang.Object {
        public static Collided = class
          extends java.lang.Object
          implements Packages.arc.util.pooling.Pool.Poolable
        {
          public x: number;
          public y: number;
          public target: Packages.mindustry.gen.Teamc;
          public set(
            _x: number,
            _y: number,
            _target: Packages.mindustry.gen.Teamc,
          ): Packages.mindustry.entities.Damage.Collided;
          public reset(): void;
          public constructor();
        };
        private static bulletDamageEvent: Packages.mindustry.game.EventType.UnitDamageEvent;
        private static rect: Packages.arc.math.geom.Rect;
        private static hitrect: Packages.arc.math.geom.Rect;
        private static vec: Packages.arc.math.geom.Vec2;
        private static seg1: Packages.arc.math.geom.Vec2;
        private static seg2: Packages.arc.math.geom.Vec2;
        private static collidedBlocks: Packages.arc.struct.IntSet;
        private static damages: Packages.arc.struct.IntFloatMap;
        private static collided: Packages.arc.struct.Seq<Packages.mindustry.entities.Damage.Collided>;
        private static collidePool: Packages.arc.util.pooling.Pool<Packages.mindustry.entities.Damage.Collided>;
        private static builds: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
        private static distances: Packages.arc.struct.FloatSeq;
        private static furthest: Packages.mindustry.world.Tile;
        private static maxDst: number;
        private static tmpBuilding: Packages.mindustry.gen.Building;
        private static tmpUnit: Packages.mindustry.gen.Unit;
        public static status(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _radius: number,
          _effect: Packages.mindustry._type.StatusEffect,
          _duration: number,
          _air: boolean,
          _ground: boolean,
        ): void;
        public static findLength(
          _b: Packages.mindustry.gen.Bullet,
          _length: number,
          _laser: boolean,
          _pierceCap: number,
        ): number;
        public static damage(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _radius: number,
          _damage: number,
        ): void;
        public static damage(
          _x: number,
          _y: number,
          _radius: number,
          _damage: number,
        ): void;
        public static damage(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _radius: number,
          _damage: number,
          _complete: boolean,
          _air: boolean,
          _ground: boolean,
        ): void;
        public static damage(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _radius: number,
          _damage: number,
          _complete: boolean,
        ): void;
        public static damage(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _radius: number,
          _damage: number,
          _air: boolean,
          _ground: boolean,
        ): void;
        public static damage(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _radius: number,
          _damage: number,
          _complete: boolean,
          _air: boolean,
          _ground: boolean,
          _scaled: boolean,
          _source: Packages.mindustry.gen.Bullet | null,
        ): void;
        public static applyArmor(
          _damage: number,
          _armor: number,
        ): number;
        public static dynamicExplosion(
          _x: number,
          _y: number,
          _flammability: number,
          _explosiveness: number,
          _power: number,
          _radius: number,
          _damage: boolean,
          _explosionFx: Packages.mindustry.entities.Effect,
        ): void;
        public static dynamicExplosion(
          _x: number,
          _y: number,
          _flammability: number,
          _explosiveness: number,
          _power: number,
          _radius: number,
          _damage: boolean,
        ): void;
        public static dynamicExplosion(
          _x: number,
          _y: number,
          _flammability: number,
          _explosiveness: number,
          _power: number,
          _radius: number,
          _damage: boolean,
          _fire: boolean,
          _ignoreTeam: Packages.mindustry.game.Team | null,
          _explosionFx: Packages.mindustry.entities.Effect,
        ): void;
        public static dynamicExplosion(
          _x: number,
          _y: number,
          _flammability: number,
          _explosiveness: number,
          _power: number,
          _radius: number,
          _damage: boolean,
          _fire: boolean,
          _ignoreTeam: Packages.mindustry.game.Team | null,
        ): void;
        public static damageUnits(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _size: number,
          _damage: number,
          _predicate: Packages.arc.func.Boolf<Packages.mindustry.gen.Unit>,
          _acceptor: Packages.arc.func.Cons<Packages.mindustry.gen.Unit>,
        ): void;
        public static tileDamage(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _baseRadius: number,
          _damage: number,
          _source: Packages.mindustry.gen.Bullet | null,
        ): void;
        public static tileDamage(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _baseRadius: number,
          _damage: number,
        ): void;
        public static createIncend(
          _x: number,
          _y: number,
          _range: number,
          _amount: number,
        ): void;
        public static applySuppression(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _range: number,
          _reload: number,
          _maxDelay: number,
          _applyParticleChance: number,
          _source: Packages.arc.math.geom.Position | null,
        ): void;
        public static applySuppression(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _range: number,
          _reload: number,
          _maxDelay: number,
          _applyParticleChance: number,
          _source: Packages.arc.math.geom.Position | null,
          _effectColor: Packages.arc.graphics.Color,
        ): void;
        public static findLaserLength(
          _b: Packages.mindustry.gen.Bullet,
          _length: number,
        ): number;
        public static collideLine(
          _hitter: Packages.mindustry.gen.Bullet,
          _team: Packages.mindustry.game.Team,
          _effect: Packages.mindustry.entities.Effect,
          _x: number,
          _y: number,
          _angle: number,
          _length: number,
          _large: boolean,
          _laser: boolean,
          _pierceCap: number,
        ): void;
        public static collideLine(
          _hitter: Packages.mindustry.gen.Bullet,
          _team: Packages.mindustry.game.Team,
          _effect: Packages.mindustry.entities.Effect,
          _x: number,
          _y: number,
          _angle: number,
          _length: number,
          _large: boolean,
          _laser: boolean,
        ): void;
        public static collideLine(
          _hitter: Packages.mindustry.gen.Bullet,
          _team: Packages.mindustry.game.Team,
          _effect: Packages.mindustry.entities.Effect,
          _x: number,
          _y: number,
          _angle: number,
          _length: number,
        ): void;
        public static collideLine(
          _hitter: Packages.mindustry.gen.Bullet,
          _team: Packages.mindustry.game.Team,
          _effect: Packages.mindustry.entities.Effect,
          _x: number,
          _y: number,
          _angle: number,
          _length: number,
          _large: boolean,
        ): void;
        private static completeDamage(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _radius: number,
          _damage: number,
        ): void;
        private static calculateDamage(
          _dist: number,
          _radius: number,
          _damage: number,
        ): number;
        public static findPierceLength(
          _b: Packages.mindustry.gen.Bullet,
          _pierceCap: number,
          _length: number,
        ): number;
        public static findPierceLength(
          _b: Packages.mindustry.gen.Bullet,
          _pierceCap: number,
          _laser: boolean,
          _length: number,
        ): number;
        public static findAbsorber(
          _team: Packages.mindustry.game.Team,
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
        ): Packages.mindustry.gen.Building | null;
        public static collideLaser(
          _b: Packages.mindustry.gen.Bullet,
          _length: number,
          _large: boolean,
          _laser: boolean,
          _pierceCap: number,
        ): number;
        public static collidePoint(
          _hitter: Packages.mindustry.gen.Bullet,
          _team: Packages.mindustry.game.Team,
          _effect: Packages.mindustry.entities.Effect,
          _x: number,
          _y: number,
        ): void;
        public static linecast(
          _hitter: Packages.mindustry.gen.Bullet,
          _x: number,
          _y: number,
          _angle: number,
          _length: number,
        ): Packages.mindustry.gen.Healthc;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare class Fires extends java.lang.Object {
        private static baseLifetime: number;
        public static remove(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public static get(
          _x: number,
          _y: number,
        ): Packages.mindustry.gen.Fire | null;
        public static get(
          _tile: Packages.mindustry.world.Tile,
        ): Packages.mindustry.gen.Fire | null;
        public static register(
          _fire: Packages.mindustry.gen.Fire,
        ): void;
        private static set(
          _tile: Packages.mindustry.world.Tile,
          _fire: Packages.mindustry.gen.Fire,
        ): void;
        public static create(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public static has(_x: number, _y: number): boolean;
        public static extinguish(
          _tile: Packages.mindustry.world.Tile,
          _intensity: number,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare class LegDestroyData extends java.lang
        .Object {
        public a: Packages.arc.math.geom.Vec2;
        public b: Packages.arc.math.geom.Vec2;
        public region: Packages.arc.graphics.g2d.TextureRegion;
        public constructor(
          _a: Packages.arc.math.geom.Vec2,
          _b: Packages.arc.math.geom.Vec2,
          _region: Packages.arc.graphics.g2d.TextureRegion,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare class Lightning extends java.lang.Object {
        private static random: Packages.arc.math.Rand;
        private static rect: Packages.arc.math.geom.Rect;
        private static entities: Packages.arc.struct.Seq<Packages.mindustry.gen.Unitc>;
        private static hit: Packages.arc.struct.IntSet;
        private static maxChain: number;
        private static hitRange: number;
        private static bhit: boolean;
        private static lastSeed: number;
        public static create(
          _bullet: Packages.mindustry.gen.Bullet,
          _color: Packages.arc.graphics.Color,
          _damage: number,
          _x: number,
          _y: number,
          _targetAngle: number,
          _length: number,
        ): void;
        public static create(
          _team: Packages.mindustry.game.Team,
          _color: Packages.arc.graphics.Color,
          _damage: number,
          _x: number,
          _y: number,
          _targetAngle: number,
          _length: number,
        ): void;
        private static createLightningInternal(
          _hitter: Packages.mindustry.gen.Bullet | null,
          _seed: number,
          _team: Packages.mindustry.game.Team,
          _color: Packages.arc.graphics.Color,
          _damage: number,
          _x: number,
          _y: number,
          _rotation: number,
          _length: number,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare class Predict extends java.lang.Object {
        private static vec: Packages.arc.math.geom.Vec2;
        private static vresult: Packages.arc.math.geom.Vec2;
        public static intercept(
          _src: Packages.arc.math.geom.Position,
          _dst: Packages.arc.math.geom.Position,
          _offsetx: number,
          _offsety: number,
          _v: number,
        ): Packages.arc.math.geom.Vec2;
        public static intercept(
          _src: Packages.mindustry.gen.Hitboxc,
          _dst: Packages.mindustry.gen.Hitboxc,
          _v: number,
        ): Packages.arc.math.geom.Vec2;
        public static intercept(
          _srcx: number,
          _srcy: number,
          _dstx: number,
          _dsty: number,
          _dstvx: number,
          _dstvy: number,
          _v: number,
        ): Packages.arc.math.geom.Vec2;
        public static intercept(
          _src: Packages.arc.math.geom.Position,
          _dst: Packages.arc.math.geom.Position,
          _v: number,
        ): Packages.arc.math.geom.Vec2;
        private static quad(
          _a: number,
          _b: number,
          _c: number,
        ): Packages.arc.math.geom.Vec2;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare class Puddles extends java.lang.Object {
        public static maxLiquid: number;
        public static remove(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public static get(
          _tile: Packages.mindustry.world.Tile,
        ): Packages.mindustry.gen.Puddle | null;
        public static register(
          _puddle: Packages.mindustry.gen.Puddle,
        ): void;
        public static deposit(
          _tile: Packages.mindustry.world.Tile,
          _source: Packages.mindustry.world.Tile,
          _liquid: Packages.mindustry._type.Liquid,
          _amount: number,
          _initial: boolean,
          _cap: boolean,
        ): void;
        public static deposit(
          _tile: Packages.mindustry.world.Tile,
          _source: Packages.mindustry.world.Tile,
          _liquid: Packages.mindustry._type.Liquid,
          _amount: number,
        ): void;
        public static deposit(
          _tile: Packages.mindustry.world.Tile,
          _liquid: Packages.mindustry._type.Liquid,
          _amount: number,
        ): void;
        public static deposit(
          _tile: Packages.mindustry.world.Tile,
          _source: Packages.mindustry.world.Tile,
          _liquid: Packages.mindustry._type.Liquid,
          _amount: number,
          _initial: boolean,
        ): void;
        private static canStayOn(
          _liquid: Packages.mindustry._type.Liquid,
          _other: Packages.mindustry._type.Liquid,
        ): boolean;
        private static reactPuddle(
          _dest: Packages.mindustry._type.Liquid,
          _liquid: Packages.mindustry._type.Liquid,
          _amount: number,
          _tile: Packages.mindustry.world.Tile,
          _x: number,
          _y: number,
        ): number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare class TargetPriority extends java.lang
        .Object {
        public static wall: number;
        public static transport: number;
        public static base: number;
        public static turret: number;
        public static core: number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare class UnitSorts extends java.lang.Object {
        public static closest: Packages.mindustry.entities.Units.Sortf;
        public static farthest: Packages.mindustry.entities.Units.Sortf;
        public static strongest: Packages.mindustry.entities.Units.Sortf;
        public static weakest: Packages.mindustry.entities.Units.Sortf;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare class Units extends java.lang.Object {
        public static Sortf = class {
          public cost(
            _unit: Packages.mindustry.gen.Unit,
            _x: number,
            _y: number,
          ): number;
        };
        private static hitrect: Packages.arc.math.geom.Rect;
        private static result: Packages.mindustry.gen.Unit;
        private static cdist: number;
        private static cpriority: number;
        private static intResult: number;
        private static buildResult: Packages.mindustry.gen.Building;
        private static anyEntityGround: boolean;
        private static aeX: number;
        private static aeY: number;
        private static aeW: number;
        private static aeH: number;
        private static anyEntityLambda: Packages.arc.func.Boolf<Packages.mindustry.gen.Unit>;
        public static count(
          _x: number,
          _y: number,
          _size: number,
          _filter: Packages.arc.func.Boolf<Packages.mindustry.gen.Unit>,
        ): number;
        public static count(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
          _filter: Packages.arc.func.Boolf<Packages.mindustry.gen.Unit>,
        ): number;
        public static any(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
          _filter: Packages.arc.func.Boolf<Packages.mindustry.gen.Unit>,
        ): boolean;
        public static closest(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _range: number,
          _predicate: Packages.arc.func.Boolf<Packages.mindustry.gen.Unit>,
        ): Packages.mindustry.gen.Unit;
        public static closest(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _predicate: Packages.arc.func.Boolf<Packages.mindustry.gen.Unit>,
        ): Packages.mindustry.gen.Unit;
        public static closest(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _range: number,
          _predicate: Packages.arc.func.Boolf<Packages.mindustry.gen.Unit>,
          _sort: Packages.mindustry.entities.Units.Sortf,
        ): Packages.mindustry.gen.Unit;
        public static canInteract(
          _player: Packages.mindustry.gen.Player,
          _tile: Packages.mindustry.gen.Building,
        ): boolean;
        public static nearby(
          _rect: Packages.arc.math.geom.Rect,
          _cons: Packages.arc.func.Cons<Packages.mindustry.gen.Unit>,
        ): void;
        public static nearby(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
          _cons: Packages.arc.func.Cons<Packages.mindustry.gen.Unit>,
        ): void;
        public static nearby(
          _team: Packages.mindustry.game.Team | null,
          _x: number,
          _y: number,
          _width: number,
          _height: number,
          _cons: Packages.arc.func.Cons<Packages.mindustry.gen.Unit>,
        ): void;
        public static nearby(
          _team: Packages.mindustry.game.Team | null,
          _x: number,
          _y: number,
          _radius: number,
          _cons: Packages.arc.func.Cons<Packages.mindustry.gen.Unit>,
        ): void;
        public static closestEnemy(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _range: number,
          _predicate: Packages.arc.func.Boolf<Packages.mindustry.gen.Unit>,
        ): Packages.mindustry.gen.Unit;
        public static getCap(
          _team: Packages.mindustry.game.Team,
        ): number;
        public static nearbyEnemies(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _width: number,
          _height: number,
          _cons: Packages.arc.func.Cons<Packages.mindustry.gen.Unit>,
        ): void;
        public static nearbyEnemies(
          _team: Packages.mindustry.game.Team,
          _rect: Packages.arc.math.geom.Rect,
          _cons: Packages.arc.func.Cons<Packages.mindustry.gen.Unit>,
        ): void;
        public static nearbyEnemies(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _radius: number,
          _cons: Packages.arc.func.Cons<Packages.mindustry.gen.Unit>,
        ): void;
        public static closestTarget(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _range: number,
          _unitPred: Packages.arc.func.Boolf<Packages.mindustry.gen.Unit>,
        ): Packages.mindustry.gen.Teamc;
        public static closestTarget(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _range: number,
        ): Packages.mindustry.gen.Teamc;
        public static closestTarget(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _range: number,
          _unitPred: Packages.arc.func.Boolf<Packages.mindustry.gen.Unit>,
          _tilePred: Packages.arc.func.Boolf<Packages.mindustry.gen.Building>,
        ): Packages.mindustry.gen.Teamc;
        public static invalidateTarget(
          _target: Packages.mindustry.gen.Teamc,
          _targeter: Packages.mindustry.gen.Unit,
          _range: number,
        ): boolean;
        public static invalidateTarget(
          _target: Packages.mindustry.gen.Posc,
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _range: number,
        ): boolean;
        public static invalidateTarget(
          _target: Packages.mindustry.gen.Posc,
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
        ): boolean;
        public static nearEnemy(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _width: number,
          _height: number,
        ): boolean;
        public static findDamagedTile(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
        ): Packages.mindustry.gen.Building;
        public static nearbyCheck(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
          _cons: Packages.arc.func.Boolf<Packages.mindustry.gen.Unit>,
        ): boolean;
        public static canCreate(
          _team: Packages.mindustry.game.Team,
          _type: Packages.mindustry._type.UnitType,
        ): boolean;
        public static getStringCap(
          _team: Packages.mindustry.game.Team,
        ): string;
        public static findEnemyTile(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _range: number,
          _checkUnder: boolean,
          _pred: Packages.arc.func.Boolf<Packages.mindustry.gen.Building>,
        ): Packages.mindustry.gen.Building;
        public static findEnemyTile(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _range: number,
          _pred: Packages.arc.func.Boolf<Packages.mindustry.gen.Building>,
        ): Packages.mindustry.gen.Building;
        public static unitDespawn(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public static closestOverlap(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _range: number,
          _predicate: Packages.arc.func.Boolf<Packages.mindustry.gen.Unit>,
        ): Packages.mindustry.gen.Unit;
        public static anyEntities(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
          _check: Packages.arc.func.Boolf<Packages.mindustry.gen.Unit>,
        ): boolean;
        public static anyEntities(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
          _ground: boolean,
        ): boolean;
        public static anyEntities(
          _tile: Packages.mindustry.world.Tile,
        ): boolean;
        public static anyEntities(
          _tile: Packages.mindustry.world.Tile,
          _ground: boolean,
        ): boolean;
        public static anyEntities(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
        ): boolean;
        public static anyEntities(
          _x: number,
          _y: number,
          _size: number,
        ): boolean;
        public static bestEnemy(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _range: number,
          _predicate: Packages.arc.func.Boolf<Packages.mindustry.gen.Unit>,
          _sort: Packages.mindustry.entities.Units.Sortf,
        ): Packages.mindustry.gen.Unit;
        public static unitDestroy(_uid: number): void;
        public static unitCapDeath(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public static unitEnvDeath(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public static unitDeath(_uid: number): void;
        public static findAllyTile(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _range: number,
          _pred: Packages.arc.func.Boolf<Packages.mindustry.gen.Building>,
        ): Packages.mindustry.gen.Building;
        public static closestBuilding(
          _team: Packages.mindustry.game.Team,
          _wx: number,
          _wy: number,
          _range: number,
          _pred: Packages.arc.func.Boolf<Packages.mindustry.gen.Building>,
        ): Packages.mindustry.gen.Building | null;
        public static nearbyBuildings(
          _x: number,
          _y: number,
          _range: number,
          _cons: Packages.arc.func.Cons<Packages.mindustry.gen.Building>,
        ): void;
        public static bestTarget(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _range: number,
          _unitPred: Packages.arc.func.Boolf<Packages.mindustry.gen.Unit>,
          _tilePred: Packages.arc.func.Boolf<Packages.mindustry.gen.Building>,
          _sort: Packages.mindustry.entities.Units.Sortf,
        ): Packages.mindustry.gen.Teamc;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace game {
      declare class EventType extends java.lang.Object {
        public static AdminRequestEvent = class extends java
          .lang.Object {
          public player: Packages.mindustry.gen.Player;
          public other?: Packages.mindustry.gen.Player;
          public action: Packages.mindustry.net.Packets.AdminAction;
          public constructor(
            _player: Packages.mindustry.gen.Player,
            _other: Packages.mindustry.gen.Player,
            _action: Packages.mindustry.net.Packets.AdminAction,
          );
        };
        public static PlayerIpUnbanEvent = class extends java
          .lang.Object {
          public ip: string;
          public constructor(_ip: string);
        };
        public static PlayerIpBanEvent = class extends java
          .lang.Object {
          public ip: string;
          public constructor(_ip: string);
        };
        public static PlayerUnbanEvent = class extends java
          .lang.Object {
          public player?: Packages.mindustry.gen.Player;
          public uuid: string;
          public constructor(
            _player: Packages.mindustry.gen.Player,
            _uuid: string,
          );
        };
        public static PlayerBanEvent = class extends java
          .lang.Object {
          public player?: Packages.mindustry.gen.Player;
          public uuid: string;
          public constructor(
            _player: Packages.mindustry.gen.Player,
            _uuid: string,
          );
        };
        public static PlayerLeave = class extends java.lang
          .Object {
          public player: Packages.mindustry.gen.Player;
          public constructor(
            _player: Packages.mindustry.gen.Player,
          );
        };
        public static PlayerConnect = class extends java
          .lang.Object {
          public player: Packages.mindustry.gen.Player;
          public constructor(
            _player: Packages.mindustry.gen.Player,
          );
        };
        public static PlayerJoin = class extends java.lang
          .Object {
          public player: Packages.mindustry.gen.Player;
          public constructor(
            _player: Packages.mindustry.gen.Player,
          );
        };
        public static PlayerConnectionConfirmed = class extends java
          .lang.Object {
          public player: Packages.mindustry.gen.Player;
          public constructor(
            _player: Packages.mindustry.gen.Player,
          );
        };
        public static ConnectPacketEvent = class extends java
          .lang.Object {
          public connection: Packages.mindustry.net.NetConnection;
          public packet: Packages.mindustry.net.Packets.ConnectPacket;
          public constructor(
            _connection: Packages.mindustry.net.NetConnection,
            _packet: Packages.mindustry.net.Packets.ConnectPacket,
          );
        };
        public static ConnectionEvent = class extends java
          .lang.Object {
          public connection: Packages.mindustry.net.NetConnection;
          public constructor(
            _connection: Packages.mindustry.net.NetConnection,
          );
        };
        public static UnitChangeEvent = class extends java
          .lang.Object {
          public player: Packages.mindustry.gen.Player;
          public unit: Packages.mindustry.gen.Unit;
          public constructor(
            _player: Packages.mindustry.gen.Player,
            _unit: Packages.mindustry.gen.Unit,
          );
        };
        public static UnitUnloadEvent = class extends java
          .lang.Object {
          public unit: Packages.mindustry.gen.Unit;
          public constructor(
            _unit: Packages.mindustry.gen.Unit,
          );
        };
        public static UnitSpawnEvent = class extends java
          .lang.Object {
          public unit: Packages.mindustry.gen.Unit;
          public constructor(
            _unit: Packages.mindustry.gen.Unit,
          );
        };
        public static UnitCreateEvent = class extends java
          .lang.Object {
          public unit: Packages.mindustry.gen.Unit;
          public spawner?: Packages.mindustry.gen.Building;
          public spawnerUnit?: Packages.mindustry.gen.Unit;
          public constructor(
            _unit: Packages.mindustry.gen.Unit,
            _spawner: Packages.mindustry.gen.Building,
            _spawnerUnit: Packages.mindustry.gen.Unit,
          );
          public constructor(
            _unit: Packages.mindustry.gen.Unit,
            _spawner: Packages.mindustry.gen.Building,
          );
        };
        public static UnitDrownEvent = class extends java
          .lang.Object {
          public unit: Packages.mindustry.gen.Unit;
          public constructor(
            _unit: Packages.mindustry.gen.Unit,
          );
        };
        public static UnitDamageEvent = class extends java
          .lang.Object {
          public unit: Packages.mindustry.gen.Unit;
          public bullet: Packages.mindustry.gen.Bullet;
          public set(
            _unit: Packages.mindustry.gen.Unit,
            _bullet: Packages.mindustry.gen.Bullet,
          ): Packages.mindustry.game.EventType.UnitDamageEvent;
          public constructor();
        };
        public static UnitBulletDestroyEvent = class extends java
          .lang.Object {
          public unit: Packages.mindustry.gen.Unit;
          public bullet: Packages.mindustry.gen.Bullet;
          public constructor(
            _unit: Packages.mindustry.gen.Unit,
            _bullet: Packages.mindustry.gen.Bullet,
          );
          public constructor();
        };
        public static UnitDestroyEvent = class extends java
          .lang.Object {
          public unit: Packages.mindustry.gen.Unit;
          public constructor(
            _unit: Packages.mindustry.gen.Unit,
          );
        };
        public static BuildingBulletDestroyEvent = class extends java
          .lang.Object {
          public build: Packages.mindustry.gen.Building;
          public bullet: Packages.mindustry.gen.Bullet;
          public constructor(
            _build: Packages.mindustry.gen.Building,
            _bullet: Packages.mindustry.gen.Bullet,
          );
          public constructor();
        };
        public static GeneratorPressureExplodeEvent = class extends java
          .lang.Object {
          public build: Packages.mindustry.gen.Building;
          public constructor(
            _build: Packages.mindustry.gen.Building,
          );
        };
        public static BlockDestroyEvent = class extends java
          .lang.Object {
          public tile: Packages.mindustry.world.Tile;
          public constructor(
            _tile: Packages.mindustry.world.Tile,
          );
        };
        public static BuildSelectEvent = class extends java
          .lang.Object {
          public tile: Packages.mindustry.world.Tile;
          public team: Packages.mindustry.game.Team;
          public builder: Packages.mindustry.gen.Unit;
          public breaking: boolean;
          public constructor(
            _tile: Packages.mindustry.world.Tile,
            _team: Packages.mindustry.game.Team,
            _builder: Packages.mindustry.gen.Unit,
            _breaking: boolean,
          );
        };
        public static BuildRotateEvent = class extends java
          .lang.Object {
          public build: Packages.mindustry.gen.Building;
          public unit?: Packages.mindustry.gen.Unit;
          public previous: number;
          public constructor(
            _build: Packages.mindustry.gen.Building,
            _unit: Packages.mindustry.gen.Unit | null,
            _previous: number,
          );
        };
        public static BlockBuildEndEvent = class extends java
          .lang.Object {
          public tile: Packages.mindustry.world.Tile;
          public team: Packages.mindustry.game.Team;
          public unit?: Packages.mindustry.gen.Unit;
          public breaking: boolean;
          public config?: any;
          public constructor(
            _tile: Packages.mindustry.world.Tile,
            _unit: Packages.mindustry.gen.Unit | null,
            _team: Packages.mindustry.game.Team,
            _breaking: boolean,
            _config: any | null,
          );
        };
        public static BlockBuildBeginEvent = class extends java
          .lang.Object {
          public tile: Packages.mindustry.world.Tile;
          public team: Packages.mindustry.game.Team;
          public unit?: Packages.mindustry.gen.Unit;
          public breaking: boolean;
          public constructor(
            _tile: Packages.mindustry.world.Tile,
            _team: Packages.mindustry.game.Team,
            _unit: Packages.mindustry.gen.Unit,
            _breaking: boolean,
          );
        };
        public static ResearchEvent = class extends java
          .lang.Object {
          public content: Packages.mindustry.ctype.UnlockableContent;
          public constructor(
            _content: Packages.mindustry.ctype.UnlockableContent,
          );
        };
        public static UnlockEvent = class extends java.lang
          .Object {
          public content: Packages.mindustry.ctype.UnlockableContent;
          public constructor(
            _content: Packages.mindustry.ctype.UnlockableContent,
          );
        };
        public static StateChangeEvent = class extends java
          .lang.Object {
          public from: Packages.mindustry.core.GameState.State;
          public to: Packages.mindustry.core.GameState.State;
          public constructor(
            _from: Packages.mindustry.core.GameState.State,
            _to: Packages.mindustry.core.GameState.State,
          );
        };
        public static CoreChangeEvent = class extends java
          .lang.Object {
          public core: Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
          public constructor(
            _core: Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild,
          );
        };
        public static BuildTeamChangeEvent = class extends java
          .lang.Object {
          public previous: Packages.mindustry.game.Team;
          public build: Packages.mindustry.gen.Building;
          public set(
            _previous: Packages.mindustry.game.Team,
            _build: Packages.mindustry.gen.Building,
          ): Packages.mindustry.game.EventType.BuildTeamChangeEvent;
          public constructor();
        };
        public static TileChangeEvent = class extends java
          .lang.Object {
          public tile: Packages.mindustry.world.Tile;
          public set(
            _tile: Packages.mindustry.world.Tile,
          ): Packages.mindustry.game.EventType.TileChangeEvent;
          public constructor();
        };
        public static TilePreChangeEvent = class extends java
          .lang.Object {
          public tile: Packages.mindustry.world.Tile;
          public set(
            _tile: Packages.mindustry.world.Tile,
          ): Packages.mindustry.game.EventType.TilePreChangeEvent;
          public constructor();
        };
        public static BuildDamageEvent = class extends java
          .lang.Object {
          public build: Packages.mindustry.gen.Building;
          public source: Packages.mindustry.gen.Bullet;
          public set(
            _build: Packages.mindustry.gen.Building,
            _source: Packages.mindustry.gen.Bullet,
          ): Packages.mindustry.game.EventType.BuildDamageEvent;
          public constructor();
        };
        public static GameOverEvent = class extends java
          .lang.Object {
          public winner: Packages.mindustry.game.Team;
          public constructor(
            _winner: Packages.mindustry.game.Team,
          );
        };
        public static BuildingCommandEvent = class extends java
          .lang.Object {
          public player: Packages.mindustry.gen.Player;
          public building: Packages.mindustry.gen.Building;
          public position: Packages.arc.math.geom.Vec2;
          public constructor(
            _player: Packages.mindustry.gen.Player,
            _building: Packages.mindustry.gen.Building,
            _position: Packages.arc.math.geom.Vec2,
          );
        };
        public static UnitControlEvent = class extends java
          .lang.Object {
          public player: Packages.mindustry.gen.Player;
          public unit?: Packages.mindustry.gen.Unit;
          public constructor(
            _player: Packages.mindustry.gen.Player,
            _unit: Packages.mindustry.gen.Unit | null,
          );
        };
        public static PayloadDropEvent = class extends java
          .lang.Object {
          public carrier: Packages.mindustry.gen.Unit;
          public unit?: Packages.mindustry.gen.Unit;
          public build?: Packages.mindustry.gen.Building;
          public constructor(
            _carrier: Packages.mindustry.gen.Unit,
            _unit: Packages.mindustry.gen.Unit,
          );
          public constructor(
            _carrier: Packages.mindustry.gen.Unit,
            _build: Packages.mindustry.gen.Building,
          );
        };
        public static PickupEvent = class extends java.lang
          .Object {
          public carrier: Packages.mindustry.gen.Unit;
          public unit?: Packages.mindustry.gen.Unit;
          public build?: Packages.mindustry.gen.Building;
          public constructor(
            _carrier: Packages.mindustry.gen.Unit,
            _unit: Packages.mindustry.gen.Unit,
          );
          public constructor(
            _carrier: Packages.mindustry.gen.Unit,
            _build: Packages.mindustry.gen.Building,
          );
        };
        public static TapEvent = class extends java.lang
          .Object {
          public player: Packages.mindustry.gen.Player;
          public tile: Packages.mindustry.world.Tile;
          public constructor(
            _player: Packages.mindustry.gen.Player,
            _tile: Packages.mindustry.world.Tile,
          );
        };
        public static ConfigEvent = class extends java.lang
          .Object {
          public tile: Packages.mindustry.gen.Building;
          public player?: Packages.mindustry.gen.Player;
          public value: any;
          public constructor(
            _tile: Packages.mindustry.gen.Building,
            _player: Packages.mindustry.gen.Player | null,
            _value: any,
          );
        };
        public static DepositEvent = class extends java.lang
          .Object {
          public tile: Packages.mindustry.gen.Building;
          public player: Packages.mindustry.gen.Player;
          public item: Packages.mindustry._type.Item;
          public amount: number;
          public constructor(
            _tile: Packages.mindustry.gen.Building,
            _player: Packages.mindustry.gen.Player,
            _item: Packages.mindustry._type.Item,
            _amount: number,
          );
        };
        public static WithdrawEvent = class extends java
          .lang.Object {
          public tile: Packages.mindustry.gen.Building;
          public player: Packages.mindustry.gen.Player;
          public item: Packages.mindustry._type.Item;
          public amount: number;
          public constructor(
            _tile: Packages.mindustry.gen.Building,
            _player: Packages.mindustry.gen.Player,
            _item: Packages.mindustry._type.Item,
            _amount: number,
          );
        };
        public static SectorCaptureEvent = class extends java
          .lang.Object {
          public sector: Packages.mindustry._type.Sector;
          public initialCapture: boolean;
          public constructor(
            _sector: Packages.mindustry._type.Sector,
            _initialCapture: boolean,
          );
        };
        public static ClientChatEvent = class extends java
          .lang.Object {
          public message: string;
          public constructor(_message: string);
        };
        public static PlayerChatEvent = class extends java
          .lang.Object {
          public player: Packages.mindustry.gen.Player;
          public message: string;
          public constructor(
            _player: Packages.mindustry.gen.Player,
            _message: string,
          );
        };
        public static TextInputEvent = class extends java
          .lang.Object {
          public player: Packages.mindustry.gen.Player;
          public textInputId: number;
          public text?: string;
          public constructor(
            _player: Packages.mindustry.gen.Player,
            _textInputId: number,
            _text: string,
          );
        };
        public static MenuOptionChooseEvent = class extends java
          .lang.Object {
          public player: Packages.mindustry.gen.Player;
          public menuId: number;
          public option: number;
          public constructor(
            _player: Packages.mindustry.gen.Player,
            _menuId: number,
            _option: number,
          );
        };
        public static ClientServerConnectEvent = class extends java
          .lang.Object {
          public ip: string;
          public port: number;
          public constructor(_ip: string, _port: number);
        };
        public static ClientPreConnectEvent = class extends java
          .lang.Object {
          public host: Packages.mindustry.net.Host;
          public constructor(
            _host: Packages.mindustry.net.Host,
          );
        };
        public static SchematicCreateEvent = class extends java
          .lang.Object {
          public schematic: Packages.mindustry.game.Schematic;
          public constructor(
            _schematic: Packages.mindustry.game.Schematic,
          );
        };
        public static SectorLaunchLoadoutEvent = class extends java
          .lang.Object {
          public sector: Packages.mindustry._type.Sector;
          public from: Packages.mindustry._type.Sector;
          public loadout: Packages.mindustry.game.Schematic;
          public constructor(
            _sector: Packages.mindustry._type.Sector,
            _from: Packages.mindustry._type.Sector,
            _loadout: Packages.mindustry.game.Schematic,
          );
        };
        public static SectorLaunchEvent = class extends java
          .lang.Object {
          public sector: Packages.mindustry._type.Sector;
          public constructor(
            _sector: Packages.mindustry._type.Sector,
          );
        };
        public static LaunchItemEvent = class extends java
          .lang.Object {
          public stack: Packages.mindustry._type.ItemStack;
          public constructor(
            _stack: Packages.mindustry._type.ItemStack,
          );
        };
        public static SectorInvasionEvent = class extends java
          .lang.Object {
          public sector: Packages.mindustry._type.Sector;
          public constructor(
            _sector: Packages.mindustry._type.Sector,
          );
        };
        public static SectorLoseEvent = class extends java
          .lang.Object {
          public sector: Packages.mindustry._type.Sector;
          public constructor(
            _sector: Packages.mindustry._type.Sector,
          );
        };
        public static SaveLoadEvent = class extends java
          .lang.Object {
          public isMap: boolean;
          public constructor(_isMap: boolean);
        };
        public static WorldLoadEndEvent = class extends java
          .lang.Object {
          public constructor();
        };
        public static WorldLoadBeginEvent = class extends java
          .lang.Object {
          public constructor();
        };
        public static WorldLoadEvent = class extends java
          .lang.Object {
          public constructor();
        };
        public static FileTreeInitEvent = class extends java
          .lang.Object {
          public constructor();
        };
        public static MusicRegisterEvent = class extends java
          .lang.Object {
          public constructor();
        };
        public static ClientLoadEvent = class extends java
          .lang.Object {
          public constructor();
        };
        public static ContentInitEvent = class extends java
          .lang.Object {
          public constructor();
        };
        public static BlockInfoEvent = class extends java
          .lang.Object {
          public constructor();
        };
        public static CoreItemDeliverEvent = class extends java
          .lang.Object {
          public constructor();
        };
        public static TurretAmmoDeliverEvent = class extends java
          .lang.Object {
          public constructor();
        };
        public static LineConfirmEvent = class extends java
          .lang.Object {
          public constructor();
        };
        public static TurnEvent = class extends java.lang
          .Object {
          public constructor();
        };
        public static WaveEvent = class extends java.lang
          .Object {
          public constructor();
        };
        public static HostEvent = class extends java.lang
          .Object {
          public constructor();
        };
        public static ResetEvent = class extends java.lang
          .Object {
          public constructor();
        };
        public static PlayEvent = class extends java.lang
          .Object {
          public constructor();
        };
        public static DisposeEvent = class extends java.lang
          .Object {
          public constructor();
        };
        public static ServerLoadEvent = class extends java
          .lang.Object {
          public constructor();
        };
        public static ClientCreateEvent = class extends java
          .lang.Object {
          public constructor();
        };
        public static SaveWriteEvent = class extends java
          .lang.Object {
          public constructor();
        };
        public static MapPublishEvent = class extends java
          .lang.Object {
          public constructor();
        };
        public static MapMakeEvent = class extends java.lang
          .Object {
          public constructor();
        };
        public static ResizeEvent = class extends java.lang
          .Object {
          public constructor();
        };
        public static LoseEvent = class extends java.lang
          .Object {
          public constructor();
        };
        public static WinEvent = class extends java.lang
          .Object {
          public constructor();
        };
        public static Trigger = class extends Packages.java
          .lang
          .Enum<Packages.mindustry.game.EventType.Trigger> {
          public static shock: Packages.mindustry.game.EventType.Trigger;
          public static openConsole: Packages.mindustry.game.EventType.Trigger;
          public static blastFreeze: Packages.mindustry.game.EventType.Trigger;
          public static impactPower: Packages.mindustry.game.EventType.Trigger;
          public static blastGenerator: Packages.mindustry.game.EventType.Trigger;
          public static shockwaveTowerUse: Packages.mindustry.game.EventType.Trigger;
          public static forceProjectorBreak: Packages.mindustry.game.EventType.Trigger;
          public static thoriumReactorOverheat: Packages.mindustry.game.EventType.Trigger;
          public static neoplasmReact: Packages.mindustry.game.EventType.Trigger;
          public static fireExtinguish: Packages.mindustry.game.EventType.Trigger;
          public static acceleratorUse: Packages.mindustry.game.EventType.Trigger;
          public static newGame: Packages.mindustry.game.EventType.Trigger;
          public static tutorialComplete: Packages.mindustry.game.EventType.Trigger;
          public static flameAmmo: Packages.mindustry.game.EventType.Trigger;
          public static resupplyTurret: Packages.mindustry.game.EventType.Trigger;
          public static turretCool: Packages.mindustry.game.EventType.Trigger;
          public static enablePixelation: Packages.mindustry.game.EventType.Trigger;
          public static exclusionDeath: Packages.mindustry.game.EventType.Trigger;
          public static suicideBomb: Packages.mindustry.game.EventType.Trigger;
          public static openWiki: Packages.mindustry.game.EventType.Trigger;
          public static teamCoreDamage: Packages.mindustry.game.EventType.Trigger;
          public static socketConfigChanged: Packages.mindustry.game.EventType.Trigger;
          public static update: Packages.mindustry.game.EventType.Trigger;
          public static unitCommandChange: Packages.mindustry.game.EventType.Trigger;
          public static unitCommandPosition: Packages.mindustry.game.EventType.Trigger;
          public static unitCommandAttack: Packages.mindustry.game.EventType.Trigger;
          public static importMod: Packages.mindustry.game.EventType.Trigger;
          public static draw: Packages.mindustry.game.EventType.Trigger;
          public static drawOver: Packages.mindustry.game.EventType.Trigger;
          public static preDraw: Packages.mindustry.game.EventType.Trigger;
          public static postDraw: Packages.mindustry.game.EventType.Trigger;
          public static uiDrawBegin: Packages.mindustry.game.EventType.Trigger;
          public static uiDrawEnd: Packages.mindustry.game.EventType.Trigger;
          public static universeDrawBegin: Packages.mindustry.game.EventType.Trigger;
          public static universeDraw: Packages.mindustry.game.EventType.Trigger;
          public static universeDrawEnd: Packages.mindustry.game.EventType.Trigger;
          private static $VALUES: Packages.mindustry.game.EventType.Trigger[];
          public static values():
            | Packages.mindustry.game.EventType.Trigger[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.mindustry.game.EventType.Trigger;
        };
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace game {
      declare class Objectives extends java.lang.Object {
        public static Objective = class {
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public display(): string;
          public complete(): boolean;
        };
        public static OnPlanet = class
          extends java.lang.Object
          implements
            Packages.mindustry.game.Objectives.Objective
        {
          public planet: Packages.mindustry._type.Planet;
          public display(): string;
          public complete(): boolean;
          public constructor(
            _planet: Packages.mindustry._type.Planet,
          );
        };
        public static OnSector = class
          extends java.lang.Object
          implements
            Packages.mindustry.game.Objectives.Objective
        {
          public preset: Packages.mindustry._type.SectorPreset;
          public display(): string;
          public complete(): boolean;
          public constructor(
            _zone: Packages.mindustry._type.SectorPreset,
          );
        };
        public static SectorComplete = class
          extends java.lang.Object
          implements
            Packages.mindustry.game.Objectives.Objective
        {
          public preset: Packages.mindustry._type.SectorPreset;
          public display(): string;
          public complete(): boolean;
          public constructor(
            _zone: Packages.mindustry._type.SectorPreset,
          );
        };
        public static Produce = class
          extends java.lang.Object
          implements
            Packages.mindustry.game.Objectives.Objective
        {
          public content: Packages.mindustry.ctype.UnlockableContent;
          public display(): string;
          public complete(): boolean;
          public constructor(
            _content: Packages.mindustry.ctype.UnlockableContent,
          );
        };
        public static Research = class
          extends java.lang.Object
          implements
            Packages.mindustry.game.Objectives.Objective
        {
          public content: Packages.mindustry.ctype.UnlockableContent;
          public display(): string;
          public complete(): boolean;
          public constructor(
            _content: Packages.mindustry.ctype.UnlockableContent,
          );
        };
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class AdminRequestCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public other: Packages.mindustry.gen.Player;
        public action: Packages.mindustry.net.Packets.AdminAction;
        public params: any;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class AnnounceCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public message: string;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class AssemblerDroneSpawnedCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public tile: Packages.mindustry.world.Tile;
        public id: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class AssemblerUnitSpawnedCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public tile: Packages.mindustry.world.Tile;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class AutoDoorToggleCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public tile: Packages.mindustry.world.Tile;
        public open: boolean;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class BeginBreakCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public unit: Packages.mindustry.gen.Unit;
        public team: Packages.mindustry.game.Team;
        public x: number;
        public y: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class BeginPlaceCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public unit: Packages.mindustry.gen.Unit;
        public result: Packages.mindustry.world.Block;
        public team: Packages.mindustry.game.Team;
        public x: number;
        public y: number;
        public rotation: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class BlockSnapshotCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public amount: Packages.short;
        public data: string[];
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public getPriority(): number;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class BlockUnitc
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public add(): void;
        public update(): void;
        public isValid(): boolean;
        public icon(): Packages.arc.graphics.g2d.TextureRegion;
        public team(
          _team: Packages.mindustry.game.Team,
        ): void;
        public dead(): boolean;
        public tile(
          _tile: Packages.mindustry.gen.Building,
        ): void;
        public tile(): Packages.mindustry.gen.Building;
        public damage(_v: number, _b: boolean): void;
        public killed(): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class BlockUnitUnit
        extends Packages.mindustry.gen.Unit
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.BlockUnitc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public static hitDuration: number;
        protected static tmp1: Packages.arc.math.geom.Vec2;
        protected static tmp2: Packages.arc.math.geom.Vec2;
        public static warpDst: number;
        protected added: boolean;
        protected applied: Packages.arc.struct.Bits;
        protected buildCounter: number;
        protected lastActive: Packages.mindustry.entities.units.BuildPlan;
        protected lastSize: number;
        protected resupplyTime: number;
        private rotation_LAST_: number;
        private rotation_TARGET_: number;
        protected statuses: Packages.arc.struct.Seq<Packages.mindustry.entities.units.StatusEntry>;
        protected wasFlying: boolean;
        protected wasHealed: boolean;
        protected wasPlayer: boolean;
        private x_LAST_: number;
        private x_TARGET_: number;
        private y_LAST_: number;
        private y_TARGET_: number;
        public add(): void;
        public remove(): void;
        public toString(): string;
        public update(): void;
        public apply(
          _effect: Packages.mindustry._type.StatusEffect,
        ): void;
        public apply(
          _effect: Packages.mindustry._type.StatusEffect,
          _duration: number,
        ): void;
        public count(): number;
        public bounds(): number;
        public set(
          _def: Packages.mindustry._type.UnitType,
          _controller: Packages.mindustry.entities.units.UnitController,
        ): void;
        public set(_x: number, _y: number): void;
        public set(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public destroy(): void;
        public cap(): number;
        public static create(): Packages.mindustry.gen.BlockUnitUnit;
        public as<T>(): T | null;
        public command(): Packages.mindustry.ai._types.CommandAI;
        public display(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public range(): number;
        public self<
          T extends Packages.mindustry.gen.Entityc,
        >(): T | null;
        public inRange(
          _other: Packages.arc.math.geom.Position,
        ): boolean;
        public move(_v: Packages.arc.math.geom.Vec2): void;
        public move(_cx: number, _cy: number): void;
        public getDuration(
          _effect: Packages.mindustry._type.StatusEffect,
        ): number;
        public item(): Packages.mindustry._type.Item;
        public isValid(): boolean;
        public getX(): number;
        public getY(): number;
        public approach(
          _vector: Packages.arc.math.geom.Vec2,
        ): void;
        public interpolate(): void;
        public trns(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public trns(_x: number, _y: number): void;
        public speed(): number;
        public draw(): void;
        public controller(
          _next: Packages.mindustry.entities.units.UnitController,
        ): void;
        public controller(): Packages.mindustry.entities.units.UnitController;
        public icon(): Packages.arc.graphics.g2d.TextureRegion;
        public lookAt(_angle: number): void;
        public lookAt(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public lookAt(_x: number, _y: number): void;
        public hitbox(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public team(
          _team: Packages.mindustry.game.Team,
        ): void;
        public afterRead(): void;
        public dead(): boolean;
        public core(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public canBuild(): boolean;
        public isPlayer(): boolean;
        public isLocal(): boolean;
        public isAdded(): boolean;
        public tileOn(): Packages.mindustry.world.Tile;
        public hitSize(): number;
        public closestCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public aim(_x: number, _y: number): void;
        public aim(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public controlWeapons(_rotateShoot: boolean): void;
        public controlWeapons(
          _rotate: boolean,
          _shoot: boolean,
        ): void;
        public inFogTo(
          _viewer: Packages.mindustry.game.Team,
        ): boolean;
        public afterSync(): void;
        public resetController(): void;
        public isRemote(): boolean;
        public snapInterpolation(): void;
        public onSolid(): boolean;
        public isFlying(): boolean;
        public canLand(): boolean;
        public classId(): number;
        public buildOn(): Packages.mindustry.gen.Building;
        public isSyncHidden(
          _player: Packages.mindustry.gen.Player,
        ): boolean;
        public tile(
          _tile: Packages.mindustry.gen.Building,
        ): void;
        public tile(): Packages.mindustry.gen.Building;
        public damage(_amount: number): void;
        public damage(_v: number, _b: boolean): void;
        public sense(
          _sensor: Packages.mindustry.logic.LAccess,
        ): number;
        public sense(
          _content: Packages.mindustry.ctype.Content,
        ): number;
        public damageContinuous(_amount: number): void;
        public closestEnemyCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public getPlayer(): Packages.mindustry.gen.Player;
        public damagePierce(_amount: number): void;
        public damagePierce(
          _amount: number,
          _withEffect: boolean,
        ): void;
        public damaged(): boolean;
        public healthf(): number;
        public clampHealth(): void;
        public heal(): void;
        public heal(_amount: number): void;
        public cheating(): boolean;
        public itemCapacity(): number;
        public serialize(): boolean;
        public clipSize(): number;
        public tileX(): number;
        public tileY(): number;
        public blockOn(): Packages.mindustry.world.Block;
        public floorOn(): Packages.mindustry.world.blocks.environment.Floor;
        public afterAllRead(): void;
        public handleSyncHidden(): void;
        public readSync(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public readSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public snapSync(): void;
        public writeSync(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public writeSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public killed(): void;
        public displayable(): boolean;
        public isCommandable(): boolean;
        public isPathImpassable(
          _tileX: number,
          _tileY: number,
        ): boolean;
        public checkTarget(
          _targetAir: boolean,
          _targetGround: boolean,
        ): boolean;
        public isBoss(): boolean;
        public collision(
          _other: Packages.mindustry.gen.Hitboxc,
          _x: number,
          _y: number,
        ): void;
        public senseObject(
          _sensor: Packages.mindustry.logic.LAccess,
        ): any;
        public damageContinuousPierce(
          _amount: number,
        ): void;
        public healFract(_amount: number): void;
        public kill(): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: number,
        ): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: any,
        ): void;
        public setProp(
          _content: Packages.mindustry.ctype.UnlockableContent,
          _value: number,
        ): void;
        public targetable(
          _targeter: Packages.mindustry.game.Team,
        ): boolean;
        public drawPlan(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _alpha: number,
        ): void;
        public isAI(): boolean;
        public isEnemy(): boolean;
        public mining(): boolean;
        public canDrown(): boolean;
        public emitWalkSound(): boolean;
        public isGrounded(): boolean;
        public floorSpeedMultiplier(): number;
        public drownFloor(): Packages.mindustry.world.blocks.environment.Floor;
        public landed(): void;
        public moveAt(
          _vector: Packages.arc.math.geom.Vec2,
        ): void;
        public moveAt(
          _vector: Packages.arc.math.geom.Vec2,
          _acceleration: number,
        ): void;
        public updateDrowning(): void;
        public wobble(): void;
        public collides(
          _other: Packages.mindustry.gen.Hitboxc,
        ): boolean;
        public deltaAngle(): number;
        public deltaLen(): number;
        public getCollisions(
          _consumer: Packages.arc.func.Cons<
            Packages.arc.math.geom.QuadTree<any>
          >,
        ): void;
        public hitboxTile(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public updateLastPosition(): void;
        public solidity(): Packages.mindustry.entities.EntityCollisions.SolidPred;
        public canPassOn(): boolean;
        public canPass(
          _tileX: number,
          _tileY: number,
        ): boolean;
        public moving(): boolean;
        public velAddNet(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public velAddNet(_vx: number, _vy: number): void;
        public buildPlan(): Packages.mindustry.entities.units.BuildPlan;
        public acceptsItem(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public hasItem(): boolean;
        public maxAccepted(
          _item: Packages.mindustry._type.Item,
        ): number;
        public addItem(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): void;
        public addItem(
          _item: Packages.mindustry._type.Item,
        ): void;
        public clearItem(): void;
        public shouldSkip(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _core: Packages.mindustry.gen.Building,
        ): boolean;
        public addBuild(
          _place: Packages.mindustry.entities.units.BuildPlan,
        ): void;
        public addBuild(
          _place: Packages.mindustry.entities.units.BuildPlan,
          _tail: boolean,
        ): void;
        public clearBuilding(): void;
        public drawBuildPlans(): void;
        public isBuilding(): boolean;
        public activelyBuilding(): boolean;
        public drawBuilding(): void;
        public drawBuildingBeam(
          _px: number,
          _py: number,
        ): void;
        public drawPlanTop(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _alpha: number,
        ): void;
        public removeBuild(
          _x: number,
          _y: number,
          _breaking: boolean,
        ): void;
        public updateBuildLogic(): void;
        public validatePlans(): void;
        public applyDynamicStatus(): Packages.mindustry.entities.units.StatusEntry;
        public unapply(
          _effect: Packages.mindustry._type.StatusEffect,
        ): void;
        public statusDamageMultiplier(
          _damageMultiplier: number,
        ): void;
        public statusReloadMultiplier(
          _reloadMultiplier: number,
        ): void;
        public statusArmor(_armor: number): void;
        public statusBuildSpeed(_buildSpeed: number): void;
        public statusDrag(_drag: number): void;
        public statusMaxHealth(_health: number): void;
        public statusSpeed(_speed: number): void;
        public statusColor(): Packages.arc.graphics.Color;
        public statusBits(): Packages.arc.struct.Bits;
        public hasEffect(
          _effect: Packages.mindustry._type.StatusEffect,
        ): boolean;
        public isImmune(
          _effect: Packages.mindustry._type.StatusEffect,
        ): boolean;
        public clearStatuses(): void;
        public canMine(): boolean;
        public canMine(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public offloadImmediately(): boolean;
        public validMine(
          _tile: Packages.mindustry.world.Tile,
        ): boolean;
        public validMine(
          _tile: Packages.mindustry.world.Tile,
          _checkDst: boolean,
        ): boolean;
        public getMineResult(
          _tile: Packages.mindustry.world.Tile,
        ): Packages.mindustry._type.Item;
        public mass(): number;
        public impulse(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public impulse(_x: number, _y: number): void;
        public impulseNet(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public rawDamage(_amount: number): void;
        public physicSize(): number;
        public getControllerName(): string;
        public pathType(): number;
        public collisionLayer(): number;
        public prefRotation(): number;
        public unloaded(): void;
        public movePref(
          _movement: Packages.arc.math.geom.Vec2,
        ): void;
        public canShoot(): boolean;
        public canTarget(
          _other: Packages.mindustry.gen.Unit,
        ): boolean;
        public hasWeapons(): boolean;
        public hittable(): boolean;
        public aimLook(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public aimLook(_x: number, _y: number): void;
        public rotateMove(
          _vec: Packages.arc.math.geom.Vec2,
        ): void;
        public updateBoosting(_boost: boolean): void;
        public isRotate(): boolean;
        public ammof(): number;
        public setWeaponRotation(_rotation: number): void;
        public setupWeapons(
          _def: Packages.mindustry._type.UnitType,
        ): void;
        public setType(
          _type: Packages.mindustry._type.UnitType,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class BufferItem extends java.lang.Object {
        public static bitMaskItem: Packages.long;
        public static bitMaskTime: Packages.long;
        public static get(
          _item: string,
          _time: number,
        ): Packages.long;
        public static time(
          _bufferitem: Packages.long,
        ): number;
        public static time(
          _bufferitem: Packages.long,
          _value: number,
        ): Packages.long;
        public static item(
          _bufferitem: Packages.long,
        ): string;
        public static item(
          _bufferitem: Packages.long,
          _value: string,
        ): Packages.long;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class BuildDestroyedCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public build: Packages.mindustry.gen.Building;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class BuildHealthUpdateCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public buildings: Packages.arc.struct.IntSeq;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class BuildingControlSelectCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public player: Packages.mindustry.gen.Player;
        public build: Packages.mindustry.gen.Building;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class BuildingTetherc
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public update(): void;
        public building(
          _building: Packages.mindustry.gen.Building | null,
        ): void;
        public building(): Packages.mindustry.gen.Building | null;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class BuildingTetherPayloadUnit
        extends Packages.mindustry.gen.Unit
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Payloadc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.BuildingTetherc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public static hitDuration: number;
        protected static tmp1: Packages.arc.math.geom.Vec2;
        protected static tmp2: Packages.arc.math.geom.Vec2;
        public static warpDst: number;
        protected added: boolean;
        protected applied: Packages.arc.struct.Bits;
        protected buildCounter: number;
        protected lastActive: Packages.mindustry.entities.units.BuildPlan;
        protected lastSize: number;
        protected payloadPower?: Packages.mindustry.world.blocks.power.PowerGraph;
        protected resupplyTime: number;
        private rotation_LAST_: number;
        private rotation_TARGET_: number;
        protected statuses: Packages.arc.struct.Seq<Packages.mindustry.entities.units.StatusEntry>;
        protected wasFlying: boolean;
        protected wasHealed: boolean;
        protected wasPlayer: boolean;
        private x_LAST_: number;
        private x_TARGET_: number;
        private y_LAST_: number;
        private y_TARGET_: number;
        public add(): void;
        public remove(): void;
        public toString(): string;
        public update(): void;
        public apply(
          _effect: Packages.mindustry._type.StatusEffect,
        ): void;
        public apply(
          _effect: Packages.mindustry._type.StatusEffect,
          _duration: number,
        ): void;
        public count(): number;
        public bounds(): number;
        public set(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public set(
          _def: Packages.mindustry._type.UnitType,
          _controller: Packages.mindustry.entities.units.UnitController,
        ): void;
        public set(_x: number, _y: number): void;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public destroy(): void;
        public cap(): number;
        public static create(): Packages.mindustry.gen.BuildingTetherPayloadUnit;
        public as<T>(): T | null;
        public command(): Packages.mindustry.ai._types.CommandAI;
        public display(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public range(): number;
        public self<
          T extends Packages.mindustry.gen.Entityc,
        >(): T | null;
        public inRange(
          _other: Packages.arc.math.geom.Position,
        ): boolean;
        public move(_v: Packages.arc.math.geom.Vec2): void;
        public move(_cx: number, _cy: number): void;
        public getDuration(
          _effect: Packages.mindustry._type.StatusEffect,
        ): number;
        public item(): Packages.mindustry._type.Item;
        public isValid(): boolean;
        public getX(): number;
        public getY(): number;
        public approach(
          _vector: Packages.arc.math.geom.Vec2,
        ): void;
        public interpolate(): void;
        public trns(_x: number, _y: number): void;
        public trns(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public speed(): number;
        public draw(): void;
        public controller(): Packages.mindustry.entities.units.UnitController;
        public controller(
          _next: Packages.mindustry.entities.units.UnitController,
        ): void;
        public icon(): Packages.arc.graphics.g2d.TextureRegion;
        public building(): Packages.mindustry.gen.Building;
        public building(
          _building: Packages.mindustry.gen.Building,
        ): void;
        public lookAt(_angle: number): void;
        public lookAt(_x: number, _y: number): void;
        public lookAt(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public hitbox(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public afterRead(): void;
        public core(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public canBuild(): boolean;
        public isPlayer(): boolean;
        public isLocal(): boolean;
        public isAdded(): boolean;
        public tileOn(): Packages.mindustry.world.Tile;
        public hitSize(): number;
        public closestCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public aim(_x: number, _y: number): void;
        public aim(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public controlWeapons(_rotateShoot: boolean): void;
        public controlWeapons(
          _rotate: boolean,
          _shoot: boolean,
        ): void;
        public inFogTo(
          _viewer: Packages.mindustry.game.Team,
        ): boolean;
        public afterSync(): void;
        public resetController(): void;
        public isRemote(): boolean;
        public snapInterpolation(): void;
        public onSolid(): boolean;
        public isFlying(): boolean;
        public canLand(): boolean;
        public classId(): number;
        public buildOn(): Packages.mindustry.gen.Building;
        public isSyncHidden(
          _player: Packages.mindustry.gen.Player,
        ): boolean;
        public damage(
          _amount: number,
          _withEffect: boolean,
        ): void;
        public damage(_amount: number): void;
        public sense(
          _sensor: Packages.mindustry.logic.LAccess,
        ): number;
        public sense(
          _content: Packages.mindustry.ctype.Content,
        ): number;
        public damageContinuous(_amount: number): void;
        public closestEnemyCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public getPlayer(): Packages.mindustry.gen.Player;
        public damagePierce(_amount: number): void;
        public damagePierce(
          _amount: number,
          _withEffect: boolean,
        ): void;
        public damaged(): boolean;
        public healthf(): number;
        public clampHealth(): void;
        public heal(): void;
        public heal(_amount: number): void;
        public cheating(): boolean;
        public itemCapacity(): number;
        public serialize(): boolean;
        public clipSize(): number;
        public tileX(): number;
        public tileY(): number;
        public blockOn(): Packages.mindustry.world.Block;
        public floorOn(): Packages.mindustry.world.blocks.environment.Floor;
        public afterAllRead(): void;
        public handleSyncHidden(): void;
        public readSync(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public readSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public snapSync(): void;
        public writeSync(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public writeSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public killed(): void;
        public displayable(): boolean;
        public isCommandable(): boolean;
        public isPathImpassable(
          _tileX: number,
          _tileY: number,
        ): boolean;
        public checkTarget(
          _targetAir: boolean,
          _targetGround: boolean,
        ): boolean;
        public payloads(): Packages.arc.struct.Seq<Packages.mindustry.world.blocks.payloads.Payload>;
        public payloads(
          _payloads: Packages.arc.struct.Seq<Packages.mindustry.world.blocks.payloads.Payload>,
        ): void;
        public isBoss(): boolean;
        public canPickup(
          _unit: Packages.mindustry.gen.Unit,
        ): boolean;
        public canPickup(
          _build: Packages.mindustry.gen.Building,
        ): boolean;
        public collision(
          _other: Packages.mindustry.gen.Hitboxc,
          _x: number,
          _y: number,
        ): void;
        public senseObject(
          _sensor: Packages.mindustry.logic.LAccess,
        ): any;
        public damageContinuousPierce(
          _amount: number,
        ): void;
        public healFract(_amount: number): void;
        public kill(): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: number,
        ): void;
        public setProp(
          _content: Packages.mindustry.ctype.UnlockableContent,
          _value: number,
        ): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: any,
        ): void;
        public targetable(
          _targeter: Packages.mindustry.game.Team,
        ): boolean;
        public drawPlan(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _alpha: number,
        ): void;
        public isAI(): boolean;
        public isEnemy(): boolean;
        public mining(): boolean;
        public canDrown(): boolean;
        public emitWalkSound(): boolean;
        public isGrounded(): boolean;
        public floorSpeedMultiplier(): number;
        public drownFloor(): Packages.mindustry.world.blocks.environment.Floor;
        public landed(): void;
        public moveAt(
          _vector: Packages.arc.math.geom.Vec2,
        ): void;
        public moveAt(
          _vector: Packages.arc.math.geom.Vec2,
          _acceleration: number,
        ): void;
        public updateDrowning(): void;
        public wobble(): void;
        public collides(
          _other: Packages.mindustry.gen.Hitboxc,
        ): boolean;
        public deltaAngle(): number;
        public deltaLen(): number;
        public getCollisions(
          _consumer: Packages.arc.func.Cons<
            Packages.arc.math.geom.QuadTree<any>
          >,
        ): void;
        public hitboxTile(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public updateLastPosition(): void;
        public solidity(): Packages.mindustry.entities.EntityCollisions.SolidPred;
        public canPassOn(): boolean;
        public canPass(
          _tileX: number,
          _tileY: number,
        ): boolean;
        public moving(): boolean;
        public velAddNet(_vx: number, _vy: number): void;
        public velAddNet(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public buildPlan(): Packages.mindustry.entities.units.BuildPlan;
        public acceptsItem(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public hasItem(): boolean;
        public maxAccepted(
          _item: Packages.mindustry._type.Item,
        ): number;
        public addItem(
          _item: Packages.mindustry._type.Item,
        ): void;
        public addItem(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): void;
        public clearItem(): void;
        public shouldSkip(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _core: Packages.mindustry.gen.Building,
        ): boolean;
        public addBuild(
          _place: Packages.mindustry.entities.units.BuildPlan,
          _tail: boolean,
        ): void;
        public addBuild(
          _place: Packages.mindustry.entities.units.BuildPlan,
        ): void;
        public clearBuilding(): void;
        public drawBuildPlans(): void;
        public isBuilding(): boolean;
        public activelyBuilding(): boolean;
        public drawBuilding(): void;
        public drawBuildingBeam(
          _px: number,
          _py: number,
        ): void;
        public drawPlanTop(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _alpha: number,
        ): void;
        public removeBuild(
          _x: number,
          _y: number,
          _breaking: boolean,
        ): void;
        public updateBuildLogic(): void;
        public validatePlans(): void;
        public applyDynamicStatus(): Packages.mindustry.entities.units.StatusEntry;
        public unapply(
          _effect: Packages.mindustry._type.StatusEffect,
        ): void;
        public statusDamageMultiplier(
          _damageMultiplier: number,
        ): void;
        public statusReloadMultiplier(
          _reloadMultiplier: number,
        ): void;
        public statusArmor(_armor: number): void;
        public statusBuildSpeed(_buildSpeed: number): void;
        public statusDrag(_drag: number): void;
        public statusMaxHealth(_health: number): void;
        public statusSpeed(_speed: number): void;
        public statusColor(): Packages.arc.graphics.Color;
        public statusBits(): Packages.arc.struct.Bits;
        public hasEffect(
          _effect: Packages.mindustry._type.StatusEffect,
        ): boolean;
        public isImmune(
          _effect: Packages.mindustry._type.StatusEffect,
        ): boolean;
        public clearStatuses(): void;
        public canMine(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public canMine(): boolean;
        public offloadImmediately(): boolean;
        public validMine(
          _tile: Packages.mindustry.world.Tile,
        ): boolean;
        public validMine(
          _tile: Packages.mindustry.world.Tile,
          _checkDst: boolean,
        ): boolean;
        public getMineResult(
          _tile: Packages.mindustry.world.Tile,
        ): Packages.mindustry._type.Item;
        public mass(): number;
        public impulse(_x: number, _y: number): void;
        public impulse(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public impulseNet(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public rawDamage(_amount: number): void;
        public physicSize(): number;
        public getControllerName(): string;
        public pathType(): number;
        public collisionLayer(): number;
        public prefRotation(): number;
        public unloaded(): void;
        public movePref(
          _movement: Packages.arc.math.geom.Vec2,
        ): void;
        public canShoot(): boolean;
        public canTarget(
          _other: Packages.mindustry.gen.Unit,
        ): boolean;
        public hasWeapons(): boolean;
        public hittable(): boolean;
        public aimLook(_x: number, _y: number): void;
        public aimLook(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public rotateMove(
          _vec: Packages.arc.math.geom.Vec2,
        ): void;
        public updateBoosting(_boost: boolean): void;
        public isRotate(): boolean;
        public ammof(): number;
        public setWeaponRotation(_rotation: number): void;
        public setupWeapons(
          _def: Packages.mindustry._type.UnitType,
        ): void;
        public pickup(
          _tile: Packages.mindustry.gen.Building,
        ): void;
        public pickup(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public hasPayload(): boolean;
        public payloadUsed(): number;
        public contentInfo(
          _table: Packages.arc.scene.ui.layout.Table,
          _itemSize: number,
          _width: number,
        ): void;
        public dropLastPayload(): boolean;
        public dropBlock(
          _payload: Packages.mindustry.world.blocks.payloads.BuildPayload,
        ): boolean;
        public canPickupPayload(
          _pay: Packages.mindustry.world.blocks.payloads.Payload,
        ): boolean;
        public dropUnit(
          _payload: Packages.mindustry.world.blocks.payloads.UnitPayload,
        ): boolean;
        public tryDropPayload(
          _payload: Packages.mindustry.world.blocks.payloads.Payload,
        ): boolean;
        public addPayload(
          _load: Packages.mindustry.world.blocks.payloads.Payload,
        ): void;
        public setType(
          _type: Packages.mindustry._type.UnitType,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class Call extends java.lang.Object {
        public static connect(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _ip: string,
          _port: number,
        ): void;
        public static label(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _message: string,
          _duration: number,
          _worldx: number,
          _worldy: number,
        ): void;
        public static label(
          _message: string,
          _duration: number,
          _worldx: number,
          _worldy: number,
        ): void;
        public static openURI(_uri: string): void;
        public static openURI(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _uri: string,
        ): void;
        public static setPosition(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _x: number,
          _y: number,
        ): void;
        public static menu(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _menuId: number,
          _title: string,
          _message: string,
          _options: string[][],
        ): void;
        public static menu(
          _menuId: number,
          _title: string,
          _message: string,
          _options: string[][],
        ): void;
        public static sound(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _sound: Packages.arc.audio.Sound,
          _volume: number,
          _pitch: number,
          _pan: number,
        ): void;
        public static sound(
          _sound: Packages.arc.audio.Sound,
          _volume: number,
          _pitch: number,
          _pan: number,
        ): void;
        public static effect(
          _effect: Packages.mindustry.entities.Effect,
          _x: number,
          _y: number,
          _rotation: number,
          _color: Packages.arc.graphics.Color,
          _data: any,
        ): void;
        public static effect(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _effect: Packages.mindustry.entities.Effect,
          _x: number,
          _y: number,
          _rotation: number,
          _color: Packages.arc.graphics.Color,
          _data: any,
        ): void;
        public static effect(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _effect: Packages.mindustry.entities.Effect,
          _x: number,
          _y: number,
          _rotation: number,
          _color: Packages.arc.graphics.Color,
        ): void;
        public static effect(
          _effect: Packages.mindustry.entities.Effect,
          _x: number,
          _y: number,
          _rotation: number,
          _color: Packages.arc.graphics.Color,
        ): void;
        public static ping(_time: Packages.long): void;
        public static sendMessage(
          _message: string,
          _unformatted: string,
          _playersender: Packages.mindustry.gen.Player,
        ): void;
        public static sendMessage(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _message: string,
          _unformatted: string,
          _playersender: Packages.mindustry.gen.Player,
        ): void;
        public static sendMessage(_message: string): void;
        public static kick(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _reason: Packages.mindustry.net.Packets.KickReason,
        ): void;
        public static kick(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _reason: string,
        ): void;
        public static registerPackets(): void;
        public static tileConfig(
          _player: Packages.mindustry.gen.Player,
          _build: Packages.mindustry.gen.Building,
          _value: any,
        ): void;
        public static setFloor(
          _tile: Packages.mindustry.world.Tile,
          _floor: Packages.mindustry.world.Block,
          _overlay: Packages.mindustry.world.Block,
        ): void;
        public static setOverlay(
          _tile: Packages.mindustry.world.Tile,
          _overlay: Packages.mindustry.world.Block,
        ): void;
        public static removeTile(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public static setTile(
          _tile: Packages.mindustry.world.Tile,
          _block: Packages.mindustry.world.Block,
          _team: Packages.mindustry.game.Team,
          _rotation: number,
        ): void;
        public static setTeam(
          _build: Packages.mindustry.gen.Building,
          _team: Packages.mindustry.game.Team,
        ): void;
        public static buildDestroyed(
          _build: Packages.mindustry.gen.Building,
        ): void;
        public static buildHealthUpdate(
          _buildings: Packages.arc.struct.IntSeq,
        ): void;
        public static announce(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _message: string,
        ): void;
        public static announce(_message: string): void;
        public static playerSpawn(
          _tile: Packages.mindustry.world.Tile,
          _player: Packages.mindustry.gen.Player,
        ): void;
        public static researched(
          _content: Packages.mindustry.ctype.Content,
        ): void;
        public static rotateBlock(
          _player: Packages.mindustry.gen.Player,
          _build: Packages.mindustry.gen.Building,
          _direction: boolean,
        ): void;
        static buildingControlSelect__forward(
          _exceptConnection: Packages.mindustry.net.NetConnection,
          _player: Packages.mindustry.gen.Player,
          _build: Packages.mindustry.gen.Building,
        ): void;
        public static gameOver(
          _winner: Packages.mindustry.game.Team,
        ): void;
        public static completeObjective(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _index: number,
        ): void;
        public static completeObjective(
          _index: number,
        ): void;
        public static createBullet(
          _type: Packages.mindustry.entities.bullet.BulletType,
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _angle: number,
          _damage: number,
          _velocityScl: number,
          _lifetimeScl: number,
        ): void;
        public static transferItemTo(
          _unit: Packages.mindustry.gen.Unit,
          _item: Packages.mindustry._type.Item,
          _amount: number,
          _x: number,
          _y: number,
          _build: Packages.mindustry.gen.Building,
        ): void;
        public static payloadDropped(
          _unit: Packages.mindustry.gen.Unit,
          _x: number,
          _y: number,
        ): void;
        public static pickedUnitPayload(
          _unit: Packages.mindustry.gen.Unit,
          _target: Packages.mindustry.gen.Unit,
        ): void;
        public static pickedBuildPayload(
          _unit: Packages.mindustry.gen.Unit,
          _build: Packages.mindustry.gen.Building,
          _onGround: boolean,
        ): void;
        public static unitEnteredPayload(
          _unit: Packages.mindustry.gen.Unit,
          _build: Packages.mindustry.gen.Building,
        ): void;
        public static assemblerUnitSpawned(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public static assemblerDroneSpawned(
          _tile: Packages.mindustry.world.Tile,
          _id: number,
        ): void;
        public static unitBlockSpawn(
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public static createWeather(
          _weather: Packages.mindustry._type.Weather,
          _intensity: number,
          _duration: number,
          _windX: number,
          _windY: number,
        ): void;
        public static commandUnits(
          _player: Packages.mindustry.gen.Player,
          _unitIds: number[],
          _buildTarget: Packages.mindustry.gen.Building,
          _unitTarget: Packages.mindustry.gen.Unit,
          _posTarget: Packages.arc.math.geom.Vec2,
          _queueCommand: boolean,
          _finalBatch: boolean,
        ): void;
        public static setRules(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _rules: Packages.mindustry.game.Rules,
        ): void;
        public static setRules(
          _rules: Packages.mindustry.game.Rules,
        ): void;
        public static spawnEffect(
          _x: number,
          _y: number,
          _rotation: number,
          _u: Packages.mindustry._type.UnitType,
        ): void;
        public static hideFollowUpMenu(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _menuId: number,
        ): void;
        public static hideFollowUpMenu(
          _menuId: number,
        ): void;
        public static playerDisconnect(
          _playerid: number,
        ): void;
        public static debugStatusClient(
          _value: number,
          _lastClientSnapshot: number,
          _snapshotsSent: number,
        ): void;
        public static debugStatusClient(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _value: number,
          _lastClientSnapshot: number,
          _snapshotsSent: number,
        ): void;
        public static debugStatusClientUnreliable(
          _value: number,
          _lastClientSnapshot: number,
          _snapshotsSent: number,
        ): void;
        public static debugStatusClientUnreliable(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _value: number,
          _lastClientSnapshot: number,
          _snapshotsSent: number,
        ): void;
        public static serverPacketReliable(
          _type: string,
          _contents: string,
        ): void;
        public static clientLogicDataReliable(
          _channel: string,
          _value: any,
        ): void;
        public static removeQueueBlock(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _x: number,
          _y: number,
          _breaking: boolean,
        ): void;
        public static sectorCapture(): void;
        public static clearObjectives(
          _playerConnection: Packages.mindustry.net.NetConnection,
        ): void;
        public static clearObjectives(): void;
        public static updateGameOver(
          _winner: Packages.mindustry.game.Team,
        ): void;
        public static clientPacketReliable(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _type: string,
          _contents: string,
        ): void;
        public static clientPacketReliable(
          _type: string,
          _contents: string,
        ): void;
        public static pingResponse(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _time: Packages.long,
        ): void;
        public static clientPacketUnreliable(
          _type: string,
          _contents: string,
        ): void;
        public static clientPacketUnreliable(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _type: string,
          _contents: string,
        ): void;
        public static soundAt(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _sound: Packages.arc.audio.Sound,
          _x: number,
          _y: number,
          _volume: number,
          _pitch: number,
        ): void;
        public static soundAt(
          _sound: Packages.arc.audio.Sound,
          _x: number,
          _y: number,
          _volume: number,
          _pitch: number,
        ): void;
        public static effectReliable(
          _effect: Packages.mindustry.entities.Effect,
          _x: number,
          _y: number,
          _rotation: number,
          _color: Packages.arc.graphics.Color,
        ): void;
        public static effectReliable(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _effect: Packages.mindustry.entities.Effect,
          _x: number,
          _y: number,
          _rotation: number,
          _color: Packages.arc.graphics.Color,
        ): void;
        public static sendChatMessage(
          _message: string,
        ): void;
        public static setObjectives(
          _executor: Packages.mindustry.game.MapObjectives,
        ): void;
        public static setObjectives(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _executor: Packages.mindustry.game.MapObjectives,
        ): void;
        public static setCameraPosition(
          _x: number,
          _y: number,
        ): void;
        public static setCameraPosition(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _x: number,
          _y: number,
        ): void;
        public static traceInfo(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _player: Packages.mindustry.gen.Player,
          _info: Packages.mindustry.net.Administration.TraceInfo,
        ): void;
        public static blockSnapshot(
          _amount: Packages.short,
          _data: string[],
        ): void;
        public static blockSnapshot(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _amount: Packages.short,
          _data: string[],
        ): void;
        public static stateSnapshot(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _waveTime: number,
          _wave: number,
          _enemies: number,
          _paused: boolean,
          _gameOver: boolean,
          _timeData: number,
          _tps: string,
          _rand0: Packages.long,
          _rand1: Packages.long,
          _coreData: string[],
        ): void;
        public static entitySnapshot(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _amount: Packages.short,
          _data: string[],
        ): void;
        public static hiddenSnapshot(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _ids: Packages.arc.struct.IntSeq,
        ): void;
        public static worldDataBegin(
          _playerConnection: Packages.mindustry.net.NetConnection,
        ): void;
        public static worldDataBegin(): void;
        public static infoMessage(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _message: string,
        ): void;
        public static infoMessage(_message: string): void;
        public static requestDebugStatus(): void;
        public static serverPacketUnreliable(
          _type: string,
          _contents: string,
        ): void;
        public static clientLogicDataUnreliable(
          _channel: string,
          _value: any,
        ): void;
        public static clientSnapshot(
          _snapshotID: number,
          _unitID: number,
          _dead: boolean,
          _x: number,
          _y: number,
          _pointerX: number,
          _pointerY: number,
          _rotation: number,
          _baseRotation: number,
          _xVelocity: number,
          _yVelocity: number,
          _mining: Packages.mindustry.world.Tile,
          _boosting: boolean,
          _shooting: boolean,
          _chatting: boolean,
          _building: boolean,
          _plans: Packages.arc.struct.Queue<Packages.mindustry.entities.units.BuildPlan>,
          _viewX: number,
          _viewY: number,
          _viewWidth: number,
          _viewHeight: number,
        ): void;
        public static adminRequest(
          _other: Packages.mindustry.gen.Player,
          _action: Packages.mindustry.net.Packets.AdminAction,
          _params: any,
        ): void;
        public static connectConfirm(): void;
        public static commandBuilding(
          _player: Packages.mindustry.gen.Player,
          _buildings: number[],
          _target: Packages.arc.math.geom.Vec2,
        ): void;
        public static takeItems(
          _build: Packages.mindustry.gen.Building,
          _item: Packages.mindustry._type.Item,
          _amount: number,
          _to: Packages.mindustry.gen.Unit,
        ): void;
        public static dropItem(_angle: number): void;
        public static unitDespawn(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public static unitControl(
          _player: Packages.mindustry.gen.Player,
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public static requestUnitPayload(
          _player: Packages.mindustry.gen.Player,
          _target: Packages.mindustry.gen.Unit,
        ): void;
        public static requestBuildPayload(
          _player: Packages.mindustry.gen.Player,
          _build: Packages.mindustry.gen.Building,
        ): void;
        public static requestDropPayload(
          _player: Packages.mindustry.gen.Player,
          _x: number,
          _y: number,
        ): void;
        public static deletePlans(
          _player: Packages.mindustry.gen.Player,
          _positions: number[],
        ): void;
        public static transferInventory(
          _player: Packages.mindustry.gen.Player,
          _build: Packages.mindustry.gen.Building,
        ): void;
        public static transferItemEffect(
          _item: Packages.mindustry._type.Item,
          _x: number,
          _y: number,
          _to: Packages.mindustry.gen.Itemsc,
        ): void;
        public static transferItemToUnit(
          _item: Packages.mindustry._type.Item,
          _x: number,
          _y: number,
          _to: Packages.mindustry.gen.Itemsc,
        ): void;
        public static setItem(
          _build: Packages.mindustry.gen.Building,
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): void;
        public static clearItems(
          _build: Packages.mindustry.gen.Building,
        ): void;
        public static setUnitCommand(
          _player: Packages.mindustry.gen.Player,
          _unitIds: number[],
          _command: Packages.mindustry.ai.UnitCommand,
        ): void;
        public static setUnitStance(
          _player: Packages.mindustry.gen.Player,
          _unitIds: number[],
          _stance: Packages.mindustry.ai.UnitStance,
        ): void;
        public static requestItem(
          _player: Packages.mindustry.gen.Player,
          _build: Packages.mindustry.gen.Building,
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): void;
        public static tileTap(
          _player: Packages.mindustry.gen.Player,
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public static buildingControlSelect(
          _player: Packages.mindustry.gen.Player,
          _build: Packages.mindustry.gen.Building,
        ): void;
        public static unitBuildingControlSelect(
          _unit: Packages.mindustry.gen.Unit,
          _build: Packages.mindustry.gen.Building,
        ): void;
        public static unitClear(
          _player: Packages.mindustry.gen.Player,
        ): void;
        public static setPlayerTeamEditor(
          _player: Packages.mindustry.gen.Player,
          _team: Packages.mindustry.game.Team,
        ): void;
        public static setHudText(_message: string): void;
        public static setHudText(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _message: string,
        ): void;
        public static setMapArea(
          _x: number,
          _y: number,
          _w: number,
          _h: number,
        ): void;
        public static logicExplosion(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _radius: number,
          _damage: number,
          _air: boolean,
          _ground: boolean,
          _pierce: boolean,
          _effect: boolean,
        ): void;
        public static syncVariable(
          _building: Packages.mindustry.gen.Building,
          _variable: number,
          _value: any,
        ): void;
        public static setFlag(
          _flag: string,
          _add: boolean,
        ): void;
        public static createMarker(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _id: number,
          _marker: Packages.mindustry.game.MapObjectives.ObjectiveMarker,
        ): void;
        public static createMarker(
          _id: number,
          _marker: Packages.mindustry.game.MapObjectives.ObjectiveMarker,
        ): void;
        public static removeMarker(_id: number): void;
        public static removeMarker(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _id: number,
        ): void;
        public static updateMarker(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _id: number,
          _control: Packages.mindustry.logic.LMarkerControl,
          _p1: number,
          _p2: number,
          _p3: number,
        ): void;
        public static updateMarker(
          _id: number,
          _control: Packages.mindustry.logic.LMarkerControl,
          _p1: number,
          _p2: number,
          _p3: number,
        ): void;
        public static updateMarkerText(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _id: number,
          _type: Packages.mindustry.logic.LMarkerControl,
          _fetch: boolean,
          _text: string,
        ): void;
        public static updateMarkerText(
          _id: number,
          _type: Packages.mindustry.logic.LMarkerControl,
          _fetch: boolean,
          _text: string,
        ): void;
        public static updateMarkerTexture(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _id: number,
          _textureName: string,
        ): void;
        public static updateMarkerTexture(
          _id: number,
          _textureName: string,
        ): void;
        public static autoDoorToggle(
          _tile: Packages.mindustry.world.Tile,
          _open: boolean,
        ): void;
        public static unitTetherBlockSpawned(
          _tile: Packages.mindustry.world.Tile,
          _id: number,
        ): void;
        public static unitDestroy(_uid: number): void;
        public static unitCapDeath(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public static unitEnvDeath(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public static unitDeath(_uid: number): void;
        public static beginBreak(
          _unit: Packages.mindustry.gen.Unit,
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
        ): void;
        public static beginPlace(
          _unit: Packages.mindustry.gen.Unit,
          _result: Packages.mindustry.world.Block,
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _rotation: number,
        ): void;
        public static constructFinish(
          _tile: Packages.mindustry.world.Tile,
          _block: Packages.mindustry.world.Block,
          _builder: Packages.mindustry.gen.Unit,
          _rotation: string,
          _team: Packages.mindustry.game.Team,
          _config: any,
        ): void;
        public static deconstructFinish(
          _tile: Packages.mindustry.world.Tile,
          _block: Packages.mindustry.world.Block,
          _builder: Packages.mindustry.gen.Unit,
        ): void;
        public static menuChoose(
          _player: Packages.mindustry.gen.Player,
          _menuId: number,
          _option: number,
        ): void;
        public static textInputResult(
          _player: Packages.mindustry.gen.Player,
          _textInputId: number,
          _text: string,
        ): void;
        static commandBuilding__forward(
          _exceptConnection: Packages.mindustry.net.NetConnection,
          _player: Packages.mindustry.gen.Player,
          _buildings: number[],
          _target: Packages.arc.math.geom.Vec2,
        ): void;
        static commandUnits__forward(
          _exceptConnection: Packages.mindustry.net.NetConnection,
          _player: Packages.mindustry.gen.Player,
          _unitIds: number[],
          _buildTarget: Packages.mindustry.gen.Building,
          _unitTarget: Packages.mindustry.gen.Unit,
          _posTarget: Packages.arc.math.geom.Vec2,
          _queueCommand: boolean,
          _finalBatch: boolean,
        ): void;
        static deletePlans__forward(
          _exceptConnection: Packages.mindustry.net.NetConnection,
          _player: Packages.mindustry.gen.Player,
          _positions: number[],
        ): void;
        public static followUpMenu(
          _menuId: number,
          _title: string,
          _message: string,
          _options: string[][],
        ): void;
        public static followUpMenu(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _menuId: number,
          _title: string,
          _message: string,
          _options: string[][],
        ): void;
        public static hideHudText(
          _playerConnection: Packages.mindustry.net.NetConnection,
        ): void;
        public static hideHudText(): void;
        public static infoPopup(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _message: string,
          _duration: number,
          _align: number,
          _top: number,
          _left: number,
          _bottom: number,
          _right: number,
        ): void;
        public static infoPopup(
          _message: string,
          _duration: number,
          _align: number,
          _top: number,
          _left: number,
          _bottom: number,
          _right: number,
        ): void;
        public static infoPopupReliable(
          _message: string,
          _duration: number,
          _align: number,
          _top: number,
          _left: number,
          _bottom: number,
          _right: number,
        ): void;
        public static infoPopupReliable(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _message: string,
          _duration: number,
          _align: number,
          _top: number,
          _left: number,
          _bottom: number,
          _right: number,
        ): void;
        public static infoToast(
          _message: string,
          _duration: number,
        ): void;
        public static infoToast(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _message: string,
          _duration: number,
        ): void;
        public static labelReliable(
          _message: string,
          _duration: number,
          _worldx: number,
          _worldy: number,
        ): void;
        public static labelReliable(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _message: string,
          _duration: number,
          _worldx: number,
          _worldy: number,
        ): void;
        public static removeWorldLabel(_id: number): void;
        static requestItem__forward(
          _exceptConnection: Packages.mindustry.net.NetConnection,
          _player: Packages.mindustry.gen.Player,
          _build: Packages.mindustry.gen.Building,
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): void;
        static rotateBlock__forward(
          _exceptConnection: Packages.mindustry.net.NetConnection,
          _player: Packages.mindustry.gen.Player,
          _build: Packages.mindustry.gen.Building,
          _direction: boolean,
        ): void;
        public static setHudTextReliable(
          _message: string,
        ): void;
        public static setHudTextReliable(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _message: string,
        ): void;
        static setPlayerTeamEditor__forward(
          _exceptConnection: Packages.mindustry.net.NetConnection,
          _player: Packages.mindustry.gen.Player,
          _team: Packages.mindustry.game.Team,
        ): void;
        static setUnitCommand__forward(
          _exceptConnection: Packages.mindustry.net.NetConnection,
          _player: Packages.mindustry.gen.Player,
          _unitIds: number[],
          _command: Packages.mindustry.ai.UnitCommand,
        ): void;
        static setUnitStance__forward(
          _exceptConnection: Packages.mindustry.net.NetConnection,
          _player: Packages.mindustry.gen.Player,
          _unitIds: number[],
          _stance: Packages.mindustry.ai.UnitStance,
        ): void;
        public static textInput(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _textInputId: number,
          _title: string,
          _message: string,
          _textLength: number,
          _def: string,
          _numeric: boolean,
          _allowEmpty: boolean,
        ): void;
        public static textInput(
          _textInputId: number,
          _title: string,
          _message: string,
          _textLength: number,
          _def: string,
          _numeric: boolean,
          _allowEmpty: boolean,
        ): void;
        public static textInput(
          _textInputId: number,
          _title: string,
          _message: string,
          _textLength: number,
          _def: string,
          _numeric: boolean,
        ): void;
        public static textInput(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _textInputId: number,
          _title: string,
          _message: string,
          _textLength: number,
          _def: string,
          _numeric: boolean,
        ): void;
        static tileConfig__forward(
          _exceptConnection: Packages.mindustry.net.NetConnection,
          _player: Packages.mindustry.gen.Player,
          _build: Packages.mindustry.gen.Building,
          _value: any,
        ): void;
        static transferInventory__forward(
          _exceptConnection: Packages.mindustry.net.NetConnection,
          _player: Packages.mindustry.gen.Player,
          _build: Packages.mindustry.gen.Building,
        ): void;
        static unitClear__forward(
          _exceptConnection: Packages.mindustry.net.NetConnection,
          _player: Packages.mindustry.gen.Player,
        ): void;
        static unitControl__forward(
          _exceptConnection: Packages.mindustry.net.NetConnection,
          _player: Packages.mindustry.gen.Player,
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public static warningToast(
          _unicode: number,
          _text: string,
        ): void;
        public static warningToast(
          _playerConnection: Packages.mindustry.net.NetConnection,
          _unicode: number,
          _text: string,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Childc
        implements
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc
      {
        public add(): void;
        public parent(): Packages.mindustry.gen.Posc | null;
        public parent(
          _parent: Packages.mindustry.gen.Posc | null,
        ): void;
        public update(): void;
        public offsetY(_offsetY: number): void;
        public offsetY(): number;
        public offsetX(_offsetX: number): void;
        public offsetX(): number;
        public rotWithParent(): boolean;
        public rotWithParent(_rotWithParent: boolean): void;
        public offsetPos(_offsetPos: number): void;
        public offsetPos(): number;
        public offsetRot(): number;
        public offsetRot(_offsetRot: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class ClearItemsCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public build: Packages.mindustry.gen.Building;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class ClientPacketReliableCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public type: string;
        public contents: string;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class ClientPacketUnreliableCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public type: string;
        public contents: string;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class ClientSnapshotCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public snapshotID: number;
        public unitID: number;
        public dead: boolean;
        public x: number;
        public y: number;
        public pointerX: number;
        public pointerY: number;
        public rotation: number;
        public baseRotation: number;
        public xVelocity: number;
        public yVelocity: number;
        public mining: Packages.mindustry.world.Tile;
        public boosting: boolean;
        public shooting: boolean;
        public chatting: boolean;
        public building: boolean;
        public plans: Packages.arc.struct.Queue<Packages.mindustry.entities.units.BuildPlan>;
        public viewX: number;
        public viewY: number;
        public viewWidth: number;
        public viewHeight: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class CommandBuildingCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public player: Packages.mindustry.gen.Player;
        public buildings: number[];
        public target: Packages.arc.math.geom.Vec2;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class CommandUnitsCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public player: Packages.mindustry.gen.Player;
        public unitIds: number[];
        public buildTarget: Packages.mindustry.gen.Building;
        public unitTarget: Packages.mindustry.gen.Unit;
        public posTarget: Packages.arc.math.geom.Vec2;
        public queueCommand: boolean;
        public finalBatch: boolean;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class ConnectCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public ip: string;
        public port: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class ConnectConfirmCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class ConstructFinishCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public tile: Packages.mindustry.world.Tile;
        public block: Packages.mindustry.world.Block;
        public builder: Packages.mindustry.gen.Unit;
        public rotation: string;
        public team: Packages.mindustry.game.Team;
        public config: any;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class ContentRegions extends java.lang
        .Object {
        public static loadRegions(
          _content: Packages.mindustry.ctype.MappableContent,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class CrawlUnit
        extends Packages.mindustry.gen.Unit
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Crawlc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public static hitDuration: number;
        protected static tmp1: Packages.arc.math.geom.Vec2;
        protected static tmp2: Packages.arc.math.geom.Vec2;
        public static warpDst: number;
        protected added: boolean;
        protected applied: Packages.arc.struct.Bits;
        protected buildCounter: number;
        protected lastActive: Packages.mindustry.entities.units.BuildPlan;
        protected lastSize: number;
        protected resupplyTime: number;
        private rotation_LAST_: number;
        private rotation_TARGET_: number;
        protected statuses: Packages.arc.struct.Seq<Packages.mindustry.entities.units.StatusEntry>;
        protected wasFlying: boolean;
        protected wasHealed: boolean;
        protected wasPlayer: boolean;
        private x_LAST_: number;
        private x_TARGET_: number;
        private y_LAST_: number;
        private y_TARGET_: number;
        public add(): void;
        public remove(): void;
        public toString(): string;
        public update(): void;
        public apply(
          _effect: Packages.mindustry._type.StatusEffect,
        ): void;
        public apply(
          _effect: Packages.mindustry._type.StatusEffect,
          _duration: number,
        ): void;
        public count(): number;
        public bounds(): number;
        public set(
          _def: Packages.mindustry._type.UnitType,
          _controller: Packages.mindustry.entities.units.UnitController,
        ): void;
        public set(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public set(_x: number, _y: number): void;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public destroy(): void;
        public cap(): number;
        public static create(): Packages.mindustry.gen.CrawlUnit;
        public as<T>(): T | null;
        public command(): Packages.mindustry.ai._types.CommandAI;
        public display(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public range(): number;
        public self<
          T extends Packages.mindustry.gen.Entityc,
        >(): T | null;
        public inRange(
          _other: Packages.arc.math.geom.Position,
        ): boolean;
        public move(_cx: number, _cy: number): void;
        public move(_v: Packages.arc.math.geom.Vec2): void;
        public getDuration(
          _effect: Packages.mindustry._type.StatusEffect,
        ): number;
        public item(): Packages.mindustry._type.Item;
        public isValid(): boolean;
        public getX(): number;
        public getY(): number;
        public approach(
          _vector: Packages.arc.math.geom.Vec2,
        ): void;
        public interpolate(): void;
        public trns(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public trns(_x: number, _y: number): void;
        public speed(): number;
        public draw(): void;
        public controller(
          _next: Packages.mindustry.entities.units.UnitController,
        ): void;
        public controller(): Packages.mindustry.entities.units.UnitController;
        public icon(): Packages.arc.graphics.g2d.TextureRegion;
        public lookAt(_x: number, _y: number): void;
        public lookAt(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public lookAt(_angle: number): void;
        public hitbox(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public afterRead(): void;
        public core(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public canBuild(): boolean;
        public isPlayer(): boolean;
        public isLocal(): boolean;
        public isAdded(): boolean;
        public tileOn(): Packages.mindustry.world.Tile;
        public hitSize(): number;
        public closestCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public aim(_x: number, _y: number): void;
        public aim(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public controlWeapons(
          _rotate: boolean,
          _shoot: boolean,
        ): void;
        public controlWeapons(_rotateShoot: boolean): void;
        public inFogTo(
          _viewer: Packages.mindustry.game.Team,
        ): boolean;
        public afterSync(): void;
        public resetController(): void;
        public isRemote(): boolean;
        public snapInterpolation(): void;
        public onSolid(): boolean;
        public isFlying(): boolean;
        public canLand(): boolean;
        public classId(): number;
        public buildOn(): Packages.mindustry.gen.Building;
        public isSyncHidden(
          _player: Packages.mindustry.gen.Player,
        ): boolean;
        public damage(_amount: number): void;
        public damage(
          _amount: number,
          _withEffect: boolean,
        ): void;
        public sense(
          _sensor: Packages.mindustry.logic.LAccess,
        ): number;
        public sense(
          _content: Packages.mindustry.ctype.Content,
        ): number;
        public damageContinuous(_amount: number): void;
        public closestEnemyCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public getPlayer(): Packages.mindustry.gen.Player;
        public damagePierce(
          _amount: number,
          _withEffect: boolean,
        ): void;
        public damagePierce(_amount: number): void;
        public damaged(): boolean;
        public healthf(): number;
        public clampHealth(): void;
        public heal(_amount: number): void;
        public heal(): void;
        public cheating(): boolean;
        public itemCapacity(): number;
        public serialize(): boolean;
        public clipSize(): number;
        public tileX(): number;
        public tileY(): number;
        public blockOn(): Packages.mindustry.world.Block;
        public floorOn(): Packages.mindustry.world.blocks.environment.Floor;
        public afterAllRead(): void;
        public handleSyncHidden(): void;
        public readSync(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public readSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public snapSync(): void;
        public writeSync(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public writeSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public killed(): void;
        public displayable(): boolean;
        public isCommandable(): boolean;
        public isPathImpassable(
          _tileX: number,
          _tileY: number,
        ): boolean;
        public checkTarget(
          _targetAir: boolean,
          _targetGround: boolean,
        ): boolean;
        public isBoss(): boolean;
        public collision(
          _other: Packages.mindustry.gen.Hitboxc,
          _x: number,
          _y: number,
        ): void;
        public senseObject(
          _sensor: Packages.mindustry.logic.LAccess,
        ): any;
        public damageContinuousPierce(
          _amount: number,
        ): void;
        public healFract(_amount: number): void;
        public kill(): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: number,
        ): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: any,
        ): void;
        public setProp(
          _content: Packages.mindustry.ctype.UnlockableContent,
          _value: number,
        ): void;
        public targetable(
          _targeter: Packages.mindustry.game.Team,
        ): boolean;
        public drawPlan(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _alpha: number,
        ): void;
        public isAI(): boolean;
        public isEnemy(): boolean;
        public mining(): boolean;
        public canDrown(): boolean;
        public emitWalkSound(): boolean;
        public isGrounded(): boolean;
        public floorSpeedMultiplier(): number;
        public drownFloor(): Packages.mindustry.world.blocks.environment.Floor;
        public landed(): void;
        public moveAt(
          _vector: Packages.arc.math.geom.Vec2,
          _acceleration: number,
        ): void;
        public moveAt(
          _vector: Packages.arc.math.geom.Vec2,
        ): void;
        public updateDrowning(): void;
        public wobble(): void;
        public collides(
          _other: Packages.mindustry.gen.Hitboxc,
        ): boolean;
        public deltaAngle(): number;
        public deltaLen(): number;
        public getCollisions(
          _consumer: Packages.arc.func.Cons<
            Packages.arc.math.geom.QuadTree<any>
          >,
        ): void;
        public hitboxTile(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public updateLastPosition(): void;
        public solidity(): Packages.mindustry.entities.EntityCollisions.SolidPred;
        public canPassOn(): boolean;
        public canPass(
          _tileX: number,
          _tileY: number,
        ): boolean;
        public moving(): boolean;
        public velAddNet(_vx: number, _vy: number): void;
        public velAddNet(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public buildPlan(): Packages.mindustry.entities.units.BuildPlan;
        public acceptsItem(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public hasItem(): boolean;
        public maxAccepted(
          _item: Packages.mindustry._type.Item,
        ): number;
        public addItem(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): void;
        public addItem(
          _item: Packages.mindustry._type.Item,
        ): void;
        public clearItem(): void;
        public shouldSkip(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _core: Packages.mindustry.gen.Building,
        ): boolean;
        public addBuild(
          _place: Packages.mindustry.entities.units.BuildPlan,
        ): void;
        public addBuild(
          _place: Packages.mindustry.entities.units.BuildPlan,
          _tail: boolean,
        ): void;
        public clearBuilding(): void;
        public drawBuildPlans(): void;
        public isBuilding(): boolean;
        public activelyBuilding(): boolean;
        public drawBuilding(): void;
        public drawBuildingBeam(
          _px: number,
          _py: number,
        ): void;
        public drawPlanTop(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _alpha: number,
        ): void;
        public removeBuild(
          _x: number,
          _y: number,
          _breaking: boolean,
        ): void;
        public updateBuildLogic(): void;
        public validatePlans(): void;
        public applyDynamicStatus(): Packages.mindustry.entities.units.StatusEntry;
        public unapply(
          _effect: Packages.mindustry._type.StatusEffect,
        ): void;
        public statusDamageMultiplier(
          _damageMultiplier: number,
        ): void;
        public statusReloadMultiplier(
          _reloadMultiplier: number,
        ): void;
        public statusArmor(_armor: number): void;
        public statusBuildSpeed(_buildSpeed: number): void;
        public statusDrag(_drag: number): void;
        public statusMaxHealth(_health: number): void;
        public statusSpeed(_speed: number): void;
        public statusColor(): Packages.arc.graphics.Color;
        public statusBits(): Packages.arc.struct.Bits;
        public hasEffect(
          _effect: Packages.mindustry._type.StatusEffect,
        ): boolean;
        public isImmune(
          _effect: Packages.mindustry._type.StatusEffect,
        ): boolean;
        public clearStatuses(): void;
        public canMine(): boolean;
        public canMine(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public offloadImmediately(): boolean;
        public validMine(
          _tile: Packages.mindustry.world.Tile,
          _checkDst: boolean,
        ): boolean;
        public validMine(
          _tile: Packages.mindustry.world.Tile,
        ): boolean;
        public getMineResult(
          _tile: Packages.mindustry.world.Tile,
        ): Packages.mindustry._type.Item;
        public mass(): number;
        public impulse(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public impulse(_x: number, _y: number): void;
        public impulseNet(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public rawDamage(_amount: number): void;
        public physicSize(): number;
        public getControllerName(): string;
        public pathType(): number;
        public collisionLayer(): number;
        public prefRotation(): number;
        public unloaded(): void;
        public movePref(
          _movement: Packages.arc.math.geom.Vec2,
        ): void;
        public canShoot(): boolean;
        public canTarget(
          _other: Packages.mindustry.gen.Unit,
        ): boolean;
        public hasWeapons(): boolean;
        public hittable(): boolean;
        public aimLook(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public aimLook(_x: number, _y: number): void;
        public rotateMove(
          _vec: Packages.arc.math.geom.Vec2,
        ): void;
        public updateBoosting(_boost: boolean): void;
        public isRotate(): boolean;
        public ammof(): number;
        public setWeaponRotation(_rotation: number): void;
        public setupWeapons(
          _def: Packages.mindustry._type.UnitType,
        ): void;
        public crawlTime(_crawlTime: number): void;
        public crawlTime(): number;
        public segmentRot(_segmentRot: number): void;
        public segmentRot(): number;
        public lastCrawlSlowdown(
          _lastCrawlSlowdown: number,
        ): void;
        public lastCrawlSlowdown(): number;
        public lastDeepFloor(
          _lastDeepFloor: Packages.mindustry.world.blocks.environment.Floor,
        ): void;
        public lastDeepFloor(): Packages.mindustry.world.blocks.environment.Floor;
        public setType(
          _type: Packages.mindustry._type.UnitType,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class CreateBulletCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public type: Packages.mindustry.entities.bullet.BulletType;
        public team: Packages.mindustry.game.Team;
        public x: number;
        public y: number;
        public angle: number;
        public damage: number;
        public velocityScl: number;
        public lifetimeScl: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class CreateWeatherCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public weather: Packages.mindustry._type.Weather;
        public intensity: number;
        public duration: number;
        public windX: number;
        public windY: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class DebugStatusClientCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public value: number;
        public lastClientSnapshot: number;
        public snapshotsSent: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public getPriority(): number;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class DebugStatusClientUnreliableCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public value: number;
        public lastClientSnapshot: number;
        public snapshotsSent: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public getPriority(): number;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class Decalc
        implements
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Timedc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc
      {
        public color(
          _color: Packages.arc.graphics.Color,
        ): void;
        public color(): Packages.arc.graphics.Color;
        public region(
          _region: Packages.arc.graphics.g2d.TextureRegion,
        ): void;
        public region(): Packages.arc.graphics.g2d.TextureRegion;
        public draw(): void;
        public clipSize(): number;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class Decal
        extends java.lang.Object
        implements
          Packages.mindustry.gen.IndexableEntity__all,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Timedc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Decalc,
          Packages.arc.util.pooling.Pool.Poolable,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.IndexableEntity__draw
      {
        protected added: boolean;
        protected index__all: number;
        protected index__draw: number;
        public add(): void;
        public remove(): void;
        public toString(): string;
        public update(): void;
        public x(): number;
        public x(_x: number): void;
        public id(_id: number): void;
        public id(): number;
        public set(_x: number, _y: number): void;
        public set(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public reset(): void;
        public static create(): Packages.mindustry.gen.Decal;
        public as<T>(): T | null;
        public y(_y: number): void;
        public y(): number;
        public color(
          _color: Packages.arc.graphics.Color,
        ): void;
        public color(): Packages.arc.graphics.Color;
        public time(): number;
        public time(_time: number): void;
        public self<
          T extends Packages.mindustry.gen.Entityc,
        >(): T | null;
        public region(): Packages.arc.graphics.g2d.TextureRegion;
        public region(
          _region: Packages.arc.graphics.g2d.TextureRegion,
        ): void;
        public getX(): number;
        public getY(): number;
        public trns(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public trns(_x: number, _y: number): void;
        public draw(): void;
        public rotation(): number;
        public rotation(_rotation: number): void;
        public fin(): number;
        public afterRead(): void;
        public isLocal(): boolean;
        public isAdded(): boolean;
        public tileOn(): Packages.mindustry.world.Tile;
        public isRemote(): boolean;
        public onSolid(): boolean;
        public classId(): number;
        public setIndex__all(_index: number): void;
        public setIndex__draw(_index: number): void;
        public buildOn(): Packages.mindustry.gen.Building;
        public serialize(): boolean;
        public clipSize(): number;
        public tileX(): number;
        public tileY(): number;
        public blockOn(): Packages.mindustry.world.Block;
        public floorOn(): Packages.mindustry.world.blocks.environment.Floor;
        public afterAllRead(): void;
        public lifetime(): number;
        public lifetime(_lifetime: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class DeconstructFinishCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public tile: Packages.mindustry.world.Tile;
        public block: Packages.mindustry.world.Block;
        public builder: Packages.mindustry.gen.Unit;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class DeletePlansCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public player: Packages.mindustry.gen.Player;
        public positions: number[];
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class DisplayCmd extends java.lang.Object {
        public static bitMaskType: Packages.long;
        public static bitMaskX: Packages.long;
        public static bitMaskY: Packages.long;
        public static bitMaskP1: Packages.long;
        public static bitMaskP2: Packages.long;
        public static bitMaskP3: Packages.long;
        public static bitMaskP4: Packages.long;
        public static get(
          _type: number,
          _x: number,
          _y: number,
          _p1: number,
          _p2: number,
          _p3: number,
          _p4: number,
        ): Packages.long;
        public static type(
          _displaycmd: Packages.long,
        ): number;
        public static type(
          _displaycmd: Packages.long,
          _value: number,
        ): Packages.long;
        public static x(_displaycmd: Packages.long): number;
        public static x(
          _displaycmd: Packages.long,
          _value: number,
        ): Packages.long;
        public static p2(
          _displaycmd: Packages.long,
        ): number;
        public static p2(
          _displaycmd: Packages.long,
          _value: number,
        ): Packages.long;
        public static y(
          _displaycmd: Packages.long,
          _value: number,
        ): Packages.long;
        public static y(_displaycmd: Packages.long): number;
        public static p1(
          _displaycmd: Packages.long,
          _value: number,
        ): Packages.long;
        public static p1(
          _displaycmd: Packages.long,
        ): number;
        public static p3(
          _displaycmd: Packages.long,
          _value: number,
        ): Packages.long;
        public static p3(
          _displaycmd: Packages.long,
        ): number;
        public static p4(
          _displaycmd: Packages.long,
          _value: number,
        ): Packages.long;
        public static p4(
          _displaycmd: Packages.long,
        ): number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class DropItemCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public angle: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class EffectCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public effect: Packages.mindustry.entities.Effect;
        public x: number;
        public y: number;
        public rotation: number;
        public color: Packages.arc.graphics.Color;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class EffectCallPacket2 extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public effect: Packages.mindustry.entities.Effect;
        public x: number;
        public y: number;
        public rotation: number;
        public color: Packages.arc.graphics.Color;
        public data: any;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class EffectReliableCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public effect: Packages.mindustry.entities.Effect;
        public x: number;
        public y: number;
        public rotation: number;
        public color: Packages.arc.graphics.Color;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class EffectStatec
        implements
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Timedc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Childc
      {
        public data(_data: any): void;
        public data(): any;
        public color(
          _color: Packages.arc.graphics.Color,
        ): void;
        public color(): Packages.arc.graphics.Color;
        public draw(): void;
        public effect(
          _effect: Packages.mindustry.entities.Effect,
        ): void;
        public effect(): Packages.mindustry.entities.Effect;
        public clipSize(): number;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class EffectState
        extends java.lang.Object
        implements
          Packages.mindustry.gen.IndexableEntity__all,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Timedc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.EffectStatec,
          Packages.arc.util.pooling.Pool.Poolable,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Childc,
          Packages.mindustry.gen.IndexableEntity__draw
      {
        protected added: boolean;
        protected index__all: number;
        protected index__draw: number;
        public add(): void;
        public remove(): void;
        public parent(): Packages.mindustry.gen.Posc;
        public parent(
          _parent: Packages.mindustry.gen.Posc,
        ): void;
        public toString(): string;
        public update(): void;
        public x(): number;
        public x(_x: number): void;
        public data(): any;
        public data(_data: any): void;
        public id(): number;
        public id(_id: number): void;
        public set(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public set(_x: number, _y: number): void;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public reset(): void;
        public static create(): Packages.mindustry.gen.EffectState;
        public as<T>(): T | null;
        public y(_y: number): void;
        public y(): number;
        public color(
          _color: Packages.arc.graphics.Color,
        ): void;
        public color(): Packages.arc.graphics.Color;
        public time(_time: number): void;
        public time(): number;
        public self<
          T extends Packages.mindustry.gen.Entityc,
        >(): T | null;
        public getX(): number;
        public getY(): number;
        public trns(_x: number, _y: number): void;
        public trns(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public draw(): void;
        public offsetY(): number;
        public offsetY(_offsetY: number): void;
        public rotation(_rotation: number): void;
        public rotation(): number;
        public offsetX(_offsetX: number): void;
        public offsetX(): number;
        public effect(): Packages.mindustry.entities.Effect;
        public effect(
          _effect: Packages.mindustry.entities.Effect,
        ): void;
        public fin(): number;
        public afterRead(): void;
        public isLocal(): boolean;
        public isAdded(): boolean;
        public tileOn(): Packages.mindustry.world.Tile;
        public isRemote(): boolean;
        public onSolid(): boolean;
        public classId(): number;
        public setIndex__all(_index: number): void;
        public setIndex__draw(_index: number): void;
        public buildOn(): Packages.mindustry.gen.Building;
        public serialize(): boolean;
        public clipSize(): number;
        public tileX(): number;
        public tileY(): number;
        public blockOn(): Packages.mindustry.world.Block;
        public floorOn(): Packages.mindustry.world.blocks.environment.Floor;
        public afterAllRead(): void;
        public lifetime(_lifetime: number): void;
        public lifetime(): number;
        public rotWithParent(_rotWithParent: boolean): void;
        public rotWithParent(): boolean;
        public offsetPos(): number;
        public offsetPos(_offsetPos: number): void;
        public offsetRot(_offsetRot: number): void;
        public offsetRot(): number;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class ElevationMoveUnit
        extends Packages.mindustry.gen.Unit
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.ElevationMovec,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public static hitDuration: number;
        protected static tmp1: Packages.arc.math.geom.Vec2;
        protected static tmp2: Packages.arc.math.geom.Vec2;
        public static warpDst: number;
        protected added: boolean;
        protected applied: Packages.arc.struct.Bits;
        protected buildCounter: number;
        protected lastActive: Packages.mindustry.entities.units.BuildPlan;
        protected lastSize: number;
        protected resupplyTime: number;
        private rotation_LAST_: number;
        private rotation_TARGET_: number;
        protected statuses: Packages.arc.struct.Seq<Packages.mindustry.entities.units.StatusEntry>;
        protected wasFlying: boolean;
        protected wasHealed: boolean;
        protected wasPlayer: boolean;
        private x_LAST_: number;
        private x_TARGET_: number;
        private y_LAST_: number;
        private y_TARGET_: number;
        public add(): void;
        public remove(): void;
        public toString(): string;
        public update(): void;
        public apply(
          _effect: Packages.mindustry._type.StatusEffect,
          _duration: number,
        ): void;
        public apply(
          _effect: Packages.mindustry._type.StatusEffect,
        ): void;
        public count(): number;
        public bounds(): number;
        public set(_x: number, _y: number): void;
        public set(
          _def: Packages.mindustry._type.UnitType,
          _controller: Packages.mindustry.entities.units.UnitController,
        ): void;
        public set(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public destroy(): void;
        public cap(): number;
        public static create(): Packages.mindustry.gen.ElevationMoveUnit;
        public as<T>(): T | null;
        public command(): Packages.mindustry.ai._types.CommandAI;
        public display(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public range(): number;
        public self<
          T extends Packages.mindustry.gen.Entityc,
        >(): T | null;
        public inRange(
          _other: Packages.arc.math.geom.Position,
        ): boolean;
        public move(_v: Packages.arc.math.geom.Vec2): void;
        public move(_cx: number, _cy: number): void;
        public getDuration(
          _effect: Packages.mindustry._type.StatusEffect,
        ): number;
        public item(): Packages.mindustry._type.Item;
        public isValid(): boolean;
        public getX(): number;
        public getY(): number;
        public approach(
          _vector: Packages.arc.math.geom.Vec2,
        ): void;
        public interpolate(): void;
        public trns(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public trns(_x: number, _y: number): void;
        public speed(): number;
        public draw(): void;
        public controller(): Packages.mindustry.entities.units.UnitController;
        public controller(
          _next: Packages.mindustry.entities.units.UnitController,
        ): void;
        public icon(): Packages.arc.graphics.g2d.TextureRegion;
        public lookAt(_angle: number): void;
        public lookAt(_x: number, _y: number): void;
        public lookAt(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public hitbox(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public afterRead(): void;
        public core(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public canBuild(): boolean;
        public isPlayer(): boolean;
        public isLocal(): boolean;
        public isAdded(): boolean;
        public tileOn(): Packages.mindustry.world.Tile;
        public hitSize(): number;
        public closestCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public aim(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public aim(_x: number, _y: number): void;
        public controlWeapons(
          _rotate: boolean,
          _shoot: boolean,
        ): void;
        public controlWeapons(_rotateShoot: boolean): void;
        public inFogTo(
          _viewer: Packages.mindustry.game.Team,
        ): boolean;
        public afterSync(): void;
        public resetController(): void;
        public isRemote(): boolean;
        public snapInterpolation(): void;
        public onSolid(): boolean;
        public isFlying(): boolean;
        public canLand(): boolean;
        public classId(): number;
        public buildOn(): Packages.mindustry.gen.Building;
        public isSyncHidden(
          _player: Packages.mindustry.gen.Player,
        ): boolean;
        public damage(
          _amount: number,
          _withEffect: boolean,
        ): void;
        public damage(_amount: number): void;
        public sense(
          _sensor: Packages.mindustry.logic.LAccess,
        ): number;
        public sense(
          _content: Packages.mindustry.ctype.Content,
        ): number;
        public damageContinuous(_amount: number): void;
        public closestEnemyCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public getPlayer(): Packages.mindustry.gen.Player;
        public damagePierce(
          _amount: number,
          _withEffect: boolean,
        ): void;
        public damagePierce(_amount: number): void;
        public damaged(): boolean;
        public healthf(): number;
        public clampHealth(): void;
        public heal(): void;
        public heal(_amount: number): void;
        public cheating(): boolean;
        public itemCapacity(): number;
        public serialize(): boolean;
        public clipSize(): number;
        public tileX(): number;
        public tileY(): number;
        public blockOn(): Packages.mindustry.world.Block;
        public floorOn(): Packages.mindustry.world.blocks.environment.Floor;
        public afterAllRead(): void;
        public handleSyncHidden(): void;
        public readSync(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public readSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public snapSync(): void;
        public writeSync(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public writeSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public killed(): void;
        public displayable(): boolean;
        public isCommandable(): boolean;
        public isPathImpassable(
          _tileX: number,
          _tileY: number,
        ): boolean;
        public checkTarget(
          _targetAir: boolean,
          _targetGround: boolean,
        ): boolean;
        public isBoss(): boolean;
        public collision(
          _other: Packages.mindustry.gen.Hitboxc,
          _x: number,
          _y: number,
        ): void;
        public senseObject(
          _sensor: Packages.mindustry.logic.LAccess,
        ): any;
        public damageContinuousPierce(
          _amount: number,
        ): void;
        public healFract(_amount: number): void;
        public kill(): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: any,
        ): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: number,
        ): void;
        public setProp(
          _content: Packages.mindustry.ctype.UnlockableContent,
          _value: number,
        ): void;
        public targetable(
          _targeter: Packages.mindustry.game.Team,
        ): boolean;
        public drawPlan(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _alpha: number,
        ): void;
        public isAI(): boolean;
        public isEnemy(): boolean;
        public mining(): boolean;
        public canDrown(): boolean;
        public emitWalkSound(): boolean;
        public isGrounded(): boolean;
        public floorSpeedMultiplier(): number;
        public drownFloor(): Packages.mindustry.world.blocks.environment.Floor;
        public landed(): void;
        public moveAt(
          _vector: Packages.arc.math.geom.Vec2,
        ): void;
        public moveAt(
          _vector: Packages.arc.math.geom.Vec2,
          _acceleration: number,
        ): void;
        public updateDrowning(): void;
        public wobble(): void;
        public collides(
          _other: Packages.mindustry.gen.Hitboxc,
        ): boolean;
        public deltaAngle(): number;
        public deltaLen(): number;
        public getCollisions(
          _consumer: Packages.arc.func.Cons<
            Packages.arc.math.geom.QuadTree<any>
          >,
        ): void;
        public hitboxTile(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public updateLastPosition(): void;
        public solidity(): Packages.mindustry.entities.EntityCollisions.SolidPred;
        public canPassOn(): boolean;
        public canPass(
          _tileX: number,
          _tileY: number,
        ): boolean;
        public moving(): boolean;
        public velAddNet(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public velAddNet(_vx: number, _vy: number): void;
        public buildPlan(): Packages.mindustry.entities.units.BuildPlan;
        public acceptsItem(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public hasItem(): boolean;
        public maxAccepted(
          _item: Packages.mindustry._type.Item,
        ): number;
        public addItem(
          _item: Packages.mindustry._type.Item,
        ): void;
        public addItem(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): void;
        public clearItem(): void;
        public shouldSkip(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _core: Packages.mindustry.gen.Building,
        ): boolean;
        public addBuild(
          _place: Packages.mindustry.entities.units.BuildPlan,
          _tail: boolean,
        ): void;
        public addBuild(
          _place: Packages.mindustry.entities.units.BuildPlan,
        ): void;
        public clearBuilding(): void;
        public drawBuildPlans(): void;
        public isBuilding(): boolean;
        public activelyBuilding(): boolean;
        public drawBuilding(): void;
        public drawBuildingBeam(
          _px: number,
          _py: number,
        ): void;
        public drawPlanTop(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _alpha: number,
        ): void;
        public removeBuild(
          _x: number,
          _y: number,
          _breaking: boolean,
        ): void;
        public updateBuildLogic(): void;
        public validatePlans(): void;
        public applyDynamicStatus(): Packages.mindustry.entities.units.StatusEntry;
        public unapply(
          _effect: Packages.mindustry._type.StatusEffect,
        ): void;
        public statusDamageMultiplier(
          _damageMultiplier: number,
        ): void;
        public statusReloadMultiplier(
          _reloadMultiplier: number,
        ): void;
        public statusArmor(_armor: number): void;
        public statusBuildSpeed(_buildSpeed: number): void;
        public statusDrag(_drag: number): void;
        public statusMaxHealth(_health: number): void;
        public statusSpeed(_speed: number): void;
        public statusColor(): Packages.arc.graphics.Color;
        public statusBits(): Packages.arc.struct.Bits;
        public hasEffect(
          _effect: Packages.mindustry._type.StatusEffect,
        ): boolean;
        public isImmune(
          _effect: Packages.mindustry._type.StatusEffect,
        ): boolean;
        public clearStatuses(): void;
        public canMine(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public canMine(): boolean;
        public offloadImmediately(): boolean;
        public validMine(
          _tile: Packages.mindustry.world.Tile,
        ): boolean;
        public validMine(
          _tile: Packages.mindustry.world.Tile,
          _checkDst: boolean,
        ): boolean;
        public getMineResult(
          _tile: Packages.mindustry.world.Tile,
        ): Packages.mindustry._type.Item;
        public mass(): number;
        public impulse(_x: number, _y: number): void;
        public impulse(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public impulseNet(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public rawDamage(_amount: number): void;
        public physicSize(): number;
        public getControllerName(): string;
        public pathType(): number;
        public collisionLayer(): number;
        public prefRotation(): number;
        public unloaded(): void;
        public movePref(
          _movement: Packages.arc.math.geom.Vec2,
        ): void;
        public canShoot(): boolean;
        public canTarget(
          _other: Packages.mindustry.gen.Unit,
        ): boolean;
        public hasWeapons(): boolean;
        public hittable(): boolean;
        public aimLook(_x: number, _y: number): void;
        public aimLook(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public rotateMove(
          _vec: Packages.arc.math.geom.Vec2,
        ): void;
        public updateBoosting(_boost: boolean): void;
        public isRotate(): boolean;
        public ammof(): number;
        public setWeaponRotation(_rotation: number): void;
        public setupWeapons(
          _def: Packages.mindustry._type.UnitType,
        ): void;
        public setType(
          _type: Packages.mindustry._type.UnitType,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class EntityMapping extends java.lang.Object {
        public static customIdMap: Packages.arc.struct.IntMap<string>;
        public static idMap: Packages.arc.func.Prov<any>[];
        public static nameMap: Packages.arc.struct.ObjectMap<
          string,
          Packages.arc.func.Prov<any>
        >;
        public static map(
          _name: string,
        ): Packages.arc.func.Prov<any>;
        public static map(
          _id: number,
        ): Packages.arc.func.Prov<any>;
        public static register(
          _name: string,
          _constructor: Packages.arc.func.Prov<any>,
        ): number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class EntitySnapshotCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public amount: Packages.short;
        public data: string[];
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public getPriority(): number;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class FogEvent extends java.lang.Object {
        public static bitMaskX: Packages.long;
        public static bitMaskY: Packages.long;
        public static bitMaskRadius: Packages.long;
        public static bitMaskTeam: Packages.long;
        public static get(
          _x: number,
          _y: number,
          _radius: number,
          _team: number,
        ): Packages.long;
        public static x(
          _fogevent: Packages.long,
          _value: number,
        ): Packages.long;
        public static x(_fogevent: Packages.long): number;
        public static y(
          _fogevent: Packages.long,
          _value: number,
        ): Packages.long;
        public static y(_fogevent: Packages.long): number;
        public static radius(
          _fogevent: Packages.long,
        ): number;
        public static radius(
          _fogevent: Packages.long,
          _value: number,
        ): Packages.long;
        public static team(
          _fogevent: Packages.long,
          _value: number,
        ): Packages.long;
        public static team(
          _fogevent: Packages.long,
        ): number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class FollowUpMenuCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public menuId: number;
        public title: string;
        public message: string;
        public options: string[][];
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class GameOverCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public winner: Packages.mindustry.game.Team;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class IndexableEntity__label {
        public setIndex__label(_index: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class WorldLabelc
        implements
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Entityc
      {
        public flags(): string;
        public flags(_flags: string): void;
        public z(): number;
        public z(_z: number): void;
        public text(): string;
        public text(_text: string): void;
        public draw(): void;
        public hide(): void;
        public clipSize(): number;
        public fontSize(_fontSize: number): void;
        public fontSize(): number;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class WorldLabel
        extends java.lang.Object
        implements
          Packages.mindustry.gen.IndexableEntity__all,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.WorldLabelc,
          Packages.mindustry.gen.IndexableEntity__sync,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.IndexableEntity__label,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.IndexableEntity__draw
      {
        public static flagBackground: string;
        public static flagOutline: string;
        protected added: boolean;
        protected index__all: number;
        protected index__draw: number;
        protected index__label: number;
        protected index__sync: number;
        private x_LAST_: number;
        private x_TARGET_: number;
        private y_LAST_: number;
        private y_TARGET_: number;
        public add(): void;
        public remove(): void;
        public toString(): string;
        public flags(_flags: string): void;
        public flags(): string;
        public update(): void;
        public x(_x: number): void;
        public x(): number;
        public id(_id: number): void;
        public id(): number;
        public set(_x: number, _y: number): void;
        public set(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public z(_z: number): void;
        public z(): number;
        public static create(): Packages.mindustry.gen.WorldLabel;
        public as<T>(): T | null;
        public y(_y: number): void;
        public y(): number;
        public text(): string;
        public text(_text: string): void;
        public self<
          T extends Packages.mindustry.gen.Entityc,
        >(): T | null;
        public getX(): number;
        public getY(): number;
        public interpolate(): void;
        public trns(_x: number, _y: number): void;
        public trns(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public draw(): void;
        public hide(): void;
        public lastUpdated(
          _lastUpdated: Packages.long,
        ): void;
        public lastUpdated(): Packages.long;
        public updateSpacing(): Packages.long;
        public updateSpacing(
          _updateSpacing: Packages.long,
        ): void;
        public afterRead(): void;
        public isLocal(): boolean;
        public isAdded(): boolean;
        public tileOn(): Packages.mindustry.world.Tile;
        public afterSync(): void;
        public isRemote(): boolean;
        public snapInterpolation(): void;
        public onSolid(): boolean;
        public classId(): number;
        public setIndex__all(_index: number): void;
        public setIndex__draw(_index: number): void;
        public setIndex__sync(_index: number): void;
        public buildOn(): Packages.mindustry.gen.Building;
        public isSyncHidden(
          _player: Packages.mindustry.gen.Player,
        ): boolean;
        public serialize(): boolean;
        public clipSize(): number;
        public tileX(): number;
        public tileY(): number;
        public blockOn(): Packages.mindustry.world.Block;
        public floorOn(): Packages.mindustry.world.blocks.environment.Floor;
        public afterAllRead(): void;
        public handleSyncHidden(): void;
        public readSync(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public readSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public snapSync(): void;
        public writeSync(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public writeSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public fontSize(_fontSize: number): void;
        public fontSize(): number;
        public static drawAt(
          _text: string,
          _x: number,
          _y: number,
          _layer: number,
          _flags: number,
          _fontSize: number,
        ): void;
        public setIndex__label(_index: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class Groups extends java.lang.Object {
        public static all: Packages.mindustry.entities.EntityGroup<Packages.mindustry.gen.Entityc>;
        public static build: Packages.mindustry.entities.EntityGroup<Packages.mindustry.gen.Building>;
        public static bullet: Packages.mindustry.entities.EntityGroup<Packages.mindustry.gen.Bullet>;
        public static draw: Packages.mindustry.entities.EntityGroup<Packages.mindustry.gen.Drawc>;
        public static fire: Packages.mindustry.entities.EntityGroup<Packages.mindustry.gen.Fire>;
        private static freeQueue: Packages.arc.struct.Seq<Packages.arc.util.pooling.Pool.Poolable>;
        public static isClearing: boolean;
        public static label: Packages.mindustry.entities.EntityGroup<Packages.mindustry.gen.WorldLabel>;
        public static player: Packages.mindustry.entities.EntityGroup<Packages.mindustry.gen.Player>;
        public static powerGraph: Packages.mindustry.entities.EntityGroup<Packages.mindustry.gen.PowerGraphUpdaterc>;
        public static puddle: Packages.mindustry.entities.EntityGroup<Packages.mindustry.gen.Puddle>;
        public static sync: Packages.mindustry.entities.EntityGroup<Packages.mindustry.gen.Syncc>;
        public static unit: Packages.mindustry.entities.EntityGroup<Packages.mindustry.gen.Unit>;
        public static weather: Packages.mindustry.entities.EntityGroup<Packages.mindustry.gen.WeatherState>;
        public static update(): void;
        public static clear(): void;
        public static init(): void;
        public static resize(
          _x: number,
          _y: number,
          _w: number,
          _h: number,
        ): void;
        public static queueFree(
          _obj: Packages.arc.util.pooling.Pool.Poolable,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class HiddenSnapshotCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public ids: Packages.arc.struct.IntSeq;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public getPriority(): number;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class HideFollowUpMenuCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public menuId: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class HideHudTextCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class Icon extends java.lang.Object {
        public static icons: Packages.arc.struct.ObjectMap<
          string,
          Packages.arc.scene.style.TextureRegionDrawable
        >;
        public static fileTextFillSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static fileTextFill: Packages.arc.scene.style.TextureRegionDrawable;
        public static fileSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static file: Packages.arc.scene.style.TextureRegionDrawable;
        public static fileTextSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static fileText: Packages.arc.scene.style.TextureRegionDrawable;
        public static leftSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static left: Packages.arc.scene.style.TextureRegionDrawable;
        public static rightSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static right: Packages.arc.scene.style.TextureRegionDrawable;
        public static upSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static up: Packages.arc.scene.style.TextureRegionDrawable;
        public static downSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static down: Packages.arc.scene.style.TextureRegionDrawable;
        public static homeSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static home: Packages.arc.scene.style.TextureRegionDrawable;
        public static okSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static ok: Packages.arc.scene.style.TextureRegionDrawable;
        public static imageSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static image: Packages.arc.scene.style.TextureRegionDrawable;
        public static starSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static star: Packages.arc.scene.style.TextureRegionDrawable;
        public static resizeSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static resize: Packages.arc.scene.style.TextureRegionDrawable;
        public static wrenchSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static wrench: Packages.arc.scene.style.TextureRegionDrawable;
        public static githubSquareSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static githubSquare: Packages.arc.scene.style.TextureRegionDrawable;
        public static fileImageSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static fileImage: Packages.arc.scene.style.TextureRegionDrawable;
        public static addSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static add: Packages.arc.scene.style.TextureRegionDrawable;
        public static editSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static edit: Packages.arc.scene.style.TextureRegionDrawable;
        public static chartBarSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static chartBar: Packages.arc.scene.style.TextureRegionDrawable;
        public static planeOutlineSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static planeOutline: Packages.arc.scene.style.TextureRegionDrawable;
        public static filterSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static filter: Packages.arc.scene.style.TextureRegionDrawable;
        public static folderSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static folder: Packages.arc.scene.style.TextureRegionDrawable;
        public static steamSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static steam: Packages.arc.scene.style.TextureRegionDrawable;
        public static downOpenSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static downOpen: Packages.arc.scene.style.TextureRegionDrawable;
        public static leftOpenSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static leftOpen: Packages.arc.scene.style.TextureRegionDrawable;
        public static upOpenSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static upOpen: Packages.arc.scene.style.TextureRegionDrawable;
        public static mapSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static map: Packages.arc.scene.style.TextureRegionDrawable;
        public static rotateSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static rotate: Packages.arc.scene.style.TextureRegionDrawable;
        public static playSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static play: Packages.arc.scene.style.TextureRegionDrawable;
        public static pauseSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static pause: Packages.arc.scene.style.TextureRegionDrawable;
        public static listSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static list: Packages.arc.scene.style.TextureRegionDrawable;
        public static cancelSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static cancel: Packages.arc.scene.style.TextureRegionDrawable;
        public static moveSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static move: Packages.arc.scene.style.TextureRegionDrawable;
        public static terminalSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static terminal: Packages.arc.scene.style.TextureRegionDrawable;
        public static undoSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static undo: Packages.arc.scene.style.TextureRegionDrawable;
        public static redoSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static redo: Packages.arc.scene.style.TextureRegionDrawable;
        public static infoSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static info: Packages.arc.scene.style.TextureRegionDrawable;
        public static infoCircleSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static infoCircle: Packages.arc.scene.style.TextureRegionDrawable;
        public static rightOpenOutSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static rightOpenOut: Packages.arc.scene.style.TextureRegionDrawable;
        public static rightOpenSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static rightOpen: Packages.arc.scene.style.TextureRegionDrawable;
        public static wavesSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static waves: Packages.arc.scene.style.TextureRegionDrawable;
        public static filtersSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static filters: Packages.arc.scene.style.TextureRegionDrawable;
        public static layersSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static layers: Packages.arc.scene.style.TextureRegionDrawable;
        public static eraserSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static eraser: Packages.arc.scene.style.TextureRegionDrawable;
        public static bookOpenSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static bookOpen: Packages.arc.scene.style.TextureRegionDrawable;
        public static gridSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static grid: Packages.arc.scene.style.TextureRegionDrawable;
        public static flipXSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static flipX: Packages.arc.scene.style.TextureRegionDrawable;
        public static flipYSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static flipY: Packages.arc.scene.style.TextureRegionDrawable;
        public static diagonalSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static diagonal: Packages.arc.scene.style.TextureRegionDrawable;
        public static discordSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static discord: Packages.arc.scene.style.TextureRegionDrawable;
        public static boxSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static box: Packages.arc.scene.style.TextureRegionDrawable;
        public static redditAlienSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static redditAlien: Packages.arc.scene.style.TextureRegionDrawable;
        public static githubSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static github: Packages.arc.scene.style.TextureRegionDrawable;
        public static googleplaySmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static googleplay: Packages.arc.scene.style.TextureRegionDrawable;
        public static androidSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static android: Packages.arc.scene.style.TextureRegionDrawable;
        public static trelloSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static trello: Packages.arc.scene.style.TextureRegionDrawable;
        public static logicSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static logic: Packages.arc.scene.style.TextureRegionDrawable;
        public static distributionSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static distribution: Packages.arc.scene.style.TextureRegionDrawable;
        public static hammerSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static hammer: Packages.arc.scene.style.TextureRegionDrawable;
        public static saveSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static save: Packages.arc.scene.style.TextureRegionDrawable;
        public static linkSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static link: Packages.arc.scene.style.TextureRegionDrawable;
        public static itchioSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static itchio: Packages.arc.scene.style.TextureRegionDrawable;
        public static lineSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static line: Packages.arc.scene.style.TextureRegionDrawable;
        public static adminSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static admin: Packages.arc.scene.style.TextureRegionDrawable;
        public static spray1Small: Packages.arc.scene.style.TextureRegionDrawable;
        public static spray1: Packages.arc.scene.style.TextureRegionDrawable;
        public static craftingSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static crafting: Packages.arc.scene.style.TextureRegionDrawable;
        public static fillSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static fill: Packages.arc.scene.style.TextureRegionDrawable;
        public static pasteSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static paste: Packages.arc.scene.style.TextureRegionDrawable;
        public static effectSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static effect: Packages.arc.scene.style.TextureRegionDrawable;
        public static bookSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static book: Packages.arc.scene.style.TextureRegionDrawable;
        public static liquidSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static liquid: Packages.arc.scene.style.TextureRegionDrawable;
        public static hostSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static host: Packages.arc.scene.style.TextureRegionDrawable;
        public static productionSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static production: Packages.arc.scene.style.TextureRegionDrawable;
        public static exitSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static exit: Packages.arc.scene.style.TextureRegionDrawable;
        public static modePvpSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static modePvp: Packages.arc.scene.style.TextureRegionDrawable;
        public static modeAttackSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static modeAttack: Packages.arc.scene.style.TextureRegionDrawable;
        public static refresh1Small: Packages.arc.scene.style.TextureRegionDrawable;
        public static refresh1: Packages.arc.scene.style.TextureRegionDrawable;
        public static noneSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static none: Packages.arc.scene.style.TextureRegionDrawable;
        public static pencilSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static pencil: Packages.arc.scene.style.TextureRegionDrawable;
        public static refreshSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static refresh: Packages.arc.scene.style.TextureRegionDrawable;
        public static modeSurvivalSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static modeSurvival: Packages.arc.scene.style.TextureRegionDrawable;
        public static commandRallySmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static commandRally: Packages.arc.scene.style.TextureRegionDrawable;
        public static unitsSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static units: Packages.arc.scene.style.TextureRegionDrawable;
        public static commandAttackSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static commandAttack: Packages.arc.scene.style.TextureRegionDrawable;
        public static trashSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static trash: Packages.arc.scene.style.TextureRegionDrawable;
        public static chatSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static chat: Packages.arc.scene.style.TextureRegionDrawable;
        public static turretSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static turret: Packages.arc.scene.style.TextureRegionDrawable;
        public static playersSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static players: Packages.arc.scene.style.TextureRegionDrawable;
        public static editorSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static editor: Packages.arc.scene.style.TextureRegionDrawable;
        public static copySmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static copy: Packages.arc.scene.style.TextureRegionDrawable;
        public static treeSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static tree: Packages.arc.scene.style.TextureRegionDrawable;
        public static lockOpenSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static lockOpen: Packages.arc.scene.style.TextureRegionDrawable;
        public static pickSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static pick: Packages.arc.scene.style.TextureRegionDrawable;
        public static exportSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static export: Packages.arc.scene.style.TextureRegionDrawable;
        public static downloadSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static download: Packages.arc.scene.style.TextureRegionDrawable;
        public static uploadSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static upload: Packages.arc.scene.style.TextureRegionDrawable;
        public static settingsSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static settings: Packages.arc.scene.style.TextureRegionDrawable;
        public static spraySmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static spray: Packages.arc.scene.style.TextureRegionDrawable;
        public static zoomSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static zoom: Packages.arc.scene.style.TextureRegionDrawable;
        public static powerOldSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static powerOld: Packages.arc.scene.style.TextureRegionDrawable;
        public static powerSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static power: Packages.arc.scene.style.TextureRegionDrawable;
        public static menuSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static menu: Packages.arc.scene.style.TextureRegionDrawable;
        public static lockSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static lock: Packages.arc.scene.style.TextureRegionDrawable;
        public static eyeSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static eye: Packages.arc.scene.style.TextureRegionDrawable;
        public static eyeOffSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static eyeOff: Packages.arc.scene.style.TextureRegionDrawable;
        public static warningSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static warning: Packages.arc.scene.style.TextureRegionDrawable;
        public static terrainSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static terrain: Packages.arc.scene.style.TextureRegionDrawable;
        public static defenseSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static defense: Packages.arc.scene.style.TextureRegionDrawable;
        public static planetSmall: Packages.arc.scene.style.TextureRegionDrawable;
        public static planet: Packages.arc.scene.style.TextureRegionDrawable;
        public static load(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class Iconc extends java.lang.Object {
        public static blockSpawn: string;
        public static blockDeepwater: string;
        public static blockShallowWater: string;
        public static blockTaintedWater: string;
        public static blockDarksandTaintedWater: string;
        public static blockSandWater: string;
        public static blockDarksandWater: string;
        public static blockTar: string;
        public static blockStone: string;
        public static blockCraters: string;
        public static blockChar: string;
        public static blockIgnarock: string;
        public static blockHotrock: string;
        public static blockMagmarock: string;
        public static blockSand: string;
        public static blockDarksand: string;
        public static blockGrass: string;
        public static blockSalt: string;
        public static blockSnow: string;
        public static blockIce: string;
        public static blockIceSnow: string;
        public static blockCliffs: string;
        public static blockRock: string;
        public static blockSnowrock: string;
        public static blockSporePine: string;
        public static blockSnowPine: string;
        public static blockPine: string;
        public static blockShrubs: string;
        public static blockWhiteTreeDead: string;
        public static blockWhiteTree: string;
        public static blockSporeCluster: string;
        public static blockShale: string;
        public static blockShaleBoulder: string;
        public static blockSandBoulder: string;
        public static blockMoss: string;
        public static blockSporeMoss: string;
        public static blockMetalFloor: string;
        public static blockMetalFloorDamaged: string;
        public static blockMetalFloor2: string;
        public static blockMetalFloor3: string;
        public static blockMetalFloor5: string;
        public static blockDarkPanel1: string;
        public static blockDarkPanel2: string;
        public static blockDarkPanel3: string;
        public static blockDarkPanel4: string;
        public static blockDarkPanel5: string;
        public static blockDarkPanel6: string;
        public static blockDarkMetal: string;
        public static blockPebbles: string;
        public static blockTendrils: string;
        public static blockOreCopper: string;
        public static blockOreLead: string;
        public static blockOreScrap: string;
        public static blockOreCoal: string;
        public static blockOreTitanium: string;
        public static blockOreThorium: string;
        public static blockGraphitePress: string;
        public static blockMultiPress: string;
        public static blockSiliconSmelter: string;
        public static blockKiln: string;
        public static blockPlastaniumCompressor: string;
        public static blockPhaseWeaver: string;
        public static blockSurgeSmelter: string;
        public static blockCryofluidMixer: string;
        public static blockBlastMixer: string;
        public static blockPyratiteMixer: string;
        public static blockMelter: string;
        public static blockSeparator: string;
        public static blockSporePress: string;
        public static blockPulverizer: string;
        public static blockCoalCentrifuge: string;
        public static blockIncinerator: string;
        public static blockCopperWall: string;
        public static blockCopperWallLarge: string;
        public static blockTitaniumWall: string;
        public static blockTitaniumWallLarge: string;
        public static blockPlastaniumWall: string;
        public static blockPlastaniumWallLarge: string;
        public static blockThoriumWall: string;
        public static blockThoriumWallLarge: string;
        public static blockPhaseWall: string;
        public static blockPhaseWallLarge: string;
        public static blockSurgeWall: string;
        public static blockSurgeWallLarge: string;
        public static blockDoor: string;
        public static blockDoorLarge: string;
        public static blockScrapWall: string;
        public static blockScrapWallLarge: string;
        public static blockScrapWallHuge: string;
        public static blockScrapWallGigantic: string;
        public static blockThruster: string;
        public static blockMender: string;
        public static blockMendProjector: string;
        public static blockOverdriveProjector: string;
        public static blockForceProjector: string;
        public static blockShockMine: string;
        public static blockConveyor: string;
        public static blockTitaniumConveyor: string;
        public static blockArmoredConveyor: string;
        public static blockJunction: string;
        public static blockBridgeConveyor: string;
        public static blockPhaseConveyor: string;
        public static blockSorter: string;
        public static blockInvertedSorter: string;
        public static blockRouter: string;
        public static blockDistributor: string;
        public static blockOverflowGate: string;
        public static blockMassDriver: string;
        public static blockMechanicalPump: string;
        public static blockRotaryPump: string;
        public static blockImpulsePump: string;
        public static blockConduit: string;
        public static blockPulseConduit: string;
        public static blockPlatedConduit: string;
        public static blockLiquidRouter: string;
        public static blockLiquidTank: string;
        public static blockLiquidJunction: string;
        public static blockBridgeConduit: string;
        public static blockPhaseConduit: string;
        public static blockPowerNode: string;
        public static blockPowerNodeLarge: string;
        public static blockSurgeTower: string;
        public static blockDiode: string;
        public static blockBattery: string;
        public static blockBatteryLarge: string;
        public static blockCombustionGenerator: string;
        public static blockThermalGenerator: string;
        public static blockSteamGenerator: string;
        public static blockDifferentialGenerator: string;
        public static blockRtgGenerator: string;
        public static blockSolarPanel: string;
        public static blockSolarPanelLarge: string;
        public static blockThoriumReactor: string;
        public static blockImpactReactor: string;
        public static blockMechanicalDrill: string;
        public static blockPneumaticDrill: string;
        public static blockLaserDrill: string;
        public static blockBlastDrill: string;
        public static blockWaterExtractor: string;
        public static blockCultivator: string;
        public static blockOilExtractor: string;
        public static blockCoreShard: string;
        public static blockCoreFoundation: string;
        public static blockCoreNucleus: string;
        public static blockVault: string;
        public static blockContainer: string;
        public static blockUnloader: string;
        public static blockLaunchPad: string;
        public static blockLaunchPadLarge: string;
        public static blockDuo: string;
        public static blockScatter: string;
        public static blockScorch: string;
        public static blockHail: string;
        public static blockWave: string;
        public static blockLancer: string;
        public static blockArc: string;
        public static blockSwarmer: string;
        public static blockSalvo: string;
        public static blockFuse: string;
        public static blockRipple: string;
        public static blockCyclone: string;
        public static blockSpectre: string;
        public static blockMeltdown: string;
        public static blockDraugFactory: string;
        public static blockSpiritFactory: string;
        public static blockPhantomFactory: string;
        public static blockCommandCenter: string;
        public static blockWraithFactory: string;
        public static blockGhoulFactory: string;
        public static blockRevenantFactory: string;
        public static blockDaggerFactory: string;
        public static blockCrawlerFactory: string;
        public static blockTitanFactory: string;
        public static blockFortressFactory: string;
        public static blockRepairPoint: string;
        public static blockDartMechPad: string;
        public static blockDeltaMechPad: string;
        public static blockTauMechPad: string;
        public static blockOmegaMechPad: string;
        public static blockJavelinShipPad: string;
        public static blockTridentShipPad: string;
        public static blockGlaiveShipPad: string;
        public static blockPowerSource: string;
        public static blockPowerVoid: string;
        public static blockItemSource: string;
        public static blockItemVoid: string;
        public static blockLiquidSource: string;
        public static blockLiquidVoid: string;
        public static blockMessage: string;
        public static blockIlluminator: string;
        public static itemCopper: string;
        public static itemLead: string;
        public static itemMetaglass: string;
        public static itemGraphite: string;
        public static itemSand: string;
        public static itemCoal: string;
        public static itemTitanium: string;
        public static itemThorium: string;
        public static itemScrap: string;
        public static itemSilicon: string;
        public static itemPlastanium: string;
        public static itemPhaseFabric: string;
        public static itemSurgeAlloy: string;
        public static itemSporePod: string;
        public static itemBlastCompound: string;
        public static itemPyratite: string;
        public static liquidWater: string;
        public static liquidSlag: string;
        public static liquidOil: string;
        public static liquidCryofluid: string;
        public static blockUnderflowGate: string;
        public static blockDartShipPad: string;
        public static blockAlphaMechPad: string;
        public static blockCliff: string;
        public static blockLegacyMechPad: string;
        public static blockGroundFactory: string;
        public static blockLegacyUnitFactory: string;
        public static blockMassConveyor: string;
        public static blockLegacyCommandCenter: string;
        public static blockBlockForge: string;
        public static blockBlockLauncher: string;
        public static blockPlastaniumConveyor: string;
        public static crater: string;
        public static blockNavalFactory: string;
        public static blockAirFactory: string;
        public static blockBasicRe_constructor: string;
        public static blockBlockLoader: string;
        public static blockBlockUnloader: string;
        public static blockCoreSilo: string;
        public static blockDataProcessor: string;
        public static blockPayloadRouter: string;
        public static blockSiliconCrucible: string;
        public static blockSegment: string;
        public static blockLargeOverdriveProjector: string;
        public static blockDisassembler: string;
        public static blockAdditiveRe_constructor: string;
        public static blockMultiplicativeRe_constructor: string;
        public static blockExponentialRe_constructor: string;
        public static blockTetrativeRe_constructor: string;
        public static blockResupplyPoint: string;
        public static blockParallax: string;
        public static unitDagger: string;
        public static unitMace: string;
        public static unitFortress: string;
        public static unitNova: string;
        public static unitPulsar: string;
        public static unitQuasar: string;
        public static unitCrawler: string;
        public static unitAtrax: string;
        public static unitSpiroct: string;
        public static unitArkyid: string;
        public static unitFlare: string;
        public static unitHorizon: string;
        public static unitZenith: string;
        public static unitAntumbra: string;
        public static unitEclipse: string;
        public static unitMono: string;
        public static unitPoly: string;
        public static unitMega: string;
        public static unitRisse: string;
        public static unitMinke: string;
        public static unitBryde: string;
        public static unitAlpha: string;
        public static unitBeta: string;
        public static unitGamma: string;
        public static unitBlock: string;
        public static unitRisso: string;
        public static blockOverdriveDome: string;
        public static blockLogicProcessor: string;
        public static blockMicroProcessor: string;
        public static blockLogicDisplay: string;
        public static blockSwitch: string;
        public static blockMemoryCell: string;
        public static blockPayloadConveyor: string;
        public static blockHyperProcessor: string;
        public static unitToxopid: string;
        public static unitVestige: string;
        public static unitCataclyst: string;
        public static unitScepter: string;
        public static unitReign: string;
        public static blockDirt: string;
        public static blockStoneWall: string;
        public static blockSporeWall: string;
        public static blockIceWall: string;
        public static blockSnowWall: string;
        public static blockDuneWall: string;
        public static blockSandWall: string;
        public static blockSaltWall: string;
        public static blockShaleWall: string;
        public static blockDirtWall: string;
        public static blockBasalt: string;
        public static blockDacite: string;
        public static blockBoulder: string;
        public static blockSnowBoulder: string;
        public static blockDaciteWall: string;
        public static blockDaciteBoulder: string;
        public static blockLargeLogicDisplay: string;
        public static unitOmura: string;
        public static blockMud: string;
        public static unitSei: string;
        public static unitQuad: string;
        public static unitOct: string;
        public static unitVela: string;
        public static unitCorvus: string;
        public static blockMemoryBank: string;
        public static blockForeshadow: string;
        public static blockTsunami: string;
        public static blockSpace: string;
        public static blockLegacyUnitFactoryAir: string;
        public static blockLegacyUnitFactoryGround: string;
        public static blockInterplanetaryAccelerator: string;
        public static blockBasaltBoulder: string;
        public static statusNone: string;
        public static statusBurning: string;
        public static statusFreezing: string;
        public static statusUnmoving: string;
        public static statusSlow: string;
        public static statusWet: string;
        public static statusMuddy: string;
        public static statusMelting: string;
        public static statusSapped: string;
        public static statusSporeSlowed: string;
        public static statusTarred: string;
        public static statusOverdrive: string;
        public static statusOverclock: string;
        public static statusShielded: string;
        public static statusBoss: string;
        public static statusShocked: string;
        public static statusBlasted: string;
        public static statusCorroded: string;
        public static statusDisarmed: string;
        public static blockDuct: string;
        public static blockRepairTurret: string;
        public static blockPayloadIncinerator: string;
        public static blockPayloadVoid: string;
        public static blockPayloadSource: string;
        public static unitRetusa: string;
        public static blockDuctRouter: string;
        public static blockDuctBridge: string;
        public static unitOxynoe: string;
        public static unitCyerce: string;
        public static unitAegires: string;
        public static statusElectrified: string;
        public static unitNavanax: string;
        public static blockSiliconArcFurnace: string;
        public static blockMetalFloor4: string;
        public static statusInvincible: string;
        public static teamSharded: string;
        public static teamCrux: string;
        public static teamDerelict: string;
        public static blockDeepWater: string;
        public static blockMoltenSlag: string;
        public static blockCraterStone: string;
        public static blockDeepTaintedWater: string;
        public static blockPooledCryofluid: string;
        public static blockEmpty: string;
        public static blockLiquidContainer: string;
        public static blockDe_constructor: string;
        public static blockConstructor: string;
        public static blockLargeConstructor: string;
        public static blockPayloadLoader: string;
        public static blockPayloadUnloader: string;
        public static blockRhyolite: string;
        public static blockRhyoliteCrater: string;
        public static blockRegolith: string;
        public static blockYellowStone: string;
        public static blockCarbonStone: string;
        public static blockFerricStone: string;
        public static blockFerricCraters: string;
        public static blockBeryllicStone: string;
        public static blockRedIce: string;
        public static blockRedmat: string;
        public static blockBluemat: string;
        public static blockRegolithWall: string;
        public static blockYellowStoneWall: string;
        public static blockRhyoliteWall: string;
        public static blockCarbonWall: string;
        public static blockFerricStoneWall: string;
        public static blockBeryllicStoneWall: string;
        public static blockRedIceWall: string;
        public static blockRedweed: string;
        public static blockPurBush: string;
        public static blockYellowcoral: string;
        public static blockCarbonBoulder: string;
        public static blockFerricBoulder: string;
        public static blockBeryllicBoulder: string;
        public static blockWallOreBeryllium: string;
        public static blockGraphiticWall: string;
        public static blockCellSynthesisChamber: string;
        public static blockCliffCrusher: string;
        public static blockBeamDrill: string;
        public static blockNuclearWarhead: string;
        public static blockWarheadAssembler: string;
        public static blockBallisticSilo: string;
        public static itemBeryllium: string;
        public static itemFissileMatter: string;
        public static itemDormantCyst: string;
        public static liquidNeoplasm: string;
        public static blockPlasmaBore: string;
        public static blockSteamVent: string;
        public static blockPressureTurbine: string;
        public static blockTurbineCondenser: string;
        public static blockBeamNode: string;
        public static blockBeamTower: string;
        public static blockBuildTower: string;
        public static itemTungsten: string;
        public static blockOreTungsten: string;
        public static blockImpactDrill: string;
        public static itemCarbide: string;
        public static unitEvoke: string;
        public static blockCarbideCrucible: string;
        public static blockSurgeDuct: string;
        public static blockSurgeConveyor: string;
        public static blockDuctUnloader: string;
        public static blockSurgeRouter: string;
        public static blockReinforcedConduit: string;
        public static blockReinforcedLiquidRouter: string;
        public static blockReinforcedLiquidContainer: string;
        public static blockReinforcedLiquidTank: string;
        public static blockReinforcedBridgeConduit: string;
        public static blockCoreCitadel: string;
        public static blockCoreAcropolis: string;
        public static blockHeatReactor: string;
        public static blockCoreBastion: string;
        public static unitIncite: string;
        public static blockOxidizer: string;
        public static blockReinforcedPump: string;
        public static itemOxide: string;
        public static liquidOxygen: string;
        public static liquidHydrogen: string;
        public static blockElectrolyzer: string;
        public static liquidOzone: string;
        public static blockReinforcedLiquidJunction: string;
        public static blockOxidationChamber: string;
        public static blockSurgeCrucible: string;
        public static unitEmanate: string;
        public static blockOverflowDuct: string;
        public static blockLargePlasmaBore: string;
        public static blockCyanogenSynthesizer: string;
        public static liquidCyanogen: string;
        public static liquidGallium: string;
        public static blockSlagCentrifuge: string;
        public static blockSlagIncinerator: string;
        public static blockPhaseSynthesizer: string;
        public static blockSublimate: string;
        public static blockReinforcedContainer: string;
        public static blockReinforcedVault: string;
        public static liquidNitrogen: string;
        public static blockAtmosphericConcentrator: string;
        public static blockUnitCargoLoader: string;
        public static blockUnitCargoUnloadPoint: string;
        public static unitManifold: string;
        public static blockArkyciteFloor: string;
        public static liquidArkycite: string;
        public static blockChemicalCombustionChamber: string;
        public static blockArkyicStone: string;
        public static blockYellowStoneBoulder: string;
        public static blockPyrolysisGenerator: string;
        public static blockWallOreTungsten: string;
        public static blockRegenProjector: string;
        public static blockTitan: string;
        public static blockSmallDe_constructor: string;
        public static blockBarrierProjector: string;
        public static blockVentCondenser: string;
        public static blockElectricHeater: string;
        public static blockPhaseHeater: string;
        public static blockArkyicWall: string;
        public static blockHeatRedirector: string;
        public static unitVanquish: string;
        public static blockTungstenWall: string;
        public static blockTungstenWallLarge: string;
        public static blockTankAssembler: string;
        public static unitAssemblyDrone: string;
        public static blockBerylliumWall: string;
        public static blockBerylliumWallLarge: string;
        public static unitQuell: string;
        public static blockBreach: string;
        public static blockEruptionDrill: string;
        public static blockShipAssembler: string;
        public static unitQuellMissile: string;
        public static blockMechAssembler: string;
        public static blockOreCrystalThorium: string;
        public static blockOreWallBeryllium: string;
        public static blockOreWallTungsten: string;
        public static blockArkyicBoulder: string;
        public static blockCrystallineStone: string;
        public static blockCrystallineStoneWall: string;
        public static blockCrystalCluster: string;
        public static blockCrystallineBoulder: string;
        public static blockCrystalFloor: string;
        public static blockVibrantCrystalCluster: string;
        public static blockRedIceBoulder: string;
        public static blockCrystalBlocks: string;
        public static blockYellowStonePlates: string;
        public static blockRoughRhyolite: string;
        public static blockRhyoliteBoulder: string;
        public static blockRedStone: string;
        public static blockDenseRedStone: string;
        public static blockRedStoneWall: string;
        public static blockRedStoneBoulder: string;
        public static blockRedDiamondWall: string;
        public static blockCrystalOrbs: string;
        public static unitConquer: string;
        public static unitDisrupt: string;
        public static unitDisruptMissile: string;
        public static blockRhyoliteVent: string;
        public static blockArkyicVent: string;
        public static blockYellowStoneVent: string;
        public static blockRedStoneVent: string;
        public static blockCarbonVent: string;
        public static blockShieldProjector: string;
        public static blockBeamLink: string;
        public static unitEffectDrone: string;
        public static blockWorldProcessor: string;
        public static blockReinforcedPayloadConveyor: string;
        public static blockReinforcedPayloadRouter: string;
        public static blockDisperse: string;
        public static blockLargeShieldProjector: string;
        public static blockPayloadMassDriver: string;
        public static blockWorldCell: string;
        public static blockCarbideWall: string;
        public static blockCarbideWallLarge: string;
        public static blockOreWallThorium: string;
        public static blockCoreZone: string;
        public static blockFabricator: string;
        public static unitStell: string;
        public static blockOreBeryllium: string;
        public static unitLocus: string;
        public static unitAvert: string;
        public static unitCleroi: string;
        public static blockTankRe_constructor: string;
        public static blockMechRe_constructor: string;
        public static blockShipRe_constructor: string;
        public static blockRadar: string;
        public static unitTurretUnitBuildTower: string;
        public static blockBlastDoor: string;
        public static alphaaaa: string;
        public static teamMalis: string;
        public static blockCanvas: string;
        public static blockArmoredDuct: string;
        public static unitAnthicus: string;
        public static unitAnthicusMissile: string;
        public static unitObviate: string;
        public static blockTankFabricator: string;
        public static blockMechFabricator: string;
        public static blockShipFabricator: string;
        public static blockUnitRepairTower: string;
        public static unitMerui: string;
        public static unitOsc: string;
        public static unitPrecept: string;
        public static blockDiffuse: string;
        public static blockBasicAssemblerModule: string;
        public static unitTecta: string;
        public static unitCollaris: string;
        public static unitElude: string;
        public static blockRefabricator: string;
        public static blockPrimeRefabricator: string;
        public static unitLatum: string;
        public static blockReinforcedSurgeWall: string;
        public static blockReinforcedSurgeWallLarge: string;
        public static blockTankRefabricator: string;
        public static blockMechRefabricator: string;
        public static blockShipRefabricator: string;
        public static blockSlagHeater: string;
        public static blockAfflict: string;
        public static blockShieldedWall: string;
        public static blockFracture: string;
        public static unitRenale: string;
        public static blockLustre: string;
        public static blockScathe: string;
        public static unitScatheMissile: string;
        public static blockRavage: string;
        public static blockUnderflowDuct: string;
        public static blockMalign: string;
        public static blockSmite: string;
        public static blockShockwaveTower: string;
        public static blockHeatSource: string;
        public static blockFluxReactor: string;
        public static blockNeoplasiaReactor: string;
        public static blockSandFloor: string;
        public static blockCrystallineVent: string;
        public static blockHeatRouter: string;
        public static blockLargePayloadMassDriver: string;
        public static blockReinforcedMessage: string;
        public static blockWorldMessage: string;
        public static statusFast: string;
        public static ranai: string;
        public static cat: string;
        public static blockWorldSwitch: string;
        public static statusDynamic: string;
        public static codes: Packages.arc.struct.ObjectIntMap<string>;
        public static codeToName: Packages.arc.struct.IntMap<string>;
        public static fileTextFill: string;
        public static file: string;
        public static fileText: string;
        public static left: string;
        public static right: string;
        public static up: string;
        public static down: string;
        public static home: string;
        public static ok: string;
        public static image: string;
        public static star: string;
        public static resize: string;
        public static wrench: string;
        public static githubSquare: string;
        public static fileImage: string;
        public static add: string;
        public static edit: string;
        public static chartBar: string;
        public static planeOutline: string;
        public static filter: string;
        public static folder: string;
        public static steam: string;
        public static downOpen: string;
        public static leftOpen: string;
        public static upOpen: string;
        public static map: string;
        public static rotate: string;
        public static play: string;
        public static pause: string;
        public static list: string;
        public static cancel: string;
        public static move: string;
        public static terminal: string;
        public static undo: string;
        public static redo: string;
        public static info: string;
        public static infoCircle: string;
        public static rightOpenOut: string;
        public static rightOpen: string;
        public static waves: string;
        public static filters: string;
        public static layers: string;
        public static eraser: string;
        public static bookOpen: string;
        public static grid: string;
        public static flipX: string;
        public static flipY: string;
        public static diagonal: string;
        public static discord: string;
        public static box: string;
        public static redditAlien: string;
        public static github: string;
        public static googleplay: string;
        public static android: string;
        public static trello: string;
        public static logic: string;
        public static distribution: string;
        public static hammer: string;
        public static save: string;
        public static link: string;
        public static itchio: string;
        public static line: string;
        public static admin: string;
        public static spray1: string;
        public static crafting: string;
        public static fill: string;
        public static paste: string;
        public static effect: string;
        public static book: string;
        public static liquid: string;
        public static host: string;
        public static production: string;
        public static exit: string;
        public static modePvp: string;
        public static modeAttack: string;
        public static refresh1: string;
        public static none: string;
        public static pencil: string;
        public static refresh: string;
        public static modeSurvival: string;
        public static commandRally: string;
        public static units: string;
        public static commandAttack: string;
        public static trash: string;
        public static chat: string;
        public static turret: string;
        public static players: string;
        public static editor: string;
        public static copy: string;
        public static tree: string;
        public static lockOpen: string;
        public static pick: string;
        public static export: string;
        public static download: string;
        public static upload: string;
        public static settings: string;
        public static spray: string;
        public static zoom: string;
        public static powerOld: string;
        public static power: string;
        public static menu: string;
        public static lock: string;
        public static eye: string;
        public static eyeOff: string;
        public static warning: string;
        public static terrain: string;
        public static defense: string;
        public static planet: string;
        public static all: string;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class Indicator extends java.lang.Object {
        public static bitMaskPos: Packages.long;
        public static bitMaskTime: Packages.long;
        public static get(
          _pos: number,
          _time: number,
        ): Packages.long;
        public static pos(
          _indicator: Packages.long,
          _value: number,
        ): Packages.long;
        public static pos(
          _indicator: Packages.long,
        ): number;
        public static time(
          _indicator: Packages.long,
        ): number;
        public static time(
          _indicator: Packages.long,
          _value: number,
        ): Packages.long;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class InfoMessageCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public message: string;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class InfoPopupCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public message: string;
        public duration: number;
        public align: number;
        public top: number;
        public left: number;
        public bottom: number;
        public right: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class InfoPopupReliableCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public message: string;
        public duration: number;
        public align: number;
        public top: number;
        public left: number;
        public bottom: number;
        public right: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class InfoToastCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public message: string;
        public duration: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class KickCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public reason: string;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public getPriority(): number;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class KickCallPacket2 extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public reason: Packages.mindustry.net.Packets.KickReason;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public getPriority(): number;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class LabelCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public message: string;
        public duration: number;
        public worldx: number;
        public worldy: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class LabelReliableCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public message: string;
        public duration: number;
        public worldx: number;
        public worldy: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class LaunchCorec
        implements
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Timedc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Entityc
      {
        public update(): void;
        public in(_in: Packages.arc.util.Interval): void;
        public in(): Packages.arc.util.Interval;
        public block(
          _block: Packages.mindustry.world.Block,
        ): void;
        public block(): Packages.mindustry.world.Block;
        public cx(): number;
        public draw(): void;
        public cy(): number;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class LaunchCore
        extends java.lang.Object
        implements
          Packages.mindustry.gen.IndexableEntity__all,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Timedc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.LaunchCorec,
          Packages.mindustry.gen.IndexableEntity__draw
      {
        protected added: boolean;
        protected index__all: number;
        protected index__draw: number;
        public add(): void;
        public remove(): void;
        public toString(): string;
        public update(): void;
        public x(_x: number): void;
        public x(): number;
        public id(_id: number): void;
        public id(): number;
        public set(_x: number, _y: number): void;
        public set(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public in(_in: Packages.arc.util.Interval): void;
        public in(): Packages.arc.util.Interval;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public static create(): Packages.mindustry.gen.LaunchCore;
        public as<T>(): T | null;
        public y(_y: number): void;
        public y(): number;
        public block(): Packages.mindustry.world.Block;
        public block(
          _block: Packages.mindustry.world.Block,
        ): void;
        public time(): number;
        public time(_time: number): void;
        public self<
          T extends Packages.mindustry.gen.Entityc,
        >(): T | null;
        public cx(): number;
        public getX(): number;
        public getY(): number;
        public trns(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public trns(_x: number, _y: number): void;
        public draw(): void;
        public cy(): number;
        public fin(): number;
        public afterRead(): void;
        public isLocal(): boolean;
        public isAdded(): boolean;
        public tileOn(): Packages.mindustry.world.Tile;
        public isRemote(): boolean;
        public onSolid(): boolean;
        public classId(): number;
        public setIndex__all(_index: number): void;
        public setIndex__draw(_index: number): void;
        public buildOn(): Packages.mindustry.gen.Building;
        public serialize(): boolean;
        public clipSize(): number;
        public tileX(): number;
        public tileY(): number;
        public blockOn(): Packages.mindustry.world.Block;
        public floorOn(): Packages.mindustry.world.blocks.environment.Floor;
        public afterAllRead(): void;
        public lifetime(_lifetime: number): void;
        public lifetime(): number;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class LaunchPayloadc
        implements
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Timedc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Teamc
      {
        public remove(): void;
        public update(): void;
        public in(_in: Packages.arc.util.Interval): void;
        public in(): Packages.arc.util.Interval;
        public cx(): number;
        public draw(): void;
        public cy(): number;
        public stacks(): Packages.arc.struct.Seq<Packages.mindustry._type.ItemStack>;
        public stacks(
          _stacks: Packages.arc.struct.Seq<Packages.mindustry._type.ItemStack>,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class LaunchPayload
        extends java.lang.Object
        implements
          Packages.mindustry.gen.IndexableEntity__all,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Timedc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.LaunchPayloadc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.IndexableEntity__draw
      {
        protected added: boolean;
        protected index__all: number;
        protected index__draw: number;
        public add(): void;
        public remove(): void;
        public toString(): string;
        public update(): void;
        public x(_x: number): void;
        public x(): number;
        public id(): number;
        public id(_id: number): void;
        public set(_x: number, _y: number): void;
        public set(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public in(_in: Packages.arc.util.Interval): void;
        public in(): Packages.arc.util.Interval;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public static create(): Packages.mindustry.gen.LaunchPayload;
        public as<T>(): T | null;
        public y(_y: number): void;
        public y(): number;
        public time(_time: number): void;
        public time(): number;
        public self<
          T extends Packages.mindustry.gen.Entityc,
        >(): T | null;
        public cx(): number;
        public getX(): number;
        public getY(): number;
        public trns(_x: number, _y: number): void;
        public trns(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public draw(): void;
        public cy(): number;
        public fin(): number;
        public team(): Packages.mindustry.game.Team;
        public team(
          _team: Packages.mindustry.game.Team,
        ): void;
        public afterRead(): void;
        public core(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public isLocal(): boolean;
        public isAdded(): boolean;
        public tileOn(): Packages.mindustry.world.Tile;
        public closestCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public inFogTo(
          _viewer: Packages.mindustry.game.Team,
        ): boolean;
        public isRemote(): boolean;
        public onSolid(): boolean;
        public classId(): number;
        public setIndex__all(_index: number): void;
        public setIndex__draw(_index: number): void;
        public buildOn(): Packages.mindustry.gen.Building;
        public closestEnemyCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public cheating(): boolean;
        public serialize(): boolean;
        public clipSize(): number;
        public tileX(): number;
        public tileY(): number;
        public blockOn(): Packages.mindustry.world.Block;
        public floorOn(): Packages.mindustry.world.blocks.environment.Floor;
        public afterAllRead(): void;
        public stacks(
          _stacks: Packages.arc.struct.Seq<Packages.mindustry._type.ItemStack>,
        ): void;
        public stacks(): Packages.arc.struct.Seq<Packages.mindustry._type.ItemStack>;
        public lifetime(_lifetime: number): void;
        public lifetime(): number;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class LegsUnit
        extends Packages.mindustry.gen.Unit
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.Legsc,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public static hitDuration: number;
        protected static straightVec: Packages.arc.math.geom.Vec2;
        protected static tmp1: Packages.arc.math.geom.Vec2;
        protected static tmp2: Packages.arc.math.geom.Vec2;
        public static warpDst: number;
        protected added: boolean;
        protected applied: Packages.arc.struct.Bits;
        protected buildCounter: number;
        protected lastActive: Packages.mindustry.entities.units.BuildPlan;
        protected lastSize: number;
        protected resupplyTime: number;
        private rotation_LAST_: number;
        private rotation_TARGET_: number;
        protected statuses: Packages.arc.struct.Seq<Packages.mindustry.entities.units.StatusEntry>;
        protected wasFlying: boolean;
        protected wasHealed: boolean;
        protected wasPlayer: boolean;
        private x_LAST_: number;
        private x_TARGET_: number;
        private y_LAST_: number;
        private y_TARGET_: number;
        public add(): void;
        public remove(): void;
        public toString(): string;
        public update(): void;
        public apply(
          _effect: Packages.mindustry._type.StatusEffect,
        ): void;
        public apply(
          _effect: Packages.mindustry._type.StatusEffect,
          _duration: number,
        ): void;
        public count(): number;
        public bounds(): number;
        public set(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public set(_x: number, _y: number): void;
        public set(
          _def: Packages.mindustry._type.UnitType,
          _controller: Packages.mindustry.entities.units.UnitController,
        ): void;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public destroy(): void;
        public cap(): number;
        public static create(): Packages.mindustry.gen.LegsUnit;
        public as<T>(): T | null;
        public command(): Packages.mindustry.ai._types.CommandAI;
        public display(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public range(): number;
        public self<
          T extends Packages.mindustry.gen.Entityc,
        >(): T | null;
        public inRange(
          _other: Packages.arc.math.geom.Position,
        ): boolean;
        public move(_v: Packages.arc.math.geom.Vec2): void;
        public move(_cx: number, _cy: number): void;
        public getDuration(
          _effect: Packages.mindustry._type.StatusEffect,
        ): number;
        public item(): Packages.mindustry._type.Item;
        public isValid(): boolean;
        public getX(): number;
        public getY(): number;
        public approach(
          _vector: Packages.arc.math.geom.Vec2,
        ): void;
        public interpolate(): void;
        public trns(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public trns(_x: number, _y: number): void;
        public speed(): number;
        public draw(): void;
        public controller(
          _next: Packages.mindustry.entities.units.UnitController,
        ): void;
        public controller(): Packages.mindustry.entities.units.UnitController;
        public icon(): Packages.arc.graphics.g2d.TextureRegion;
        public lookAt(_angle: number): void;
        public lookAt(_x: number, _y: number): void;
        public lookAt(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public hitbox(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public totalLength(): number;
        public totalLength(_totalLength: number): void;
        public afterRead(): void;
        public core(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public canBuild(): boolean;
        public isPlayer(): boolean;
        public isLocal(): boolean;
        public isAdded(): boolean;
        public tileOn(): Packages.mindustry.world.Tile;
        public hitSize(): number;
        public closestCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public aim(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public aim(_x: number, _y: number): void;
        public controlWeapons(_rotateShoot: boolean): void;
        public controlWeapons(
          _rotate: boolean,
          _shoot: boolean,
        ): void;
        public inFogTo(
          _viewer: Packages.mindustry.game.Team,
        ): boolean;
        public afterSync(): void;
        public resetController(): void;
        public isRemote(): boolean;
        public snapInterpolation(): void;
        public onSolid(): boolean;
        public isFlying(): boolean;
        public canLand(): boolean;
        public classId(): number;
        public buildOn(): Packages.mindustry.gen.Building;
        public isSyncHidden(
          _player: Packages.mindustry.gen.Player,
        ): boolean;
        public damage(
          _amount: number,
          _withEffect: boolean,
        ): void;
        public damage(_amount: number): void;
        public sense(
          _sensor: Packages.mindustry.logic.LAccess,
        ): number;
        public sense(
          _content: Packages.mindustry.ctype.Content,
        ): number;
        public damageContinuous(_amount: number): void;
        public closestEnemyCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public getPlayer(): Packages.mindustry.gen.Player;
        public damagePierce(_amount: number): void;
        public damagePierce(
          _amount: number,
          _withEffect: boolean,
        ): void;
        public damaged(): boolean;
        public healthf(): number;
        public clampHealth(): void;
        public heal(): void;
        public heal(_amount: number): void;
        public cheating(): boolean;
        public itemCapacity(): number;
        public serialize(): boolean;
        public clipSize(): number;
        public tileX(): number;
        public tileY(): number;
        public blockOn(): Packages.mindustry.world.Block;
        public floorOn(): Packages.mindustry.world.blocks.environment.Floor;
        public afterAllRead(): void;
        public handleSyncHidden(): void;
        public readSync(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public readSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public snapSync(): void;
        public writeSync(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public writeSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public killed(): void;
        public displayable(): boolean;
        public isCommandable(): boolean;
        public isPathImpassable(
          _tileX: number,
          _tileY: number,
        ): boolean;
        public checkTarget(
          _targetAir: boolean,
          _targetGround: boolean,
        ): boolean;
        public isBoss(): boolean;
        public collision(
          _other: Packages.mindustry.gen.Hitboxc,
          _x: number,
          _y: number,
        ): void;
        public senseObject(
          _sensor: Packages.mindustry.logic.LAccess,
        ): any;
        public damageContinuousPierce(
          _amount: number,
        ): void;
        public healFract(_amount: number): void;
        public kill(): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: any,
        ): void;
        public setProp(
          _content: Packages.mindustry.ctype.UnlockableContent,
          _value: number,
        ): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: number,
        ): void;
        public targetable(
          _targeter: Packages.mindustry.game.Team,
        ): boolean;
        public drawPlan(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _alpha: number,
        ): void;
        public isAI(): boolean;
        public isEnemy(): boolean;
        public mining(): boolean;
        public baseRotation(_baseRotation: number): void;
        public baseRotation(): number;
        public canDrown(): boolean;
        public emitWalkSound(): boolean;
        public isGrounded(): boolean;
        public floorSpeedMultiplier(): number;
        public drownFloor(): Packages.mindustry.world.blocks.environment.Floor;
        public landed(): void;
        public moveAt(
          _vector: Packages.arc.math.geom.Vec2,
          _acceleration: number,
        ): void;
        public moveAt(
          _vector: Packages.arc.math.geom.Vec2,
        ): void;
        public updateDrowning(): void;
        public wobble(): void;
        public collides(
          _other: Packages.mindustry.gen.Hitboxc,
        ): boolean;
        public deltaAngle(): number;
        public deltaLen(): number;
        public getCollisions(
          _consumer: Packages.arc.func.Cons<
            Packages.arc.math.geom.QuadTree<any>
          >,
        ): void;
        public hitboxTile(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public updateLastPosition(): void;
        public solidity(): Packages.mindustry.entities.EntityCollisions.SolidPred;
        public canPassOn(): boolean;
        public canPass(
          _tileX: number,
          _tileY: number,
        ): boolean;
        public moving(): boolean;
        public velAddNet(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public velAddNet(_vx: number, _vy: number): void;
        public buildPlan(): Packages.mindustry.entities.units.BuildPlan;
        public acceptsItem(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public hasItem(): boolean;
        public maxAccepted(
          _item: Packages.mindustry._type.Item,
        ): number;
        public addItem(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): void;
        public addItem(
          _item: Packages.mindustry._type.Item,
        ): void;
        public clearItem(): void;
        public shouldSkip(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _core: Packages.mindustry.gen.Building,
        ): boolean;
        public addBuild(
          _place: Packages.mindustry.entities.units.BuildPlan,
        ): void;
        public addBuild(
          _place: Packages.mindustry.entities.units.BuildPlan,
          _tail: boolean,
        ): void;
        public clearBuilding(): void;
        public drawBuildPlans(): void;
        public isBuilding(): boolean;
        public activelyBuilding(): boolean;
        public drawBuilding(): void;
        public drawBuildingBeam(
          _px: number,
          _py: number,
        ): void;
        public drawPlanTop(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _alpha: number,
        ): void;
        public removeBuild(
          _x: number,
          _y: number,
          _breaking: boolean,
        ): void;
        public updateBuildLogic(): void;
        public validatePlans(): void;
        public applyDynamicStatus(): Packages.mindustry.entities.units.StatusEntry;
        public unapply(
          _effect: Packages.mindustry._type.StatusEffect,
        ): void;
        public statusDamageMultiplier(
          _damageMultiplier: number,
        ): void;
        public statusReloadMultiplier(
          _reloadMultiplier: number,
        ): void;
        public statusArmor(_armor: number): void;
        public statusBuildSpeed(_buildSpeed: number): void;
        public statusDrag(_drag: number): void;
        public statusMaxHealth(_health: number): void;
        public statusSpeed(_speed: number): void;
        public statusColor(): Packages.arc.graphics.Color;
        public statusBits(): Packages.arc.struct.Bits;
        public hasEffect(
          _effect: Packages.mindustry._type.StatusEffect,
        ): boolean;
        public isImmune(
          _effect: Packages.mindustry._type.StatusEffect,
        ): boolean;
        public clearStatuses(): void;
        public canMine(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public canMine(): boolean;
        public offloadImmediately(): boolean;
        public validMine(
          _tile: Packages.mindustry.world.Tile,
          _checkDst: boolean,
        ): boolean;
        public validMine(
          _tile: Packages.mindustry.world.Tile,
        ): boolean;
        public getMineResult(
          _tile: Packages.mindustry.world.Tile,
        ): Packages.mindustry._type.Item;
        public mass(): number;
        public impulse(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public impulse(_x: number, _y: number): void;
        public impulseNet(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public rawDamage(_amount: number): void;
        public physicSize(): number;
        public getControllerName(): string;
        public pathType(): number;
        public collisionLayer(): number;
        public prefRotation(): number;
        public unloaded(): void;
        public movePref(
          _movement: Packages.arc.math.geom.Vec2,
        ): void;
        public canShoot(): boolean;
        public canTarget(
          _other: Packages.mindustry.gen.Unit,
        ): boolean;
        public hasWeapons(): boolean;
        public hittable(): boolean;
        public aimLook(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public aimLook(_x: number, _y: number): void;
        public rotateMove(
          _vec: Packages.arc.math.geom.Vec2,
        ): void;
        public updateBoosting(_boost: boolean): void;
        public isRotate(): boolean;
        public ammof(): number;
        public setWeaponRotation(_rotation: number): void;
        public setupWeapons(
          _def: Packages.mindustry._type.UnitType,
        ): void;
        public legOffset(
          _out: Packages.arc.math.geom.Vec2,
          _index: number,
        ): Packages.arc.math.geom.Vec2;
        public legs(
          _legs: Packages.mindustry.entities.Leg[],
        ): void;
        public legs():
          | Packages.mindustry.entities.Leg[]
          | null;
        public lastDeepFloor(): Packages.mindustry.world.blocks.environment.Floor;
        public lastDeepFloor(
          _lastDeepFloor: Packages.mindustry.world.blocks.environment.Floor,
        ): void;
        public legAngle(_index: number): number;
        public curMoveOffset(
          _curMoveOffset: Packages.arc.math.geom.Vec2,
        ): void;
        public curMoveOffset(): Packages.arc.math.geom.Vec2;
        public defaultLegAngle(_index: number): number;
        public moveSpace(): number;
        public moveSpace(_moveSpace: number): void;
        public resetLegs(_legLength: number): void;
        public resetLegs(): void;
        public setType(
          _type: Packages.mindustry._type.UnitType,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class LegsUnitLegacyArkyid
        extends Packages.mindustry.gen.LegsUnit
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.Legsc,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public static create(): Packages.mindustry.gen.LegsUnitLegacyArkyid;
        public classId(): number;
        public serialize(): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class LegsUnitLegacySpiroct
        extends Packages.mindustry.gen.LegsUnit
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.Legsc,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public static create(): Packages.mindustry.gen.LegsUnitLegacySpiroct;
        public classId(): number;
        public serialize(): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class LegsUnitLegacyToxopid
        extends Packages.mindustry.gen.LegsUnit
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.Legsc,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public static create(): Packages.mindustry.gen.LegsUnitLegacyToxopid;
        public classId(): number;
        public serialize(): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class LogicExplosionCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public team: Packages.mindustry.game.Team;
        public x: number;
        public y: number;
        public radius: number;
        public damage: number;
        public air: boolean;
        public ground: boolean;
        public pierce: boolean;
        public effect: boolean;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class LogicIO extends java.lang.Object {
        public static allStatements: Packages.arc.struct.Seq<
          Packages.arc.func.Prov<Packages.mindustry.logic.LStatement>
        >;
        public static write(
          _obj: any,
          _out: Packages.java.lang.StringBuilder,
        ): void;
        public static read(
          _tokens: string[],
          _length: number,
        ): Packages.mindustry.logic.LStatement;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class MechUnit
        extends Packages.mindustry.gen.Unit
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Mechc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.ElevationMovec,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public static hitDuration: number;
        protected static tmp1: Packages.arc.math.geom.Vec2;
        protected static tmp2: Packages.arc.math.geom.Vec2;
        public static warpDst: number;
        protected added: boolean;
        protected applied: Packages.arc.struct.Bits;
        private baseRotation_LAST_: number;
        private baseRotation_TARGET_: number;
        protected buildCounter: number;
        protected lastActive: Packages.mindustry.entities.units.BuildPlan;
        protected lastSize: number;
        protected resupplyTime: number;
        private rotation_LAST_: number;
        private rotation_TARGET_: number;
        protected statuses: Packages.arc.struct.Seq<Packages.mindustry.entities.units.StatusEntry>;
        protected walked: boolean;
        protected wasFlying: boolean;
        protected wasHealed: boolean;
        protected wasPlayer: boolean;
        private x_LAST_: number;
        private x_TARGET_: number;
        private y_LAST_: number;
        private y_TARGET_: number;
        public add(): void;
        public remove(): void;
        public toString(): string;
        public update(): void;
        public apply(
          _effect: Packages.mindustry._type.StatusEffect,
          _duration: number,
        ): void;
        public apply(
          _effect: Packages.mindustry._type.StatusEffect,
        ): void;
        public count(): number;
        public bounds(): number;
        public set(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public set(
          _def: Packages.mindustry._type.UnitType,
          _controller: Packages.mindustry.entities.units.UnitController,
        ): void;
        public set(_x: number, _y: number): void;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public destroy(): void;
        public cap(): number;
        public static create(): Packages.mindustry.gen.MechUnit;
        public as<T>(): T | null;
        public command(): Packages.mindustry.ai._types.CommandAI;
        public display(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public range(): number;
        public self<
          T extends Packages.mindustry.gen.Entityc,
        >(): T | null;
        public inRange(
          _other: Packages.arc.math.geom.Position,
        ): boolean;
        public move(_v: Packages.arc.math.geom.Vec2): void;
        public move(_cx: number, _cy: number): void;
        public getDuration(
          _effect: Packages.mindustry._type.StatusEffect,
        ): number;
        public item(): Packages.mindustry._type.Item;
        public isValid(): boolean;
        public getX(): number;
        public getY(): number;
        public approach(
          _vector: Packages.arc.math.geom.Vec2,
        ): void;
        public interpolate(): void;
        public trns(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public trns(_x: number, _y: number): void;
        public speed(): number;
        public draw(): void;
        public controller(): Packages.mindustry.entities.units.UnitController;
        public controller(
          _next: Packages.mindustry.entities.units.UnitController,
        ): void;
        public icon(): Packages.arc.graphics.g2d.TextureRegion;
        public lookAt(_x: number, _y: number): void;
        public lookAt(_angle: number): void;
        public lookAt(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public hitbox(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public afterRead(): void;
        public core(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public canBuild(): boolean;
        public isPlayer(): boolean;
        public isLocal(): boolean;
        public isAdded(): boolean;
        public tileOn(): Packages.mindustry.world.Tile;
        public hitSize(): number;
        public closestCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public aim(_x: number, _y: number): void;
        public aim(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public controlWeapons(_rotateShoot: boolean): void;
        public controlWeapons(
          _rotate: boolean,
          _shoot: boolean,
        ): void;
        public inFogTo(
          _viewer: Packages.mindustry.game.Team,
        ): boolean;
        public afterSync(): void;
        public resetController(): void;
        public isRemote(): boolean;
        public snapInterpolation(): void;
        public onSolid(): boolean;
        public isFlying(): boolean;
        public canLand(): boolean;
        public classId(): number;
        public buildOn(): Packages.mindustry.gen.Building;
        public isSyncHidden(
          _player: Packages.mindustry.gen.Player,
        ): boolean;
        public damage(
          _amount: number,
          _withEffect: boolean,
        ): void;
        public damage(_amount: number): void;
        public sense(
          _sensor: Packages.mindustry.logic.LAccess,
        ): number;
        public sense(
          _content: Packages.mindustry.ctype.Content,
        ): number;
        public damageContinuous(_amount: number): void;
        public closestEnemyCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public getPlayer(): Packages.mindustry.gen.Player;
        public damagePierce(_amount: number): void;
        public damagePierce(
          _amount: number,
          _withEffect: boolean,
        ): void;
        public damaged(): boolean;
        public healthf(): number;
        public clampHealth(): void;
        public heal(_amount: number): void;
        public heal(): void;
        public cheating(): boolean;
        public itemCapacity(): number;
        public serialize(): boolean;
        public clipSize(): number;
        public tileX(): number;
        public tileY(): number;
        public blockOn(): Packages.mindustry.world.Block;
        public floorOn(): Packages.mindustry.world.blocks.environment.Floor;
        public afterAllRead(): void;
        public handleSyncHidden(): void;
        public readSync(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public readSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public snapSync(): void;
        public writeSync(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public writeSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public killed(): void;
        public displayable(): boolean;
        public isCommandable(): boolean;
        public isPathImpassable(
          _tileX: number,
          _tileY: number,
        ): boolean;
        public checkTarget(
          _targetAir: boolean,
          _targetGround: boolean,
        ): boolean;
        public isBoss(): boolean;
        public collision(
          _other: Packages.mindustry.gen.Hitboxc,
          _x: number,
          _y: number,
        ): void;
        public senseObject(
          _sensor: Packages.mindustry.logic.LAccess,
        ): any;
        public damageContinuousPierce(
          _amount: number,
        ): void;
        public healFract(_amount: number): void;
        public kill(): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: number,
        ): void;
        public setProp(
          _content: Packages.mindustry.ctype.UnlockableContent,
          _value: number,
        ): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: any,
        ): void;
        public targetable(
          _targeter: Packages.mindustry.game.Team,
        ): boolean;
        public drawPlan(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _alpha: number,
        ): void;
        public isAI(): boolean;
        public isEnemy(): boolean;
        public mining(): boolean;
        public baseRotation(): number;
        public baseRotation(_baseRotation: number): void;
        public canDrown(): boolean;
        public emitWalkSound(): boolean;
        public isGrounded(): boolean;
        public floorSpeedMultiplier(): number;
        public drownFloor(): Packages.mindustry.world.blocks.environment.Floor;
        public landed(): void;
        public moveAt(
          _vector: Packages.arc.math.geom.Vec2,
        ): void;
        public moveAt(
          _vector: Packages.arc.math.geom.Vec2,
          _acceleration: number,
        ): void;
        public updateDrowning(): void;
        public wobble(): void;
        public collides(
          _other: Packages.mindustry.gen.Hitboxc,
        ): boolean;
        public deltaAngle(): number;
        public deltaLen(): number;
        public getCollisions(
          _consumer: Packages.arc.func.Cons<
            Packages.arc.math.geom.QuadTree<any>
          >,
        ): void;
        public hitboxTile(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public updateLastPosition(): void;
        public solidity(): Packages.mindustry.entities.EntityCollisions.SolidPred;
        public canPassOn(): boolean;
        public canPass(
          _tileX: number,
          _tileY: number,
        ): boolean;
        public moving(): boolean;
        public velAddNet(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public velAddNet(_vx: number, _vy: number): void;
        public buildPlan(): Packages.mindustry.entities.units.BuildPlan;
        public acceptsItem(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public hasItem(): boolean;
        public maxAccepted(
          _item: Packages.mindustry._type.Item,
        ): number;
        public addItem(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): void;
        public addItem(
          _item: Packages.mindustry._type.Item,
        ): void;
        public clearItem(): void;
        public shouldSkip(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _core: Packages.mindustry.gen.Building,
        ): boolean;
        public addBuild(
          _place: Packages.mindustry.entities.units.BuildPlan,
          _tail: boolean,
        ): void;
        public addBuild(
          _place: Packages.mindustry.entities.units.BuildPlan,
        ): void;
        public clearBuilding(): void;
        public drawBuildPlans(): void;
        public isBuilding(): boolean;
        public activelyBuilding(): boolean;
        public drawBuilding(): void;
        public drawBuildingBeam(
          _px: number,
          _py: number,
        ): void;
        public drawPlanTop(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _alpha: number,
        ): void;
        public removeBuild(
          _x: number,
          _y: number,
          _breaking: boolean,
        ): void;
        public updateBuildLogic(): void;
        public validatePlans(): void;
        public applyDynamicStatus(): Packages.mindustry.entities.units.StatusEntry;
        public unapply(
          _effect: Packages.mindustry._type.StatusEffect,
        ): void;
        public statusDamageMultiplier(
          _damageMultiplier: number,
        ): void;
        public statusReloadMultiplier(
          _reloadMultiplier: number,
        ): void;
        public statusArmor(_armor: number): void;
        public statusBuildSpeed(_buildSpeed: number): void;
        public statusDrag(_drag: number): void;
        public statusMaxHealth(_health: number): void;
        public statusSpeed(_speed: number): void;
        public statusColor(): Packages.arc.graphics.Color;
        public statusBits(): Packages.arc.struct.Bits;
        public hasEffect(
          _effect: Packages.mindustry._type.StatusEffect,
        ): boolean;
        public isImmune(
          _effect: Packages.mindustry._type.StatusEffect,
        ): boolean;
        public clearStatuses(): void;
        public canMine(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public canMine(): boolean;
        public offloadImmediately(): boolean;
        public validMine(
          _tile: Packages.mindustry.world.Tile,
        ): boolean;
        public validMine(
          _tile: Packages.mindustry.world.Tile,
          _checkDst: boolean,
        ): boolean;
        public getMineResult(
          _tile: Packages.mindustry.world.Tile,
        ): Packages.mindustry._type.Item;
        public mass(): number;
        public impulse(_x: number, _y: number): void;
        public impulse(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public impulseNet(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public rawDamage(_amount: number): void;
        public physicSize(): number;
        public getControllerName(): string;
        public pathType(): number;
        public collisionLayer(): number;
        public prefRotation(): number;
        public unloaded(): void;
        public movePref(
          _movement: Packages.arc.math.geom.Vec2,
        ): void;
        public canShoot(): boolean;
        public canTarget(
          _other: Packages.mindustry.gen.Unit,
        ): boolean;
        public hasWeapons(): boolean;
        public hittable(): boolean;
        public aimLook(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public aimLook(_x: number, _y: number): void;
        public rotateMove(
          _vec: Packages.arc.math.geom.Vec2,
        ): void;
        public updateBoosting(_boost: boolean): void;
        public isRotate(): boolean;
        public ammof(): number;
        public setWeaponRotation(_rotation: number): void;
        public setupWeapons(
          _def: Packages.mindustry._type.UnitType,
        ): void;
        public walkExtend(_scaled: boolean): number;
        public walkExtension(): number;
        public walkExtension(_walkExtension: number): void;
        public walkTime(): number;
        public walkTime(_walkTime: number): void;
        public setType(
          _type: Packages.mindustry._type.UnitType,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class MechUnitLegacyNova
        extends Packages.mindustry.gen.MechUnit
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Mechc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.ElevationMovec,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public static create(): Packages.mindustry.gen.MechUnitLegacyNova;
        public classId(): number;
        public serialize(): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class MechUnitLegacyPulsar
        extends Packages.mindustry.gen.MechUnit
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Mechc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.ElevationMovec,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public static create(): Packages.mindustry.gen.MechUnitLegacyPulsar;
        public classId(): number;
        public serialize(): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class MechUnitLegacyQuasar
        extends Packages.mindustry.gen.MechUnit
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Mechc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.ElevationMovec,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public static create(): Packages.mindustry.gen.MechUnitLegacyQuasar;
        public classId(): number;
        public serialize(): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class MenuCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public menuId: number;
        public title: string;
        public message: string;
        public options: string[][];
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class MenuChooseCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public player: Packages.mindustry.gen.Player;
        public menuId: number;
        public option: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class Musics extends java.lang.Object {
        public static boss1: Packages.arc.audio.Music;
        public static boss2: Packages.arc.audio.Music;
        public static coreLaunch: Packages.arc.audio.Music;
        public static editor: Packages.arc.audio.Music;
        public static fine: Packages.arc.audio.Music;
        public static game1: Packages.arc.audio.Music;
        public static game2: Packages.arc.audio.Music;
        public static game3: Packages.arc.audio.Music;
        public static game4: Packages.arc.audio.Music;
        public static game5: Packages.arc.audio.Music;
        public static game6: Packages.arc.audio.Music;
        public static game7: Packages.arc.audio.Music;
        public static game8: Packages.arc.audio.Music;
        public static game9: Packages.arc.audio.Music;
        public static land: Packages.arc.audio.Music;
        public static launch: Packages.arc.audio.Music;
        public static menu: Packages.arc.audio.Music;
        public static load(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class OpenURICallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public uri: string;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class PackTile extends java.lang.Object {
        public static bitMaskBlock: Packages.long;
        public static bitMaskFloor: Packages.long;
        public static bitMaskOverlay: Packages.long;
        public static get(
          _block: Packages.short,
          _floor: Packages.short,
          _overlay: Packages.short,
        ): Packages.long;
        public static floor(
          _packtile: Packages.long,
          _value: Packages.short,
        ): Packages.long;
        public static floor(
          _packtile: Packages.long,
        ): Packages.short;
        public static block(
          _packtile: Packages.long,
          _value: Packages.short,
        ): Packages.long;
        public static block(
          _packtile: Packages.long,
        ): Packages.short;
        public static overlay(
          _packtile: Packages.long,
          _value: Packages.short,
        ): Packages.long;
        public static overlay(
          _packtile: Packages.long,
        ): Packages.short;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class PathTile extends java.lang.Object {
        public static bitMaskHealth: number;
        public static bitMaskTeam: number;
        public static bitMaskSolid: number;
        public static bitMaskLiquid: number;
        public static bitMaskLegSolid: number;
        public static bitMaskNearLiquid: number;
        public static bitMaskNearGround: number;
        public static bitMaskNearSolid: number;
        public static bitMaskNearLegSolid: number;
        public static bitMaskDeep: number;
        public static bitMaskDamages: number;
        public static bitMaskAllDeep: number;
        public static bitMaskTeamPassable: number;
        public static get(
          _health: number,
          _team: number,
          _solid: boolean,
          _liquid: boolean,
          _legSolid: boolean,
          _nearLiquid: boolean,
          _nearGround: boolean,
          _nearSolid: boolean,
          _nearLegSolid: boolean,
          _deep: boolean,
          _damages: boolean,
          _allDeep: boolean,
          _teamPassable: boolean,
        ): number;
        public static solid(
          _pathtile: number,
          _value: boolean,
        ): number;
        public static solid(_pathtile: number): boolean;
        public static team(
          _pathtile: number,
          _value: number,
        ): number;
        public static team(_pathtile: number): number;
        public static health(_pathtile: number): number;
        public static health(
          _pathtile: number,
          _value: number,
        ): number;
        public static legSolid(
          _pathtile: number,
          _value: boolean,
        ): number;
        public static legSolid(_pathtile: number): boolean;
        public static liquid(
          _pathtile: number,
          _value: boolean,
        ): number;
        public static liquid(_pathtile: number): boolean;
        public static teamPassable(
          _pathtile: number,
          _value: boolean,
        ): number;
        public static teamPassable(
          _pathtile: number,
        ): boolean;
        public static nearGround(
          _pathtile: number,
          _value: boolean,
        ): number;
        public static nearGround(
          _pathtile: number,
        ): boolean;
        public static nearSolid(_pathtile: number): boolean;
        public static nearSolid(
          _pathtile: number,
          _value: boolean,
        ): number;
        public static deep(
          _pathtile: number,
          _value: boolean,
        ): number;
        public static deep(_pathtile: number): boolean;
        public static damages(_pathtile: number): boolean;
        public static damages(
          _pathtile: number,
          _value: boolean,
        ): number;
        public static allDeep(_pathtile: number): boolean;
        public static allDeep(
          _pathtile: number,
          _value: boolean,
        ): number;
        public static nearLiquid(
          _pathtile: number,
          _value: boolean,
        ): number;
        public static nearLiquid(
          _pathtile: number,
        ): boolean;
        public static nearLegSolid(
          _pathtile: number,
        ): boolean;
        public static nearLegSolid(
          _pathtile: number,
          _value: boolean,
        ): number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class PayloadDroppedCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public unit: Packages.mindustry.gen.Unit;
        public x: number;
        public y: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class PayloadUnit
        extends Packages.mindustry.gen.Unit
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Payloadc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public static hitDuration: number;
        protected static tmp1: Packages.arc.math.geom.Vec2;
        protected static tmp2: Packages.arc.math.geom.Vec2;
        public static warpDst: number;
        protected added: boolean;
        protected applied: Packages.arc.struct.Bits;
        protected buildCounter: number;
        protected lastActive: Packages.mindustry.entities.units.BuildPlan;
        protected lastSize: number;
        protected payloadPower?: Packages.mindustry.world.blocks.power.PowerGraph;
        protected resupplyTime: number;
        private rotation_LAST_: number;
        private rotation_TARGET_: number;
        protected statuses: Packages.arc.struct.Seq<Packages.mindustry.entities.units.StatusEntry>;
        protected wasFlying: boolean;
        protected wasHealed: boolean;
        protected wasPlayer: boolean;
        private x_LAST_: number;
        private x_TARGET_: number;
        private y_LAST_: number;
        private y_TARGET_: number;
        public add(): void;
        public remove(): void;
        public toString(): string;
        public update(): void;
        public apply(
          _effect: Packages.mindustry._type.StatusEffect,
        ): void;
        public apply(
          _effect: Packages.mindustry._type.StatusEffect,
          _duration: number,
        ): void;
        public count(): number;
        public bounds(): number;
        public set(_x: number, _y: number): void;
        public set(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public set(
          _def: Packages.mindustry._type.UnitType,
          _controller: Packages.mindustry.entities.units.UnitController,
        ): void;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public destroy(): void;
        public cap(): number;
        public static create(): Packages.mindustry.gen.PayloadUnit;
        public as<T>(): T | null;
        public command(): Packages.mindustry.ai._types.CommandAI;
        public display(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public range(): number;
        public self<
          T extends Packages.mindustry.gen.Entityc,
        >(): T | null;
        public inRange(
          _other: Packages.arc.math.geom.Position,
        ): boolean;
        public move(_v: Packages.arc.math.geom.Vec2): void;
        public move(_cx: number, _cy: number): void;
        public getDuration(
          _effect: Packages.mindustry._type.StatusEffect,
        ): number;
        public item(): Packages.mindustry._type.Item;
        public isValid(): boolean;
        public getX(): number;
        public getY(): number;
        public approach(
          _vector: Packages.arc.math.geom.Vec2,
        ): void;
        public interpolate(): void;
        public trns(_x: number, _y: number): void;
        public trns(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public speed(): number;
        public draw(): void;
        public controller(
          _next: Packages.mindustry.entities.units.UnitController,
        ): void;
        public controller(): Packages.mindustry.entities.units.UnitController;
        public icon(): Packages.arc.graphics.g2d.TextureRegion;
        public lookAt(_angle: number): void;
        public lookAt(_x: number, _y: number): void;
        public lookAt(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public hitbox(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public afterRead(): void;
        public core(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public canBuild(): boolean;
        public isPlayer(): boolean;
        public isLocal(): boolean;
        public isAdded(): boolean;
        public tileOn(): Packages.mindustry.world.Tile;
        public hitSize(): number;
        public closestCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public aim(_x: number, _y: number): void;
        public aim(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public controlWeapons(
          _rotate: boolean,
          _shoot: boolean,
        ): void;
        public controlWeapons(_rotateShoot: boolean): void;
        public inFogTo(
          _viewer: Packages.mindustry.game.Team,
        ): boolean;
        public afterSync(): void;
        public resetController(): void;
        public isRemote(): boolean;
        public snapInterpolation(): void;
        public onSolid(): boolean;
        public isFlying(): boolean;
        public canLand(): boolean;
        public classId(): number;
        public buildOn(): Packages.mindustry.gen.Building;
        public isSyncHidden(
          _player: Packages.mindustry.gen.Player,
        ): boolean;
        public damage(_amount: number): void;
        public damage(
          _amount: number,
          _withEffect: boolean,
        ): void;
        public sense(
          _sensor: Packages.mindustry.logic.LAccess,
        ): number;
        public sense(
          _content: Packages.mindustry.ctype.Content,
        ): number;
        public damageContinuous(_amount: number): void;
        public closestEnemyCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public getPlayer(): Packages.mindustry.gen.Player;
        public damagePierce(
          _amount: number,
          _withEffect: boolean,
        ): void;
        public damagePierce(_amount: number): void;
        public damaged(): boolean;
        public healthf(): number;
        public clampHealth(): void;
        public heal(): void;
        public heal(_amount: number): void;
        public cheating(): boolean;
        public itemCapacity(): number;
        public serialize(): boolean;
        public clipSize(): number;
        public tileX(): number;
        public tileY(): number;
        public blockOn(): Packages.mindustry.world.Block;
        public floorOn(): Packages.mindustry.world.blocks.environment.Floor;
        public afterAllRead(): void;
        public handleSyncHidden(): void;
        public readSync(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public readSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public snapSync(): void;
        public writeSync(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public writeSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public killed(): void;
        public displayable(): boolean;
        public isCommandable(): boolean;
        public isPathImpassable(
          _tileX: number,
          _tileY: number,
        ): boolean;
        public checkTarget(
          _targetAir: boolean,
          _targetGround: boolean,
        ): boolean;
        public payloads(): Packages.arc.struct.Seq<Packages.mindustry.world.blocks.payloads.Payload>;
        public payloads(
          _payloads: Packages.arc.struct.Seq<Packages.mindustry.world.blocks.payloads.Payload>,
        ): void;
        public isBoss(): boolean;
        public canPickup(
          _build: Packages.mindustry.gen.Building,
        ): boolean;
        public canPickup(
          _unit: Packages.mindustry.gen.Unit,
        ): boolean;
        public collision(
          _other: Packages.mindustry.gen.Hitboxc,
          _x: number,
          _y: number,
        ): void;
        public senseObject(
          _sensor: Packages.mindustry.logic.LAccess,
        ): any;
        public damageContinuousPierce(
          _amount: number,
        ): void;
        public healFract(_amount: number): void;
        public kill(): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: number,
        ): void;
        public setProp(
          _content: Packages.mindustry.ctype.UnlockableContent,
          _value: number,
        ): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: any,
        ): void;
        public targetable(
          _targeter: Packages.mindustry.game.Team,
        ): boolean;
        public drawPlan(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _alpha: number,
        ): void;
        public isAI(): boolean;
        public isEnemy(): boolean;
        public mining(): boolean;
        public canDrown(): boolean;
        public emitWalkSound(): boolean;
        public isGrounded(): boolean;
        public floorSpeedMultiplier(): number;
        public drownFloor(): Packages.mindustry.world.blocks.environment.Floor;
        public landed(): void;
        public moveAt(
          _vector: Packages.arc.math.geom.Vec2,
        ): void;
        public moveAt(
          _vector: Packages.arc.math.geom.Vec2,
          _acceleration: number,
        ): void;
        public updateDrowning(): void;
        public wobble(): void;
        public collides(
          _other: Packages.mindustry.gen.Hitboxc,
        ): boolean;
        public deltaAngle(): number;
        public deltaLen(): number;
        public getCollisions(
          _consumer: Packages.arc.func.Cons<
            Packages.arc.math.geom.QuadTree<any>
          >,
        ): void;
        public hitboxTile(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public updateLastPosition(): void;
        public solidity(): Packages.mindustry.entities.EntityCollisions.SolidPred;
        public canPassOn(): boolean;
        public canPass(
          _tileX: number,
          _tileY: number,
        ): boolean;
        public moving(): boolean;
        public velAddNet(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public velAddNet(_vx: number, _vy: number): void;
        public buildPlan(): Packages.mindustry.entities.units.BuildPlan;
        public acceptsItem(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public hasItem(): boolean;
        public maxAccepted(
          _item: Packages.mindustry._type.Item,
        ): number;
        public addItem(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): void;
        public addItem(
          _item: Packages.mindustry._type.Item,
        ): void;
        public clearItem(): void;
        public shouldSkip(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _core: Packages.mindustry.gen.Building,
        ): boolean;
        public addBuild(
          _place: Packages.mindustry.entities.units.BuildPlan,
          _tail: boolean,
        ): void;
        public addBuild(
          _place: Packages.mindustry.entities.units.BuildPlan,
        ): void;
        public clearBuilding(): void;
        public drawBuildPlans(): void;
        public isBuilding(): boolean;
        public activelyBuilding(): boolean;
        public drawBuilding(): void;
        public drawBuildingBeam(
          _px: number,
          _py: number,
        ): void;
        public drawPlanTop(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _alpha: number,
        ): void;
        public removeBuild(
          _x: number,
          _y: number,
          _breaking: boolean,
        ): void;
        public updateBuildLogic(): void;
        public validatePlans(): void;
        public applyDynamicStatus(): Packages.mindustry.entities.units.StatusEntry;
        public unapply(
          _effect: Packages.mindustry._type.StatusEffect,
        ): void;
        public statusDamageMultiplier(
          _damageMultiplier: number,
        ): void;
        public statusReloadMultiplier(
          _reloadMultiplier: number,
        ): void;
        public statusArmor(_armor: number): void;
        public statusBuildSpeed(_buildSpeed: number): void;
        public statusDrag(_drag: number): void;
        public statusMaxHealth(_health: number): void;
        public statusSpeed(_speed: number): void;
        public statusColor(): Packages.arc.graphics.Color;
        public statusBits(): Packages.arc.struct.Bits;
        public hasEffect(
          _effect: Packages.mindustry._type.StatusEffect,
        ): boolean;
        public isImmune(
          _effect: Packages.mindustry._type.StatusEffect,
        ): boolean;
        public clearStatuses(): void;
        public canMine(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public canMine(): boolean;
        public offloadImmediately(): boolean;
        public validMine(
          _tile: Packages.mindustry.world.Tile,
        ): boolean;
        public validMine(
          _tile: Packages.mindustry.world.Tile,
          _checkDst: boolean,
        ): boolean;
        public getMineResult(
          _tile: Packages.mindustry.world.Tile,
        ): Packages.mindustry._type.Item;
        public mass(): number;
        public impulse(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public impulse(_x: number, _y: number): void;
        public impulseNet(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public rawDamage(_amount: number): void;
        public physicSize(): number;
        public getControllerName(): string;
        public pathType(): number;
        public collisionLayer(): number;
        public prefRotation(): number;
        public unloaded(): void;
        public movePref(
          _movement: Packages.arc.math.geom.Vec2,
        ): void;
        public canShoot(): boolean;
        public canTarget(
          _other: Packages.mindustry.gen.Unit,
        ): boolean;
        public hasWeapons(): boolean;
        public hittable(): boolean;
        public aimLook(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public aimLook(_x: number, _y: number): void;
        public rotateMove(
          _vec: Packages.arc.math.geom.Vec2,
        ): void;
        public updateBoosting(_boost: boolean): void;
        public isRotate(): boolean;
        public ammof(): number;
        public setWeaponRotation(_rotation: number): void;
        public setupWeapons(
          _def: Packages.mindustry._type.UnitType,
        ): void;
        public pickup(
          _tile: Packages.mindustry.gen.Building,
        ): void;
        public pickup(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public hasPayload(): boolean;
        public payloadUsed(): number;
        public contentInfo(
          _table: Packages.arc.scene.ui.layout.Table,
          _itemSize: number,
          _width: number,
        ): void;
        public dropLastPayload(): boolean;
        public dropBlock(
          _payload: Packages.mindustry.world.blocks.payloads.BuildPayload,
        ): boolean;
        public canPickupPayload(
          _pay: Packages.mindustry.world.blocks.payloads.Payload,
        ): boolean;
        public dropUnit(
          _payload: Packages.mindustry.world.blocks.payloads.UnitPayload,
        ): boolean;
        public tryDropPayload(
          _payload: Packages.mindustry.world.blocks.payloads.Payload,
        ): boolean;
        public addPayload(
          _load: Packages.mindustry.world.blocks.payloads.Payload,
        ): void;
        public setType(
          _type: Packages.mindustry._type.UnitType,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class PayloadUnitLegacyOct
        extends Packages.mindustry.gen.PayloadUnit
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Payloadc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public static create(): Packages.mindustry.gen.PayloadUnitLegacyOct;
        public classId(): number;
        public serialize(): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class PayloadUnitLegacyQuad
        extends Packages.mindustry.gen.PayloadUnit
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Payloadc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public static create(): Packages.mindustry.gen.PayloadUnitLegacyQuad;
        public classId(): number;
        public serialize(): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class PickedBuildPayloadCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public unit: Packages.mindustry.gen.Unit;
        public build: Packages.mindustry.gen.Building;
        public onGround: boolean;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class PickedUnitPayloadCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public unit: Packages.mindustry.gen.Unit;
        public target: Packages.mindustry.gen.Unit;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class PingCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public time: Packages.long;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class PingResponseCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public time: Packages.long;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class PlayerDisconnectCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public playerid: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class PlayerSpawnCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public tile: Packages.mindustry.world.Tile;
        public player: Packages.mindustry.gen.Player;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class RemoveQueueBlockCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public x: number;
        public y: number;
        public breaking: boolean;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class RemoveTileCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public tile: Packages.mindustry.world.Tile;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class RemoveWorldLabelCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public id: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class RequestBuildPayloadCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public player: Packages.mindustry.gen.Player;
        public build: Packages.mindustry.gen.Building;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class RequestDebugStatusCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class RequestDropPayloadCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public player: Packages.mindustry.gen.Player;
        public x: number;
        public y: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class RequestItemCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public player: Packages.mindustry.gen.Player;
        public build: Packages.mindustry.gen.Building;
        public item: Packages.mindustry._type.Item;
        public amount: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class RequestUnitPayloadCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public player: Packages.mindustry.gen.Player;
        public target: Packages.mindustry.gen.Unit;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class ResearchedCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public content: Packages.mindustry.ctype.Content;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class RotateBlockCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public player: Packages.mindustry.gen.Player;
        public build: Packages.mindustry.gen.Building;
        public direction: boolean;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class SectorCaptureCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class SendChatMessageCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public message: string;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class SendMessageCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public message: string;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class SendMessageCallPacket2 extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public message: string;
        public unformatted: string;
        public playersender: Packages.mindustry.gen.Player;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class ServerPacketReliableCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public type: string;
        public contents: string;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class ServerPacketUnreliableCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public type: string;
        public contents: string;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class SetCameraPositionCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public x: number;
        public y: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class SetFloorCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public tile: Packages.mindustry.world.Tile;
        public floor: Packages.mindustry.world.Block;
        public overlay: Packages.mindustry.world.Block;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class SetHudTextCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public message: string;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class SetHudTextReliableCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public message: string;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class SetItemCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public build: Packages.mindustry.gen.Building;
        public item: Packages.mindustry._type.Item;
        public amount: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class SetMapAreaCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public x: number;
        public y: number;
        public w: number;
        public h: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class SetObjectivesCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public executor: Packages.mindustry.game.MapObjectives;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class SetOverlayCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public tile: Packages.mindustry.world.Tile;
        public overlay: Packages.mindustry.world.Block;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class SetPlayerTeamEditorCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public player: Packages.mindustry.gen.Player;
        public team: Packages.mindustry.game.Team;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class SetPositionCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public x: number;
        public y: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class SetRulesCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public rules: Packages.mindustry.game.Rules;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class SetTeamCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public build: Packages.mindustry.gen.Building;
        public team: Packages.mindustry.game.Team;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class SetTileCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public tile: Packages.mindustry.world.Tile;
        public block: Packages.mindustry.world.Block;
        public team: Packages.mindustry.game.Team;
        public rotation: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class SetUnitCommandCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public player: Packages.mindustry.gen.Player;
        public unitIds: number[];
        public command: Packages.mindustry.ai.UnitCommand;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class SoundAtCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public sound: Packages.arc.audio.Sound;
        public x: number;
        public y: number;
        public volume: number;
        public pitch: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class SoundCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public sound: Packages.arc.audio.Sound;
        public volume: number;
        public pitch: number;
        public pan: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class Sounds extends java.lang.Object {
        private static idToSound: Packages.arc.struct.IntMap<any>;
        private static soundToId: Packages.arc.struct.ObjectIntMap<any>;
        public static artillery: Packages.arc.audio.Sound;
        public static back: Packages.arc.audio.Sound;
        public static bang: Packages.arc.audio.Sound;
        public static beam: Packages.arc.audio.Sound;
        public static bigshot: Packages.arc.audio.Sound;
        public static bioLoop: Packages.arc.audio.Sound;
        public static blaster: Packages.arc.audio.Sound;
        public static bolt: Packages.arc.audio.Sound;
        public static boom: Packages.arc.audio.Sound;
        public static breaks: Packages.arc.audio.Sound;
        public static build: Packages.arc.audio.Sound;
        public static buttonClick: Packages.arc.audio.Sound;
        public static cannon: Packages.arc.audio.Sound;
        public static chatMessage: Packages.arc.audio.Sound;
        public static click: Packages.arc.audio.Sound;
        public static combustion: Packages.arc.audio.Sound;
        public static conveyor: Packages.arc.audio.Sound;
        public static corexplode: Packages.arc.audio.Sound;
        public static cutter: Packages.arc.audio.Sound;
        public static door: Packages.arc.audio.Sound;
        public static drill: Packages.arc.audio.Sound;
        public static drillCharge: Packages.arc.audio.Sound;
        public static drillImpact: Packages.arc.audio.Sound;
        public static dullExplosion: Packages.arc.audio.Sound;
        public static electricHum: Packages.arc.audio.Sound;
        public static explosion: Packages.arc.audio.Sound;
        public static explosionbig: Packages.arc.audio.Sound;
        public static extractLoop: Packages.arc.audio.Sound;
        public static fire: Packages.arc.audio.Sound;
        public static flame: Packages.arc.audio.Sound;
        public static flame2: Packages.arc.audio.Sound;
        public static flux: Packages.arc.audio.Sound;
        public static glow: Packages.arc.audio.Sound;
        public static grinding: Packages.arc.audio.Sound;
        public static hum: Packages.arc.audio.Sound;
        public static largeCannon: Packages.arc.audio.Sound;
        public static largeExplosion: Packages.arc.audio.Sound;
        public static laser: Packages.arc.audio.Sound;
        public static laserbeam: Packages.arc.audio.Sound;
        public static laserbig: Packages.arc.audio.Sound;
        public static laserblast: Packages.arc.audio.Sound;
        public static lasercharge: Packages.arc.audio.Sound;
        public static lasercharge2: Packages.arc.audio.Sound;
        public static lasershoot: Packages.arc.audio.Sound;
        public static machine: Packages.arc.audio.Sound;
        public static malignShoot: Packages.arc.audio.Sound;
        public static mediumCannon: Packages.arc.audio.Sound;
        public static message: Packages.arc.audio.Sound;
        public static mineDeploy: Packages.arc.audio.Sound;
        public static minebeam: Packages.arc.audio.Sound;
        public static missile: Packages.arc.audio.Sound;
        public static missileLarge: Packages.arc.audio.Sound;
        public static missileLaunch: Packages.arc.audio.Sound;
        public static missileSmall: Packages.arc.audio.Sound;
        public static missileTrail: Packages.arc.audio.Sound;
        public static mud: Packages.arc.audio.Sound;
        public static noammo: Packages.arc.audio.Sound;
        public static pew: Packages.arc.audio.Sound;
        public static place: Packages.arc.audio.Sound;
        public static plantBreak: Packages.arc.audio.Sound;
        public static plasmaboom: Packages.arc.audio.Sound;
        public static plasmadrop: Packages.arc.audio.Sound;
        public static press: Packages.arc.audio.Sound;
        public static pulse: Packages.arc.audio.Sound;
        public static pulseBlast: Packages.arc.audio.Sound;
        public static railgun: Packages.arc.audio.Sound;
        public static rain: Packages.arc.audio.Sound;
        public static release: Packages.arc.audio.Sound;
        public static respawn: Packages.arc.audio.Sound;
        public static respawning: Packages.arc.audio.Sound;
        public static rockBreak: Packages.arc.audio.Sound;
        public static sap: Packages.arc.audio.Sound;
        public static shield: Packages.arc.audio.Sound;
        public static shockBlast: Packages.arc.audio.Sound;
        public static shoot: Packages.arc.audio.Sound;
        public static shootAlt: Packages.arc.audio.Sound;
        public static shootAltLong: Packages.arc.audio.Sound;
        public static shootBig: Packages.arc.audio.Sound;
        public static shootSmite: Packages.arc.audio.Sound;
        public static shootSnap: Packages.arc.audio.Sound;
        public static shotgun: Packages.arc.audio.Sound;
        public static smelter: Packages.arc.audio.Sound;
        public static spark: Packages.arc.audio.Sound;
        public static spellLoop: Packages.arc.audio.Sound;
        public static splash: Packages.arc.audio.Sound;
        public static spray: Packages.arc.audio.Sound;
        public static steam: Packages.arc.audio.Sound;
        public static swish: Packages.arc.audio.Sound;
        public static techloop: Packages.arc.audio.Sound;
        public static thruster: Packages.arc.audio.Sound;
        public static titanExplosion: Packages.arc.audio.Sound;
        public static torch: Packages.arc.audio.Sound;
        public static tractorbeam: Packages.arc.audio.Sound;
        public static unlock: Packages.arc.audio.Sound;
        public static wave: Packages.arc.audio.Sound;
        public static wind: Packages.arc.audio.Sound;
        public static wind2: Packages.arc.audio.Sound;
        public static wind3: Packages.arc.audio.Sound;
        public static windhowl: Packages.arc.audio.Sound;
        public static none: Packages.arc.audio.Sound;
        public static load(): void;
        public static getSoundId(
          _sound: Packages.arc.audio.Sound,
        ): number;
        public static getSound(
          _id: number,
        ): Packages.arc.audio.Sound;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class SpawnEffectCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public x: number;
        public y: number;
        public rotation: number;
        public u: Packages.mindustry._type.UnitType;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class StateSnapshotCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public waveTime: number;
        public wave: number;
        public enemies: number;
        public paused: boolean;
        public gameOver: boolean;
        public timeData: number;
        public tps: string;
        public rand0: Packages.long;
        public rand1: Packages.long;
        public coreData: string[];
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public getPriority(): number;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class TakeItemsCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public build: Packages.mindustry.gen.Building;
        public item: Packages.mindustry._type.Item;
        public amount: number;
        public to: Packages.mindustry.gen.Unit;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class TankUnit
        extends Packages.mindustry.gen.Unit
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.ElevationMovec,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Tankc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public static hitDuration: number;
        protected static tmp1: Packages.arc.math.geom.Vec2;
        protected static tmp2: Packages.arc.math.geom.Vec2;
        public static warpDst: number;
        protected added: boolean;
        protected applied: Packages.arc.struct.Bits;
        protected buildCounter: number;
        protected lastActive: Packages.mindustry.entities.units.BuildPlan;
        protected lastSize: number;
        protected lastSlowdown: number;
        protected resupplyTime: number;
        private rotation_LAST_: number;
        private rotation_TARGET_: number;
        protected statuses: Packages.arc.struct.Seq<Packages.mindustry.entities.units.StatusEntry>;
        protected treadEffectTime: number;
        protected wasFlying: boolean;
        protected wasHealed: boolean;
        protected wasPlayer: boolean;
        private x_LAST_: number;
        private x_TARGET_: number;
        private y_LAST_: number;
        private y_TARGET_: number;
        public add(): void;
        public remove(): void;
        public toString(): string;
        public update(): void;
        public apply(
          _effect: Packages.mindustry._type.StatusEffect,
        ): void;
        public apply(
          _effect: Packages.mindustry._type.StatusEffect,
          _duration: number,
        ): void;
        public count(): number;
        public bounds(): number;
        public set(_x: number, _y: number): void;
        public set(
          _def: Packages.mindustry._type.UnitType,
          _controller: Packages.mindustry.entities.units.UnitController,
        ): void;
        public set(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public destroy(): void;
        public cap(): number;
        public static create(): Packages.mindustry.gen.TankUnit;
        public as<T>(): T | null;
        public command(): Packages.mindustry.ai._types.CommandAI;
        public display(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public range(): number;
        public self<
          T extends Packages.mindustry.gen.Entityc,
        >(): T | null;
        public inRange(
          _other: Packages.arc.math.geom.Position,
        ): boolean;
        public move(_cx: number, _cy: number): void;
        public move(_v: Packages.arc.math.geom.Vec2): void;
        public getDuration(
          _effect: Packages.mindustry._type.StatusEffect,
        ): number;
        public item(): Packages.mindustry._type.Item;
        public isValid(): boolean;
        public getX(): number;
        public getY(): number;
        public approach(
          _vector: Packages.arc.math.geom.Vec2,
        ): void;
        public interpolate(): void;
        public trns(_x: number, _y: number): void;
        public trns(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public speed(): number;
        public draw(): void;
        public controller(): Packages.mindustry.entities.units.UnitController;
        public controller(
          _next: Packages.mindustry.entities.units.UnitController,
        ): void;
        public icon(): Packages.arc.graphics.g2d.TextureRegion;
        public lookAt(_x: number, _y: number): void;
        public lookAt(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public lookAt(_angle: number): void;
        public hitbox(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public afterRead(): void;
        public core(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public canBuild(): boolean;
        public isPlayer(): boolean;
        public isLocal(): boolean;
        public isAdded(): boolean;
        public tileOn(): Packages.mindustry.world.Tile;
        public hitSize(): number;
        public closestCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public aim(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public aim(_x: number, _y: number): void;
        public controlWeapons(
          _rotate: boolean,
          _shoot: boolean,
        ): void;
        public controlWeapons(_rotateShoot: boolean): void;
        public inFogTo(
          _viewer: Packages.mindustry.game.Team,
        ): boolean;
        public afterSync(): void;
        public resetController(): void;
        public isRemote(): boolean;
        public snapInterpolation(): void;
        public onSolid(): boolean;
        public isFlying(): boolean;
        public canLand(): boolean;
        public classId(): number;
        public buildOn(): Packages.mindustry.gen.Building;
        public isSyncHidden(
          _player: Packages.mindustry.gen.Player,
        ): boolean;
        public damage(_amount: number): void;
        public damage(
          _amount: number,
          _withEffect: boolean,
        ): void;
        public sense(
          _content: Packages.mindustry.ctype.Content,
        ): number;
        public sense(
          _sensor: Packages.mindustry.logic.LAccess,
        ): number;
        public damageContinuous(_amount: number): void;
        public closestEnemyCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public getPlayer(): Packages.mindustry.gen.Player;
        public damagePierce(_amount: number): void;
        public damagePierce(
          _amount: number,
          _withEffect: boolean,
        ): void;
        public damaged(): boolean;
        public healthf(): number;
        public clampHealth(): void;
        public heal(): void;
        public heal(_amount: number): void;
        public cheating(): boolean;
        public itemCapacity(): number;
        public serialize(): boolean;
        public clipSize(): number;
        public tileX(): number;
        public tileY(): number;
        public blockOn(): Packages.mindustry.world.Block;
        public floorOn(): Packages.mindustry.world.blocks.environment.Floor;
        public afterAllRead(): void;
        public handleSyncHidden(): void;
        public readSync(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public readSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public snapSync(): void;
        public writeSync(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public writeSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public killed(): void;
        public displayable(): boolean;
        public isCommandable(): boolean;
        public isPathImpassable(
          _tileX: number,
          _tileY: number,
        ): boolean;
        public checkTarget(
          _targetAir: boolean,
          _targetGround: boolean,
        ): boolean;
        public isBoss(): boolean;
        public collision(
          _other: Packages.mindustry.gen.Hitboxc,
          _x: number,
          _y: number,
        ): void;
        public senseObject(
          _sensor: Packages.mindustry.logic.LAccess,
        ): any;
        public damageContinuousPierce(
          _amount: number,
        ): void;
        public healFract(_amount: number): void;
        public kill(): void;
        public setProp(
          _content: Packages.mindustry.ctype.UnlockableContent,
          _value: number,
        ): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: any,
        ): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: number,
        ): void;
        public targetable(
          _targeter: Packages.mindustry.game.Team,
        ): boolean;
        public drawPlan(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _alpha: number,
        ): void;
        public isAI(): boolean;
        public isEnemy(): boolean;
        public mining(): boolean;
        public canDrown(): boolean;
        public emitWalkSound(): boolean;
        public isGrounded(): boolean;
        public floorSpeedMultiplier(): number;
        public drownFloor(): Packages.mindustry.world.blocks.environment.Floor;
        public landed(): void;
        public moveAt(
          _vector: Packages.arc.math.geom.Vec2,
        ): void;
        public moveAt(
          _vector: Packages.arc.math.geom.Vec2,
          _acceleration: number,
        ): void;
        public updateDrowning(): void;
        public wobble(): void;
        public collides(
          _other: Packages.mindustry.gen.Hitboxc,
        ): boolean;
        public deltaAngle(): number;
        public deltaLen(): number;
        public getCollisions(
          _consumer: Packages.arc.func.Cons<
            Packages.arc.math.geom.QuadTree<any>
          >,
        ): void;
        public hitboxTile(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public updateLastPosition(): void;
        public solidity(): Packages.mindustry.entities.EntityCollisions.SolidPred;
        public canPassOn(): boolean;
        public canPass(
          _tileX: number,
          _tileY: number,
        ): boolean;
        public moving(): boolean;
        public velAddNet(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public velAddNet(_vx: number, _vy: number): void;
        public buildPlan(): Packages.mindustry.entities.units.BuildPlan;
        public acceptsItem(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public hasItem(): boolean;
        public maxAccepted(
          _item: Packages.mindustry._type.Item,
        ): number;
        public addItem(
          _item: Packages.mindustry._type.Item,
        ): void;
        public addItem(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): void;
        public clearItem(): void;
        public shouldSkip(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _core: Packages.mindustry.gen.Building,
        ): boolean;
        public addBuild(
          _place: Packages.mindustry.entities.units.BuildPlan,
        ): void;
        public addBuild(
          _place: Packages.mindustry.entities.units.BuildPlan,
          _tail: boolean,
        ): void;
        public clearBuilding(): void;
        public drawBuildPlans(): void;
        public isBuilding(): boolean;
        public activelyBuilding(): boolean;
        public drawBuilding(): void;
        public drawBuildingBeam(
          _px: number,
          _py: number,
        ): void;
        public drawPlanTop(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _alpha: number,
        ): void;
        public removeBuild(
          _x: number,
          _y: number,
          _breaking: boolean,
        ): void;
        public updateBuildLogic(): void;
        public validatePlans(): void;
        public applyDynamicStatus(): Packages.mindustry.entities.units.StatusEntry;
        public unapply(
          _effect: Packages.mindustry._type.StatusEffect,
        ): void;
        public statusDamageMultiplier(
          _damageMultiplier: number,
        ): void;
        public statusReloadMultiplier(
          _reloadMultiplier: number,
        ): void;
        public statusArmor(_armor: number): void;
        public statusBuildSpeed(_buildSpeed: number): void;
        public statusDrag(_drag: number): void;
        public statusMaxHealth(_health: number): void;
        public statusSpeed(_speed: number): void;
        public statusColor(): Packages.arc.graphics.Color;
        public statusBits(): Packages.arc.struct.Bits;
        public hasEffect(
          _effect: Packages.mindustry._type.StatusEffect,
        ): boolean;
        public isImmune(
          _effect: Packages.mindustry._type.StatusEffect,
        ): boolean;
        public clearStatuses(): void;
        public canMine(): boolean;
        public canMine(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public offloadImmediately(): boolean;
        public validMine(
          _tile: Packages.mindustry.world.Tile,
        ): boolean;
        public validMine(
          _tile: Packages.mindustry.world.Tile,
          _checkDst: boolean,
        ): boolean;
        public getMineResult(
          _tile: Packages.mindustry.world.Tile,
        ): Packages.mindustry._type.Item;
        public mass(): number;
        public impulse(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public impulse(_x: number, _y: number): void;
        public impulseNet(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public rawDamage(_amount: number): void;
        public physicSize(): number;
        public getControllerName(): string;
        public pathType(): number;
        public collisionLayer(): number;
        public prefRotation(): number;
        public unloaded(): void;
        public movePref(
          _movement: Packages.arc.math.geom.Vec2,
        ): void;
        public canShoot(): boolean;
        public canTarget(
          _other: Packages.mindustry.gen.Unit,
        ): boolean;
        public hasWeapons(): boolean;
        public hittable(): boolean;
        public aimLook(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public aimLook(_x: number, _y: number): void;
        public rotateMove(
          _vec: Packages.arc.math.geom.Vec2,
        ): void;
        public updateBoosting(_boost: boolean): void;
        public isRotate(): boolean;
        public ammof(): number;
        public setWeaponRotation(_rotation: number): void;
        public setupWeapons(
          _def: Packages.mindustry._type.UnitType,
        ): void;
        public treadTime(): number;
        public treadTime(_treadTime: number): void;
        public walked(): boolean;
        public walked(_walked: boolean): void;
        public setType(
          _type: Packages.mindustry._type.UnitType,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class Tex extends java.lang.Object {
        public static alphaBgLine: Packages.arc.scene.style.Drawable;
        public static alphaBg: Packages.arc.scene.style.Drawable;
        public static alphaaaa: Packages.arc.scene.style.Drawable;
        public static barTop: Packages.arc.scene.style.Drawable;
        public static bar: Packages.arc.scene.style.Drawable;
        public static buttonDisabled: Packages.arc.scene.style.Drawable;
        public static buttonDown: Packages.arc.scene.style.Drawable;
        public static buttonEdge1: Packages.arc.scene.style.Drawable;
        public static buttonEdge2: Packages.arc.scene.style.Drawable;
        public static buttonEdge3: Packages.arc.scene.style.Drawable;
        public static buttonEdge4: Packages.arc.scene.style.Drawable;
        public static buttonEdgeDown1: Packages.arc.scene.style.Drawable;
        public static buttonEdgeDown3: Packages.arc.scene.style.Drawable;
        public static buttonEdgeOver1: Packages.arc.scene.style.Drawable;
        public static buttonEdgeOver3: Packages.arc.scene.style.Drawable;
        public static buttonEdgeOver4: Packages.arc.scene.style.Drawable;
        public static buttonOver: Packages.arc.scene.style.Drawable;
        public static buttonRed: Packages.arc.scene.style.Drawable;
        public static buttonRightDisabled: Packages.arc.scene.style.Drawable;
        public static buttonRightDown: Packages.arc.scene.style.Drawable;
        public static buttonRightOver: Packages.arc.scene.style.Drawable;
        public static buttonRight: Packages.arc.scene.style.Drawable;
        public static buttonSelectTrans: Packages.arc.scene.style.Drawable;
        public static buttonSelect: Packages.arc.scene.style.Drawable;
        public static buttonSideLeftDown: Packages.arc.scene.style.Drawable;
        public static buttonSideLeftOver: Packages.arc.scene.style.Drawable;
        public static buttonSideLeft: Packages.arc.scene.style.Drawable;
        public static buttonSideRightDown: Packages.arc.scene.style.Drawable;
        public static buttonSideRightOver: Packages.arc.scene.style.Drawable;
        public static buttonSideRight: Packages.arc.scene.style.Drawable;
        public static buttonTrans: Packages.arc.scene.style.Drawable;
        public static button: Packages.arc.scene.style.Drawable;
        public static cat: Packages.arc.scene.style.Drawable;
        public static checkDisabled: Packages.arc.scene.style.Drawable;
        public static checkOff: Packages.arc.scene.style.Drawable;
        public static checkOnDisabled: Packages.arc.scene.style.Drawable;
        public static checkOnOver: Packages.arc.scene.style.Drawable;
        public static checkOn: Packages.arc.scene.style.Drawable;
        public static checkOver: Packages.arc.scene.style.Drawable;
        public static clear: Packages.arc.scene.style.Drawable;
        public static crater: Packages.arc.scene.style.Drawable;
        public static cursor: Packages.arc.scene.style.Drawable;
        public static discordBanner: Packages.arc.scene.style.Drawable;
        public static flatDownBase: Packages.arc.scene.style.Drawable;
        public static infoBanner: Packages.arc.scene.style.Drawable;
        public static inventory: Packages.arc.scene.style.Drawable;
        public static logicNode: Packages.arc.scene.style.Drawable;
        public static logo: Packages.arc.scene.style.Drawable;
        public static nomap: Packages.arc.scene.style.Drawable;
        public static pane2: Packages.arc.scene.style.Drawable;
        public static paneLeft: Packages.arc.scene.style.Drawable;
        public static paneRight: Packages.arc.scene.style.Drawable;
        public static paneSolid: Packages.arc.scene.style.Drawable;
        public static paneTop: Packages.arc.scene.style.Drawable;
        public static pane: Packages.arc.scene.style.Drawable;
        public static ranai: Packages.arc.scene.style.Drawable;
        public static scrollHorizontal: Packages.arc.scene.style.Drawable;
        public static scrollKnobHorizontalBlack: Packages.arc.scene.style.Drawable;
        public static scrollKnobVerticalBlack: Packages.arc.scene.style.Drawable;
        public static scrollKnobVerticalThin: Packages.arc.scene.style.Drawable;
        public static scroll: Packages.arc.scene.style.Drawable;
        public static selection: Packages.arc.scene.style.Drawable;
        public static sidelineOver: Packages.arc.scene.style.Drawable;
        public static sideline: Packages.arc.scene.style.Drawable;
        public static sliderBack: Packages.arc.scene.style.Drawable;
        public static sliderKnobDown: Packages.arc.scene.style.Drawable;
        public static sliderKnob: Packages.arc.scene.style.Drawable;
        public static sliderKnobOver: Packages.arc.scene.style.Drawable;
        public static slider: Packages.arc.scene.style.Drawable;
        public static underline2: Packages.arc.scene.style.Drawable;
        public static underlineDisabled: Packages.arc.scene.style.Drawable;
        public static underlineOver: Packages.arc.scene.style.Drawable;
        public static underlineRed: Packages.arc.scene.style.Drawable;
        public static underlineWhite: Packages.arc.scene.style.Drawable;
        public static underline: Packages.arc.scene.style.Drawable;
        public static wavepane: Packages.arc.scene.style.Drawable;
        public static whitePane: Packages.arc.scene.style.Drawable;
        public static whiteui: Packages.arc.scene.style.Drawable;
        public static windowEmpty: Packages.arc.scene.style.Drawable;
        public static load(): void;
        public static loadStyles(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class TextInputCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public textInputId: number;
        public title: string;
        public message: string;
        public textLength: number;
        public def: string;
        public numeric: boolean;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class TextInputResultCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public player: Packages.mindustry.gen.Player;
        public textInputId: number;
        public text: string;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class TileConfigCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public player: Packages.mindustry.gen.Player;
        public build: Packages.mindustry.gen.Building;
        public value: any;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class TileOp extends java.lang.Object {
        public static bitMaskX: Packages.long;
        public static bitMaskY: Packages.long;
        public static bitMaskType: Packages.long;
        public static bitMaskValue: Packages.long;
        public static get(
          _x: Packages.short,
          _y: Packages.short,
          _type: string,
          _value: Packages.short,
        ): Packages.long;
        public static type(_tileop: Packages.long): string;
        public static type(
          _tileop: Packages.long,
          _value: string,
        ): Packages.long;
        public static value(
          _tileop: Packages.long,
        ): Packages.short;
        public static value(
          _tileop: Packages.long,
          _value: Packages.short,
        ): Packages.long;
        public static x(
          _tileop: Packages.long,
          _value: Packages.short,
        ): Packages.long;
        public static x(
          _tileop: Packages.long,
        ): Packages.short;
        public static y(
          _tileop: Packages.long,
          _value: Packages.short,
        ): Packages.long;
        public static y(
          _tileop: Packages.long,
        ): Packages.short;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class TileTapCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public player: Packages.mindustry.gen.Player;
        public tile: Packages.mindustry.world.Tile;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class TimeItem extends java.lang.Object {
        public static bitMaskData: Packages.long;
        public static bitMaskItem: Packages.long;
        public static bitMaskTime: Packages.long;
        public static get(
          _data: Packages.short,
          _item: Packages.short,
          _time: number,
        ): Packages.long;
        public static data(
          _timeitem: Packages.long,
        ): Packages.short;
        public static data(
          _timeitem: Packages.long,
          _value: Packages.short,
        ): Packages.long;
        public static time(
          _timeitem: Packages.long,
          _value: number,
        ): Packages.long;
        public static time(
          _timeitem: Packages.long,
        ): number;
        public static item(
          _timeitem: Packages.long,
        ): Packages.short;
        public static item(
          _timeitem: Packages.long,
          _value: Packages.short,
        ): Packages.long;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class TimedKillc
        implements
          Packages.mindustry.gen.Posc,
          Packages.arc.math.Scaled,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public update(): void;
        public time(): number;
        public time(_time: number): void;
        public fin(): number;
        public lifetime(): number;
        public lifetime(_lifetime: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class TimedKillUnit
        extends Packages.mindustry.gen.Unit
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.TimedKillc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public static hitDuration: number;
        protected static tmp1: Packages.arc.math.geom.Vec2;
        protected static tmp2: Packages.arc.math.geom.Vec2;
        public static warpDst: number;
        protected added: boolean;
        protected applied: Packages.arc.struct.Bits;
        protected buildCounter: number;
        protected lastActive: Packages.mindustry.entities.units.BuildPlan;
        protected lastSize: number;
        protected resupplyTime: number;
        private rotation_LAST_: number;
        private rotation_TARGET_: number;
        protected statuses: Packages.arc.struct.Seq<Packages.mindustry.entities.units.StatusEntry>;
        protected wasFlying: boolean;
        protected wasHealed: boolean;
        protected wasPlayer: boolean;
        private x_LAST_: number;
        private x_TARGET_: number;
        private y_LAST_: number;
        private y_TARGET_: number;
        public add(): void;
        public remove(): void;
        public toString(): string;
        public update(): void;
        public apply(
          _effect: Packages.mindustry._type.StatusEffect,
          _duration: number,
        ): void;
        public apply(
          _effect: Packages.mindustry._type.StatusEffect,
        ): void;
        public count(): number;
        public bounds(): number;
        public set(
          _def: Packages.mindustry._type.UnitType,
          _controller: Packages.mindustry.entities.units.UnitController,
        ): void;
        public set(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public set(_x: number, _y: number): void;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public destroy(): void;
        public cap(): number;
        public static create(): Packages.mindustry.gen.TimedKillUnit;
        public as<T>(): T | null;
        public command(): Packages.mindustry.ai._types.CommandAI;
        public display(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public range(): number;
        public time(_time: number): void;
        public time(): number;
        public self<
          T extends Packages.mindustry.gen.Entityc,
        >(): T | null;
        public inRange(
          _other: Packages.arc.math.geom.Position,
        ): boolean;
        public move(_v: Packages.arc.math.geom.Vec2): void;
        public move(_cx: number, _cy: number): void;
        public getDuration(
          _effect: Packages.mindustry._type.StatusEffect,
        ): number;
        public item(): Packages.mindustry._type.Item;
        public isValid(): boolean;
        public getX(): number;
        public getY(): number;
        public approach(
          _vector: Packages.arc.math.geom.Vec2,
        ): void;
        public interpolate(): void;
        public trns(_x: number, _y: number): void;
        public trns(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public speed(): number;
        public draw(): void;
        public controller(
          _next: Packages.mindustry.entities.units.UnitController,
        ): void;
        public controller(): Packages.mindustry.entities.units.UnitController;
        public icon(): Packages.arc.graphics.g2d.TextureRegion;
        public fin(): number;
        public lookAt(_x: number, _y: number): void;
        public lookAt(_angle: number): void;
        public lookAt(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public hitbox(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public afterRead(): void;
        public core(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public canBuild(): boolean;
        public isPlayer(): boolean;
        public isLocal(): boolean;
        public isAdded(): boolean;
        public tileOn(): Packages.mindustry.world.Tile;
        public hitSize(): number;
        public closestCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public aim(_x: number, _y: number): void;
        public aim(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public controlWeapons(_rotateShoot: boolean): void;
        public controlWeapons(
          _rotate: boolean,
          _shoot: boolean,
        ): void;
        public inFogTo(
          _viewer: Packages.mindustry.game.Team,
        ): boolean;
        public afterSync(): void;
        public resetController(): void;
        public isRemote(): boolean;
        public snapInterpolation(): void;
        public onSolid(): boolean;
        public isFlying(): boolean;
        public canLand(): boolean;
        public classId(): number;
        public buildOn(): Packages.mindustry.gen.Building;
        public isSyncHidden(
          _player: Packages.mindustry.gen.Player,
        ): boolean;
        public damage(_amount: number): void;
        public damage(
          _amount: number,
          _withEffect: boolean,
        ): void;
        public sense(
          _sensor: Packages.mindustry.logic.LAccess,
        ): number;
        public sense(
          _content: Packages.mindustry.ctype.Content,
        ): number;
        public damageContinuous(_amount: number): void;
        public closestEnemyCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public getPlayer(): Packages.mindustry.gen.Player;
        public damagePierce(
          _amount: number,
          _withEffect: boolean,
        ): void;
        public damagePierce(_amount: number): void;
        public damaged(): boolean;
        public healthf(): number;
        public clampHealth(): void;
        public heal(): void;
        public heal(_amount: number): void;
        public cheating(): boolean;
        public itemCapacity(): number;
        public serialize(): boolean;
        public clipSize(): number;
        public tileX(): number;
        public tileY(): number;
        public blockOn(): Packages.mindustry.world.Block;
        public floorOn(): Packages.mindustry.world.blocks.environment.Floor;
        public afterAllRead(): void;
        public handleSyncHidden(): void;
        public readSync(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public readSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public snapSync(): void;
        public writeSync(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public writeSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public killed(): void;
        public displayable(): boolean;
        public isCommandable(): boolean;
        public isPathImpassable(
          _tileX: number,
          _tileY: number,
        ): boolean;
        public checkTarget(
          _targetAir: boolean,
          _targetGround: boolean,
        ): boolean;
        public isBoss(): boolean;
        public collision(
          _other: Packages.mindustry.gen.Hitboxc,
          _x: number,
          _y: number,
        ): void;
        public senseObject(
          _sensor: Packages.mindustry.logic.LAccess,
        ): any;
        public damageContinuousPierce(
          _amount: number,
        ): void;
        public healFract(_amount: number): void;
        public kill(): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: any,
        ): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: number,
        ): void;
        public setProp(
          _content: Packages.mindustry.ctype.UnlockableContent,
          _value: number,
        ): void;
        public targetable(
          _targeter: Packages.mindustry.game.Team,
        ): boolean;
        public drawPlan(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _alpha: number,
        ): void;
        public isAI(): boolean;
        public isEnemy(): boolean;
        public mining(): boolean;
        public lifetime(): number;
        public lifetime(_lifetime: number): void;
        public canDrown(): boolean;
        public emitWalkSound(): boolean;
        public isGrounded(): boolean;
        public floorSpeedMultiplier(): number;
        public drownFloor(): Packages.mindustry.world.blocks.environment.Floor;
        public landed(): void;
        public moveAt(
          _vector: Packages.arc.math.geom.Vec2,
          _acceleration: number,
        ): void;
        public moveAt(
          _vector: Packages.arc.math.geom.Vec2,
        ): void;
        public updateDrowning(): void;
        public wobble(): void;
        public collides(
          _other: Packages.mindustry.gen.Hitboxc,
        ): boolean;
        public deltaAngle(): number;
        public deltaLen(): number;
        public getCollisions(
          _consumer: Packages.arc.func.Cons<
            Packages.arc.math.geom.QuadTree<any>
          >,
        ): void;
        public hitboxTile(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public updateLastPosition(): void;
        public solidity(): Packages.mindustry.entities.EntityCollisions.SolidPred;
        public canPassOn(): boolean;
        public canPass(
          _tileX: number,
          _tileY: number,
        ): boolean;
        public moving(): boolean;
        public velAddNet(_vx: number, _vy: number): void;
        public velAddNet(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public buildPlan(): Packages.mindustry.entities.units.BuildPlan;
        public acceptsItem(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public hasItem(): boolean;
        public maxAccepted(
          _item: Packages.mindustry._type.Item,
        ): number;
        public addItem(
          _item: Packages.mindustry._type.Item,
        ): void;
        public addItem(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): void;
        public clearItem(): void;
        public shouldSkip(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _core: Packages.mindustry.gen.Building,
        ): boolean;
        public addBuild(
          _place: Packages.mindustry.entities.units.BuildPlan,
        ): void;
        public addBuild(
          _place: Packages.mindustry.entities.units.BuildPlan,
          _tail: boolean,
        ): void;
        public clearBuilding(): void;
        public drawBuildPlans(): void;
        public isBuilding(): boolean;
        public activelyBuilding(): boolean;
        public drawBuilding(): void;
        public drawBuildingBeam(
          _px: number,
          _py: number,
        ): void;
        public drawPlanTop(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _alpha: number,
        ): void;
        public removeBuild(
          _x: number,
          _y: number,
          _breaking: boolean,
        ): void;
        public updateBuildLogic(): void;
        public validatePlans(): void;
        public applyDynamicStatus(): Packages.mindustry.entities.units.StatusEntry;
        public unapply(
          _effect: Packages.mindustry._type.StatusEffect,
        ): void;
        public statusDamageMultiplier(
          _damageMultiplier: number,
        ): void;
        public statusReloadMultiplier(
          _reloadMultiplier: number,
        ): void;
        public statusArmor(_armor: number): void;
        public statusBuildSpeed(_buildSpeed: number): void;
        public statusDrag(_drag: number): void;
        public statusMaxHealth(_health: number): void;
        public statusSpeed(_speed: number): void;
        public statusColor(): Packages.arc.graphics.Color;
        public statusBits(): Packages.arc.struct.Bits;
        public hasEffect(
          _effect: Packages.mindustry._type.StatusEffect,
        ): boolean;
        public isImmune(
          _effect: Packages.mindustry._type.StatusEffect,
        ): boolean;
        public clearStatuses(): void;
        public canMine(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public canMine(): boolean;
        public offloadImmediately(): boolean;
        public validMine(
          _tile: Packages.mindustry.world.Tile,
          _checkDst: boolean,
        ): boolean;
        public validMine(
          _tile: Packages.mindustry.world.Tile,
        ): boolean;
        public getMineResult(
          _tile: Packages.mindustry.world.Tile,
        ): Packages.mindustry._type.Item;
        public mass(): number;
        public impulse(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public impulse(_x: number, _y: number): void;
        public impulseNet(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public rawDamage(_amount: number): void;
        public physicSize(): number;
        public getControllerName(): string;
        public pathType(): number;
        public collisionLayer(): number;
        public prefRotation(): number;
        public unloaded(): void;
        public movePref(
          _movement: Packages.arc.math.geom.Vec2,
        ): void;
        public canShoot(): boolean;
        public canTarget(
          _other: Packages.mindustry.gen.Unit,
        ): boolean;
        public hasWeapons(): boolean;
        public hittable(): boolean;
        public aimLook(_x: number, _y: number): void;
        public aimLook(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public rotateMove(
          _vec: Packages.arc.math.geom.Vec2,
        ): void;
        public updateBoosting(_boost: boolean): void;
        public isRotate(): boolean;
        public ammof(): number;
        public setWeaponRotation(_rotation: number): void;
        public setupWeapons(
          _def: Packages.mindustry._type.UnitType,
        ): void;
        public setType(
          _type: Packages.mindustry._type.UnitType,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class TraceInfoCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public player: Packages.mindustry.gen.Player;
        public info: Packages.mindustry.net.Administration.TraceInfo;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class TransferInventoryCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public player: Packages.mindustry.gen.Player;
        public build: Packages.mindustry.gen.Building;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class TransferItemEffectCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public item: Packages.mindustry._type.Item;
        public x: number;
        public y: number;
        public to: Packages.mindustry.gen.Itemsc;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class TransferItemToCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public unit: Packages.mindustry.gen.Unit;
        public item: Packages.mindustry._type.Item;
        public amount: number;
        public x: number;
        public y: number;
        public build: Packages.mindustry.gen.Building;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class TransferItemToUnitCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public item: Packages.mindustry._type.Item;
        public x: number;
        public y: number;
        public to: Packages.mindustry.gen.Itemsc;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class UnitBlockSpawnCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public tile: Packages.mindustry.world.Tile;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class UnitBuildingControlSelectCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public unit: Packages.mindustry.gen.Unit;
        public build: Packages.mindustry.gen.Building;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class UnitCapDeathCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public unit: Packages.mindustry.gen.Unit;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class UnitClearCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public player: Packages.mindustry.gen.Player;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class UnitControlCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public player: Packages.mindustry.gen.Player;
        public unit: Packages.mindustry.gen.Unit;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public handleServer(
          _con: Packages.mindustry.net.NetConnection,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class UnitDeathCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public uid: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class UnitDespawnCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public unit: Packages.mindustry.gen.Unit;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class UnitDestroyCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public uid: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class UnitEntity
        extends Packages.mindustry.gen.Unit
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public static hitDuration: number;
        protected static tmp1: Packages.arc.math.geom.Vec2;
        protected static tmp2: Packages.arc.math.geom.Vec2;
        public static warpDst: number;
        protected added: boolean;
        protected applied: Packages.arc.struct.Bits;
        protected buildCounter: number;
        protected lastActive: Packages.mindustry.entities.units.BuildPlan;
        protected lastSize: number;
        protected resupplyTime: number;
        private rotation_LAST_: number;
        private rotation_TARGET_: number;
        protected statuses: Packages.arc.struct.Seq<Packages.mindustry.entities.units.StatusEntry>;
        protected wasFlying: boolean;
        protected wasHealed: boolean;
        protected wasPlayer: boolean;
        private x_LAST_: number;
        private x_TARGET_: number;
        private y_LAST_: number;
        private y_TARGET_: number;
        public add(): void;
        public remove(): void;
        public toString(): string;
        public update(): void;
        public apply(
          _effect: Packages.mindustry._type.StatusEffect,
          _duration: number,
        ): void;
        public apply(
          _effect: Packages.mindustry._type.StatusEffect,
        ): void;
        public count(): number;
        public bounds(): number;
        public set(_x: number, _y: number): void;
        public set(
          _def: Packages.mindustry._type.UnitType,
          _controller: Packages.mindustry.entities.units.UnitController,
        ): void;
        public set(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public destroy(): void;
        public cap(): number;
        public static create(): Packages.mindustry.gen.UnitEntity;
        public as<T>(): T | null;
        public command(): Packages.mindustry.ai._types.CommandAI;
        public display(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public range(): number;
        public self<
          T extends Packages.mindustry.gen.Entityc,
        >(): T | null;
        public inRange(
          _other: Packages.arc.math.geom.Position,
        ): boolean;
        public move(_v: Packages.arc.math.geom.Vec2): void;
        public move(_cx: number, _cy: number): void;
        public getDuration(
          _effect: Packages.mindustry._type.StatusEffect,
        ): number;
        public item(): Packages.mindustry._type.Item;
        public isValid(): boolean;
        public getX(): number;
        public getY(): number;
        public approach(
          _vector: Packages.arc.math.geom.Vec2,
        ): void;
        public interpolate(): void;
        public trns(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public trns(_x: number, _y: number): void;
        public speed(): number;
        public draw(): void;
        public controller(): Packages.mindustry.entities.units.UnitController;
        public controller(
          _next: Packages.mindustry.entities.units.UnitController,
        ): void;
        public icon(): Packages.arc.graphics.g2d.TextureRegion;
        public lookAt(_angle: number): void;
        public lookAt(_x: number, _y: number): void;
        public lookAt(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public hitbox(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public afterRead(): void;
        public core(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public canBuild(): boolean;
        public isPlayer(): boolean;
        public isLocal(): boolean;
        public isAdded(): boolean;
        public tileOn(): Packages.mindustry.world.Tile;
        public hitSize(): number;
        public closestCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public aim(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public aim(_x: number, _y: number): void;
        public controlWeapons(
          _rotate: boolean,
          _shoot: boolean,
        ): void;
        public controlWeapons(_rotateShoot: boolean): void;
        public inFogTo(
          _viewer: Packages.mindustry.game.Team,
        ): boolean;
        public afterSync(): void;
        public resetController(): void;
        public isRemote(): boolean;
        public snapInterpolation(): void;
        public onSolid(): boolean;
        public isFlying(): boolean;
        public canLand(): boolean;
        public classId(): number;
        public buildOn(): Packages.mindustry.gen.Building;
        public isSyncHidden(
          _player: Packages.mindustry.gen.Player,
        ): boolean;
        public damage(
          _amount: number,
          _withEffect: boolean,
        ): void;
        public damage(_amount: number): void;
        public sense(
          _sensor: Packages.mindustry.logic.LAccess,
        ): number;
        public sense(
          _content: Packages.mindustry.ctype.Content,
        ): number;
        public damageContinuous(_amount: number): void;
        public closestEnemyCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public getPlayer(): Packages.mindustry.gen.Player;
        public damagePierce(
          _amount: number,
          _withEffect: boolean,
        ): void;
        public damagePierce(_amount: number): void;
        public damaged(): boolean;
        public healthf(): number;
        public clampHealth(): void;
        public heal(): void;
        public heal(_amount: number): void;
        public cheating(): boolean;
        public itemCapacity(): number;
        public serialize(): boolean;
        public clipSize(): number;
        public tileX(): number;
        public tileY(): number;
        public blockOn(): Packages.mindustry.world.Block;
        public floorOn(): Packages.mindustry.world.blocks.environment.Floor;
        public afterAllRead(): void;
        public handleSyncHidden(): void;
        public readSync(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public readSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public snapSync(): void;
        public writeSync(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public writeSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public killed(): void;
        public displayable(): boolean;
        public isCommandable(): boolean;
        public isPathImpassable(
          _tileX: number,
          _tileY: number,
        ): boolean;
        public checkTarget(
          _targetAir: boolean,
          _targetGround: boolean,
        ): boolean;
        public isBoss(): boolean;
        public collision(
          _other: Packages.mindustry.gen.Hitboxc,
          _x: number,
          _y: number,
        ): void;
        public senseObject(
          _sensor: Packages.mindustry.logic.LAccess,
        ): any;
        public damageContinuousPierce(
          _amount: number,
        ): void;
        public healFract(_amount: number): void;
        public kill(): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: any,
        ): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: number,
        ): void;
        public setProp(
          _content: Packages.mindustry.ctype.UnlockableContent,
          _value: number,
        ): void;
        public targetable(
          _targeter: Packages.mindustry.game.Team,
        ): boolean;
        public drawPlan(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _alpha: number,
        ): void;
        public isAI(): boolean;
        public isEnemy(): boolean;
        public mining(): boolean;
        public canDrown(): boolean;
        public emitWalkSound(): boolean;
        public isGrounded(): boolean;
        public floorSpeedMultiplier(): number;
        public drownFloor(): Packages.mindustry.world.blocks.environment.Floor;
        public landed(): void;
        public moveAt(
          _vector: Packages.arc.math.geom.Vec2,
        ): void;
        public moveAt(
          _vector: Packages.arc.math.geom.Vec2,
          _acceleration: number,
        ): void;
        public updateDrowning(): void;
        public wobble(): void;
        public collides(
          _other: Packages.mindustry.gen.Hitboxc,
        ): boolean;
        public deltaAngle(): number;
        public deltaLen(): number;
        public getCollisions(
          _consumer: Packages.arc.func.Cons<
            Packages.arc.math.geom.QuadTree<any>
          >,
        ): void;
        public hitboxTile(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public updateLastPosition(): void;
        public solidity(): Packages.mindustry.entities.EntityCollisions.SolidPred;
        public canPassOn(): boolean;
        public canPass(
          _tileX: number,
          _tileY: number,
        ): boolean;
        public moving(): boolean;
        public velAddNet(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public velAddNet(_vx: number, _vy: number): void;
        public buildPlan(): Packages.mindustry.entities.units.BuildPlan;
        public acceptsItem(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public hasItem(): boolean;
        public maxAccepted(
          _item: Packages.mindustry._type.Item,
        ): number;
        public addItem(
          _item: Packages.mindustry._type.Item,
        ): void;
        public addItem(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): void;
        public clearItem(): void;
        public shouldSkip(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _core: Packages.mindustry.gen.Building,
        ): boolean;
        public addBuild(
          _place: Packages.mindustry.entities.units.BuildPlan,
          _tail: boolean,
        ): void;
        public addBuild(
          _place: Packages.mindustry.entities.units.BuildPlan,
        ): void;
        public clearBuilding(): void;
        public drawBuildPlans(): void;
        public isBuilding(): boolean;
        public activelyBuilding(): boolean;
        public drawBuilding(): void;
        public drawBuildingBeam(
          _px: number,
          _py: number,
        ): void;
        public drawPlanTop(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _alpha: number,
        ): void;
        public removeBuild(
          _x: number,
          _y: number,
          _breaking: boolean,
        ): void;
        public updateBuildLogic(): void;
        public validatePlans(): void;
        public applyDynamicStatus(): Packages.mindustry.entities.units.StatusEntry;
        public unapply(
          _effect: Packages.mindustry._type.StatusEffect,
        ): void;
        public statusDamageMultiplier(
          _damageMultiplier: number,
        ): void;
        public statusReloadMultiplier(
          _reloadMultiplier: number,
        ): void;
        public statusArmor(_armor: number): void;
        public statusBuildSpeed(_buildSpeed: number): void;
        public statusDrag(_drag: number): void;
        public statusMaxHealth(_health: number): void;
        public statusSpeed(_speed: number): void;
        public statusColor(): Packages.arc.graphics.Color;
        public statusBits(): Packages.arc.struct.Bits;
        public hasEffect(
          _effect: Packages.mindustry._type.StatusEffect,
        ): boolean;
        public isImmune(
          _effect: Packages.mindustry._type.StatusEffect,
        ): boolean;
        public clearStatuses(): void;
        public canMine(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public canMine(): boolean;
        public offloadImmediately(): boolean;
        public validMine(
          _tile: Packages.mindustry.world.Tile,
        ): boolean;
        public validMine(
          _tile: Packages.mindustry.world.Tile,
          _checkDst: boolean,
        ): boolean;
        public getMineResult(
          _tile: Packages.mindustry.world.Tile,
        ): Packages.mindustry._type.Item;
        public mass(): number;
        public impulse(_x: number, _y: number): void;
        public impulse(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public impulseNet(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public rawDamage(_amount: number): void;
        public physicSize(): number;
        public getControllerName(): string;
        public pathType(): number;
        public collisionLayer(): number;
        public prefRotation(): number;
        public unloaded(): void;
        public movePref(
          _movement: Packages.arc.math.geom.Vec2,
        ): void;
        public canShoot(): boolean;
        public canTarget(
          _other: Packages.mindustry.gen.Unit,
        ): boolean;
        public hasWeapons(): boolean;
        public hittable(): boolean;
        public aimLook(_x: number, _y: number): void;
        public aimLook(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public rotateMove(
          _vec: Packages.arc.math.geom.Vec2,
        ): void;
        public updateBoosting(_boost: boolean): void;
        public isRotate(): boolean;
        public ammof(): number;
        public setWeaponRotation(_rotation: number): void;
        public setupWeapons(
          _def: Packages.mindustry._type.UnitType,
        ): void;
        public setType(
          _type: Packages.mindustry._type.UnitType,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class UnitEntityLegacyAlpha
        extends Packages.mindustry.gen.UnitEntity
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public static create(): Packages.mindustry.gen.UnitEntityLegacyAlpha;
        public classId(): number;
        public serialize(): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class UnitEntityLegacyBeta
        extends Packages.mindustry.gen.UnitEntity
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public static create(): Packages.mindustry.gen.UnitEntityLegacyBeta;
        public classId(): number;
        public serialize(): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class UnitEntityLegacyGamma
        extends Packages.mindustry.gen.UnitEntity
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public static create(): Packages.mindustry.gen.UnitEntityLegacyGamma;
        public classId(): number;
        public serialize(): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class UnitEntityLegacyMono
        extends Packages.mindustry.gen.UnitEntity
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public static create(): Packages.mindustry.gen.UnitEntityLegacyMono;
        public classId(): number;
        public serialize(): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class UnitEntityLegacyPoly
        extends Packages.mindustry.gen.UnitEntity
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public static create(): Packages.mindustry.gen.UnitEntityLegacyPoly;
        public classId(): number;
        public serialize(): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class UnitEnvDeathCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public unit: Packages.mindustry.gen.Unit;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class UnitTetherBlockSpawnedCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public tile: Packages.mindustry.world.Tile;
        public id: number;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class UnitTetherc
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public update(): void;
        public afterRead(): void;
        public afterSync(): void;
        public spawner(): Packages.mindustry.gen.Unit | null;
        public spawner(
          _spawner: Packages.mindustry.gen.Unit | null,
        ): void;
        public spawnerUnitId(): number;
        public spawnerUnitId(_spawnerUnitId: number): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare abstract class WaterMovec
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public add(): void;
        public update(): void;
        public draw(): void;
        public onSolid(): boolean;
        public emitWalkSound(): boolean;
        public floorSpeedMultiplier(): number;
        public solidity(): Packages.mindustry.entities.EntityCollisions.SolidPred;
        public pathType(): number;
        public onLiquid(): boolean;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class UnitWaterMove
        extends Packages.mindustry.gen.Unit
        implements
          Packages.mindustry.gen.Flyingc,
          Packages.mindustry.gen.Posc,
          Packages.mindustry.gen.Hitboxc,
          Packages.mindustry.gen.Minerc,
          Packages.mindustry.gen.Shieldc,
          Packages.mindustry.gen.Statusc,
          Packages.mindustry.gen.Itemsc,
          Packages.mindustry.gen.Unitc,
          Packages.mindustry.gen.Weaponsc,
          Packages.mindustry.gen.Boundedc,
          Packages.mindustry.gen.Physicsc,
          Packages.mindustry.gen.Teamc,
          Packages.mindustry.gen.Velc,
          Packages.mindustry.gen.Drawc,
          Packages.mindustry.gen.Builderc,
          Packages.mindustry.gen.Syncc,
          Packages.mindustry.gen.Rotc,
          Packages.mindustry.gen.WaterMovec,
          Packages.mindustry.gen.Entityc,
          Packages.mindustry.gen.Healthc
      {
        public static hitDuration: number;
        protected static tmp1: Packages.arc.math.geom.Vec2;
        protected static tmp2: Packages.arc.math.geom.Vec2;
        public static warpDst: number;
        protected added: boolean;
        protected applied: Packages.arc.struct.Bits;
        protected buildCounter: number;
        protected lastActive: Packages.mindustry.entities.units.BuildPlan;
        protected lastSize: number;
        protected resupplyTime: number;
        private rotation_LAST_: number;
        private rotation_TARGET_: number;
        protected statuses: Packages.arc.struct.Seq<Packages.mindustry.entities.units.StatusEntry>;
        protected tleft: Packages.mindustry.graphics.Trail;
        protected trailColor: Packages.arc.graphics.Color;
        protected tright: Packages.mindustry.graphics.Trail;
        protected wasFlying: boolean;
        protected wasHealed: boolean;
        protected wasPlayer: boolean;
        private x_LAST_: number;
        private x_TARGET_: number;
        private y_LAST_: number;
        private y_TARGET_: number;
        public add(): void;
        public remove(): void;
        public toString(): string;
        public update(): void;
        public apply(
          _effect: Packages.mindustry._type.StatusEffect,
          _duration: number,
        ): void;
        public apply(
          _effect: Packages.mindustry._type.StatusEffect,
        ): void;
        public count(): number;
        public bounds(): number;
        public set(_x: number, _y: number): void;
        public set(
          _def: Packages.mindustry._type.UnitType,
          _controller: Packages.mindustry.entities.units.UnitController,
        ): void;
        public set(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public destroy(): void;
        public cap(): number;
        public static create(): Packages.mindustry.gen.UnitWaterMove;
        public as<T>(): T | null;
        public command(): Packages.mindustry.ai._types.CommandAI;
        public display(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public range(): number;
        public self<
          T extends Packages.mindustry.gen.Entityc,
        >(): T | null;
        public inRange(
          _other: Packages.arc.math.geom.Position,
        ): boolean;
        public move(_v: Packages.arc.math.geom.Vec2): void;
        public move(_cx: number, _cy: number): void;
        public getDuration(
          _effect: Packages.mindustry._type.StatusEffect,
        ): number;
        public item(): Packages.mindustry._type.Item;
        public isValid(): boolean;
        public getX(): number;
        public getY(): number;
        public approach(
          _vector: Packages.arc.math.geom.Vec2,
        ): void;
        public interpolate(): void;
        public trns(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public trns(_x: number, _y: number): void;
        public speed(): number;
        public draw(): void;
        public controller(
          _next: Packages.mindustry.entities.units.UnitController,
        ): void;
        public controller(): Packages.mindustry.entities.units.UnitController;
        public icon(): Packages.arc.graphics.g2d.TextureRegion;
        public lookAt(_x: number, _y: number): void;
        public lookAt(_angle: number): void;
        public lookAt(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public hitbox(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public afterRead(): void;
        public core(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public canBuild(): boolean;
        public isPlayer(): boolean;
        public isLocal(): boolean;
        public isAdded(): boolean;
        public tileOn(): Packages.mindustry.world.Tile;
        public hitSize(): number;
        public closestCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public aim(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public aim(_x: number, _y: number): void;
        public controlWeapons(_rotateShoot: boolean): void;
        public controlWeapons(
          _rotate: boolean,
          _shoot: boolean,
        ): void;
        public inFogTo(
          _viewer: Packages.mindustry.game.Team,
        ): boolean;
        public afterSync(): void;
        public resetController(): void;
        public isRemote(): boolean;
        public snapInterpolation(): void;
        public onSolid(): boolean;
        public isFlying(): boolean;
        public canLand(): boolean;
        public classId(): number;
        public buildOn(): Packages.mindustry.gen.Building;
        public isSyncHidden(
          _player: Packages.mindustry.gen.Player,
        ): boolean;
        public damage(_amount: number): void;
        public damage(
          _amount: number,
          _withEffect: boolean,
        ): void;
        public sense(
          _content: Packages.mindustry.ctype.Content,
        ): number;
        public sense(
          _sensor: Packages.mindustry.logic.LAccess,
        ): number;
        public damageContinuous(_amount: number): void;
        public closestEnemyCore(): Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild;
        public getPlayer(): Packages.mindustry.gen.Player;
        public damagePierce(
          _amount: number,
          _withEffect: boolean,
        ): void;
        public damagePierce(_amount: number): void;
        public damaged(): boolean;
        public healthf(): number;
        public clampHealth(): void;
        public heal(_amount: number): void;
        public heal(): void;
        public cheating(): boolean;
        public itemCapacity(): number;
        public serialize(): boolean;
        public clipSize(): number;
        public tileX(): number;
        public tileY(): number;
        public blockOn(): Packages.mindustry.world.Block;
        public floorOn(): Packages.mindustry.world.blocks.environment.Floor;
        public afterAllRead(): void;
        public handleSyncHidden(): void;
        public readSync(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public readSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public snapSync(): void;
        public writeSync(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public writeSyncManual(
          _buffer: Packages.java.nio.FloatBuffer,
        ): void;
        public killed(): void;
        public displayable(): boolean;
        public isCommandable(): boolean;
        public isPathImpassable(
          _tileX: number,
          _tileY: number,
        ): boolean;
        public checkTarget(
          _targetAir: boolean,
          _targetGround: boolean,
        ): boolean;
        public isBoss(): boolean;
        public collision(
          _other: Packages.mindustry.gen.Hitboxc,
          _x: number,
          _y: number,
        ): void;
        public senseObject(
          _sensor: Packages.mindustry.logic.LAccess,
        ): any;
        public damageContinuousPierce(
          _amount: number,
        ): void;
        public healFract(_amount: number): void;
        public kill(): void;
        public setProp(
          _content: Packages.mindustry.ctype.UnlockableContent,
          _value: number,
        ): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: any,
        ): void;
        public setProp(
          _prop: Packages.mindustry.logic.LAccess,
          _value: number,
        ): void;
        public targetable(
          _targeter: Packages.mindustry.game.Team,
        ): boolean;
        public drawPlan(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _alpha: number,
        ): void;
        public isAI(): boolean;
        public isEnemy(): boolean;
        public mining(): boolean;
        public canDrown(): boolean;
        public emitWalkSound(): boolean;
        public isGrounded(): boolean;
        public floorSpeedMultiplier(): number;
        public drownFloor(): Packages.mindustry.world.blocks.environment.Floor;
        public landed(): void;
        public moveAt(
          _vector: Packages.arc.math.geom.Vec2,
          _acceleration: number,
        ): void;
        public moveAt(
          _vector: Packages.arc.math.geom.Vec2,
        ): void;
        public updateDrowning(): void;
        public wobble(): void;
        public collides(
          _other: Packages.mindustry.gen.Hitboxc,
        ): boolean;
        public deltaAngle(): number;
        public deltaLen(): number;
        public getCollisions(
          _consumer: Packages.arc.func.Cons<
            Packages.arc.math.geom.QuadTree<any>
          >,
        ): void;
        public hitboxTile(
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public updateLastPosition(): void;
        public solidity(): Packages.mindustry.entities.EntityCollisions.SolidPred;
        public canPassOn(): boolean;
        public canPass(
          _tileX: number,
          _tileY: number,
        ): boolean;
        public moving(): boolean;
        public velAddNet(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public velAddNet(_vx: number, _vy: number): void;
        public buildPlan(): Packages.mindustry.entities.units.BuildPlan;
        public acceptsItem(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public hasItem(): boolean;
        public maxAccepted(
          _item: Packages.mindustry._type.Item,
        ): number;
        public addItem(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        ): void;
        public addItem(
          _item: Packages.mindustry._type.Item,
        ): void;
        public clearItem(): void;
        public shouldSkip(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _core: Packages.mindustry.gen.Building,
        ): boolean;
        public addBuild(
          _place: Packages.mindustry.entities.units.BuildPlan,
          _tail: boolean,
        ): void;
        public addBuild(
          _place: Packages.mindustry.entities.units.BuildPlan,
        ): void;
        public clearBuilding(): void;
        public drawBuildPlans(): void;
        public isBuilding(): boolean;
        public activelyBuilding(): boolean;
        public drawBuilding(): void;
        public drawBuildingBeam(
          _px: number,
          _py: number,
        ): void;
        public drawPlanTop(
          _plan: Packages.mindustry.entities.units.BuildPlan,
          _alpha: number,
        ): void;
        public removeBuild(
          _x: number,
          _y: number,
          _breaking: boolean,
        ): void;
        public updateBuildLogic(): void;
        public validatePlans(): void;
        public applyDynamicStatus(): Packages.mindustry.entities.units.StatusEntry;
        public unapply(
          _effect: Packages.mindustry._type.StatusEffect,
        ): void;
        public statusDamageMultiplier(
          _damageMultiplier: number,
        ): void;
        public statusReloadMultiplier(
          _reloadMultiplier: number,
        ): void;
        public statusArmor(_armor: number): void;
        public statusBuildSpeed(_buildSpeed: number): void;
        public statusDrag(_drag: number): void;
        public statusMaxHealth(_health: number): void;
        public statusSpeed(_speed: number): void;
        public statusColor(): Packages.arc.graphics.Color;
        public statusBits(): Packages.arc.struct.Bits;
        public hasEffect(
          _effect: Packages.mindustry._type.StatusEffect,
        ): boolean;
        public isImmune(
          _effect: Packages.mindustry._type.StatusEffect,
        ): boolean;
        public clearStatuses(): void;
        public canMine(
          _item: Packages.mindustry._type.Item,
        ): boolean;
        public canMine(): boolean;
        public offloadImmediately(): boolean;
        public validMine(
          _tile: Packages.mindustry.world.Tile,
          _checkDst: boolean,
        ): boolean;
        public validMine(
          _tile: Packages.mindustry.world.Tile,
        ): boolean;
        public getMineResult(
          _tile: Packages.mindustry.world.Tile,
        ): Packages.mindustry._type.Item;
        public mass(): number;
        public impulse(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public impulse(_x: number, _y: number): void;
        public impulseNet(
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public rawDamage(_amount: number): void;
        public physicSize(): number;
        public getControllerName(): string;
        public pathType(): number;
        public collisionLayer(): number;
        public prefRotation(): number;
        public unloaded(): void;
        public movePref(
          _movement: Packages.arc.math.geom.Vec2,
        ): void;
        public canShoot(): boolean;
        public canTarget(
          _other: Packages.mindustry.gen.Unit,
        ): boolean;
        public hasWeapons(): boolean;
        public hittable(): boolean;
        public aimLook(_x: number, _y: number): void;
        public aimLook(
          _pos: Packages.arc.math.geom.Position,
        ): void;
        public rotateMove(
          _vec: Packages.arc.math.geom.Vec2,
        ): void;
        public updateBoosting(_boost: boolean): void;
        public isRotate(): boolean;
        public ammof(): number;
        public setWeaponRotation(_rotation: number): void;
        public setupWeapons(
          _def: Packages.mindustry._type.UnitType,
        ): void;
        public onLiquid(): boolean;
        public setType(
          _type: Packages.mindustry._type.UnitType,
        ): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class UpdateGameOverCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public winner: Packages.mindustry.game.Team;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class WarningToastCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public unicode: number;
        public text: string;
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace gen {
      declare class WorldDataBeginCallPacket extends Packages
        .mindustry.net.Packet {
        private DATA: string[];
        public write(
          _WRITE: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _READ: Packages.arc.util.io.Reads,
          _LENGTH: number,
        ): void;
        public handled(): void;
        public handleClient(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare class Drawf extends java.lang.Object {
        private static vecs: Packages.arc.math.geom.Vec2[];
        private static points: Packages.arc.struct.FloatSeq;
        public static target(
          _x: number,
          _y: number,
          _rad: number,
          _alpha: number,
          _color: Packages.arc.graphics.Color,
        ): void;
        public static target(
          _x: number,
          _y: number,
          _rad: number,
          _color: Packages.arc.graphics.Color,
        ): void;
        public static line(
          _color: Packages.arc.graphics.Color,
          _x: number,
          _y: number,
          _x2: number,
          _y2: number,
        ): void;
        public static text(): number;
        public static square(
          _x: number,
          _y: number,
          _radius: number,
          _rotation: number,
        ): void;
        public static square(
          _x: number,
          _y: number,
          _radius: number,
        ): void;
        public static square(
          _x: number,
          _y: number,
          _radius: number,
          _color: Packages.arc.graphics.Color,
        ): void;
        public static square(
          _x: number,
          _y: number,
          _radius: number,
          _rotation: number,
          _color: Packages.arc.graphics.Color,
        ): void;
        public static select(
          _x: number,
          _y: number,
          _radius: number,
          _color: Packages.arc.graphics.Color,
        ): void;
        private static point(
          _x: number,
          _y: number,
          _baseX: number,
          _baseY: number,
          _rotation: number,
        ): void;
        public static arrow(
          _x: number,
          _y: number,
          _x2: number,
          _y2: number,
          _length: number,
          _radius: number,
        ): void;
        public static arrow(
          _x: number,
          _y: number,
          _x2: number,
          _y2: number,
          _length: number,
          _radius: number,
          _color: Packages.arc.graphics.Color,
        ): void;
        public static additive(
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _color: Packages.arc.graphics.Color,
          _x: number,
          _y: number,
        ): void;
        public static additive(
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _color: Packages.arc.graphics.Color,
          _alpha: number,
          _x: number,
          _y: number,
          _rotation: number,
          _layer: number,
        ): void;
        public static additive(
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _color: Packages.arc.graphics.Color,
          _x: number,
          _y: number,
          _rotation: number,
          _layer: number,
        ): void;
        public static additive(
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _color: Packages.arc.graphics.Color,
          _x: number,
          _y: number,
          _rotation: number,
        ): void;
        public static light(
          _x: number,
          _y: number,
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _rotation: number,
          _color: Packages.arc.graphics.Color,
          _opacity: number,
        ): void;
        public static light(
          _x: number,
          _y: number,
          _x2: number,
          _y2: number,
        ): void;
        public static light(
          _x: number,
          _y: number,
          _radius: number,
          _color: Packages.arc.graphics.Color,
          _opacity: number,
        ): void;
        public static light(
          _pos: Packages.arc.math.geom.Position,
          _radius: number,
          _color: Packages.arc.graphics.Color,
          _opacity: number,
        ): void;
        public static light(
          _x: number,
          _y: number,
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _color: Packages.arc.graphics.Color,
          _opacity: number,
        ): void;
        public static light(
          _x: number,
          _y: number,
          _x2: number,
          _y2: number,
          _stroke: number,
          _tint: Packages.arc.graphics.Color,
          _alpha: number,
        ): void;
        public static tri(
          _x: number,
          _y: number,
          _width: number,
          _length: number,
          _rotation: number,
        ): void;
        public static dashLine(
          _color: Packages.arc.graphics.Color,
          _x: number,
          _y: number,
          _x2: number,
          _y2: number,
        ): void;
        public static dashLine(
          _color: Packages.arc.graphics.Color,
          _x: number,
          _y: number,
          _x2: number,
          _y2: number,
          _segments: number,
        ): void;
        public static dashCircle(
          _x: number,
          _y: number,
          _rad: number,
          _color: Packages.arc.graphics.Color,
        ): void;
        public static selected(
          _tile: Packages.mindustry.world.Tile,
          _color: Packages.arc.graphics.Color,
        ): void;
        public static selected(
          _tile: Packages.mindustry.gen.Building,
          _color: Packages.arc.graphics.Color,
        ): void;
        public static selected(
          _x: number,
          _y: number,
          _block: Packages.mindustry.world.Block,
          _color: Packages.arc.graphics.Color,
        ): void;
        public static liquid(
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _x: number,
          _y: number,
          _alpha: number,
          _color: Packages.arc.graphics.Color,
          _rotation: number,
        ): void;
        public static liquid(
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _x: number,
          _y: number,
          _alpha: number,
          _color: Packages.arc.graphics.Color,
        ): void;
        public static checkBleed(
          _pixmap: Packages.arc.graphics.Pixmap,
        ): void;
        public static shadow(
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _x: number,
          _y: number,
        ): void;
        public static shadow(
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _x: number,
          _y: number,
          _rotation: number,
        ): void;
        public static shadow(
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _x: number,
          _y: number,
          _width: number,
          _height: number,
          _rotation: number,
        ): void;
        public static shadow(
          _x: number,
          _y: number,
          _rad: number,
        ): void;
        public static shadow(
          _x: number,
          _y: number,
          _rad: number,
          _alpha: number,
        ): void;
        public static laser(
          _line: Packages.arc.graphics.g2d.TextureRegion,
          _edge: Packages.arc.graphics.g2d.TextureRegion,
          _x: number,
          _y: number,
          _x2: number,
          _y2: number,
        ): void;
        public static laser(
          _line: Packages.arc.graphics.g2d.TextureRegion,
          _start: Packages.arc.graphics.g2d.TextureRegion,
          _end: Packages.arc.graphics.g2d.TextureRegion,
          _x: number,
          _y: number,
          _x2: number,
          _y2: number,
        ): void;
        public static laser(
          _line: Packages.arc.graphics.g2d.TextureRegion,
          _edge: Packages.arc.graphics.g2d.TextureRegion,
          _x: number,
          _y: number,
          _x2: number,
          _y2: number,
          _scale: number,
        ): void;
        public static laser(
          _line: Packages.arc.graphics.g2d.TextureRegion,
          _start: Packages.arc.graphics.g2d.TextureRegion,
          _end: Packages.arc.graphics.g2d.TextureRegion,
          _x: number,
          _y: number,
          _x2: number,
          _y2: number,
          _scale: number,
        ): void;
        public static spinSprite(
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _x: number,
          _y: number,
          _r: number,
        ): void;
        public static squareShadow(
          _x: number,
          _y: number,
          _rad: number,
          _alpha: number,
        ): void;
        public static dashRect(
          _color: Packages.arc.graphics.Color,
          _rect: Packages.arc.math.geom.Rect,
        ): void;
        public static dashRect(
          _color: Packages.arc.graphics.Color,
          _x: number,
          _y: number,
          _width: number,
          _height: number,
        ): void;
        public static buildBeam(
          _x: number,
          _y: number,
          _tx: number,
          _ty: number,
          _radius: number,
        ): void;
        public static limitLine(
          _start: Packages.arc.math.geom.Position,
          _dest: Packages.arc.math.geom.Position,
          _len1: number,
          _len2: number,
        ): void;
        public static dashLineDst(
          _color: Packages.arc.graphics.Color,
          _x: number,
          _y: number,
          _x2: number,
          _y2: number,
        ): void;
        public static circles(
          _x: number,
          _y: number,
          _rad: number,
        ): void;
        public static circles(
          _x: number,
          _y: number,
          _rad: number,
          _color: Packages.arc.graphics.Color,
        ): void;
        public static dashSquare(
          _color: Packages.arc.graphics.Color,
          _x: number,
          _y: number,
          _size: number,
        ): void;
        public static flame(
          _x: number,
          _y: number,
          _divisions: number,
          _rotation: number,
          _length: number,
          _width: number,
          _pan: number,
        ): void;
        public static construct(
          _t: Packages.mindustry.gen.Building,
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _rotation: number,
          _progress: number,
          _alpha: number,
          _time: number,
        ): void;
        public static construct(
          _x: number,
          _y: number,
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _color: Packages.arc.graphics.Color,
          _rotation: number,
          _progress: number,
          _alpha: number,
          _time: number,
        ): void;
        public static construct(
          _t: Packages.mindustry.gen.Building,
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _color: Packages.arc.graphics.Color,
          _rotation: number,
          _progress: number,
          _alpha: number,
          _time: number,
        ): void;
        public static construct(
          _t: Packages.mindustry.gen.Building,
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _color: Packages.arc.graphics.Color,
          _rotation: number,
          _progress: number,
          _alpha: number,
          _time: number,
          _size: number,
        ): void;
        public static construct(
          _x: number,
          _y: number,
          _region: Packages.arc.graphics.g2d.TextureRegion,
          _rotation: number,
          _progress: number,
          _alpha: number,
          _time: number,
        ): void;
        public static construct(
          _t: Packages.mindustry.gen.Building,
          _content: Packages.mindustry.ctype.UnlockableContent,
          _rotation: number,
          _progress: number,
          _alpha: number,
          _time: number,
        ): void;
        public static dashRectBasic(
          _x: number,
          _y: number,
          _width: number,
          _height: number,
        ): void;
        public static dashLineBasic(
          _x: number,
          _y: number,
          _x2: number,
          _y2: number,
        ): void;
        public static flameFront(
          _x: number,
          _y: number,
          _divisions: number,
          _rotation: number,
          _length: number,
          _width: number,
        ): void;
        public static dashSquareBasic(
          _x: number,
          _y: number,
          _size: number,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare class EnvRenderers extends java.lang.Object {
        public static init(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare class InverseKinematics extends java.lang
        .Object {
        private static mat1: Packages.arc.math.geom.Vec2[];
        private static mat2: Packages.arc.math.geom.Vec2[];
        private static temp: Packages.arc.math.geom.Vec2;
        private static temp2: Packages.arc.math.geom.Vec2;
        private static at1: Packages.arc.math.geom.Vec2;
        public static solve(
          _lengthA: number,
          _lengthB: number,
          _end: Packages.arc.math.geom.Vec2,
          _side: boolean,
          _result: Packages.arc.math.geom.Vec2,
        ): boolean;
        public static solve(
          _lengthA: number,
          _lengthB: number,
          _end: Packages.arc.math.geom.Vec2,
          _attractor: Packages.arc.math.geom.Vec2,
          _result: Packages.arc.math.geom.Vec2,
        ): boolean;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare class Layer extends java.lang.Object {
        public static min: number;
        public static background: number;
        public static floor: number;
        public static scorch: number;
        public static debris: number;
        public static blockUnder: number;
        public static block: number;
        public static blockCracks: number;
        public static blockAfterCracks: number;
        public static blockAdditive: number;
        public static blockProp: number;
        public static blockOver: number;
        public static blockBuilding: number;
        public static turret: number;
        public static turretHeat: number;
        public static groundUnit: number;
        public static power: number;
        public static legUnit: number;
        public static darkness: number;
        public static plans: number;
        public static flyingUnitLow: number;
        public static bullet: number;
        public static effect: number;
        public static flyingUnit: number;
        public static overlayUI: number;
        public static buildBeam: number;
        public static shields: number;
        public static weather: number;
        public static light: number;
        public static playerName: number;
        public static fogOfWar: number;
        public static space: number;
        public static end: number;
        public static endPixeled: number;
        public static max: number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare class Pal extends java.lang.Object {
        public static darkOutline: Packages.arc.graphics.Color;
        public static thoriumPink: Packages.arc.graphics.Color;
        public static coalBlack: Packages.arc.graphics.Color;
        public static items: Packages.arc.graphics.Color;
        public static command: Packages.arc.graphics.Color;
        public static sap: Packages.arc.graphics.Color;
        public static sapBullet: Packages.arc.graphics.Color;
        public static sapBulletBack: Packages.arc.graphics.Color;
        public static suppress: Packages.arc.graphics.Color;
        public static regen: Packages.arc.graphics.Color;
        public static reactorPurple: Packages.arc.graphics.Color;
        public static reactorPurple2: Packages.arc.graphics.Color;
        public static spore: Packages.arc.graphics.Color;
        public static shield: Packages.arc.graphics.Color;
        public static bulletYellow: Packages.arc.graphics.Color;
        public static bulletYellowBack: Packages.arc.graphics.Color;
        public static darkMetal: Packages.arc.graphics.Color;
        public static darkerMetal: Packages.arc.graphics.Color;
        public static darkestMetal: Packages.arc.graphics.Color;
        public static missileYellow: Packages.arc.graphics.Color;
        public static missileYellowBack: Packages.arc.graphics.Color;
        public static meltdownHit: Packages.arc.graphics.Color;
        public static plastaniumBack: Packages.arc.graphics.Color;
        public static plastaniumFront: Packages.arc.graphics.Color;
        public static lightFlame: Packages.arc.graphics.Color;
        public static darkFlame: Packages.arc.graphics.Color;
        public static lightPyraFlame: Packages.arc.graphics.Color;
        public static darkPyraFlame: Packages.arc.graphics.Color;
        public static turretHeat: Packages.arc.graphics.Color;
        public static lightOrange: Packages.arc.graphics.Color;
        public static lightishOrange: Packages.arc.graphics.Color;
        public static lighterOrange: Packages.arc.graphics.Color;
        public static lightishGray: Packages.arc.graphics.Color;
        public static darkishGray: Packages.arc.graphics.Color;
        public static darkerGray: Packages.arc.graphics.Color;
        public static darkestGray: Packages.arc.graphics.Color;
        public static shadow: Packages.arc.graphics.Color;
        public static ammo: Packages.arc.graphics.Color;
        public static rubble: Packages.arc.graphics.Color;
        public static boostTo: Packages.arc.graphics.Color;
        public static boostFrom: Packages.arc.graphics.Color;
        public static lancerLaser: Packages.arc.graphics.Color;
        public static stoneGray: Packages.arc.graphics.Color;
        public static engine: Packages.arc.graphics.Color;
        public static health: Packages.arc.graphics.Color;
        public static heal: Packages.arc.graphics.Color;
        public static bar: Packages.arc.graphics.Color;
        public static accent: Packages.arc.graphics.Color;
        public static stat: Packages.arc.graphics.Color;
        public static negativeStat: Packages.arc.graphics.Color;
        public static gray: Packages.arc.graphics.Color;
        public static metalGrayDark: Packages.arc.graphics.Color;
        public static accentBack: Packages.arc.graphics.Color;
        public static place: Packages.arc.graphics.Color;
        public static remove: Packages.arc.graphics.Color;
        public static noplace: Packages.arc.graphics.Color;
        public static removeBack: Packages.arc.graphics.Color;
        public static placeRotate: Packages.arc.graphics.Color;
        public static breakInvalid: Packages.arc.graphics.Color;
        public static range: Packages.arc.graphics.Color;
        public static power: Packages.arc.graphics.Color;
        public static powerBar: Packages.arc.graphics.Color;
        public static powerLight: Packages.arc.graphics.Color;
        public static placing: Packages.arc.graphics.Color;
        public static unitFront: Packages.arc.graphics.Color;
        public static unitBack: Packages.arc.graphics.Color;
        public static lightTrail: Packages.arc.graphics.Color;
        public static surge: Packages.arc.graphics.Color;
        public static plastanium: Packages.arc.graphics.Color;
        public static redSpark: Packages.arc.graphics.Color;
        public static orangeSpark: Packages.arc.graphics.Color;
        public static redDust: Packages.arc.graphics.Color;
        public static redderDust: Packages.arc.graphics.Color;
        public static plasticSmoke: Packages.arc.graphics.Color;
        public static adminChat: Packages.arc.graphics.Color;
        public static neoplasmOutline: Packages.arc.graphics.Color;
        public static neoplasm1: Packages.arc.graphics.Color;
        public static neoplasmMid: Packages.arc.graphics.Color;
        public static neoplasm2: Packages.arc.graphics.Color;
        public static logicBlocks: Packages.arc.graphics.Color;
        public static logicControl: Packages.arc.graphics.Color;
        public static logicOperations: Packages.arc.graphics.Color;
        public static logicIo: Packages.arc.graphics.Color;
        public static logicUnits: Packages.arc.graphics.Color;
        public static logicWorld: Packages.arc.graphics.Color;
        public static berylShot: Packages.arc.graphics.Color;
        public static tungstenShot: Packages.arc.graphics.Color;
        public static plasticBurn: Packages.arc.graphics.Color;
        public static muddy: Packages.arc.graphics.Color;
        public static redLight: Packages.arc.graphics.Color;
        public static slagOrange: Packages.arc.graphics.Color;
        public static techBlue: Packages.arc.graphics.Color;
        public static vent: Packages.arc.graphics.Color;
        public static vent2: Packages.arc.graphics.Color;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare class Shaders extends java.lang.Object {
        public static MeshShader = class extends Packages
          .mindustry.graphics.Shaders.LoadShader {
          public constructor();
        };
        public static BlockBuildShader = class extends Packages
          .mindustry.graphics.Shaders.LoadShader {
          public progress: number;
          public region: Packages.arc.graphics.g2d.TextureRegion;
          public time: number;
          public apply(): void;
          public constructor();
        };
        public static ShieldShader = class extends Packages
          .mindustry.graphics.Shaders.LoadShader {
          public apply(): void;
          public constructor();
        };
        public static FogShader = class extends Packages
          .mindustry.graphics.Shaders.LoadShader {
          public constructor();
        };
        public static BuildBeamShader = class extends Packages
          .mindustry.graphics.Shaders.LoadShader {
          public apply(): void;
          public constructor();
        };
        public static UnitBuildShader = class extends Packages
          .mindustry.graphics.Shaders.LoadShader {
          public progress: number;
          public time: number;
          public color: Packages.arc.graphics.Color;
          public region: Packages.arc.graphics.g2d.TextureRegion;
          public apply(): void;
          public constructor();
        };
        public static UnitArmorShader = class extends Packages
          .mindustry.graphics.Shaders.LoadShader {
          public progress: number;
          public time: number;
          public region: Packages.arc.graphics.g2d.TextureRegion;
          public apply(): void;
          public constructor();
        };
        public static DarknessShader = class extends Packages
          .mindustry.graphics.Shaders.LoadShader {
          public constructor();
        };
        public static LightShader = class extends Packages
          .mindustry.graphics.Shaders.LoadShader {
          public ambient: Packages.arc.graphics.Color;
          public apply(): void;
          public constructor();
        };
        public static SurfaceShader = class extends Packages
          .arc.graphics.gl.Shader {
          noiseTex: Packages.arc.graphics.Texture;
          public apply(): void;
          public loadNoise(): void;
          public textureName(): string;
          public constructor(_frag: string);
          public constructor(
            _vertRaw: string,
            _fragRaw: string,
          );
        };
        public static SpaceShader = class extends Packages
          .mindustry.graphics.Shaders.SurfaceShader {
          texture: Packages.arc.graphics.Texture;
          public apply(): void;
          public constructor(_frag: string);
        };
        public static PlanetShader = class extends Packages
          .mindustry.graphics.Shaders.LoadShader {
          public lightDir: Packages.arc.math.geom.Vec3;
          public ambientColor: Packages.arc.graphics.Color;
          public camDir: Packages.arc.math.geom.Vec3;
          public camPos: Packages.arc.math.geom.Vec3;
          public planet: Packages.mindustry._type.Planet;
          public apply(): void;
          public constructor();
        };
        public static CloudShader = class extends Packages
          .mindustry.graphics.Shaders.LoadShader {
          public lightDir: Packages.arc.math.geom.Vec3;
          public ambientColor: Packages.arc.graphics.Color;
          public camDir: Packages.arc.math.geom.Vec3;
          public alpha: number;
          public planet: Packages.mindustry._type.Planet;
          public apply(): void;
          public constructor();
        };
        public static PlanetGridShader = class extends Packages
          .mindustry.graphics.Shaders.LoadShader {
          public mouse: Packages.arc.math.geom.Vec3;
          public apply(): void;
          public constructor();
        };
        public static AtmosphereShader = class extends Packages
          .mindustry.graphics.Shaders.LoadShader {
          public camera: Packages.arc.graphics.g3d.Camera3D;
          public planet: Packages.mindustry._type.Planet;
          mat: Packages.arc.math.geom.Mat3D;
          public apply(): void;
          public constructor();
        };
        public static LoadShader = class extends Packages
          .arc.graphics.gl.Shader {
          public constructor(_frag: string, _vert: string);
        };
        public static ShockwaveShader = class extends Packages
          .mindustry.graphics.Shaders.LoadShader {
          static max: number;
          static size: number;
          protected data: Packages.arc.struct.FloatSeq;
          protected uniforms: Packages.arc.struct.FloatSeq;
          protected hadAny: boolean;
          protected buffer: Packages.arc.graphics.gl.FrameBuffer;
          public lifetime: number;
          public add(
            _x: number,
            _y: number,
            _radius: number,
            _lifetime: number,
          ): void;
          public add(
            _x: number,
            _y: number,
            _radius: number,
          ): void;
          public apply(): void;
          public constructor();
        };
        public static blockbuild: Packages.mindustry.graphics.Shaders.BlockBuildShader;
        public static shield?: Packages.mindustry.graphics.Shaders.ShieldShader;
        public static buildBeam: Packages.mindustry.graphics.Shaders.BuildBeamShader;
        public static build: Packages.mindustry.graphics.Shaders.UnitBuildShader;
        public static armor: Packages.mindustry.graphics.Shaders.UnitArmorShader;
        public static darkness: Packages.mindustry.graphics.Shaders.DarknessShader;
        public static fog: Packages.mindustry.graphics.Shaders.FogShader;
        public static light: Packages.mindustry.graphics.Shaders.LightShader;
        public static water: Packages.mindustry.graphics.Shaders.SurfaceShader;
        public static mud: Packages.mindustry.graphics.Shaders.SurfaceShader;
        public static tar: Packages.mindustry.graphics.Shaders.SurfaceShader;
        public static slag: Packages.mindustry.graphics.Shaders.SurfaceShader;
        public static cryofluid: Packages.mindustry.graphics.Shaders.SurfaceShader;
        public static space: Packages.mindustry.graphics.Shaders.SurfaceShader;
        public static caustics: Packages.mindustry.graphics.Shaders.SurfaceShader;
        public static arkycite: Packages.mindustry.graphics.Shaders.SurfaceShader;
        public static planet: Packages.mindustry.graphics.Shaders.PlanetShader;
        public static clouds: Packages.mindustry.graphics.Shaders.CloudShader;
        public static planetGrid: Packages.mindustry.graphics.Shaders.PlanetGridShader;
        public static atmosphere: Packages.mindustry.graphics.Shaders.AtmosphereShader;
        public static shockwave: Packages.mindustry.graphics.Shaders.ShockwaveShader;
        public static mesh: Packages.mindustry.graphics.Shaders.MeshShader;
        public static unlit: Packages.arc.graphics.gl.Shader;
        public static screenspace: Packages.arc.graphics.gl.Shader;
        public static init(): void;
        public static getShaderFi(
          _file: string,
        ): Packages.arc.files.Fi;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare class Voronoi extends java.lang.Object {
        static Site = class extends java.lang.Object {
          coord: Packages.arc.math.geom.Vec2;
          sitenbr: number;
        };
        static Halfedge = class extends java.lang.Object {
          ELleft: Packages.mindustry.graphics.Voronoi.Halfedge;
          ELright: Packages.mindustry.graphics.Voronoi.Halfedge;
          ELedge: Packages.mindustry.graphics.Voronoi.Edge;
          deleted: boolean;
          ELpm: number;
          vertex: Packages.mindustry.graphics.Voronoi.Site;
          ystar: number;
          PQnext: Packages.mindustry.graphics.Voronoi.Halfedge;
        };
        static Edge = class extends java.lang.Object {
          a: number;
          b: number;
          c: number;
          ep: Packages.mindustry.graphics.Voronoi.Site[];
          reg: Packages.mindustry.graphics.Voronoi.Site[];
          edgenbr: number;
        };
        public static GraphEdge = class extends java.lang
          .Object {
          public x1: number;
          public y1: number;
          public x2: number;
          public y2: number;
          public site1: number;
          public site2: number;
          public constructor();
        };
        private static LE: number;
        private static RE: number;
        siteidx: number;
        sites: Packages.mindustry.graphics.Voronoi.Site[];
        nsites: number;
        borderMinX: number;
        borderMaxX: number;
        borderMinY: number;
        borderMaxY: number;
        ymin: number;
        deltay: number;
        nvertices: number;
        nedges: number;
        bottomsite: Packages.mindustry.graphics.Voronoi.Site;
        PQcount: number;
        PQmin: number;
        PQhashsize: number;
        PQhash: Packages.mindustry.graphics.Voronoi.Halfedge[];
        ELhashsize: number;
        ELhash: Packages.mindustry.graphics.Voronoi.Halfedge[];
        allEdges: Packages.arc.struct.Seq<Packages.mindustry.graphics.Voronoi.GraphEdge>;
        minDistanceBetweenSites: number;
        private insert(
          _lb: Packages.mindustry.graphics.Voronoi.Halfedge,
          _newHe: Packages.mindustry.graphics.Voronoi.Halfedge,
        ): void;
        private next(): Packages.mindustry.graphics.Voronoi.Site;
        private delete(
          _he: Packages.mindustry.graphics.Voronoi.Halfedge,
        ): void;
        private right(
          _el: Packages.mindustry.graphics.Voronoi.Halfedge,
          _p: Packages.arc.math.geom.Vec2,
        ): boolean;
        public static generate(
          _values: Packages.arc.math.geom.Vec2[],
          _minX: number,
          _maxX: number,
          _minY: number,
          _maxY: number,
        ): Packages.arc.struct.Seq<Packages.mindustry.graphics.Voronoi.GraphEdge>;
        private endpoint(
          _e: Packages.mindustry.graphics.Voronoi.Edge,
          _lr: number,
          _s: Packages.mindustry.graphics.Voronoi.Site,
        ): void;
        private getHash(
          _b: number,
        ): Packages.mindustry.graphics.Voronoi.Halfedge;
        private intersect(
          _el1: Packages.mindustry.graphics.Voronoi.Halfedge,
          _el2: Packages.mindustry.graphics.Voronoi.Halfedge,
        ): Packages.mindustry.graphics.Voronoi.Site;
        generateVoronoi(
          _values: Packages.arc.math.geom.Vec2[],
          _minX: number,
          _maxX: number,
          _minY: number,
          _maxY: number,
        ): Packages.arc.struct.Seq<Packages.mindustry.graphics.Voronoi.GraphEdge>;
        private newHe(
          _e: Packages.mindustry.graphics.Voronoi.Edge,
          _pm: number,
        ): Packages.mindustry.graphics.Voronoi.Halfedge;
        private rightreg(
          _he: Packages.mindustry.graphics.Voronoi.Halfedge,
        ): Packages.mindustry.graphics.Voronoi.Site;
        private bisect(
          _s1: Packages.mindustry.graphics.Voronoi.Site,
          _s2: Packages.mindustry.graphics.Voronoi.Site,
        ): Packages.mindustry.graphics.Voronoi.Edge;
        private pqdelete(
          _he: Packages.mindustry.graphics.Voronoi.Halfedge,
        ): void;
        private pqinsert(
          _he: Packages.mindustry.graphics.Voronoi.Halfedge,
          _v: Packages.mindustry.graphics.Voronoi.Site,
          _offset: number,
        ): void;
        private leftReg(
          _he: Packages.mindustry.graphics.Voronoi.Halfedge,
        ): Packages.mindustry.graphics.Voronoi.Site;
        private clipLine(
          _e: Packages.mindustry.graphics.Voronoi.Edge,
        ): void;
        private pqbucket(
          _he: Packages.mindustry.graphics.Voronoi.Halfedge,
        ): number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace input {
      declare class PlaceMode extends Packages.java.lang
        .Enum<Packages.mindustry.input.PlaceMode> {
        public static none: Packages.mindustry.input.PlaceMode;
        public static breaking: Packages.mindustry.input.PlaceMode;
        public static placing: Packages.mindustry.input.PlaceMode;
        public static schematicSelect: Packages.mindustry.input.PlaceMode;
        public static rebuildSelect: Packages.mindustry.input.PlaceMode;
        private static $VALUES: Packages.mindustry.input.PlaceMode[];
        public static values():
          | Packages.mindustry.input.PlaceMode[]
          | null;
        public static valueOf(
          _name: string,
        ): Packages.mindustry.input.PlaceMode;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace input {
      declare class DesktopInput extends Packages.mindustry
        .input.InputHandler {
        public movement: Packages.arc.math.geom.Vec2;
        public cursorType: Packages.arc.Graphics.Cursor;
        public selectX: number;
        public selectY: number;
        public schemX: number;
        public schemY: number;
        public lastLineX: number;
        public lastLineY: number;
        public schematicX: number;
        public schematicY: number;
        public mode: Packages.mindustry.input.PlaceMode;
        public selectScale: number;
        public splan?: Packages.mindustry.entities.units.BuildPlan;
        public deleting: boolean;
        public shouldShoot: boolean;
        public panning: boolean;
        public panScale: number;
        public panSpeed: number;
        public panBoostSpeed: number;
        public selectMillis: Packages.long;
        public prevSelected: Packages.mindustry.world.Tile;
        public lastCtrlGroup: number;
        public lastCtrlGroupSelectMillis: Packages.long;
        public update(): void;
        public touchDown(
          _x: number,
          _y: number,
          _pointer: number,
          _button: Packages.arc.input.KeyCode,
        ): boolean;
        public tap(
          _x: number,
          _y: number,
          _count: number,
          _button: Packages.arc.input.KeyCode,
        ): boolean;
        protected updateMovement(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public updateState(): void;
        public drawBottom(): void;
        public drawTop(): void;
        pollInput(): void;
        showHint(): boolean;
        public getMouseX(): number;
        public getMouseY(): number;
        public selectedBlock(): boolean;
        public buildPlacementUI(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public buildUI(
          _group: Packages.arc.scene.Group,
        ): void;
        public useSchematic(
          _schem: Packages.mindustry.game.Schematic,
        ): void;
        public panCamera(
          _position: Packages.arc.math.geom.Vec2,
        ): void;
        public isBreaking(): boolean;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace input {
      declare class MobileInput
        extends Packages.mindustry.input.InputHandler
        implements
          Packages.arc.input.GestureDetector.GestureListener
      {
        private static maxPanSpeed: number;
        public edgePan: number;
        public vector: Packages.arc.math.geom.Vec2;
        public movement: Packages.arc.math.geom.Vec2;
        public targetPos: Packages.arc.math.geom.Vec2;
        public lastZoom: number;
        public lineStartX: number;
        public lineStartY: number;
        public lastLineX: number;
        public lastLineY: number;
        public lineScale: number;
        public crosshairScale: number;
        public lastTarget: Packages.mindustry.gen.Teamc;
        public shiftDeltaX: number;
        public shiftDeltaY: number;
        public removals: Packages.arc.struct.Seq<Packages.mindustry.entities.units.BuildPlan>;
        public selecting: boolean;
        public lineMode: boolean;
        public schematicMode: boolean;
        public rebuildMode: boolean;
        public queueCommandMode: boolean;
        public mode: Packages.mindustry.input.PlaceMode;
        public lastBlock?: Packages.mindustry.world.Block;
        public lastPlaced?: Packages.mindustry.entities.units.BuildPlan;
        public down: boolean;
        public manualShooting: boolean;
        public target?: Packages.mindustry.gen.Teamc;
        public payloadTarget?: Packages.arc.math.geom.Position;
        public unitTapped?: Packages.mindustry.gen.Unit;
        public buildingTapped?: Packages.mindustry.gen.Building;
        public update(): void;
        public pan(
          _x: number,
          _y: number,
          _deltaX: number,
          _deltaY: number,
        ): boolean;
        public touchDown(
          _screenX: number,
          _screenY: number,
          _pointer: number,
          _button: Packages.arc.input.KeyCode,
        ): boolean;
        public touchUp(
          _screenX: number,
          _screenY: number,
          _pointer: number,
          _button: Packages.arc.input.KeyCode,
        ): boolean;
        public tap(
          _x: number,
          _y: number,
          _count: number,
          _button: Packages.arc.input.KeyCode,
        ): boolean;
        public longPress(_x: number, _y: number): boolean;
        public zoom(
          _initialDistance: number,
          _distance: number,
        ): boolean;
        public panStop(
          _x: number,
          _y: number,
          _pointer: number,
          _button: Packages.arc.input.KeyCode,
        ): boolean;
        protected drawPlan(
          _plan: Packages.mindustry.entities.units.BuildPlan,
        ): void;
        protected updateMovement(
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public updateState(): void;
        public drawBottom(): void;
        public drawTop(): void;
        protected schemOriginX(): number;
        protected schemOriginY(): number;
        hasSchem(): boolean;
        hasPlan(
          _tile: Packages.mindustry.world.Tile,
        ): boolean;
        checkTargets(_x: number, _y: number): void;
        removePlan(
          _plan: Packages.mindustry.entities.units.BuildPlan,
        ): void;
        checkOverlapPlacement(
          _x: number,
          _y: number,
          _block: Packages.mindustry.world.Block,
        ): boolean;
        protected autoPan(): void;
        showCancel(): boolean;
        isLinePlacing(): boolean;
        isAreaBreaking(): boolean;
        getPlan(
          _tile: Packages.mindustry.world.Tile,
        ): Packages.mindustry.entities.units.BuildPlan;
        public isPlacing(): boolean;
        public buildPlacementUI(
          _table: Packages.arc.scene.ui.layout.Table,
        ): void;
        public buildUI(
          _group: Packages.arc.scene.Group,
        ): void;
        public drawOverSelect(): void;
        public useSchematic(
          _schem: Packages.mindustry.game.Schematic,
        ): void;
        public isBreaking(): boolean;
        public isRebuildSelecting(): boolean;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace distribution {
          declare class DirectionBridge extends Packages
            .mindustry.world.Block {
            public DirectionBridgeBuild = class extends Packages
              .mindustry.gen.Building {
              public occupied: Packages.mindustry.world.blocks.distribution.DirectionBridge.DirectionBridgeBuild[];
              public lastLink?: Packages.mindustry.world.blocks.distribution.DirectionBridge.DirectionBridgeBuild;
              this$0: Packages.mindustry.world.blocks.distribution.DirectionBridge;
              public draw(): void;
              public drawSelect(): void;
              public findLink(): Packages.mindustry.world.blocks.distribution.DirectionBridge.DirectionBridgeBuild | null;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.distribution.DirectionBridge,
              );
            };
            private static otherReq: Packages.mindustry.entities.units.BuildPlan;
            private otherDst: number;
            public bridgeRegion: Packages.arc.graphics.g2d.TextureRegion;
            public bridgeBotRegion: Packages.arc.graphics.g2d.TextureRegion;
            public bridgeLiquidRegion: Packages.arc.graphics.g2d.TextureRegion;
            public arrowRegion: Packages.arc.graphics.g2d.TextureRegion;
            public dirRegion: Packages.arc.graphics.g2d.TextureRegion;
            public range: number;
            public init(): void;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
              _line: boolean,
            ): void;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public drawPlanConfigTop(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public changePlacementPath(
              _points: Packages.arc.struct.Seq<Packages.arc.math.geom.Point2>,
              _rotation: number,
            ): void;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public drawBridge(
              _rotation: number,
              _x1: number,
              _y1: number,
              _x2: number,
              _y2: number,
              _liquidColor: Packages.arc.graphics.Color | null,
            ): void;
            public positionsValid(
              _x1: number,
              _y1: number,
              _x2: number,
              _y2: number,
            ): boolean;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace distribution {
          declare class ItemBridge extends Packages
            .mindustry.world.Block {
            public ItemBridgeBuild = class extends Packages
              .mindustry.gen.Building {
              public link: number;
              public incoming: Packages.arc.struct.IntSeq;
              public warmup: number;
              public time: number;
              public timeSpeed: number;
              public wasMoved: boolean;
              public moved: boolean;
              public transportCounter: number;
              this$0: Packages.mindustry.world.blocks.distribution.ItemBridge;
              public version(): string;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              protected checkAccept(
                _source: Packages.mindustry.gen.Building,
                _link: Packages.mindustry.world.Tile,
              ): boolean;
              public config(): Packages.arc.math.geom.Point2;
              public config(): any;
              public draw(): void;
              protected linked(
                _source: Packages.mindustry.gen.Building,
              ): boolean;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public canDump(
                _to: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public shouldConsume(): boolean;
              public acceptLiquid(
                _source: Packages.mindustry.gen.Building,
                _liquid: Packages.mindustry._type.Liquid,
              ): boolean;
              public canDumpLiquid(
                _to: Packages.mindustry.gen.Building,
                _liquid: Packages.mindustry._type.Liquid,
              ): boolean;
              public updateTile(): void;
              public playerPlaced(_config: any): void;
              public onConfigureBuildTapped(
                _other: Packages.mindustry.gen.Building,
              ): boolean;
              public drawConfigure(): void;
              public drawSelect(): void;
              public pickedUp(): void;
              private drawInput(
                _other: Packages.mindustry.world.Tile,
              ): void;
              public checkIncoming(): void;
              public doDump(): void;
              public updateTransport(
                _other: Packages.mindustry.gen.Building,
              ): void;
              protected checkDump(
                _to: Packages.mindustry.gen.Building,
              ): boolean;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.distribution.ItemBridge,
              );
            };
            private static otherReq: Packages.mindustry.entities.units.BuildPlan;
            public timerCheckMoved: number;
            public range: number;
            public transportTime: number;
            public endRegion: Packages.arc.graphics.g2d.TextureRegion;
            public bridgeRegion: Packages.arc.graphics.g2d.TextureRegion;
            public arrowRegion: Packages.arc.graphics.g2d.TextureRegion;
            public fadeIn: boolean;
            public moveArrows: boolean;
            public pulse: boolean;
            public arrowSpacing: number;
            public arrowOffset: number;
            public arrowPeriod: number;
            public arrowTimeScl: number;
            public bridgeWidth: number;
            public lastBuild?: Packages.mindustry.world.blocks.distribution.ItemBridge.ItemBridgeBuild;
            public init(): void;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public handlePlacementLine(
              _plans: Packages.arc.struct.Seq<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public drawPlanConfigTop(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public changePlacementPath(
              _points: Packages.arc.struct.Seq<Packages.arc.math.geom.Point2>,
              _rotation: number,
            ): void;
            public drawBridge(
              _req: Packages.mindustry.entities.units.BuildPlan,
              _ox: number,
              _oy: number,
              _flip: number,
            ): void;
            public findLink(
              _x: number,
              _y: number,
            ): Packages.mindustry.world.Tile;
            public linkValid(
              _tile: Packages.mindustry.world.Tile,
              _other: Packages.mindustry.world.Tile,
              _checkDouble: boolean,
            ): boolean;
            public linkValid(
              _tile: Packages.mindustry.world.Tile,
              _other: Packages.mindustry.world.Tile,
            ): boolean;
            public positionsValid(
              _x1: number,
              _y1: number,
              _x2: number,
              _y2: number,
            ): boolean;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace input {
      declare class Placement extends java.lang.Object {
        public static NormalizeResult = class extends java
          .lang.Object {
          public x: number;
          public y: number;
          public x2: number;
          public y2: number;
          public rotation: number;
          public constructor();
        };
        public static NormalizeDrawResult = class extends java
          .lang.Object {
          public x: number;
          public y: number;
          public x2: number;
          public y2: number;
          public constructor();
        };
        private static plans1: Packages.arc.struct.Seq<Packages.mindustry.entities.units.BuildPlan>;
        private static tmpPoints: Packages.arc.struct.Seq<Packages.arc.math.geom.Point2>;
        private static tmpPoints2: Packages.arc.struct.Seq<Packages.arc.math.geom.Point2>;
        private static result: Packages.mindustry.input.Placement.NormalizeResult;
        private static drawResult: Packages.mindustry.input.Placement.NormalizeDrawResult;
        private static bres: Packages.arc.math.geom.Bresenham2;
        private static points: Packages.arc.struct.Seq<Packages.arc.math.geom.Point2>;
        private static costs: Packages.arc.struct.IntFloatMap;
        private static parents: Packages.arc.struct.IntIntMap;
        private static closed: Packages.arc.struct.IntSet;
        public static normalizeArea(
          _tilex: number,
          _tiley: number,
          _endx: number,
          _endy: number,
          _rotation: number,
          _snap: boolean,
          _maxLength: number,
        ): Packages.mindustry.input.Placement.NormalizeResult;
        public static normalizeDrawArea(
          _block: Packages.mindustry.world.Block,
          _startx: number,
          _starty: number,
          _endx: number,
          _endy: number,
          _snap: boolean,
          _maxLength: number,
          _scaling: number,
        ): Packages.mindustry.input.Placement.NormalizeDrawResult;
        public static upgradeLine(
          _startX: number,
          _startY: number,
          _endX: number,
          _endY: number,
        ): Packages.arc.struct.Seq<Packages.arc.math.geom.Point2>;
        public static pathfindLine(
          _conveyors: boolean,
          _startX: number,
          _startY: number,
          _endX: number,
          _endY: number,
        ): Packages.arc.struct.Seq<Packages.arc.math.geom.Point2>;
        public static normalizeRectangle(
          _startX: number,
          _startY: number,
          _endX: number,
          _endY: number,
          _blockSize: number,
        ): Packages.arc.struct.Seq<Packages.arc.math.geom.Point2>;
        public static normalizeLine(
          _startX: number,
          _startY: number,
          _endX: number,
          _endY: number,
        ): Packages.arc.struct.Seq<Packages.arc.math.geom.Point2>;
        public static calculateBridges(
          _plans: Packages.arc.struct.Seq<Packages.mindustry.entities.units.BuildPlan>,
          _bridge: Packages.mindustry.world.blocks.distribution.DirectionBridge,
          _hasJunction: boolean,
          _avoid: Packages.arc.func.Boolf<Packages.mindustry.world.Block>,
        ): void;
        public static calculateBridges(
          _plans: Packages.arc.struct.Seq<Packages.mindustry.entities.units.BuildPlan>,
          _bridge: Packages.mindustry.world.blocks.distribution.ItemBridge,
          _avoid: Packages.arc.func.Boolf<Packages.mindustry.world.Block>,
        ): void;
        public static calculateBridges(
          _plans: Packages.arc.struct.Seq<Packages.mindustry.entities.units.BuildPlan>,
          _bridge: Packages.mindustry.world.blocks.distribution.ItemBridge,
        ): void;
        public static calculateNodes(
          _points: Packages.arc.struct.Seq<Packages.arc.math.geom.Point2>,
          _block: Packages.mindustry.world.Block,
          _rotation: number,
          _overlapper: Packages.arc.func.Boolf2<
            Packages.arc.math.geom.Point2,
            Packages.arc.math.geom.Point2
          >,
        ): void;
        public static isSidePlace(
          _plans: Packages.arc.struct.Seq<Packages.mindustry.entities.units.BuildPlan>,
        ): boolean;
        private static astar(
          _startX: number,
          _startY: number,
          _endX: number,
          _endY: number,
        ): boolean;
        private static validNode(
          _tile: Packages.mindustry.world.Tile,
          _other: Packages.mindustry.world.Tile,
        ): boolean;
        private static tileHeuristic(
          _tile: Packages.mindustry.world.Tile,
          _other: Packages.mindustry.world.Tile,
        ): number;
        private static distanceHeuristic(
          _x1: number,
          _y1: number,
          _x2: number,
          _y2: number,
        ): number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace io {
      declare class JsonIO extends java.lang.Object {
        static CustomJson = class extends Packages.arc.util
          .serialization.Json {
          private baseObject: any;
          protected newInstance(
            _type: Class | Packages.java.lang.Class<any>,
          ): any;
          public fromJson<T>(
            _type: Class<T> | Packages.java.lang.Class<T>,
            _json: string,
          ): T | null;
          public fromBaseJson<T>(
            _type: Class<T> | Packages.java.lang.Class<T>,
            _base: T,
            _json: string,
          ): T | null;
        };
        private static jsonBase: Packages.mindustry.io.JsonIO.CustomJson;
        public static json: Packages.arc.util.serialization.Json;
        static apply(
          _json: Packages.arc.util.serialization.Json,
        ): void;
        public static write(_object: any): string;
        public static read<T>(
          _type: Class<T> | Packages.java.lang.Class<T>,
          _string: string,
        ): T | null;
        public static read<T>(
          _type: Class<T> | Packages.java.lang.Class<T>,
          _base: T,
          _string: string,
        ): T | null;
        public static print(_in: string): string;
        public static copy<T>(_object: T): T | null;
        public static copy<T>(
          _object: T,
          _dest: T,
        ): T | null;
        public static readBytes<T>(
          _type: Class<T> | Packages.java.lang.Class<T>,
          _elementType:
            | Class<any>
            | Packages.java.lang.Class<any>,
          _input: Packages.java.io.DataInputStream,
        ): T | null;
        public static writeBytes(
          _value: any,
          _elementType:
            | Class<any>
            | Packages.java.lang.Class<any>,
          _output: Packages.java.io.DataOutputStream,
        ): void;
        public static classTag(
          _tag: string,
          _type: Class<any> | Packages.java.lang.Class<any>,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace io {
      declare abstract class SaveFileReader extends java
        .lang.Object {
        public static IORunner = class<T> {
          public accept(_stream: T): void;
        };
        public static CustomChunk = class {
          public write(
            _stream: Packages.java.io.DataOutput,
          ): void;
          public read(
            _stream: Packages.java.io.DataInput,
          ): void;
          public shouldWrite(): boolean;
          public writeNet(): boolean;
        };
        public static fallback: Packages.arc.struct.ObjectMap<
          string,
          string
        >;
        public static modContentNameMap: Packages.arc.struct.ObjectMap<
          string,
          string
        >;
        protected byteOutput: Packages.arc.util.io.ReusableByteOutStream;
        protected byteOutput2: Packages.arc.util.io.ReusableByteOutStream;
        protected dataBytes: Packages.java.io.DataOutputStream;
        protected dataBytes2: Packages.java.io.DataOutputStream;
        protected byteOutputSmall: Packages.arc.util.io.ReusableByteOutStream;
        protected dataBytesSmall: Packages.java.io.DataOutputStream;
        protected chunkNested: boolean;
        protected lastRegionLength: number;
        protected currCounter?: Packages.arc.util.io.CounterInputStream;
        public write(
          _stream: Packages.java.io.DataOutputStream,
        ): void;
        public read(
          _stream: Packages.java.io.DataInputStream,
          _counter: Packages.arc.util.io.CounterInputStream,
          _context: Packages.mindustry.world.WorldContext,
        ): void;
        public region(
          _name: string,
          _stream: Packages.java.io.DataInput,
          _counter: Packages.arc.util.io.CounterInputStream,
          _cons: Packages.mindustry.io.SaveFileReader.IORunner<Packages.java.io.DataInput>,
        ): void;
        public region(
          _name: string,
          _stream: Packages.java.io.DataOutput,
          _cons: Packages.mindustry.io.SaveFileReader.IORunner<Packages.java.io.DataOutput>,
        ): void;
        public static mapFallback(_name: string): string;
        public readChunk(
          _input: Packages.java.io.DataInput,
          _isShort: boolean,
          _runner: Packages.mindustry.io.SaveFileReader.IORunner<Packages.java.io.DataInput>,
        ): number;
        public readChunk(
          _input: Packages.java.io.DataInput,
          _runner: Packages.mindustry.io.SaveFileReader.IORunner<Packages.java.io.DataInput>,
        ): number;
        public writeChunk(
          _output: Packages.java.io.DataOutput,
          _isShort: boolean,
          _runner: Packages.mindustry.io.SaveFileReader.IORunner<Packages.java.io.DataOutput>,
        ): void;
        public writeChunk(
          _output: Packages.java.io.DataOutput,
          _runner: Packages.mindustry.io.SaveFileReader.IORunner<Packages.java.io.DataOutput>,
        ): void;
        public skipChunk(
          _input: Packages.java.io.DataInput,
        ): void;
        public skipChunk(
          _input: Packages.java.io.DataInput,
          _isShort: boolean,
        ): void;
        public writeStringMap(
          _stream: Packages.java.io.DataOutput,
          _map: Packages.arc.struct.ObjectMap<
            string,
            string
          >,
        ): void;
        public readStringMap(
          _stream: Packages.java.io.DataInput,
        ): Packages.arc.struct.StringMap;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace io {
      declare abstract class SaveVersion extends Packages
        .mindustry.io.SaveFileReader {
        protected static customChunks: Packages.arc.struct.OrderedMap<
          string,
          Packages.mindustry.io.SaveFileReader.CustomChunk
        >;
        public version: number;
        protected lastReadBuild: number;
        protected entityMapping?: Packages.arc.func.Prov<any>[];
        public write(
          _stream: Packages.java.io.DataOutputStream,
        ): void;
        public write(
          _stream: Packages.java.io.DataOutputStream,
          _extraTags: Packages.arc.struct.StringMap,
        ): void;
        public read(
          _stream: Packages.java.io.DataInputStream,
          _counter: Packages.arc.util.io.CounterInputStream,
          _context: Packages.mindustry.world.WorldContext,
        ): void;
        public getMeta(
          _stream: Packages.java.io.DataInput,
        ): Packages.mindustry.io.SaveMeta;
        public writeMap(
          _stream: Packages.java.io.DataOutput,
        ): void;
        public static addCustomChunk(
          _name: string,
          _chunk: Packages.mindustry.io.SaveFileReader.CustomChunk,
        ): void;
        public writeEntityMapping(
          _stream: Packages.java.io.DataOutput,
        ): void;
        public writeTeamBlocks(
          _stream: Packages.java.io.DataOutput,
        ): void;
        public writeWorldEntities(
          _stream: Packages.java.io.DataOutput,
        ): void;
        public readEntityMapping(
          _stream: Packages.java.io.DataInput,
        ): void;
        public readTeamBlocks(
          _stream: Packages.java.io.DataInput,
        ): void;
        public readWorldEntities(
          _stream: Packages.java.io.DataInput,
        ): void;
        public writeCustomChunks(
          _stream: Packages.java.io.DataOutput,
          _net: boolean,
        ): void;
        public writeMeta(
          _stream: Packages.java.io.DataOutput,
          _tags: Packages.arc.struct.StringMap,
        ): void;
        public readMeta(
          _stream: Packages.java.io.DataInput,
          _context: Packages.mindustry.world.WorldContext,
        ): void;
        public readCustomChunks(
          _stream: Packages.java.io.DataInput,
        ): void;
        public writeEntities(
          _stream: Packages.java.io.DataOutput,
        ): void;
        public writeMarkers(
          _stream: Packages.java.io.DataOutput,
        ): void;
        public readMarkers(
          _stream: Packages.java.io.DataInput,
        ): void;
        public readEntities(
          _stream: Packages.java.io.DataInput,
        ): void;
        public writeContentHeader(
          _stream: Packages.java.io.DataOutput,
        ): void;
        public readMap(
          _stream: Packages.java.io.DataInput,
          _context: Packages.mindustry.world.WorldContext,
        ): void;
        public readContentHeader(
          _stream: Packages.java.io.DataInput,
        ): void;
        public constructor(_version: number);
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace io {
      declare class MapIO extends java.lang.Object {
        private static pngHeader: number[];
        public static createMap(
          _file: Packages.arc.files.Fi,
          _custom: boolean,
        ): Packages.mindustry.maps.Map;
        public static readImage(
          _pixmap: Packages.arc.graphics.Pixmap,
          _tiles: Packages.mindustry.world.Tiles,
        ): void;
        public static loadMap(
          _map: Packages.mindustry.maps.Map,
          _cons: Packages.mindustry.world.WorldContext,
        ): void;
        public static loadMap(
          _map: Packages.mindustry.maps.Map,
        ): void;
        public static writeMap(
          _file: Packages.arc.files.Fi,
          _map: Packages.mindustry.maps.Map,
        ): void;
        public static generatePreview(
          _tiles: Packages.mindustry.world.Tiles,
        ): Packages.arc.graphics.Pixmap;
        public static generatePreview(
          _map: Packages.mindustry.maps.Map,
        ): Packages.arc.graphics.Pixmap;
        public static colorFor(
          _wall: Packages.mindustry.world.Block,
          _floor: Packages.mindustry.world.Block,
          _overlay: Packages.mindustry.world.Block,
          _team: Packages.mindustry.game.Team,
        ): number;
        public static isImage(
          _file: Packages.arc.files.Fi,
        ): boolean;
        public static writeImage(
          _tiles: Packages.mindustry.world.Tiles,
        ): Packages.arc.graphics.Pixmap;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace io {
      declare class SaveIO extends java.lang.Object {
        public static SaveException = class extends Packages
          .java.lang.RuntimeException {
          public constructor(
            _throwable: Packages.java.lang.Throwable,
          );
        };
        public static header: string[];
        public static versions: Packages.arc.struct.IntMap<Packages.mindustry.io.SaveVersion>;
        public static versionArray: Packages.arc.struct.Seq<Packages.mindustry.io.SaveVersion>;
        public static load(
          _file: Packages.arc.files.Fi,
          _context: Packages.mindustry.world.WorldContext,
        ): void;
        public static load(
          _file: Packages.arc.files.Fi,
        ): void;
        public static load(
          _is: Packages.java.io.InputStream,
          _context: Packages.mindustry.world.WorldContext,
        ): void;
        public static load(_saveName: string): void;
        public static write(
          _file: Packages.arc.files.Fi,
          _tags: Packages.arc.struct.StringMap,
        ): void;
        public static write(
          _file: Packages.arc.files.Fi,
        ): void;
        public static write(
          _os: Packages.java.io.OutputStream,
          _tags: Packages.arc.struct.StringMap,
        ): void;
        public static save(
          _file: Packages.arc.files.Fi,
        ): void;
        public static getVersion(): Packages.mindustry.io.SaveVersion;
        public static readHeader(
          _input: Packages.java.io.DataInput,
        ): void;
        public static getMeta(
          _stream: Packages.java.io.DataInputStream,
        ): Packages.mindustry.io.SaveMeta;
        public static getMeta(
          _file: Packages.arc.files.Fi,
        ): Packages.mindustry.io.SaveMeta;
        public static isSaveValid(
          _file: Packages.arc.files.Fi,
        ): boolean;
        public static isSaveValid(
          _stream: Packages.java.io.DataInputStream,
        ): boolean;
        public static backupFileFor(
          _file: Packages.arc.files.Fi,
        ): Packages.arc.files.Fi;
        public static getSaveWriter(
          _version: number,
        ): Packages.mindustry.io.SaveVersion;
        public static getSaveWriter(): Packages.mindustry.io.SaveVersion;
        private static isSaveFileValid(
          _file: Packages.arc.files.Fi,
        ): boolean;
        public static getStream(
          _file: Packages.arc.files.Fi,
        ): Packages.java.io.DataInputStream;
        public static getBackupStream(
          _file: Packages.arc.files.Fi,
        ): Packages.java.io.DataInputStream;
        public static fileFor(
          _slot: number,
        ): Packages.arc.files.Fi;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace io {
      declare class SavePreviewLoader extends Packages.arc
        .assets.loaders.TextureLoader {
        public loadAsync(
          _manager: Packages.arc.assets.AssetManager,
          _fileName: string,
          _file: Packages.arc.files.Fi,
          _parameter: Packages.arc.assets.loaders.TextureLoader.TextureParameter,
        ): void;
        public loadAsync(
          _manager: Packages.arc.assets.AssetManager,
          _fileName: string,
          _file: Packages.arc.files.Fi,
          _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace io {
      declare class TypeIO extends java.lang.Object {
        public static BuildingBox = class
          extends java.lang.Object
          implements
            Packages.mindustry.io.TypeIO
              .Boxed<Packages.mindustry.gen.Building>
        {
          public pos: number;
          public toString(): string;
          public unbox(): Packages.mindustry.gen.Building;
          public unbox(): any;
          public constructor(_pos: number);
        };
        public static UnitBox = class
          extends java.lang.Object
          implements
            Packages.mindustry.io.TypeIO
              .Boxed<Packages.mindustry.gen.Unit>
        {
          public id: number;
          public toString(): string;
          public unbox(): Packages.mindustry.gen.Unit;
          public unbox(): any;
          public constructor(_id: number);
        };
        public static Boxed = class<T> {
          public unbox(): T | null;
        };
        static noMounts: Packages.mindustry.entities.units.WeaponMount[];
        static noAbilities: Packages.mindustry.entities.abilities.Ability[];
        public static readObject(
          _read: Packages.arc.util.io.Reads,
        ): any | null;
        public static writeObject(
          _write: Packages.arc.util.io.Writes,
          _object: any,
        ): void;
        public static readBytes(
          _read: Packages.arc.util.io.Reads,
        ): string[] | null;
        public static writeBytes(
          _write: Packages.arc.util.io.Writes,
          _bytes: string[],
        ): void;
        public static readString(
          _read: Packages.java.nio.ByteBuffer,
        ): string;
        public static readString(
          _read: Packages.arc.util.io.Reads,
        ): string;
        public static writeString(
          _write: Packages.arc.util.io.Writes,
          _string: string,
        ): void;
        public static writeString(
          _write: Packages.java.nio.ByteBuffer,
          _string: string,
        ): void;
        public static readColor(
          _read: Packages.arc.util.io.Reads,
          _color: Packages.arc.graphics.Color,
        ): Packages.arc.graphics.Color;
        public static readColor(
          _read: Packages.arc.util.io.Reads,
        ): Packages.arc.graphics.Color;
        public static readTeam(
          _read: Packages.arc.util.io.Reads,
        ): Packages.mindustry.game.Team;
        public static readUnit(
          _read: Packages.arc.util.io.Reads,
        ): Packages.mindustry.gen.Unit;
        public static readCommand(
          _read: Packages.arc.util.io.Reads,
        ): Packages.mindustry.ai.UnitCommand | null;
        public static writeColor(
          _write: Packages.arc.util.io.Writes,
          _color: Packages.arc.graphics.Color,
        ): void;
        public static writeCommand(
          _write: Packages.arc.util.io.Writes,
          _command: Packages.mindustry.ai.UnitCommand | null,
        ): void;
        public static writeTeam(
          _write: Packages.arc.util.io.Writes,
          _team: Packages.mindustry.game.Team,
        ): void;
        public static writeUnit(
          _write: Packages.arc.util.io.Writes,
          _unit: Packages.mindustry.gen.Unit,
        ): void;
        public static writeBuilding(
          _write: Packages.arc.util.io.Writes,
          _tile: Packages.mindustry.gen.Building,
        ): void;
        public static readBuilding(
          _read: Packages.arc.util.io.Reads,
        ): Packages.mindustry.gen.Building;
        public static writeIntSeq(
          _write: Packages.arc.util.io.Writes,
          _seq: Packages.arc.struct.IntSeq,
        ): void;
        public static readIntSeq(
          _read: Packages.arc.util.io.Reads,
        ): Packages.arc.struct.IntSeq;
        public static readPayload(
          _read: Packages.arc.util.io.Reads,
        ): Packages.mindustry.world.blocks.payloads.Payload;
        public static writePayload(
          _writes: Packages.arc.util.io.Writes,
          _payload: Packages.mindustry.world.blocks.payloads.Payload,
        ): void;
        public static readTile(
          _read: Packages.arc.util.io.Reads,
        ): Packages.mindustry.world.Tile;
        public static writeTile(
          _write: Packages.arc.util.io.Writes,
          _tile: Packages.mindustry.world.Tile,
        ): void;
        public static readVec2(
          _read: Packages.arc.util.io.Reads,
        ): Packages.arc.math.geom.Vec2;
        public static readVec2(
          _read: Packages.arc.util.io.Reads,
          _base: Packages.arc.math.geom.Vec2,
        ): Packages.arc.math.geom.Vec2;
        public static writeVec2(
          _write: Packages.arc.util.io.Writes,
          _v: Packages.arc.math.geom.Vec2,
        ): void;
        public static readObjectBoxed(
          _read: Packages.arc.util.io.Reads,
          _box: boolean,
        ): any | null;
        public static writeEntity(
          _write: Packages.arc.util.io.Writes,
          _entity: Packages.mindustry.gen.Entityc,
        ): void;
        public static writeAction(
          _write: Packages.arc.util.io.Writes,
          _reason: Packages.mindustry.net.Packets.AdminAction,
        ): void;
        public static readEntity<
          T extends Packages.mindustry.gen.Entityc,
        >(_read: Packages.arc.util.io.Reads): T | null;
        public static writeBlock(
          _write: Packages.arc.util.io.Writes,
          _block: Packages.mindustry.world.Block,
        ): void;
        public static readBlock(
          _read: Packages.arc.util.io.Reads,
        ): Packages.mindustry.world.Block;
        public static readAction(
          _read: Packages.arc.util.io.Reads,
        ): Packages.mindustry.net.Packets.AdminAction;
        public static readMounts(
          _read: Packages.arc.util.io.Reads,
        ):
          | Packages.mindustry.entities.units.WeaponMount[]
          | null;
        public static readMounts(
          _read: Packages.arc.util.io.Reads,
          _mounts: Packages.mindustry.entities.units.WeaponMount[],
        ):
          | Packages.mindustry.entities.units.WeaponMount[]
          | null;
        public static readItems(
          _read: Packages.arc.util.io.Reads,
          _stack: Packages.mindustry._type.ItemStack,
        ): Packages.mindustry._type.ItemStack;
        public static readItems(
          _read: Packages.arc.util.io.Reads,
        ): Packages.mindustry._type.ItemStack;
        public static readStatus(
          _read: Packages.arc.util.io.Reads,
        ): Packages.mindustry.entities.units.StatusEntry;
        public static readPlansQueue(
          _read: Packages.arc.util.io.Reads,
        ): Packages.arc.struct.Queue<Packages.mindustry.entities.units.BuildPlan>;
        public static readAbilities(
          _read: Packages.arc.util.io.Reads,
          _abilities: Packages.mindustry.entities.abilities.Ability[],
        ):
          | Packages.mindustry.entities.abilities.Ability[]
          | null;
        public static readAbilities(
          _read: Packages.arc.util.io.Reads,
        ):
          | Packages.mindustry.entities.abilities.Ability[]
          | null;
        public static writeAbilities(
          _write: Packages.arc.util.io.Writes,
          _abilities: Packages.mindustry.entities.abilities.Ability[],
        ): void;
        public static writeController(
          _write: Packages.arc.util.io.Writes,
          _control: Packages.mindustry.entities.units.UnitController,
        ): void;
        public static readController(
          _read: Packages.arc.util.io.Reads,
          _prev: Packages.mindustry.entities.units.UnitController,
        ): Packages.mindustry.entities.units.UnitController;
        public static writeBulletType(
          _write: Packages.arc.util.io.Writes,
          _type: Packages.mindustry.entities.bullet.BulletType,
        ): void;
        public static writeWeather(
          _write: Packages.arc.util.io.Writes,
          _item: Packages.mindustry._type.Weather,
        ): void;
        public static readWeather(
          _read: Packages.arc.util.io.Reads,
        ): Packages.mindustry._type.Weather;
        public static readBulletType(
          _read: Packages.arc.util.io.Reads,
        ): Packages.mindustry.entities.bullet.BulletType;
        public static writeMounts(
          _writes: Packages.arc.util.io.Writes,
          _mounts: Packages.mindustry.entities.units.WeaponMount[],
        ): void;
        public static writePlan(
          _write: Packages.arc.util.io.Writes,
          _plan: Packages.mindustry.entities.units.BuildPlan,
        ): void;
        public static writeItems(
          _write: Packages.arc.util.io.Writes,
          _stack: Packages.mindustry._type.ItemStack,
        ): void;
        public static writeStatus(
          _write: Packages.arc.util.io.Writes,
          _entry: Packages.mindustry.entities.units.StatusEntry,
        ): void;
        public static writePlansQueueNet(
          _write: Packages.arc.util.io.Writes,
          _plans: Packages.arc.struct.Queue<Packages.mindustry.entities.units.BuildPlan>,
        ): void;
        public static readEffect(
          _read: Packages.arc.util.io.Reads,
        ): Packages.mindustry.entities.Effect;
        public static writeEffect(
          _write: Packages.arc.util.io.Writes,
          _effect: Packages.mindustry.entities.Effect,
        ): void;
        public static writeStringArray(
          _write: Packages.arc.util.io.Writes,
          _strings: string[][],
        ): void;
        public static readStringArray(
          _read: Packages.arc.util.io.Reads,
        ): string[][] | null;
        public static writeKick(
          _write: Packages.arc.util.io.Writes,
          _reason: Packages.mindustry.net.Packets.KickReason,
        ): void;
        public static readKick(
          _read: Packages.arc.util.io.Reads,
        ): Packages.mindustry.net.Packets.KickReason;
        public static writeItem(
          _write: Packages.arc.util.io.Writes,
          _item: Packages.mindustry._type.Item,
        ): void;
        public static readItem(
          _read: Packages.arc.util.io.Reads,
        ): Packages.mindustry._type.Item;
        public static writeContent(
          _write: Packages.arc.util.io.Writes,
          _cont: Packages.mindustry.ctype.Content,
        ): void;
        public static readContent(
          _read: Packages.arc.util.io.Reads,
        ): Packages.mindustry.ctype.Content;
        public static writeRules(
          _write: Packages.arc.util.io.Writes,
          _rules: Packages.mindustry.game.Rules,
        ): void;
        public static readRules(
          _read: Packages.arc.util.io.Reads,
        ): Packages.mindustry.game.Rules;
        public static writeObjectives(
          _write: Packages.arc.util.io.Writes,
          _executor: Packages.mindustry.game.MapObjectives,
        ): void;
        public static readObjectives(
          _read: Packages.arc.util.io.Reads,
        ): Packages.mindustry.game.MapObjectives;
        public static writeSound(
          _write: Packages.arc.util.io.Writes,
          _sound: Packages.arc.audio.Sound,
        ): void;
        public static readSound(
          _read: Packages.arc.util.io.Reads,
        ): Packages.arc.audio.Sound;
        public static writeUnitType(
          _write: Packages.arc.util.io.Writes,
          _effect: Packages.mindustry._type.UnitType,
        ): void;
        public static readUnitType(
          _read: Packages.arc.util.io.Reads,
        ): Packages.mindustry._type.UnitType;
        public static writeTraceInfo(
          _write: Packages.arc.util.io.Writes,
          _trace: Packages.mindustry.net.Administration.TraceInfo,
        ): void;
        public static readTraceInfo(
          _read: Packages.arc.util.io.Reads,
        ): Packages.mindustry.net.Administration.TraceInfo;
        public static readLiquid(
          _read: Packages.arc.util.io.Reads,
        ): Packages.mindustry._type.Liquid;
        public static writeStringData(
          _buffer: Packages.java.io.DataOutput,
          _string: string,
        ): void;
        public static readStringData(
          _buffer: Packages.java.io.DataInput,
        ): string;
        public static getMaxPlans(
          _plans: Packages.arc.struct.Queue<Packages.mindustry.entities.units.BuildPlan>,
        ): number;
        public static readPlan(
          _read: Packages.arc.util.io.Reads,
        ): Packages.mindustry.entities.units.BuildPlan;
        public static writeStance(
          _write: Packages.arc.util.io.Writes,
          _stance: Packages.mindustry.ai.UnitStance | null,
        ): void;
        public static readStance(
          _read: Packages.arc.util.io.Reads,
        ): Packages.mindustry.ai.UnitStance;
        public static writeStrings(
          _write: Packages.arc.util.io.Writes,
          _strings: string[],
          _maxLen: number,
        ): void;
        public static writeStrings(
          _write: Packages.arc.util.io.Writes,
          _strings: string[],
        ): void;
        public static readStrings(
          _read: Packages.arc.util.io.Reads,
        ): string[] | null;
        public static writePlans(
          _write: Packages.arc.util.io.Writes,
          _plans: Packages.mindustry.entities.units.BuildPlan[],
        ): void;
        public static readPlans(
          _read: Packages.arc.util.io.Reads,
        ):
          | Packages.mindustry.entities.units.BuildPlan[]
          | null;
        public static writeMarkerControl(
          _write: Packages.arc.util.io.Writes,
          _reason: Packages.mindustry.logic.LMarkerControl,
        ): void;
        public static readMarkerControl(
          _read: Packages.arc.util.io.Reads,
        ): Packages.mindustry.logic.LMarkerControl;
        public static writeObjectiveMarker(
          _write: Packages.arc.util.io.Writes,
          _marker: Packages.mindustry.game.MapObjectives.ObjectiveMarker,
        ): void;
        public static readObjectiveMarker(
          _read: Packages.arc.util.io.Reads,
        ): Packages.mindustry.game.MapObjectives.ObjectiveMarker;
        public static writeVecNullable(
          _write: Packages.arc.util.io.Writes,
          _v: Packages.arc.math.geom.Vec2 | null,
        ): void;
        public static readVecNullable(
          _read: Packages.arc.util.io.Reads,
        ): Packages.arc.math.geom.Vec2 | null;
        public static writeLiquid(
          _write: Packages.arc.util.io.Writes,
          _liquid: Packages.mindustry._type.Liquid,
        ): void;
        public static readInts(
          _read: Packages.arc.util.io.Reads,
        ): number[] | null;
        public static writeInts(
          _write: Packages.arc.util.io.Writes,
          _ints: number[],
        ): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare class LParser extends java.lang.Object {
        static JumpIndex = class extends java.lang.Object {
          jump: Packages.mindustry.logic.LStatements.JumpStatement;
          location: string;
          public constructor(
            _jump: Packages.mindustry.logic.LStatements.JumpStatement,
            _location: string,
          );
        };
        private static tokens: string[];
        private static maxJumps: number;
        private static opNameChanges: Packages.arc.struct.StringMap;
        private static jumps: Packages.arc.struct.Seq<Packages.mindustry.logic.LParser.JumpIndex>;
        private static jumpLocations: Packages.arc.struct.ObjectIntMap<string>;
        statements: Packages.arc.struct.Seq<Packages.mindustry.logic.LStatement>;
        chars: string[];
        pos: number;
        line: number;
        tok: number;
        privileged: boolean;
        checkRead(): void;
        comment(): void;
        parse(): Packages.arc.struct.Seq<Packages.mindustry.logic.LStatement>;
        error(_message: string): void;
        string(): string;
        token(): string;
        statement(): void;
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace logic {
      declare class LStatements extends java.lang.Object {
        public static LocalePrintStatement = class extends Packages
          .mindustry.logic.LStatement {
          public value: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          public privileged(): boolean;
          public constructor();
        };
        public static MakeMarkerStatement = class extends Packages
          .mindustry.logic.LStatement {
          public type: string;
          public id: string;
          public x: string;
          public y: string;
          public replace: string;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public category(): Packages.mindustry.logic.LCategory;
          public privileged(): boolean;
          public constructor();
        };
        public static SetMarkerStatement = class extends Packages
          .mindustry.logic.LStatement {
          public type: Packages.mindustry.logic.LMarkerControl;
          public id: string;
          public p1: string;
          public p2: string;
          public p3: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          rebuild(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public privileged(): boolean;
          public constructor();
        };
        public static PlaySoundStatement = class extends Packages
          .mindustry.logic.LStatement {
          public positional: boolean;
          public id: string;
          public volume: string;
          public pitch: string;
          public pan: string;
          public x: string;
          public y: string;
          public limit: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          rebuild(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public privileged(): boolean;
          public constructor();
        };
        public static SetPropStatement = class extends Packages
          .mindustry.logic.LStatement {
          public type: string;
          public of: string;
          public value: string;
          private selected: number;
          private tfield: Packages.arc.scene.ui.TextField;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          public privileged(): boolean;
          private stype(_text: string): void;
          public constructor();
        };
        public static SetFlagStatement = class extends Packages
          .mindustry.logic.LStatement {
          public flag: string;
          public value: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          public privileged(): boolean;
          public constructor();
        };
        public static GetFlagStatement = class extends Packages
          .mindustry.logic.LStatement {
          public result: string;
          public flag: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          public privileged(): boolean;
          public constructor();
        };
        public static ClientDataStatement = class extends Packages
          .mindustry.logic.LStatement {
          public channel: string;
          public value: string;
          public reliable: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          public hidden(): boolean;
          public privileged(): boolean;
          public constructor();
        };
        public static SyncStatement = class extends Packages
          .mindustry.logic.LStatement {
          public variable: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          public privileged(): boolean;
          public constructor();
        };
        public static FetchStatement = class extends Packages
          .mindustry.logic.LStatement {
          public type: Packages.mindustry.logic.FetchType;
          public result: string;
          public team: string;
          public index: string;
          public extra: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          rebuild(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public privileged(): boolean;
          public constructor();
        };
        public static SetRateStatement = class extends Packages
          .mindustry.logic.LStatement {
          public amount: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          public privileged(): boolean;
          public constructor();
        };
        public static ExplosionStatement = class extends Packages
          .mindustry.logic.LStatement {
          public team: string;
          public x: string;
          public y: string;
          public radius: string;
          public damage: string;
          public air: string;
          public ground: string;
          public pierce: string;
          public effect: string;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public build(
            _b: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public category(): Packages.mindustry.logic.LCategory;
          public privileged(): boolean;
          public constructor();
        };
        public static EffectStatement = class extends Packages
          .mindustry.logic.LStatement {
          public type: string;
          public x: string;
          public y: string;
          public sizerot: string;
          public color: string;
          public data: string;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public build(
            _b: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public category(): Packages.mindustry.logic.LCategory;
          public privileged(): boolean;
          public constructor();
        };
        public static CutsceneStatement = class extends Packages
          .mindustry.logic.LStatement {
          public action: Packages.mindustry.logic.CutsceneAction;
          public p1: string;
          public p2: string;
          public p3: string;
          public p4: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          rebuild(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public privileged(): boolean;
          public constructor();
        };
        public static FlushMessageStatement = class extends Packages
          .mindustry.logic.LStatement {
          public type: Packages.mindustry.logic.MessageType;
          public duration: string;
          public outSuccess: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          rebuild(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public privileged(): boolean;
          public constructor();
        };
        public static SetRuleStatement = class extends Packages
          .mindustry.logic.LStatement {
          public rule: Packages.mindustry.logic.LogicRule;
          public value: string;
          public p1: string;
          public p2: string;
          public p3: string;
          public p4: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          rebuild(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public privileged(): boolean;
          public constructor();
        };
        public static SpawnWaveStatement = class extends Packages
          .mindustry.logic.LStatement {
          public x: string;
          public y: string;
          public natural: string;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public category(): Packages.mindustry.logic.LCategory;
          public privileged(): boolean;
          public constructor();
        };
        public static WeatherSetStatement = class extends Packages
          .mindustry.logic.LStatement {
          public weather: string;
          public state: string;
          private tfield: Packages.arc.scene.ui.TextField;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public category(): Packages.mindustry.logic.LCategory;
          public privileged(): boolean;
          public constructor();
        };
        public static WeatherSenseStatement = class extends Packages
          .mindustry.logic.LStatement {
          public to: string;
          public weather: string;
          private tfield: Packages.arc.scene.ui.TextField;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public category(): Packages.mindustry.logic.LCategory;
          public privileged(): boolean;
          public constructor();
        };
        public static ApplyStatusStatement = class extends Packages
          .mindustry.logic.LStatement {
          public clear: boolean;
          public effect: string;
          public unit: string;
          public duration: string;
          private static statusNames?: string[];
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          rebuild(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public privileged(): boolean;
          public constructor();
        };
        public static SpawnUnitStatement = class extends Packages
          .mindustry.logic.LStatement {
          public type: string;
          public x: string;
          public y: string;
          public rotation: string;
          public team: string;
          public result: string;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public category(): Packages.mindustry.logic.LCategory;
          public privileged(): boolean;
          public constructor();
        };
        public static SetBlockStatement = class extends Packages
          .mindustry.logic.LStatement {
          public layer: Packages.mindustry.logic.TileLayer;
          public block: string;
          public x: string;
          public y: string;
          public team: string;
          public rotation: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          rebuild(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public privileged(): boolean;
          public constructor();
        };
        public static GetBlockStatement = class extends Packages
          .mindustry.logic.LStatement {
          public layer: Packages.mindustry.logic.TileLayer;
          public result: string;
          public x: string;
          public y: string;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public category(): Packages.mindustry.logic.LCategory;
          public privileged(): boolean;
          public constructor();
        };
        public static UnitLocateStatement = class extends Packages
          .mindustry.logic.LStatement {
          public locate: Packages.mindustry.logic.LLocate;
          public flag: Packages.mindustry.world.meta.BlockFlag;
          public enemy: string;
          public ore: string;
          public outX: string;
          public outY: string;
          public outFound: string;
          public outBuild: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          rebuild(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public constructor();
        };
        public static UnitRadarStatement = class extends Packages
          .mindustry.logic.LStatements.RadarStatement {
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public category(): Packages.mindustry.logic.LCategory;
          public buildFrom(): boolean;
          public constructor();
        };
        public static UnitControlStatement = class extends Packages
          .mindustry.logic.LStatement {
          public type: Packages.mindustry.logic.LUnitControl;
          public p1: string;
          public p2: string;
          public p3: string;
          public p4: string;
          public p5: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          rebuild(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public constructor();
        };
        public static UnitBindStatement = class extends Packages
          .mindustry.logic.LStatement {
          public type: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          public constructor();
        };
        public static JumpStatement = class extends Packages
          .mindustry.logic.LStatement {
          private static last: Packages.arc.graphics.Color;
          public dest: Packages.mindustry.logic.LCanvas.StatementElem;
          public destIndex: number;
          public op: Packages.mindustry.logic.ConditionOp;
          public value: string;
          public compare: string;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public category(): Packages.mindustry.logic.LCategory;
          rebuild(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public setupUI(): void;
          public saveUI(): void;
          public constructor();
        };
        public static EndStatement = class extends Packages
          .mindustry.logic.LStatement {
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          public constructor();
        };
        public static PackColorStatement = class extends Packages
          .mindustry.logic.LStatement {
          public result: string;
          public r: string;
          public g: string;
          public b: string;
          public a: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          public constructor();
        };
        public static LookupStatement = class extends Packages
          .mindustry.logic.LStatement {
          public type: Packages.mindustry.ctype.ContentType;
          public result: string;
          public id: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          public constructor();
        };
        public static StopStatement = class extends Packages
          .mindustry.logic.LStatement {
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          public constructor();
        };
        public static WaitStatement = class extends Packages
          .mindustry.logic.LStatement {
          public value: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          public constructor();
        };
        public static OperationStatement = class extends Packages
          .mindustry.logic.LStatement {
          public op: Packages.mindustry.logic.LogicOp;
          public dest: string;
          public a: string;
          public b: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          rebuild(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          opButton(
            _table: Packages.arc.scene.ui.layout.Table,
            _parent: Packages.arc.scene.ui.layout.Table,
          ): void;
          funcs(
            _table: Packages.arc.scene.ui.layout.Table,
            _parent: Packages.arc.scene.ui.layout.Table,
          ): void;
          public constructor();
        };
        public static SetStatement = class extends Packages
          .mindustry.logic.LStatement {
          public to: string;
          public from: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          public constructor();
        };
        public static SensorStatement = class extends Packages
          .mindustry.logic.LStatement {
          public to: string;
          public from: string;
          public type: string;
          private selected: number;
          private tfield: Packages.arc.scene.ui.TextField;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public category(): Packages.mindustry.logic.LCategory;
          private stype(_text: string): void;
          public constructor();
        };
        public static RadarStatement = class extends Packages
          .mindustry.logic.LStatement {
          public target1: Packages.mindustry.logic.RadarTarget;
          public target2: Packages.mindustry.logic.RadarTarget;
          public target3: Packages.mindustry.logic.RadarTarget;
          public sort: Packages.mindustry.logic.RadarSort;
          public radar: string;
          public sortOrder: string;
          public output: string;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public category(): Packages.mindustry.logic.LCategory;
          public buildFrom(): boolean;
          public constructor();
        };
        public static ControlStatement = class extends Packages
          .mindustry.logic.LStatement {
          public type: Packages.mindustry.logic.LAccess;
          public target: string;
          public p1: string;
          public p2: string;
          public p3: string;
          public p4: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          rebuild(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public constructor();
        };
        public static GetLinkStatement = class extends Packages
          .mindustry.logic.LStatement {
          public output: string;
          public address: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          public constructor();
        };
        public static PrintFlushStatement = class extends Packages
          .mindustry.logic.LStatement {
          public target: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          public constructor();
        };
        public static DrawFlushStatement = class extends Packages
          .mindustry.logic.LStatement {
          public target: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          public constructor();
        };
        public static FormatStatement = class extends Packages
          .mindustry.logic.LStatement {
          public value: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          public constructor();
        };
        public static PrintStatement = class extends Packages
          .mindustry.logic.LStatement {
          public value: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          public constructor();
        };
        public static DrawStatement = class extends Packages
          .mindustry.logic.LStatement {
          static aligns: string[];
          static nameToAlign: Packages.arc.struct.ObjectMap<
            string,
            number
          >;
          public type: Packages.mindustry.world.blocks.logic.LogicDisplay.GraphicsType;
          public x: string;
          public y: string;
          public p1: string;
          public p2: string;
          public p3: string;
          public p4: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          public afterRead(): void;
          rebuild(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public constructor();
        };
        public static WriteStatement = class extends Packages
          .mindustry.logic.LStatement {
          public input: string;
          public target: string;
          public address: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          public constructor();
        };
        public static ReadStatement = class extends Packages
          .mindustry.logic.LStatement {
          public output: string;
          public target: string;
          public address: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public category(): Packages.mindustry.logic.LCategory;
          public constructor();
        };
        public static InvalidStatement = class extends Packages
          .mindustry.logic.LStatement {
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public constructor();
        };
        public static CommentStatement = class extends Packages
          .mindustry.logic.LStatement {
          public comment: string;
          public build(
            _builder: Packages.mindustry.logic.LAssembler,
          ): Packages.mindustry.logic.LExecutor.LInstruction;
          public build(
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public constructor();
        };
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare class MapException extends Packages.java.lang
        .RuntimeException {
        public map: Packages.mindustry.maps.Map;
        public constructor(
          _map: Packages.mindustry.maps.Map,
          _s: string,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare class MapPreviewLoader extends Packages.arc
        .assets.loaders.TextureLoader {
        public static MapPreviewParameter = class extends Packages
          .arc.assets.loaders.TextureLoader
          .TextureParameter {
          public map: Packages.mindustry.maps.Map;
          public constructor(
            _map: Packages.mindustry.maps.Map,
          );
        };
        private static check: Packages.java.lang.Runnable;
        public getDependencies(
          _fileName: string,
          _file: Packages.arc.files.Fi,
          _parameter: Packages.arc.assets.loaders.TextureLoader.TextureParameter,
        ): Packages.arc.struct.Seq<
          Packages.arc.assets.AssetDescriptor<any>
        >;
        public getDependencies(
          _fileName: string,
          _file: Packages.arc.files.Fi,
          _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
        ): Packages.arc.struct.Seq<any>;
        public loadSync(
          _manager: Packages.arc.assets.AssetManager,
          _fileName: string,
          _file: Packages.arc.files.Fi,
          _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
        ): any;
        public loadSync(
          _manager: Packages.arc.assets.AssetManager,
          _fileName: string,
          _file: Packages.arc.files.Fi,
          _parameter: Packages.arc.assets.loaders.TextureLoader.TextureParameter,
        ): Packages.arc.graphics.Texture;
        public loadAsync(
          _manager: Packages.arc.assets.AssetManager,
          _fileName: string,
          _file: Packages.arc.files.Fi,
          _parameter: Packages.arc.assets.AssetLoaderParameters<any>,
        ): void;
        public loadAsync(
          _manager: Packages.arc.assets.AssetManager,
          _fileName: string,
          _file: Packages.arc.files.Fi,
          _parameter: Packages.arc.assets.loaders.TextureLoader.TextureParameter,
        ): void;
        public static setupLoaders(): void;
        public static checkPreviews(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare class SectorDamage extends java.lang.Object {
        public static maxRetWave: number;
        public static maxWavesSimulated: number;
        private static rubble: boolean;
        public static apply(_fraction: number): void;
        static cost(
          _tile: Packages.mindustry.world.Tile,
        ): number;
        public static writeParameters(
          _info: Packages.mindustry.game.SectorInfo,
        ): void;
        public static getDamage(
          _info: Packages.mindustry.game.SectorInfo,
          _wavesPassed: number,
        ): number;
        public static getDamage(
          _info: Packages.mindustry.game.SectorInfo,
        ): number;
        public static getDamage(
          _info: Packages.mindustry.game.SectorInfo,
          _wavesPassed: number,
          _retWave: boolean,
        ): number;
        public static applyCalculatedDamage(): void;
        public static getWavesSurvived(
          _info: Packages.mindustry.game.SectorInfo,
        ): number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace mod {
      declare class ClassMap extends java.lang.Object {
        public static classes: Packages.arc.struct.ObjectMap<
          string,
          Packages.java.lang.Class<any>
        >;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace mod {
      declare abstract class Plugin extends Packages
        .mindustry.mod.Mod {
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace java {
    declare namespace util {
      declare namespace concurrent {
        declare class CopyOnWriteArrayList<E> {}
      }
    }
  }
}
declare namespace Packages {
  declare namespace net {
    declare namespace jpountz {
      declare namespace lz4 {
        declare abstract class LZ4Decompressor {
          public decompress(
            _arg0: string[],
            _arg1: number,
            _arg2: string[],
            _arg3: number,
            _arg4: number,
          ): number;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace net {
    declare namespace jpountz {
      declare namespace lz4 {
        declare abstract class LZ4FastDecompressor
          extends java.lang.Object
          implements
            Packages.net.jpountz.lz4.LZ4Decompressor
        {
          public toString(): string;
          public decompress(
            _arg0: string[],
            _arg1: number,
            _arg2: number,
          ): string[] | null;
          public decompress(
            _arg0: string[],
            _arg1: number,
          ): string[] | null;
          public decompress(
            _arg0: Packages.java.nio.ByteBuffer,
            _arg1: Packages.java.nio.ByteBuffer,
          ): void;
          public decompress(
            _arg0: string[],
            _arg1: string[],
          ): number;
          public decompress(
            _arg0: string[],
            _arg1: number,
            _arg2: string[],
            _arg3: number,
            _arg4: number,
          ): number;
          public decompress(
            _arg0: string[],
            _arg1: string[],
            _arg2: number,
          ): number;
          public decompress(
            _arg0: Packages.java.nio.ByteBuffer,
            _arg1: number,
            _arg2: Packages.java.nio.ByteBuffer,
            _arg3: number,
            _arg4: number,
          ): number;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace net {
    declare namespace jpountz {
      declare namespace lz4 {
        declare abstract class LZ4Compressor extends java
          .lang.Object {
          public toString(): string;
          public compress(
            _arg0: string[],
            _arg1: number,
            _arg2: number,
          ): string[] | null;
          public compress(_arg0: string[]): string[] | null;
          public compress(
            _arg0: Packages.java.nio.ByteBuffer,
            _arg1: Packages.java.nio.ByteBuffer,
          ): void;
          public compress(
            _arg0: string[],
            _arg1: string[],
          ): number;
          public compress(
            _arg0: string[],
            _arg1: number,
            _arg2: number,
            _arg3: string[],
            _arg4: number,
            _arg5: number,
          ): number;
          public compress(
            _arg0: string[],
            _arg1: number,
            _arg2: number,
            _arg3: string[],
            _arg4: number,
          ): number;
          public compress(
            _arg0: Packages.java.nio.ByteBuffer,
            _arg1: number,
            _arg2: number,
            _arg3: Packages.java.nio.ByteBuffer,
            _arg4: number,
            _arg5: number,
          ): number;
          public maxCompressedLength(_arg0: number): number;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace net {
      declare class ArcNetProvider
        extends java.lang.Object
        implements Packages.mindustry.net.Net.NetProvider
      {
        public static PacketSerializer = class
          extends java.lang.Object
          implements Packages.arc.net.NetSerializer
        {
          private static debug: boolean;
          decompressBuffer: Packages.java.lang.ThreadLocal<Packages.java.nio.ByteBuffer>;
          reads: Packages.java.lang.ThreadLocal<Packages.arc.util.io.Reads>;
          writes: Packages.java.lang.ThreadLocal<Packages.arc.util.io.Writes>;
          static upload: Packages.arc.math.WindowedMean;
          static download: Packages.arc.math.WindowedMean;
          static lastUpload: Packages.long;
          static lastDownload: Packages.long;
          static uploadAccum: Packages.long;
          static downloadAccum: Packages.long;
          static lastPos: number;
          public write(
            _byteBuffer: Packages.java.nio.ByteBuffer,
            _o: any,
          ): void;
          public read(
            _byteBuffer: Packages.java.nio.ByteBuffer,
          ): any;
          public readFramework(
            _buffer: Packages.java.nio.ByteBuffer,
          ): Packages.arc.net.FrameworkMessage;
          public writeFramework(
            _buffer: Packages.java.nio.ByteBuffer,
            _message: Packages.arc.net.FrameworkMessage,
          ): void;
          public constructor();
        };
        ArcConnection = class extends Packages.mindustry.net
          .NetConnection {
          public connection: Packages.arc.net.Connection;
          this$0: Packages.mindustry.net.ArcNetProvider;
          public close(): void;
          public send(
            _object: any,
            _reliable: boolean,
          ): void;
          public isConnected(): boolean;
          public sendStream(
            _stream: Packages.mindustry.net.Streamable,
          ): void;
          public constructor(
            _this$0: Packages.mindustry.net.ArcNetProvider,
            _address: string,
            _connection: Packages.arc.net.Connection,
          );
        };
        client: Packages.arc.net.Client;
        packetSupplier: Packages.arc.func.Prov<Packages.java.net.DatagramPacket>;
        server: Packages.arc.net.Server;
        connections: Packages.java.util.concurrent.CopyOnWriteArrayList<Packages.mindustry.net.ArcNetProvider.ArcConnection>;
        serverThread: Packages.java.lang.Thread;
        private static decompressor: Packages.net.jpountz.lz4.LZ4FastDecompressor;
        private static compressor: Packages.net.jpountz.lz4.LZ4Compressor;
        private playerLimitCache: number;
        private packetSpamLimit: number;
        public dispose(): void;
        public setConnectFilter(
          _connectFilter: Packages.arc.net.Server.ServerConnectFilter,
        ): void;
        public getConnectFilter(): Packages.arc.net.Server.ServerConnectFilter | null;
        public getConnections(): Packages.java.lang.Iterable<Packages.mindustry.net.ArcNetProvider.ArcConnection>;
        public disconnectClient(): void;
        public closeServer(): void;
        public connectClient(
          _ip: string,
          _port: number,
          _success: Packages.java.lang.Runnable,
        ): void;
        public sendClient(
          _object: any,
          _reliable: boolean,
        ): void;
        public discoverServers(
          _callback: Packages.arc.func.Cons<Packages.mindustry.net.Host>,
          _done: Packages.java.lang.Runnable,
        ): void;
        public pingHost(
          _address: string,
          _port: number,
          _valid: Packages.arc.func.Cons<Packages.mindustry.net.Host>,
          _invalid: Packages.arc.func.Cons<Packages.java.lang.Exception>,
        ): void;
        public hostServer(_port: number): void;
        private static isLocal(
          _addr: Packages.java.net.InetAddress,
        ): boolean;
        private pingHostImpl(
          _address: string,
          _port: number,
        ): Packages.mindustry.net.Host;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace net {
      declare class CrashSender extends java.lang.Object {
        public static log(
          _exception: Packages.java.lang.Throwable,
        ): void;
        private static ret(): void;
        public static send(
          _exception: Packages.java.lang.Throwable,
          _writeListener: Packages.arc.func.Cons<Packages.java.io.File>,
        ): void;
        public static createReport(_error: string): string;
        private static writeException(
          _e: Packages.java.lang.Throwable,
        ): string;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace net {
      declare class NetworkIO extends java.lang.Object {
        private static readString(
          _buffer: Packages.java.nio.ByteBuffer,
        ): string;
        private static writeString(
          _buffer: Packages.java.nio.ByteBuffer,
          _string: string,
          _maxlen: number,
        ): void;
        private static writeString(
          _buffer: Packages.java.nio.ByteBuffer,
          _string: string,
        ): void;
        public static writeWorld(
          _player: Packages.mindustry.gen.Player,
          _os: Packages.java.io.OutputStream,
        ): void;
        public static loadWorld(
          _is: Packages.java.io.InputStream,
        ): void;
        public static readServerData(
          _ping: number,
          _hostAddress: string,
          _buffer: Packages.java.nio.ByteBuffer,
        ): Packages.mindustry.net.Host;
        public static writeServerData(): Packages.java.nio.ByteBuffer;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace net {
      declare class Packets extends java.lang.Object {
        public static ConnectPacket = class extends Packages
          .mindustry.net.Packet {
          public version: number;
          public versionType: string;
          public mods: Packages.arc.struct.Seq<string>;
          public name: string;
          public locale: string;
          public uuid: string;
          public usid: string;
          public mobile: boolean;
          public color: number;
          public write(
            _buffer: Packages.arc.util.io.Writes,
          ): void;
          public read(
            _buffer: Packages.arc.util.io.Reads,
          ): void;
          public constructor();
        };
        public static StreamChunk = class extends Packages
          .mindustry.net.Packet {
          public id: number;
          public data: string[];
          public write(
            _buffer: Packages.arc.util.io.Writes,
          ): void;
          public read(
            _buffer: Packages.arc.util.io.Reads,
          ): void;
          public constructor();
        };
        public static StreamBegin = class extends Packages
          .mindustry.net.Packet {
          private static lastid: number;
          public id: number;
          public total: number;
          public type: string;
          public write(
            _buffer: Packages.arc.util.io.Writes,
          ): void;
          public read(
            _buffer: Packages.arc.util.io.Reads,
          ): void;
          public constructor();
        };
        public static WorldStream = class extends Packages
          .mindustry.net.Streamable {
          public constructor();
        };
        public static Disconnect = class extends Packages
          .mindustry.net.Packet {
          public reason: string;
          public getPriority(): number;
          public constructor();
        };
        public static Connect = class extends Packages
          .mindustry.net.Packet {
          public addressTCP: string;
          public getPriority(): number;
          public constructor();
        };
        public static AdminAction = class extends Packages
          .java.lang
          .Enum<Packages.mindustry.net.Packets.AdminAction> {
          public static kick: Packages.mindustry.net.Packets.AdminAction;
          public static ban: Packages.mindustry.net.Packets.AdminAction;
          public static trace: Packages.mindustry.net.Packets.AdminAction;
          public static wave: Packages.mindustry.net.Packets.AdminAction;
          public static switchTeam: Packages.mindustry.net.Packets.AdminAction;
          public static all: Packages.mindustry.net.Packets.AdminAction[];
          private static $VALUES: Packages.mindustry.net.Packets.AdminAction[];
          public static values():
            | Packages.mindustry.net.Packets.AdminAction[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.mindustry.net.Packets.AdminAction;
        };
        public static KickReason = class extends Packages
          .java.lang
          .Enum<Packages.mindustry.net.Packets.KickReason> {
          public static kick: Packages.mindustry.net.Packets.KickReason;
          public static clientOutdated: Packages.mindustry.net.Packets.KickReason;
          public static serverOutdated: Packages.mindustry.net.Packets.KickReason;
          public static banned: Packages.mindustry.net.Packets.KickReason;
          public static gameover: Packages.mindustry.net.Packets.KickReason;
          public static recentKick: Packages.mindustry.net.Packets.KickReason;
          public static nameInUse: Packages.mindustry.net.Packets.KickReason;
          public static idInUse: Packages.mindustry.net.Packets.KickReason;
          public static nameEmpty: Packages.mindustry.net.Packets.KickReason;
          public static customClient: Packages.mindustry.net.Packets.KickReason;
          public static serverClose: Packages.mindustry.net.Packets.KickReason;
          public static vote: Packages.mindustry.net.Packets.KickReason;
          public static typeMismatch: Packages.mindustry.net.Packets.KickReason;
          public static whitelist: Packages.mindustry.net.Packets.KickReason;
          public static playerLimit: Packages.mindustry.net.Packets.KickReason;
          public static serverRestarting: Packages.mindustry.net.Packets.KickReason;
          public static all: Packages.mindustry.net.Packets.KickReason[];
          public quiet: boolean;
          private static $VALUES: Packages.mindustry.net.Packets.KickReason[];
          public toString(): string;
          public static values():
            | Packages.mindustry.net.Packets.KickReason[]
            | null;
          public static valueOf(
            _name: string,
          ): Packages.mindustry.net.Packets.KickReason;
          public extraText(): string;
        };
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace net {
      declare class ValidateException extends Packages.java
        .lang.RuntimeException {
        public player: Packages.mindustry.gen.Player;
        public constructor(
          _player: Packages.mindustry.gen.Player,
          _s: string,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare class CellLiquid extends Packages.mindustry
        ._type.Liquid {
        public colorFrom: Packages.arc.graphics.Color;
        public colorTo: Packages.arc.graphics.Color;
        public cells: number;
        public spreadTarget?: Packages.mindustry._type.Liquid;
        public maxSpread: number;
        public spreadConversion: number;
        public spreadDamage: number;
        public removeScaling: number;
        public update(
          _puddle: Packages.mindustry.gen.Puddle,
        ): void;
        public drawPuddle(
          _puddle: Packages.mindustry.gen.Puddle,
        ): void;
        public react(
          _other: Packages.mindustry._type.Liquid,
          _amount: number,
          _tile: Packages.mindustry.world.Tile,
          _x: number,
          _y: number,
        ): number;
        public constructor(
          _name: string,
          _color: Packages.arc.graphics.Color,
        );
        public constructor(_name: string);
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare class ErrorContent extends Packages.mindustry
        .ctype.Content {
        public getContentType(): Packages.mindustry.ctype.ContentType;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare class Fonts extends java.lang.Object {
        private static mainFont: string;
        private static unscaled: Packages.arc.struct.ObjectSet<string>;
        private static unicodeIcons: Packages.arc.struct.ObjectIntMap<string>;
        private static stringIcons: Packages.arc.struct.ObjectMap<
          string,
          string
        >;
        private static largeIcons: Packages.arc.struct.ObjectMap<
          string,
          Packages.arc.graphics.g2d.TextureRegion
        >;
        public static def: Packages.arc.graphics.g2d.Font;
        public static outline: Packages.arc.graphics.g2d.Font;
        public static icon: Packages.arc.graphics.g2d.Font;
        public static iconLarge: Packages.arc.graphics.g2d.Font;
        public static tech: Packages.arc.graphics.g2d.Font;
        public static logic: Packages.arc.graphics.g2d.Font;
        public static getGlyph(
          _font: Packages.arc.graphics.g2d.Font,
          _glyph: string,
        ): Packages.arc.scene.style.TextureRegionDrawable;
        public static loadSystemCursors(): void;
        public static loadDefaultFont(): void;
        public static mergeFontAtlas(
          _atlas: Packages.arc.graphics.g2d.TextureAtlas,
        ): void;
        public static getUnicodeStr(
          _content: string,
        ): string;
        public static getUnicode(_content: string): number;
        public static hasUnicodeStr(
          _content: string,
        ): boolean;
        public static getLargeIcon(
          _name: string,
        ): Packages.arc.graphics.g2d.TextureRegion;
        public static loadFonts(): void;
        public static loadContentIcons(): void;
        public static cursorScale(): number;
        public static unicodeToName(
          _unicode: number,
        ): string | null;
        static fontParameter(): Packages.arc.freetype.FreeTypeFontGenerator.FreeTypeFontParameter;
        public static loadContentIconsHeadless(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare class ItemDisplay extends Packages.arc.scene
        .ui.layout.Table {
        public item: Packages.mindustry._type.Item;
        public amount: number;
        public constructor(
          _item: Packages.mindustry._type.Item,
          _amount: number,
          _timePeriod: number,
          _showName: boolean,
        );
        public constructor(
          _item: Packages.mindustry._type.Item,
          _amount: number,
        );
        public constructor(
          _item: Packages.mindustry._type.Item,
          _amount: number,
          _showName: boolean,
        );
        public constructor(
          _item: Packages.mindustry._type.Item,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare class Links extends java.lang.Object {
        public static LinkEntry = class extends java.lang
          .Object {
          public name: string;
          public title: string;
          public description: string;
          public link: string;
          public color: Packages.arc.graphics.Color;
          public icon: Packages.arc.scene.style.Drawable;
          public constructor(
            _name: string,
            _link: string,
            _icon: Packages.arc.scene.style.Drawable,
            _color: Packages.arc.graphics.Color,
          );
        };
        private static links: Packages.mindustry.ui.Links.LinkEntry[];
        public static getLinks():
          | Packages.mindustry.ui.Links.LinkEntry[]
          | null;
        private static report(): string;
        private static createLinks(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare class LiquidDisplay extends Packages.arc.scene
        .ui.layout.Table {
        public liquid: Packages.mindustry._type.Liquid;
        public amount: number;
        public perSecond: boolean;
        public constructor(
          _liquid: Packages.mindustry._type.Liquid,
          _amount: number,
          _perSecond: boolean,
        );
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare class Menus extends java.lang.Object {
        public static MenuListener = class {
          public get(
            _player: Packages.mindustry.gen.Player,
            _option: number,
          ): void;
        };
        public static TextInputListener = class {
          public get(
            _player: Packages.mindustry.gen.Player,
            _text: string | null,
          ): void;
        };
        private static menuListeners: Packages.arc.struct.Seq<Packages.mindustry.ui.Menus.MenuListener>;
        private static textInputListeners: Packages.arc.struct.Seq<Packages.mindustry.ui.Menus.TextInputListener>;
        public static label(
          _message: string,
          _duration: number,
          _worldx: number,
          _worldy: number,
        ): void;
        public static openURI(_uri: string): void;
        public static menu(
          _menuId: number,
          _title: string,
          _message: string,
          _options: string[][],
        ): void;
        public static announce(_message: string): void;
        public static hideFollowUpMenu(
          _menuId: number,
        ): void;
        public static infoMessage(_message: string): void;
        public static setHudText(_message: string): void;
        public static menuChoose(
          _player: Packages.mindustry.gen.Player | null,
          _menuId: number,
          _option: number,
        ): void;
        public static textInputResult(
          _player: Packages.mindustry.gen.Player | null,
          _textInputId: number,
          _text: string | null,
        ): void;
        public static followUpMenu(
          _menuId: number,
          _title: string,
          _message: string,
          _options: string[][],
        ): void;
        public static hideHudText(): void;
        public static infoPopup(
          _message: string,
          _duration: number,
          _align: number,
          _top: number,
          _left: number,
          _bottom: number,
          _right: number,
        ): void;
        public static infoPopupReliable(
          _message: string,
          _duration: number,
          _align: number,
          _top: number,
          _left: number,
          _bottom: number,
          _right: number,
        ): void;
        public static infoToast(
          _message: string,
          _duration: number,
        ): void;
        public static labelReliable(
          _message: string,
          _duration: number,
          _worldx: number,
          _worldy: number,
        ): void;
        public static removeWorldLabel(_id: number): void;
        public static setHudTextReliable(
          _message: string,
        ): void;
        public static textInput(
          _textInputId: number,
          _title: string,
          _message: string,
          _textLength: number,
          _def: string,
          _numeric: boolean,
        ): void;
        public static textInput(
          _textInputId: number,
          _title: string,
          _message: string,
          _textLength: number,
          _def: string,
          _numeric: boolean,
          _allowEmpty: boolean,
        ): void;
        public static warningToast(
          _unicode: number,
          _text: string,
        ): void;
        public static registerMenu(
          _listener: Packages.mindustry.ui.Menus.MenuListener,
        ): number;
        public static registerTextInput(
          _listener: Packages.mindustry.ui.Menus.TextInputListener,
        ): number;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare class Minimap extends Packages.arc.scene.ui
        .layout.Table {
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare class Styles extends java.lang.Object {
        public static black: Packages.arc.scene.style.Drawable;
        public static black9: Packages.arc.scene.style.Drawable;
        public static black8: Packages.arc.scene.style.Drawable;
        public static black6: Packages.arc.scene.style.Drawable;
        public static black3: Packages.arc.scene.style.Drawable;
        public static black5: Packages.arc.scene.style.Drawable;
        public static grayPanel: Packages.arc.scene.style.Drawable;
        public static none: Packages.arc.scene.style.Drawable;
        public static flatDown: Packages.arc.scene.style.Drawable;
        public static flatOver: Packages.arc.scene.style.Drawable;
        public static accentDrawable: Packages.arc.scene.style.Drawable;
        public static defaultb: Packages.arc.scene.ui.Button.ButtonStyle;
        public static underlineb: Packages.arc.scene.ui.Button.ButtonStyle;
        public static defaultt: Packages.arc.scene.ui.TextButton.TextButtonStyle;
        public static flatt: Packages.arc.scene.ui.TextButton.TextButtonStyle;
        public static grayt: Packages.arc.scene.ui.TextButton.TextButtonStyle;
        public static flatTogglet: Packages.arc.scene.ui.TextButton.TextButtonStyle;
        public static flatBordert: Packages.arc.scene.ui.TextButton.TextButtonStyle;
        public static nonet: Packages.arc.scene.ui.TextButton.TextButtonStyle;
        public static logicTogglet: Packages.arc.scene.ui.TextButton.TextButtonStyle;
        public static flatToggleMenut: Packages.arc.scene.ui.TextButton.TextButtonStyle;
        public static togglet: Packages.arc.scene.ui.TextButton.TextButtonStyle;
        public static cleart: Packages.arc.scene.ui.TextButton.TextButtonStyle;
        public static clearTogglet: Packages.arc.scene.ui.TextButton.TextButtonStyle;
        public static fullTogglet: Packages.arc.scene.ui.TextButton.TextButtonStyle;
        public static squareTogglet: Packages.arc.scene.ui.TextButton.TextButtonStyle;
        public static logict: Packages.arc.scene.ui.TextButton.TextButtonStyle;
        public static defaulti: Packages.arc.scene.ui.ImageButton.ImageButtonStyle;
        public static nodei: Packages.arc.scene.ui.ImageButton.ImageButtonStyle;
        public static emptyi: Packages.arc.scene.ui.ImageButton.ImageButtonStyle;
        public static emptyTogglei: Packages.arc.scene.ui.ImageButton.ImageButtonStyle;
        public static selecti: Packages.arc.scene.ui.ImageButton.ImageButtonStyle;
        public static logici: Packages.arc.scene.ui.ImageButton.ImageButtonStyle;
        public static geni: Packages.arc.scene.ui.ImageButton.ImageButtonStyle;
        public static grayi: Packages.arc.scene.ui.ImageButton.ImageButtonStyle;
        public static graySquarei: Packages.arc.scene.ui.ImageButton.ImageButtonStyle;
        public static flati: Packages.arc.scene.ui.ImageButton.ImageButtonStyle;
        public static squarei: Packages.arc.scene.ui.ImageButton.ImageButtonStyle;
        public static squareTogglei: Packages.arc.scene.ui.ImageButton.ImageButtonStyle;
        public static clearNonei: Packages.arc.scene.ui.ImageButton.ImageButtonStyle;
        public static cleari: Packages.arc.scene.ui.ImageButton.ImageButtonStyle;
        public static clearTogglei: Packages.arc.scene.ui.ImageButton.ImageButtonStyle;
        public static clearNoneTogglei: Packages.arc.scene.ui.ImageButton.ImageButtonStyle;
        public static defaultPane: Packages.arc.scene.ui.ScrollPane.ScrollPaneStyle;
        public static horizontalPane: Packages.arc.scene.ui.ScrollPane.ScrollPaneStyle;
        public static smallPane: Packages.arc.scene.ui.ScrollPane.ScrollPaneStyle;
        public static noBarPane: Packages.arc.scene.ui.ScrollPane.ScrollPaneStyle;
        public static defaultSlider: Packages.arc.scene.ui.Slider.SliderStyle;
        public static defaultLabel: Packages.arc.scene.ui.Label.LabelStyle;
        public static outlineLabel: Packages.arc.scene.ui.Label.LabelStyle;
        public static techLabel: Packages.arc.scene.ui.Label.LabelStyle;
        public static defaultField: Packages.arc.scene.ui.TextField.TextFieldStyle;
        public static nodeField: Packages.arc.scene.ui.TextField.TextFieldStyle;
        public static areaField: Packages.arc.scene.ui.TextField.TextFieldStyle;
        public static nodeArea: Packages.arc.scene.ui.TextField.TextFieldStyle;
        public static defaultCheck: Packages.arc.scene.ui.CheckBox.CheckBoxStyle;
        public static defaultDialog: Packages.arc.scene.ui.Dialog.DialogStyle;
        public static fullDialog: Packages.arc.scene.ui.Dialog.DialogStyle;
        public static defaultTree: Packages.arc.scene.ui.TreeElement.TreeStyle;
        public static load(): void;
        private static createFlatDown(): Packages.arc.scene.style.Drawable;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare class WarningBar extends Packages.arc.scene
        .Element {
        public barWidth: number;
        public spacing: number;
        public skew: number;
        public draw(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare class Build extends java.lang.Object {
        private static tmp: Packages.arc.struct.IntSet;
        public static validPlace(
          _type: Packages.mindustry.world.Block,
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _rotation: number,
          _checkVisible: boolean,
        ): boolean;
        public static validPlace(
          _type: Packages.mindustry.world.Block,
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _rotation: number,
        ): boolean;
        public static validBreak(
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
        ): boolean;
        public static getEnemyOverlap(
          _block: Packages.mindustry.world.Block,
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
        ): Packages.mindustry.gen.Building | null;
        public static beginBreak(
          _unit: Packages.mindustry.gen.Unit | null,
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
        ): void;
        public static beginPlace(
          _unit: Packages.mindustry.gen.Unit | null,
          _result: Packages.mindustry.world.Block,
          _team: Packages.mindustry.game.Team,
          _x: number,
          _y: number,
          _rotation: number,
        ): void;
        public static contactsShallows(
          _x: number,
          _y: number,
          _block: Packages.mindustry.world.Block,
        ): boolean;
        public static contactsGround(
          _x: number,
          _y: number,
          _block: Packages.mindustry.world.Block,
        ): boolean;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare class ColorMapper extends java.lang.Object {
        private static color2block: Packages.arc.struct.IntMap<Packages.mindustry.world.Block>;
        public static get(
          _color: number,
        ): Packages.mindustry.world.Block;
        public static load(): void;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare class DirectionalItemBuffer extends java.lang
        .Object {
        BufferItemStruct = class extends java.lang.Object {
          item: string;
          time: number;
          this$0: Packages.mindustry.world.DirectionalItemBuffer;
        };
        public buffers: Packages.long[][];
        public indexes: number[];
        public remove(_buffer: number): void;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public accept(
          _buffer: number,
          _item: Packages.mindustry._type.Item,
        ): void;
        public poll(
          _buffer: number,
          _speed: number,
        ): Packages.mindustry._type.Item;
        public accepts(_buffer: number): boolean;
        public constructor(_capacity: number);
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare class Edges extends java.lang.Object {
        private static maxRadius: number;
        private static edges: Packages.arc.math.geom.Point2[][];
        private static edgeInside: Packages.arc.math.geom.Point2[][];
        private static polygons: Packages.arc.math.geom.Vec2[][];
        public static getFacingEdge(
          _tile: Packages.mindustry.world.Tile,
          _other: Packages.mindustry.world.Tile,
        ): Packages.mindustry.world.Tile;
        public static getFacingEdge(
          _tile: Packages.mindustry.gen.Building,
          _other: Packages.mindustry.gen.Building,
        ): Packages.mindustry.world.Tile;
        public static getFacingEdge(
          _block: Packages.mindustry.world.Block,
          _tilex: number,
          _tiley: number,
          _other: Packages.mindustry.world.Tile,
        ): Packages.mindustry.world.Tile;
        public static getEdges(
          _size: number,
        ): Packages.arc.math.geom.Point2[] | null;
        public static getInsideEdges(
          _size: number,
        ): Packages.arc.math.geom.Point2[] | null;
        public static getPixelPolygon(
          _radius: number,
        ): Packages.arc.math.geom.Vec2[] | null;
        public constructor();
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare class ItemBuffer extends java.lang.Object {
        TimeItemStruct = class extends java.lang.Object {
          data: Packages.short;
          item: Packages.short;
          time: number;
          this$0: Packages.mindustry.world.ItemBuffer;
        };
        private buffer: Packages.long[];
        private index: number;
        public remove(): void;
        public write(
          _write: Packages.arc.util.io.Writes,
        ): void;
        public read(
          _read: Packages.arc.util.io.Reads,
        ): void;
        public accept(
          _item: Packages.mindustry._type.Item,
        ): void;
        public accept(
          _item: Packages.mindustry._type.Item,
          _data: Packages.short,
        ): void;
        public poll(
          _speed: number,
        ): Packages.mindustry._type.Item;
        public accepts(): boolean;
        public constructor(_capacity: number);
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare namespace _types {
        declare class AssemblerAI extends Packages.mindustry
          .entities.units.AIController {
          public targetPos: Packages.arc.math.geom.Vec2;
          public targetAngle: number;
          public updateMovement(): void;
          public inPosition(): boolean;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare namespace _types {
        declare class BoostAI extends Packages.mindustry
          .entities.units.AIController {
          public updateUnit(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare namespace _types {
        declare class BuilderAI extends Packages.mindustry
          .entities.units.AIController {
          public static buildRadius: number;
          public static retreatDst: number;
          public static retreatDelay: number;
          public static defaultRebuildPeriod: number;
          public assistFollowing?: Packages.mindustry.gen.Unit;
          public following?: Packages.mindustry.gen.Unit;
          public enemy?: Packages.mindustry.gen.Teamc;
          public lastPlan?: Packages.mindustry.game.Teams.BlockPlan;
          public fleeRange: number;
          public rebuildPeriod: number;
          public alwaysFlee: boolean;
          public onlyAssist: boolean;
          found: boolean;
          retreatTimer: number;
          public init(): void;
          public fallback(): Packages.mindustry.entities.units.AIController;
          public useFallback(): boolean;
          public updateMovement(): void;
          public shouldShoot(): boolean;
          protected nearEnemy(
            _x: number,
            _y: number,
          ): boolean;
          public constructor(
            _alwaysFlee: boolean,
            _fleeRange: number,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace units {
          declare class UnitCargoUnloadPoint extends Packages
            .mindustry.world.Block {
            public UnitCargoUnloadPointBuild = class extends Packages
              .mindustry.gen.Building {
              public item: Packages.mindustry._type.Item;
              public staleTimer: number;
              public stale: boolean;
              this$0: Packages.mindustry.world.blocks.units.UnitCargoUnloadPoint;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public config(): any;
              public draw(): void;
              public acceptStack(
                _item: Packages.mindustry._type.Item,
                _amount: number,
                _source: Packages.mindustry.gen.Teamc,
              ): number;
              public updateTile(): void;
              public buildConfiguration(
                _table: Packages.arc.scene.ui.layout.Table,
              ): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.units.UnitCargoUnloadPoint,
              );
            };
            public staleTimeDuration: number;
            public topRegion: Packages.arc.graphics.g2d.TextureRegion;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare namespace _types {
        declare class CargoAI extends Packages.mindustry
          .entities.units.AIController {
          static orderedItems: Packages.arc.struct.Seq<Packages.mindustry._type.Item>;
          static targets: Packages.arc.struct.Seq<Packages.mindustry.world.blocks.units.UnitCargoUnloadPoint.UnitCargoUnloadPointBuild>;
          public static emptyWaitTime: number;
          public static dropSpacing: number;
          public static transferRange: number;
          public static moveRange: number;
          public static moveSmoothing: number;
          public unloadTarget?: Packages.mindustry.world.blocks.units.UnitCargoUnloadPoint.UnitCargoUnloadPointBuild;
          public itemTarget?: Packages.mindustry._type.Item;
          public noDestTimer: number;
          public targetIndex: number;
          public updateMovement(): void;
          public findAnyTarget(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public findDropTarget(
            _item: Packages.mindustry._type.Item,
            _offset: number,
            _ignore: Packages.mindustry.world.blocks.units.UnitCargoUnloadPoint.UnitCargoUnloadPointBuild,
          ): number;
          sortTargets(
            _targets: Packages.arc.struct.Seq<Packages.mindustry.world.blocks.units.UnitCargoUnloadPoint.UnitCargoUnloadPointBuild>,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare namespace _types {
        declare class DefenderAI extends Packages.mindustry
          .entities.units.AIController {
          public findTarget(
            _x: number,
            _y: number,
            _range: number,
            _air: boolean,
            _ground: boolean,
          ): Packages.mindustry.gen.Teamc;
          public updateTargeting(): void;
          public updateMovement(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare namespace _types {
        declare class FlyingAI extends Packages.mindustry
          .entities.units.AIController {
          public findTarget(
            _x: number,
            _y: number,
            _range: number,
            _air: boolean,
            _ground: boolean,
          ): Packages.mindustry.gen.Teamc;
          public updateMovement(): void;
          public findMainTarget(
            _x: number,
            _y: number,
            _range: number,
            _air: boolean,
            _ground: boolean,
          ): Packages.mindustry.gen.Teamc;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare namespace _types {
        declare class FlyingFollowAI extends Packages
          .mindustry.ai._types.FlyingAI {
          public following: Packages.mindustry.gen.Teamc;
          public fallback(): Packages.mindustry.entities.units.AIController;
          public useFallback(): boolean;
          public updateVisuals(): void;
          public updateMovement(): void;
          public shouldFaceTarget(): boolean;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare namespace _types {
        declare class GroundAI extends Packages.mindustry
          .entities.units.AIController {
          public updateMovement(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare namespace _types {
        declare class HugAI extends Packages.mindustry
          .entities.units.AIController {
          public updateMovement(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare namespace _types {
        declare class MinerAI extends Packages.mindustry
          .entities.units.AIController {
          public mining: boolean;
          public targetItem: Packages.mindustry._type.Item;
          public ore: Packages.mindustry.world.Tile;
          public updateMovement(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare namespace _types {
        declare class MissileAI extends Packages.mindustry
          .entities.units.AIController {
          public shooter?: Packages.mindustry.gen.Unit;
          public target(
            _x: number,
            _y: number,
            _range: number,
            _air: boolean,
            _ground: boolean,
          ): Packages.mindustry.gen.Teamc;
          public retarget(): boolean;
          public updateMovement(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare namespace _types {
        declare class RepairAI extends Packages.mindustry
          .entities.units.AIController {
          public static retreatDst: number;
          public static fleeRange: number;
          public static retreatDelay: number;
          avoid?: Packages.mindustry.gen.Teamc;
          retreatTimer: number;
          damagedTarget: Packages.mindustry.gen.Building;
          public updateTargeting(): void;
          public updateMovement(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ai {
      declare namespace _types {
        declare class SuicideAI extends Packages.mindustry
          .ai._types.GroundAI {
          static blockedByBlock: boolean;
          public target(
            _x: number,
            _y: number,
            _range: number,
            _air: boolean,
            _ground: boolean,
          ): Packages.mindustry.gen.Teamc;
          public updateUnit(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace abilities {
        declare class ArmorPlateAbility extends Packages
          .mindustry.entities.abilities.Ability {
          public plateRegion: Packages.arc.graphics.g2d.TextureRegion;
          public shineRegion: Packages.arc.graphics.g2d.TextureRegion;
          public plateSuffix: string;
          public shineSuffix: string;
          public color?: Packages.arc.graphics.Color;
          public shineSpeed: number;
          public z: number;
          public drawPlate: boolean;
          public drawShine: boolean;
          public healthMultiplier: number;
          protected warmup: number;
          public update(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public draw(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public addStats(
            _t: Packages.arc.scene.ui.layout.Table,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace abilities {
        declare class EnergyFieldAbility extends Packages
          .mindustry.entities.abilities.Ability {
          private static all: Packages.arc.struct.Seq<Packages.mindustry.gen.Healthc>;
          public damage: number;
          public reload: number;
          public range: number;
          public healEffect: Packages.mindustry.entities.Effect;
          public hitEffect: Packages.mindustry.entities.Effect;
          public damageEffect: Packages.mindustry.entities.Effect;
          public status: Packages.mindustry._type.StatusEffect;
          public shootSound: Packages.arc.audio.Sound;
          public statusDuration: number;
          public x: number;
          public y: number;
          public targetGround: boolean;
          public targetAir: boolean;
          public hitBuildings: boolean;
          public hitUnits: boolean;
          public maxTargets: number;
          public healPercent: number;
          public sameTypeHealMult: number;
          public displayHeal: boolean;
          public layer: number;
          public blinkScl: number;
          public blinkSize: number;
          public effectRadius: number;
          public sectorRad: number;
          public rotateSpeed: number;
          public sectors: number;
          public color: Packages.arc.graphics.Color;
          public useAmmo: boolean;
          protected timer: number;
          protected curStroke: number;
          protected anyNearby: boolean;
          public update(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public draw(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public addStats(
            _t: Packages.arc.scene.ui.layout.Table,
          ): void;
          public constructor(
            _damage: number,
            _reload: number,
            _range: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace abilities {
        declare class ForceFieldAbility extends Packages
          .mindustry.entities.abilities.Ability {
          public radius: number;
          public regen: number;
          public max: number;
          public cooldown: number;
          public sides: number;
          public rotation: number;
          protected radiusScale: number;
          protected alpha: number;
          protected wasBroken: boolean;
          private static realRad: number;
          private static paramUnit: Packages.mindustry.gen.Unit;
          private static paramField: Packages.mindustry.entities.abilities.ForceFieldAbility;
          private static shieldConsumer: Packages.arc.func.Cons<Packages.mindustry.gen.Bullet>;
          public update(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public draw(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public displayBars(
            _unit: Packages.mindustry.gen.Unit,
            _bars: Packages.arc.scene.ui.layout.Table,
          ): void;
          public addStats(
            _t: Packages.arc.scene.ui.layout.Table,
          ): void;
          public checkRadius(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public constructor(
            _radius: number,
            _regen: number,
            _max: number,
            _cooldown: number,
            _sides: number,
            _rotation: number,
          );
          public constructor(
            _radius: number,
            _regen: number,
            _max: number,
            _cooldown: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace abilities {
        declare class LiquidExplodeAbility extends Packages
          .mindustry.entities.abilities.Ability {
          public liquid: Packages.mindustry._type.Liquid;
          public amount: number;
          public radAmountScale: number;
          public radScale: number;
          public noiseMag: number;
          public noiseScl: number;
          public death(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public addStats(
            _t: Packages.arc.scene.ui.layout.Table,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace abilities {
        declare class LiquidRegenAbility extends Packages
          .mindustry.entities.abilities.Ability {
          public liquid: Packages.mindustry._type.Liquid;
          public slurpSpeed: number;
          public regenPerSlurp: number;
          public slurpEffectChance: number;
          public slurpEffect: Packages.mindustry.entities.Effect;
          public update(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public addStats(
            _t: Packages.arc.scene.ui.layout.Table,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace abilities {
        declare class MoveEffectAbility extends Packages
          .mindustry.entities.abilities.Ability {
          public minVelocity: number;
          public interval: number;
          public x: number;
          public y: number;
          public rotation: number;
          public rotateEffect: boolean;
          public effectParam: number;
          public teamColor: boolean;
          public parentizeEffects: boolean;
          public color: Packages.arc.graphics.Color;
          public effect: Packages.mindustry.entities.Effect;
          protected counter: number;
          public update(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public constructor(
            _x: number,
            _y: number,
            _color: Packages.arc.graphics.Color,
            _effect: Packages.mindustry.entities.Effect,
            _interval: number,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace abilities {
        declare class MoveLightningAbility extends Packages
          .mindustry.entities.abilities.Ability {
          public damage: number;
          public chance: number;
          public length: number;
          public minSpeed: number;
          public maxSpeed: number;
          public color: Packages.arc.graphics.Color;
          public y: number;
          public x: number;
          public alternate: boolean;
          public heatRegion: string;
          public bullet?: Packages.mindustry.entities.bullet.BulletType;
          public bulletAngle: number;
          public bulletSpread: number;
          public shootEffect: Packages.mindustry.entities.Effect;
          public parentizeEffects: boolean;
          public shootSound: Packages.arc.audio.Sound;
          protected side: number;
          public update(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public draw(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public addStats(
            _t: Packages.arc.scene.ui.layout.Table,
          ): void;
          public constructor(
            _damage: number,
            _length: number,
            _chance: number,
            _y: number,
            _minSpeed: number,
            _maxSpeed: number,
            _color: Packages.arc.graphics.Color,
          );
          public constructor(
            _damage: number,
            _length: number,
            _chance: number,
            _y: number,
            _minSpeed: number,
            _maxSpeed: number,
            _color: Packages.arc.graphics.Color,
            _heatRegion: string,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace abilities {
        declare class RegenAbility extends Packages
          .mindustry.entities.abilities.Ability {
          public percentAmount: number;
          public amount: number;
          public update(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public addStats(
            _t: Packages.arc.scene.ui.layout.Table,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace abilities {
        declare class RepairFieldAbility extends Packages
          .mindustry.entities.abilities.Ability {
          public amount: number;
          public reload: number;
          public range: number;
          public healEffect: Packages.mindustry.entities.Effect;
          public activeEffect: Packages.mindustry.entities.Effect;
          public parentizeEffects: boolean;
          protected timer: number;
          protected wasHealed: boolean;
          public update(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public addStats(
            _t: Packages.arc.scene.ui.layout.Table,
          ): void;
          public constructor(
            _amount: number,
            _reload: number,
            _range: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace abilities {
        declare class ShieldArcAbility extends Packages
          .mindustry.entities.abilities.Ability {
          private static paramUnit: Packages.mindustry.gen.Unit;
          private static paramField: Packages.mindustry.entities.abilities.ShieldArcAbility;
          private static paramPos: Packages.arc.math.geom.Vec2;
          private static shieldConsumer: Packages.arc.func.Cons<Packages.mindustry.gen.Bullet>;
          public radius: number;
          public regen: number;
          public max: number;
          public cooldown: number;
          public angle: number;
          public angleOffset: number;
          public x: number;
          public y: number;
          public whenShooting: boolean;
          public width: number;
          public drawArc: boolean;
          public region?: string;
          public color?: Packages.arc.graphics.Color;
          public offsetRegion: boolean;
          protected widthScale: number;
          protected alpha: number;
          public update(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public init(
            _type: Packages.mindustry._type.UnitType,
          ): void;
          public draw(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public displayBars(
            _unit: Packages.mindustry.gen.Unit,
            _bars: Packages.arc.scene.ui.layout.Table,
          ): void;
          public addStats(
            _t: Packages.arc.scene.ui.layout.Table,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace abilities {
        declare class ShieldRegenFieldAbility extends Packages
          .mindustry.entities.abilities.Ability {
          public amount: number;
          public max: number;
          public reload: number;
          public range: number;
          public applyEffect: Packages.mindustry.entities.Effect;
          public activeEffect: Packages.mindustry.entities.Effect;
          public parentizeEffects: boolean;
          protected timer: number;
          protected applied: boolean;
          public update(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public addStats(
            _t: Packages.arc.scene.ui.layout.Table,
          ): void;
          public constructor(
            _amount: number,
            _max: number,
            _reload: number,
            _range: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace abilities {
        declare class SpawnDeathAbility extends Packages
          .mindustry.entities.abilities.Ability {
          public unit: Packages.mindustry._type.UnitType;
          public amount: number;
          public randAmount: number;
          public spread: number;
          public faceOutwards: boolean;
          public death(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public addStats(
            _t: Packages.arc.scene.ui.layout.Table,
          ): void;
          public constructor(
            _unit: Packages.mindustry._type.UnitType,
            _amount: number,
            _spread: number,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace abilities {
        declare class StatusFieldAbility extends Packages
          .mindustry.entities.abilities.Ability {
          public effect: Packages.mindustry._type.StatusEffect;
          public duration: number;
          public reload: number;
          public range: number;
          public onShoot: boolean;
          public applyEffect: Packages.mindustry.entities.Effect;
          public activeEffect: Packages.mindustry.entities.Effect;
          public effectX: number;
          public effectY: number;
          public parentizeEffects: boolean;
          public effectSizeParam: boolean;
          protected timer: number;
          public update(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public addStats(
            _t: Packages.arc.scene.ui.layout.Table,
          ): void;
          public constructor(
            _effect: Packages.mindustry._type.StatusEffect,
            _duration: number,
            _reload: number,
            _range: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace abilities {
        declare class SuppressionFieldAbility extends Packages
          .mindustry.entities.abilities.Ability {
          protected static rand: Packages.arc.math.Rand;
          public reload: number;
          public range: number;
          public orbRadius: number;
          public orbMidScl: number;
          public orbSinScl: number;
          public orbSinMag: number;
          public color: Packages.arc.graphics.Color;
          public layer: number;
          public x: number;
          public y: number;
          public particles: number;
          public particleSize: number;
          public particleLen: number;
          public rotateScl: number;
          public particleLife: number;
          public active: boolean;
          public particleInterp: Packages.arc.math.Interp;
          public particleColor: Packages.arc.graphics.Color;
          public effectColor: Packages.arc.graphics.Color;
          public applyParticleChance: number;
          protected timer: number;
          public update(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public init(
            _type: Packages.mindustry._type.UnitType,
          ): void;
          public draw(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public addStats(
            _t: Packages.arc.scene.ui.layout.Table,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace abilities {
        declare class UnitSpawnAbility extends Packages
          .mindustry.entities.abilities.Ability {
          public unit: Packages.mindustry._type.UnitType;
          public spawnTime: number;
          public spawnX: number;
          public spawnY: number;
          public spawnEffect: Packages.mindustry.entities.Effect;
          public parentizeEffects: boolean;
          protected timer: number;
          public update(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public localized(): string;
          public draw(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public addStats(
            _t: Packages.arc.scene.ui.layout.Table,
          ): void;
          public constructor(
            _unit: Packages.mindustry._type.UnitType,
            _spawnTime: number,
            _spawnX: number,
            _spawnY: number,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace bullet {
        declare class BasicBulletType extends Packages
          .mindustry.entities.bullet.BulletType {
          public backColor: Packages.arc.graphics.Color;
          public frontColor: Packages.arc.graphics.Color;
          public mixColorFrom: Packages.arc.graphics.Color;
          public mixColorTo: Packages.arc.graphics.Color;
          public width: number;
          public height: number;
          public shrinkX: number;
          public shrinkY: number;
          public shrinkInterp: Packages.arc.math.Interp;
          public spin: number;
          public rotationOffset: number;
          public sprite: string;
          public backSprite?: string;
          public backRegion: Packages.arc.graphics.g2d.TextureRegion;
          public frontRegion: Packages.arc.graphics.g2d.TextureRegion;
          public load(): void;
          public draw(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public constructor();
          public constructor(
            _speed: number,
            _damage: number,
          );
          public constructor(
            _speed: number,
            _damage: number,
            _bulletSprite: string,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace bullet {
        declare class ArtilleryBulletType extends Packages
          .mindustry.entities.bullet.BasicBulletType {
          public trailMult: number;
          public trailSize: number;
          public update(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public constructor();
          public constructor(
            _speed: number,
            _damage: number,
          );
          public constructor(
            _speed: number,
            _damage: number,
            _bulletSprite: string,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace bullet {
        declare class BombBulletType extends Packages
          .mindustry.entities.bullet.BasicBulletType {
          public constructor(
            _damage: number,
            _radius: number,
            _sprite: string,
          );
          public constructor(
            _damage: number,
            _radius: number,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace bullet {
        declare class ContinuousBulletType extends Packages
          .mindustry.entities.bullet.BulletType {
          public length: number;
          public shake: number;
          public damageInterval: number;
          public largeHit: boolean;
          public continuous: boolean;
          public timescaleDamage: boolean;
          public update(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public init(): void;
          public init(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public currentLength(
            _b: Packages.mindustry.gen.Bullet,
          ): number;
          protected calculateRange(): number;
          public estimateDPS(): number;
          public continuousDamage(): number;
          public applyDamage(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace bullet {
        declare class ContinuousFlameBulletType extends Packages
          .mindustry.entities.bullet.ContinuousBulletType {
          public lightStroke: number;
          public width: number;
          public oscScl: number;
          public oscMag: number;
          public divisions: number;
          public drawFlare: boolean;
          public flareColor: Packages.arc.graphics.Color;
          public flareWidth: number;
          public flareInnerScl: number;
          public flareLength: number;
          public flareInnerLenScl: number;
          public flareLayer: number;
          public flareRotSpeed: number;
          public rotateFlare: boolean;
          public lengthInterp: Packages.arc.math.Interp;
          public lengthWidthPans: number[];
          public colors: Packages.arc.graphics.Color[];
          public currentLength(
            _b: Packages.mindustry.gen.Bullet,
          ): number;
          public draw(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public drawLight(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public constructor(_damage: number);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace bullet {
        declare class ContinuousLaserBulletType extends Packages
          .mindustry.entities.bullet.ContinuousBulletType {
          public fadeTime: number;
          public lightStroke: number;
          public divisions: number;
          public colors: Packages.arc.graphics.Color[];
          public strokeFrom: number;
          public strokeTo: number;
          public pointyScaling: number;
          public backLength: number;
          public frontLength: number;
          public width: number;
          public oscScl: number;
          public oscMag: number;
          public currentLength(
            _b: Packages.mindustry.gen.Bullet,
          ): number;
          public draw(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public drawLight(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public constructor(_damage: number);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace bullet {
        declare class EmpBulletType extends Packages
          .mindustry.entities.bullet.BasicBulletType {
          public radius: number;
          public timeIncrease: number;
          public timeDuration: number;
          public powerDamageScl: number;
          public powerSclDecrease: number;
          public hitPowerEffect: Packages.mindustry.entities.Effect;
          public chainEffect: Packages.mindustry.entities.Effect;
          public applyEffect: Packages.mindustry.entities.Effect;
          public hitUnits: boolean;
          public unitDamageScl: number;
          public hit(
            _b: Packages.mindustry.gen.Bullet,
            _x: number,
            _y: number,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace bullet {
        declare class ExplosionBulletType extends Packages
          .mindustry.entities.bullet.BulletType {
          public constructor(
            _splashDamage: number,
            _splashDamageRadius: number,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace bullet {
        declare class FireBulletType extends Packages
          .mindustry.entities.bullet.BulletType {
          public colorFrom: Packages.arc.graphics.Color;
          public colorMid: Packages.arc.graphics.Color;
          public colorTo: Packages.arc.graphics.Color;
          public radius: number;
          public velMin: number;
          public velMax: number;
          public fireTrailChance: number;
          public trailEffect2: Packages.mindustry.entities.Effect;
          public fireEffectChance: number;
          public fireEffectChance2: number;
          public update(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public init(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public draw(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public constructor(
            _speed: number,
            _damage: number,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace bullet {
        declare class FlakBulletType extends Packages
          .mindustry.entities.bullet.BasicBulletType {
          public explodeRange: number;
          public explodeDelay: number;
          public flakDelay: number;
          public flakInterval: number;
          public update(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public constructor(
            _speed: number,
            _damage: number,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace bullet {
        declare class LaserBoltBulletType extends Packages
          .mindustry.entities.bullet.BasicBulletType {
          public width: number;
          public height: number;
          public draw(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public constructor(
            _speed: number,
            _damage: number,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace bullet {
        declare class LaserBulletType extends Packages
          .mindustry.entities.bullet.BulletType {
          public colors: Packages.arc.graphics.Color[];
          public laserEffect: Packages.mindustry.entities.Effect;
          public length: number;
          public width: number;
          public lengthFalloff: number;
          public sideLength: number;
          public sideWidth: number;
          public sideAngle: number;
          public lightningSpacing: number;
          public lightningDelay: number;
          public lightningAngleRand: number;
          public largeHit: boolean;
          public init(): void;
          public init(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          protected calculateRange(): number;
          public draw(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public drawLight(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public estimateDPS(): number;
          public constructor(_damage: number);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace bullet {
        declare class LightningBulletType extends Packages
          .mindustry.entities.bullet.BulletType {
          public lightningColor: Packages.arc.graphics.Color;
          public lightningLength: number;
          public lightningLengthRand: number;
          public init(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          protected calculateRange(): number;
          public draw(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public estimateDPS(): number;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace bullet {
        declare class LiquidBulletType extends Packages
          .mindustry.entities.bullet.BulletType {
          public liquid: Packages.mindustry._type.Liquid;
          public puddleSize: number;
          public orbSize: number;
          public boilTime: number;
          public update(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public hit(
            _b: Packages.mindustry.gen.Bullet,
            _hitx: number,
            _hity: number,
          ): void;
          public draw(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public despawned(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public constructor(
            _liquid: Packages.mindustry._type.Liquid | null,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace bullet {
        declare class MassDriverBolt extends Packages
          .mindustry.entities.bullet.BasicBulletType {
          public update(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public hit(
            _b: Packages.mindustry.gen.Bullet,
            _hitx: number,
            _hity: number,
          ): void;
          public despawned(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace bullet {
        declare class MissileBulletType extends Packages
          .mindustry.entities.bullet.BasicBulletType {
          public constructor(
            _speed: number,
            _damage: number,
            _bulletSprite: string,
          );
          public constructor(
            _speed: number,
            _damage: number,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace bullet {
        declare class PointBulletType extends Packages
          .mindustry.entities.bullet.BulletType {
          private static cdist: number;
          private static result: Packages.mindustry.gen.Unit;
          public trailSpacing: number;
          public init(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace bullet {
        declare class PointLaserBulletType extends Packages
          .mindustry.entities.bullet.BulletType {
          public sprite: string;
          public laser: Packages.arc.graphics.g2d.TextureRegion;
          public laserEnd: Packages.arc.graphics.g2d.TextureRegion;
          public color: Packages.arc.graphics.Color;
          public beamEffect: Packages.mindustry.entities.Effect;
          public beamEffectInterval: number;
          public beamEffectSize: number;
          public oscScl: number;
          public oscMag: number;
          public damageInterval: number;
          public shake: number;
          public update(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public load(): void;
          public draw(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public estimateDPS(): number;
          public updateTrail(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public updateTrailEffects(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public updateBulletInterval(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public continuousDamage(): number;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace bullet {
        declare class RailBulletType extends Packages
          .mindustry.entities.bullet.BulletType {
          public pierceEffect: Packages.mindustry.entities.Effect;
          public pointEffect: Packages.mindustry.entities.Effect;
          public lineEffect: Packages.mindustry.entities.Effect;
          public endEffect: Packages.mindustry.entities.Effect;
          public length: number;
          public pointEffectSpace: number;
          public init(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          protected calculateRange(): number;
          public testCollision(
            _bullet: Packages.mindustry.gen.Bullet,
            _tile: Packages.mindustry.gen.Building,
          ): boolean;
          public handlePierce(
            _b: Packages.mindustry.gen.Bullet,
            _initialHealth: number,
            _x: number,
            _y: number,
          ): void;
          public hitTile(
            _b: Packages.mindustry.gen.Bullet,
            _build: Packages.mindustry.gen.Building,
            _x: number,
            _y: number,
            _initialHealth: number,
            _direct: boolean,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace bullet {
        declare class SapBulletType extends Packages
          .mindustry.entities.bullet.BulletType {
          public length: number;
          public sapStrength: number;
          public color: Packages.arc.graphics.Color;
          public width: number;
          public init(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          protected calculateRange(): number;
          public draw(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public drawLight(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace bullet {
        declare class ShrapnelBulletType extends Packages
          .mindustry.entities.bullet.BulletType {
          public length: number;
          public width: number;
          public fromColor: Packages.arc.graphics.Color;
          public toColor: Packages.arc.graphics.Color;
          public hitLarge: boolean;
          public serrations: number;
          public serrationLenScl: number;
          public serrationWidth: number;
          public serrationSpacing: number;
          public serrationSpaceOffset: number;
          public serrationFadeOffset: number;
          public init(): void;
          public init(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          protected calculateRange(): number;
          public draw(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace bullet {
        declare class SpaceLiquidBulletType extends Packages
          .mindustry.entities.bullet.BulletType {
          public orbSize: number;
          public draw(
            _b: Packages.mindustry.gen.Bullet,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace effect {
        declare class ExplosionEffect extends Packages
          .mindustry.entities.Effect {
          public waveColor: Packages.arc.graphics.Color;
          public smokeColor: Packages.arc.graphics.Color;
          public sparkColor: Packages.arc.graphics.Color;
          public waveLife: number;
          public waveStroke: number;
          public waveRad: number;
          public waveRadBase: number;
          public sparkStroke: number;
          public sparkRad: number;
          public sparkLen: number;
          public smokeSize: number;
          public smokeSizeBase: number;
          public smokeRad: number;
          public smokes: number;
          public sparks: number;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace effect {
        declare class MultiEffect extends Packages.mindustry
          .entities.Effect {
          public effects: Packages.mindustry.entities.Effect[];
          public create(
            _x: number,
            _y: number,
            _rotation: number,
            _color: Packages.arc.graphics.Color,
            _data: any,
          ): void;
          public constructor();
          public constructor(
            ..._effects: Packages.mindustry.entities.Effect[]
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace effect {
        declare class ParticleEffect extends Packages
          .mindustry.entities.Effect {
          private static rand: Packages.arc.math.Rand;
          private static rv: Packages.arc.math.geom.Vec2;
          public colorFrom: Packages.arc.graphics.Color;
          public colorTo: Packages.arc.graphics.Color;
          public particles: number;
          public randLength: boolean;
          public casingFlip: boolean;
          public cone: number;
          public length: number;
          public baseLength: number;
          public interp: Packages.arc.math.Interp;
          public sizeInterp?: Packages.arc.math.Interp;
          public offsetX: number;
          public offsetY: number;
          public lightScl: number;
          public lightOpacity: number;
          public lightColor?: Packages.arc.graphics.Color;
          public spin: number;
          public sizeFrom: number;
          public sizeTo: number;
          public useRotation: boolean;
          public offset: number;
          public region: string;
          public line: boolean;
          public strokeFrom: number;
          public strokeTo: number;
          public lenFrom: number;
          public lenTo: number;
          public cap: boolean;
          private tex?: Packages.arc.graphics.g2d.TextureRegion;
          public init(): void;
          public render(
            _e: Packages.mindustry.entities.Effect.EffectContainer,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace effect {
        declare class RadialEffect extends Packages
          .mindustry.entities.Effect {
          public effect: Packages.mindustry.entities.Effect;
          public rotationSpacing: number;
          public rotationOffset: number;
          public lengthOffset: number;
          public amount: number;
          public create(
            _x: number,
            _y: number,
            _rotation: number,
            _color: Packages.arc.graphics.Color,
            _data: any,
          ): void;
          public constructor();
          public constructor(
            _effect: Packages.mindustry.entities.Effect,
            _amount: number,
            _spacing: number,
            _lengthOffset: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace effect {
        declare class SeqEffect extends Packages.mindustry
          .entities.Effect {
          public effects: Packages.mindustry.entities.Effect[];
          public init(): void;
          public render(
            _e: Packages.mindustry.entities.Effect.EffectContainer,
          ): void;
          public constructor();
          public constructor(
            ..._effects: Packages.mindustry.entities.Effect[]
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace effect {
        declare class WaveEffect extends Packages.mindustry
          .entities.Effect {
          public colorFrom: Packages.arc.graphics.Color;
          public colorTo: Packages.arc.graphics.Color;
          public lightColor?: Packages.arc.graphics.Color;
          public sizeFrom: number;
          public sizeTo: number;
          public lightScl: number;
          public lightOpacity: number;
          public sides: number;
          public rotation: number;
          public strokeFrom: number;
          public strokeTo: number;
          public interp: Packages.arc.math.Interp;
          public lightInterp: Packages.arc.math.Interp;
          public offsetX: number;
          public offsetY: number;
          public init(): void;
          public render(
            _e: Packages.mindustry.entities.Effect.EffectContainer,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace part {
        declare class FlarePart extends Packages.mindustry
          .entities.part.DrawPart {
          public sides: number;
          public radius: number;
          public radiusTo: number;
          public stroke: number;
          public innerScl: number;
          public innerRadScl: number;
          public x: number;
          public y: number;
          public rotation: number;
          public rotMove: number;
          public spinSpeed: number;
          public followRotation: boolean;
          public color1: Packages.arc.graphics.Color;
          public color2: Packages.arc.graphics.Color;
          public progress: Packages.mindustry.entities.part.DrawPart.PartProgress;
          public layer: number;
          public load(_name: string): void;
          public draw(
            _params: Packages.mindustry.entities.part.DrawPart.PartParams,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace part {
        declare class HaloPart extends Packages.mindustry
          .entities.part.DrawPart {
          public hollow: boolean;
          public tri: boolean;
          public shapes: number;
          public sides: number;
          public radius: number;
          public radiusTo: number;
          public stroke: number;
          public strokeTo: number;
          public triLength: number;
          public triLengthTo: number;
          public haloRadius: number;
          public haloRadiusTo: number;
          public x: number;
          public y: number;
          public shapeRotation: number;
          public moveX: number;
          public moveY: number;
          public shapeMoveRot: number;
          public haloRotateSpeed: number;
          public haloRotation: number;
          public rotateSpeed: number;
          public color: Packages.arc.graphics.Color;
          public colorTo?: Packages.arc.graphics.Color;
          public mirror: boolean;
          public progress: Packages.mindustry.entities.part.DrawPart.PartProgress;
          public layer: number;
          public layerOffset: number;
          public load(_name: string): void;
          public draw(
            _params: Packages.mindustry.entities.part.DrawPart.PartParams,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace part {
        declare class HoverPart extends Packages.mindustry
          .entities.part.DrawPart {
          public radius: number;
          public x: number;
          public y: number;
          public rotation: number;
          public phase: number;
          public stroke: number;
          public minStroke: number;
          public circles: number;
          public sides: number;
          public color: Packages.arc.graphics.Color;
          public mirror: boolean;
          public layer: number;
          public layerOffset: number;
          public load(_name: string): void;
          public draw(
            _params: Packages.mindustry.entities.part.DrawPart.PartParams,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace part {
        declare class RegionPart extends Packages.mindustry
          .entities.part.DrawPart {
          protected childParam: Packages.mindustry.entities.part.DrawPart.PartParams;
          public suffix: string;
          public name?: string;
          public heat: Packages.arc.graphics.g2d.TextureRegion;
          public light: Packages.arc.graphics.g2d.TextureRegion;
          public regions: Packages.arc.graphics.g2d.TextureRegion[];
          public outlines: Packages.arc.graphics.g2d.TextureRegion[];
          public mirror: boolean;
          public outline: boolean;
          public drawRegion: boolean;
          public heatLight: boolean;
          public progress: Packages.mindustry.entities.part.DrawPart.PartProgress;
          public growProgress: Packages.mindustry.entities.part.DrawPart.PartProgress;
          public heatProgress: Packages.mindustry.entities.part.DrawPart.PartProgress;
          public blending: Packages.arc.graphics.Blending;
          public layer: number;
          public layerOffset: number;
          public heatLayerOffset: number;
          public turretHeatLayer: number;
          public outlineLayerOffset: number;
          public x: number;
          public y: number;
          public xScl: number;
          public yScl: number;
          public rotation: number;
          public moveX: number;
          public moveY: number;
          public growX: number;
          public growY: number;
          public moveRot: number;
          public heatLightOpacity: number;
          public color?: Packages.arc.graphics.Color;
          public colorTo?: Packages.arc.graphics.Color;
          public mixColor?: Packages.arc.graphics.Color;
          public mixColorTo?: Packages.arc.graphics.Color;
          public heatColor: Packages.arc.graphics.Color;
          public children: Packages.arc.struct.Seq<Packages.mindustry.entities.part.DrawPart>;
          public moves: Packages.arc.struct.Seq<Packages.mindustry.entities.part.DrawPart.PartMove>;
          public load(_name: string): void;
          public draw(
            _params: Packages.mindustry.entities.part.DrawPart.PartParams,
          ): void;
          public getOutlines(
            _out: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.TextureRegion>,
          ): void;
          public constructor();
          public constructor(
            _region: string,
            _blending: Packages.arc.graphics.Blending,
            _color: Packages.arc.graphics.Color,
          );
          public constructor(_region: string);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace part {
        declare class ShapePart extends Packages.mindustry
          .entities.part.DrawPart {
          public circle: boolean;
          public hollow: boolean;
          public sides: number;
          public radius: number;
          public radiusTo: number;
          public stroke: number;
          public strokeTo: number;
          public x: number;
          public y: number;
          public rotation: number;
          public moveX: number;
          public moveY: number;
          public moveRot: number;
          public rotateSpeed: number;
          public color: Packages.arc.graphics.Color;
          public colorTo?: Packages.arc.graphics.Color;
          public mirror: boolean;
          public progress: Packages.mindustry.entities.part.DrawPart.PartProgress;
          public layer: number;
          public layerOffset: number;
          public load(_name: string): void;
          public draw(
            _params: Packages.mindustry.entities.part.DrawPart.PartParams,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace pattern {
        declare class ShootAlternate extends Packages
          .mindustry.entities.pattern.ShootPattern {
          public barrels: number;
          public spread: number;
          public barrelOffset: number;
          public shoot(
            _totalShots: number,
            _handler: Packages.mindustry.entities.pattern.ShootPattern.BulletHandler,
            _barrelIncrementer: Packages.java.lang.Runnable | null,
          ): void;
          public constructor(_spread: number);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace pattern {
        declare class ShootBarrel extends Packages.mindustry
          .entities.pattern.ShootPattern {
          public barrels: number[];
          public barrelOffset: number;
          public flip(): void;
          public shoot(
            _totalShots: number,
            _handler: Packages.mindustry.entities.pattern.ShootPattern.BulletHandler,
            _barrelIncrementer: Packages.java.lang.Runnable | null,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace pattern {
        declare class ShootHelix extends Packages.mindustry
          .entities.pattern.ShootPattern {
          public scl: number;
          public mag: number;
          public offset: number;
          public shoot(
            _totalShots: number,
            _handler: Packages.mindustry.entities.pattern.ShootPattern.BulletHandler,
            _barrelIncrementer: Packages.java.lang.Runnable | null,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace pattern {
        declare class ShootMulti extends Packages.mindustry
          .entities.pattern.ShootPattern {
          public source: Packages.mindustry.entities.pattern.ShootPattern;
          public dest: Packages.mindustry.entities.pattern.ShootPattern[];
          public flip(): void;
          public shoot(
            _totalShots: number,
            _handler: Packages.mindustry.entities.pattern.ShootPattern.BulletHandler,
            _barrelIncrementer: Packages.java.lang.Runnable | null,
          ): void;
          public constructor(
            _source: Packages.mindustry.entities.pattern.ShootPattern,
            ..._dest: Packages.mindustry.entities.pattern.ShootPattern[]
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace pattern {
        declare class ShootSine extends Packages.mindustry
          .entities.pattern.ShootPattern {
          public scl: number;
          public mag: number;
          public shoot(
            _totalShots: number,
            _handler: Packages.mindustry.entities.pattern.ShootPattern.BulletHandler,
            _barrelIncrementer: Packages.java.lang.Runnable | null,
          ): void;
          public constructor(_scl: number, _mag: number);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace pattern {
        declare class ShootSpread extends Packages.mindustry
          .entities.pattern.ShootPattern {
          public spread: number;
          public shoot(
            _totalShots: number,
            _handler: Packages.mindustry.entities.pattern.ShootPattern.BulletHandler,
            _barrelIncrementer: Packages.java.lang.Runnable | null,
          ): void;
          public constructor(
            _shots: number,
            _spread: number,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace entities {
      declare namespace pattern {
        declare class ShootSummon extends Packages.mindustry
          .entities.pattern.ShootPattern {
          public x: number;
          public y: number;
          public radius: number;
          public spread: number;
          public shoot(
            _totalShots: number,
            _handler: Packages.mindustry.entities.pattern.ShootPattern.BulletHandler,
            _barrelIncrementer: Packages.java.lang.Runnable | null,
          ): void;
          public constructor(
            _x: number,
            _y: number,
            _radius: number,
            _spread: number,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare namespace g3d {
        declare abstract class PlanetMesh
          extends java.lang.Object
          implements
            Packages.mindustry.graphics.g3d.GenericMesh
        {
          protected mesh: Packages.arc.graphics.Mesh;
          protected planet: Packages.mindustry._type.Planet;
          protected shader: Packages.arc.graphics.gl.Shader;
          public render(
            _params: Packages.mindustry.graphics.g3d.PlanetParams,
            _projection: Packages.arc.math.geom.Mat3D,
            _transform: Packages.arc.math.geom.Mat3D,
          ): void;
          public preRender(
            _params: Packages.mindustry.graphics.g3d.PlanetParams,
          ): void;
          public constructor(
            _planet: Packages.mindustry._type.Planet,
            _mesh: Packages.arc.graphics.Mesh,
            _shader: Packages.arc.graphics.gl.Shader,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare namespace g3d {
        declare class HexMesh extends Packages.mindustry
          .graphics.g3d.PlanetMesh {
          public preRender(
            _params: Packages.mindustry.graphics.g3d.PlanetParams,
          ): void;
          public constructor();
          public constructor(
            _planet: Packages.mindustry._type.Planet,
            _mesher: Packages.mindustry.graphics.g3d.HexMesher,
            _divisions: number,
            _shader: Packages.arc.graphics.gl.Shader,
          );
          public constructor(
            _planet: Packages.mindustry._type.Planet,
            _divisions: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare namespace g3d {
        declare class HexSkyMesh extends Packages.mindustry
          .graphics.g3d.PlanetMesh {
          static mat: Packages.arc.math.geom.Mat3D;
          public speed: number;
          public render(
            _params: Packages.mindustry.graphics.g3d.PlanetParams,
            _projection: Packages.arc.math.geom.Mat3D,
            _transform: Packages.arc.math.geom.Mat3D,
          ): void;
          public preRender(
            _params: Packages.mindustry.graphics.g3d.PlanetParams,
          ): void;
          public relRot(): number;
          public constructor(
            _planet: Packages.mindustry._type.Planet,
            _seed: number,
            _speed: number,
            _radius: number,
            _divisions: number,
            _color: Packages.arc.graphics.Color,
            _octaves: number,
            _persistence: number,
            _scl: number,
            _thresh: number,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare namespace g3d {
        declare class MatMesh
          extends java.lang.Object
          implements
            Packages.mindustry.graphics.g3d.GenericMesh
        {
          private static tmp: Packages.arc.math.geom.Mat3D;
          mesh: Packages.mindustry.graphics.g3d.GenericMesh;
          mat: Packages.arc.math.geom.Mat3D;
          public render(
            _params: Packages.mindustry.graphics.g3d.PlanetParams,
            _projection: Packages.arc.math.geom.Mat3D,
            _transform: Packages.arc.math.geom.Mat3D,
          ): void;
          public constructor(
            _mesh: Packages.mindustry.graphics.g3d.GenericMesh,
            _mat: Packages.arc.math.geom.Mat3D,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare namespace g3d {
        declare class MeshBuilder extends java.lang.Object {
          private static v1: Packages.arc.math.geom.Vec3;
          private static v2: Packages.arc.math.geom.Vec3;
          private static v3: Packages.arc.math.geom.Vec3;
          private static v4: Packages.arc.math.geom.Vec3;
          private static floats: number[];
          private static mesh: Packages.arc.graphics.Mesh;
          private static end(): Packages.arc.graphics.Mesh;
          private static begin(_count: number): void;
          private static normal(
            _v1: Packages.arc.math.geom.Vec3,
            _v2: Packages.arc.math.geom.Vec3,
            _v3: Packages.arc.math.geom.Vec3,
          ): Packages.arc.math.geom.Vec3;
          private static vert(
            _a: Packages.arc.math.geom.Vec3,
            _normal: Packages.arc.math.geom.Vec3,
            _color: Packages.arc.graphics.Color,
          ): void;
          public static buildHex(
            _color: Packages.arc.graphics.Color,
            _divisions: number,
            _lines: boolean,
            _radius: number,
          ): Packages.arc.graphics.Mesh;
          public static buildHex(
            _mesher: Packages.mindustry.graphics.g3d.HexMesher,
            _divisions: number,
            _lines: boolean,
            _radius: number,
            _intensity: number,
          ): Packages.arc.graphics.Mesh;
          public static buildPlanetGrid(
            _grid: Packages.mindustry.graphics.g3d.PlanetGrid,
            _color: Packages.arc.graphics.Color,
            _scale: number,
          ): Packages.arc.graphics.Mesh;
          private static verts(
            _a: Packages.arc.math.geom.Vec3,
            _b: Packages.arc.math.geom.Vec3,
            _c: Packages.arc.math.geom.Vec3,
            _normal: Packages.arc.math.geom.Vec3,
            _color: Packages.arc.graphics.Color,
          ): void;
          public static buildIcosphere(
            _divisions: number,
            _radius: number,
            _color: Packages.arc.graphics.Color,
          ): Packages.arc.graphics.Mesh;
          public static buildIcosphere(
            _divisions: number,
            _radius: number,
          ): Packages.arc.graphics.Mesh;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare namespace g3d {
        declare class MultiMesh
          extends java.lang.Object
          implements
            Packages.mindustry.graphics.g3d.GenericMesh
        {
          meshes: Packages.mindustry.graphics.g3d.GenericMesh[];
          public render(
            _params: Packages.mindustry.graphics.g3d.PlanetParams,
            _projection: Packages.arc.math.geom.Mat3D,
            _transform: Packages.arc.math.geom.Mat3D,
          ): void;
          public constructor(
            ..._meshes: Packages.mindustry.graphics.g3d.GenericMesh[]
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare namespace g3d {
        declare class NoiseMesh extends Packages.mindustry
          .graphics.g3d.HexMesh {
          public constructor(
            _planet: Packages.mindustry._type.Planet,
            _seed: number,
            _divisions: number,
            _color: Packages.arc.graphics.Color,
            _radius: number,
            _octaves: number,
            _persistence: number,
            _scale: number,
            _mag: number,
          );
          public constructor(
            _planet: Packages.mindustry._type.Planet,
            _seed: number,
            _divisions: number,
            _radius: number,
            _octaves: number,
            _persistence: number,
            _scale: number,
            _mag: number,
            _color1: Packages.arc.graphics.Color,
            _color2: Packages.arc.graphics.Color,
            _coct: number,
            _cper: number,
            _cscl: number,
            _cthresh: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare namespace g3d {
        declare class ShaderSphereMesh extends Packages
          .mindustry.graphics.g3d.PlanetMesh {
          public constructor(
            _planet: Packages.mindustry._type.Planet,
            _shader: Packages.arc.graphics.gl.Shader,
            _divisions: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace graphics {
      declare namespace g3d {
        declare class SunMesh extends Packages.mindustry
          .graphics.g3d.HexMesh {
          public constructor(
            _planet: Packages.mindustry._type.Planet,
            _divisions: number,
            _octaves: number,
            _persistence: number,
            _scl: number,
            _pow: number,
            _mag: number,
            _colorScale: number,
            ..._colors: Packages.arc.graphics.Color[]
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace io {
      declare namespace versions {
        declare class LegacyIO extends java.lang.Object {
          public static unitMap: Packages.arc.struct.StringMap;
          public static readServers(): Packages.arc.struct.Seq<Packages.mindustry.ui.dialogs.JoinDialog.Server>;
          public static readResearch(): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace io {
      declare namespace versions {
        declare class LegacyRegionSaveVersion extends Packages
          .mindustry.io.SaveVersion {
          public read(
            _stream: Packages.java.io.DataInputStream,
            _counter: Packages.arc.util.io.CounterInputStream,
            _context: Packages.mindustry.world.WorldContext,
          ): void;
          public constructor(_version: number);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace io {
      declare namespace versions {
        declare abstract class LegacySaveVersion extends Packages
          .mindustry.io.versions.LegacyRegionSaveVersion {
          public readMap(
            _stream: Packages.java.io.DataInput,
            _context: Packages.mindustry.world.WorldContext,
          ): void;
          public readLegacyEntities(
            _stream: Packages.java.io.DataInput,
          ): void;
          public constructor(_version: number);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace io {
      declare namespace versions {
        declare class LegacySaveVersion2 extends Packages
          .mindustry.io.versions.LegacyRegionSaveVersion {
          public readWorldEntities(
            _stream: Packages.java.io.DataInput,
          ): void;
          public constructor(_version: number);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace io {
      declare namespace versions {
        declare class Save1 extends Packages.mindustry.io
          .versions.LegacySaveVersion {
          public readEntities(
            _stream: Packages.java.io.DataInput,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace io {
      declare namespace versions {
        declare class Save2 extends Packages.mindustry.io
          .versions.LegacySaveVersion {
          public readEntities(
            _stream: Packages.java.io.DataInput,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace io {
      declare namespace versions {
        declare class Save3 extends Packages.mindustry.io
          .versions.LegacySaveVersion {
          public readEntities(
            _stream: Packages.java.io.DataInput,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace io {
      declare namespace versions {
        declare class Save4 extends Packages.mindustry.io
          .versions.LegacySaveVersion2 {
          public readEntities(
            _stream: Packages.java.io.DataInput,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace io {
      declare namespace versions {
        declare class Save5 extends Packages.mindustry.io
          .versions.LegacySaveVersion2 {
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace io {
      declare namespace versions {
        declare class Save6 extends Packages.mindustry.io
          .versions.LegacyRegionSaveVersion {
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace io {
      declare namespace versions {
        declare class Save7 extends Packages.mindustry.io
          .SaveVersion {
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace filters {
        declare class BlendFilter extends Packages.mindustry
          .maps.filters.GenerateFilter {
          public radius: number;
          public block: Packages.mindustry.world.Block;
          public floor: Packages.mindustry.world.Block;
          public ignore: Packages.mindustry.world.Block;
          public apply(
            _in: Packages.mindustry.maps.filters.GenerateFilter.GenerateInput,
          ): void;
          public options():
            | Packages.mindustry.maps.filters.FilterOption[]
            | null;
          public icon(): string;
          public isBuffered(): boolean;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace filters {
        declare class ClearFilter extends Packages.mindustry
          .maps.filters.GenerateFilter {
          public target: Packages.mindustry.world.Block;
          public replace: Packages.mindustry.world.Block;
          public ignore: Packages.mindustry.world.Block;
          public apply(
            _in: Packages.mindustry.maps.filters.GenerateFilter.GenerateInput,
          ): void;
          public options():
            | Packages.mindustry.maps.filters.FilterOption[]
            | null;
          public icon(): string;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace filters {
        declare class CoreSpawnFilter extends Packages
          .mindustry.maps.filters.GenerateFilter {
          public amount: number;
          public apply(
            _tiles: Packages.mindustry.world.Tiles,
            _in: Packages.mindustry.maps.filters.GenerateFilter.GenerateInput,
          ): void;
          public options():
            | Packages.mindustry.maps.filters.FilterOption[]
            | null;
          public icon(): string;
          public isPost(): boolean;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace filters {
        declare class DistortFilter extends Packages
          .mindustry.maps.filters.GenerateFilter {
          public scl: number;
          public mag: number;
          public apply(
            _in: Packages.mindustry.maps.filters.GenerateFilter.GenerateInput,
          ): void;
          public options():
            | Packages.mindustry.maps.filters.FilterOption[]
            | null;
          public icon(): string;
          public isBuffered(): boolean;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace filters {
        declare class EnemySpawnFilter extends Packages
          .mindustry.maps.filters.GenerateFilter {
          public amount: number;
          public apply(
            _tiles: Packages.mindustry.world.Tiles,
            _in: Packages.mindustry.maps.filters.GenerateFilter.GenerateInput,
          ): void;
          public options():
            | Packages.mindustry.maps.filters.FilterOption[]
            | null;
          public icon(): string;
          public isPost(): boolean;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace filters {
        declare class MedianFilter extends Packages
          .mindustry.maps.filters.GenerateFilter {
          private static blocks: Packages.arc.struct.IntSeq;
          private static floors: Packages.arc.struct.IntSeq;
          public radius: number;
          public percentile: number;
          public apply(
            _in: Packages.mindustry.maps.filters.GenerateFilter.GenerateInput,
          ): void;
          public options():
            | Packages.mindustry.maps.filters.FilterOption[]
            | null;
          public icon(): string;
          public isBuffered(): boolean;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace filters {
        declare class MirrorFilter extends Packages
          .mindustry.maps.filters.GenerateFilter {
          private static v1: Packages.arc.math.geom.Vec2;
          private static v2: Packages.arc.math.geom.Vec2;
          private static v3: Packages.arc.math.geom.Vec2;
          public angle: number;
          public rotate: boolean;
          public apply(
            _in: Packages.mindustry.maps.filters.GenerateFilter.GenerateInput,
          ): void;
          public options():
            | Packages.mindustry.maps.filters.FilterOption[]
            | null;
          left(
            _a: Packages.arc.math.geom.Vec2,
            _b: Packages.arc.math.geom.Vec2,
            _c: Packages.arc.math.geom.Vec2,
          ): boolean;
          public draw(
            _image: Packages.arc.scene.ui.Image,
          ): void;
          public icon(): string;
          mirror(
            _width: number,
            _height: number,
            _p: Packages.arc.math.geom.Vec2,
            _x0: number,
            _y0: number,
            _x1: number,
            _y1: number,
          ): void;
          clipHalfLine(
            _v: Packages.arc.math.geom.Vec2,
            _xmin: number,
            _ymin: number,
            _xmax: number,
            _ymax: number,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace filters {
        declare class NoiseFilter extends Packages.mindustry
          .maps.filters.GenerateFilter {
          public scl: number;
          public threshold: number;
          public octaves: number;
          public falloff: number;
          public tilt: number;
          public floor: Packages.mindustry.world.Block;
          public block: Packages.mindustry.world.Block;
          public target: Packages.mindustry.world.Block;
          public apply(
            _in: Packages.mindustry.maps.filters.GenerateFilter.GenerateInput,
          ): void;
          public options():
            | Packages.mindustry.maps.filters.FilterOption[]
            | null;
          public icon(): string;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace filters {
        declare class OreFilter extends Packages.mindustry
          .maps.filters.GenerateFilter {
          public scl: number;
          public threshold: number;
          public octaves: number;
          public falloff: number;
          public tilt: number;
          public ore: Packages.mindustry.world.Block;
          public target: Packages.mindustry.world.Block;
          public apply(
            _in: Packages.mindustry.maps.filters.GenerateFilter.GenerateInput,
          ): void;
          public options():
            | Packages.mindustry.maps.filters.FilterOption[]
            | null;
          public icon(): string;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace filters {
        declare class OreMedianFilter extends Packages
          .mindustry.maps.filters.GenerateFilter {
          private static blocks: Packages.arc.struct.IntSeq;
          public radius: number;
          public percentile: number;
          public apply(
            _in: Packages.mindustry.maps.filters.GenerateFilter.GenerateInput,
          ): void;
          public options():
            | Packages.mindustry.maps.filters.FilterOption[]
            | null;
          public icon(): string;
          public isBuffered(): boolean;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace filters {
        declare class RandomItemFilter extends Packages
          .mindustry.maps.filters.GenerateFilter {
          public drops: Packages.arc.struct.Seq<Packages.mindustry._type.ItemStack>;
          public chance: number;
          public apply(
            _tiles: Packages.mindustry.world.Tiles,
            _in: Packages.mindustry.maps.filters.GenerateFilter.GenerateInput,
          ): void;
          public options():
            | Packages.mindustry.maps.filters.FilterOption[]
            | null;
          public isPost(): boolean;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace filters {
        declare class RiverNoiseFilter extends Packages
          .mindustry.maps.filters.GenerateFilter {
          public scl: number;
          public threshold: number;
          public threshold2: number;
          public octaves: number;
          public falloff: number;
          public floor: Packages.mindustry.world.Block;
          public floor2: Packages.mindustry.world.Block;
          public block: Packages.mindustry.world.Block;
          public target: Packages.mindustry.world.Block;
          public apply(
            _in: Packages.mindustry.maps.filters.GenerateFilter.GenerateInput,
          ): void;
          public options():
            | Packages.mindustry.maps.filters.FilterOption[]
            | null;
          public icon(): string;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace filters {
        declare class ScatterFilter extends Packages
          .mindustry.maps.filters.GenerateFilter {
          public chance: number;
          public flooronto: Packages.mindustry.world.Block;
          public floor: Packages.mindustry.world.Block;
          public block: Packages.mindustry.world.Block;
          public apply(
            _in: Packages.mindustry.maps.filters.GenerateFilter.GenerateInput,
          ): void;
          public options():
            | Packages.mindustry.maps.filters.FilterOption[]
            | null;
          public icon(): string;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace filters {
        declare class SpawnPathFilter extends Packages
          .mindustry.maps.filters.GenerateFilter {
          public radius: number;
          public block: Packages.mindustry.world.Block;
          public apply(
            _tiles: Packages.mindustry.world.Tiles,
            _in: Packages.mindustry.maps.filters.GenerateFilter.GenerateInput,
          ): void;
          public options():
            | Packages.mindustry.maps.filters.FilterOption[]
            | null;
          public icon(): string;
          public isPost(): boolean;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace filters {
        declare class TerrainFilter extends Packages
          .mindustry.maps.filters.GenerateFilter {
          public scl: number;
          public threshold: number;
          public octaves: number;
          public falloff: number;
          public magnitude: number;
          public circleScl: number;
          public tilt: number;
          public floor: Packages.mindustry.world.Block;
          public block: Packages.mindustry.world.Block;
          public apply(
            _in: Packages.mindustry.maps.filters.GenerateFilter.GenerateInput,
          ): void;
          public options():
            | Packages.mindustry.maps.filters.FilterOption[]
            | null;
          public icon(): string;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace generators {
        declare class BaseGenerator extends java.lang
          .Object {
          private static axis: Packages.arc.math.geom.Vec2;
          private static rotator: Packages.arc.math.geom.Vec2;
          private static range: number;
          private static insanity: boolean;
          private tiles: Packages.mindustry.world.Tiles;
          private cores: Packages.arc.struct.Seq<Packages.mindustry.world.Tile>;
          static set(
            _tile: Packages.mindustry.world.Tile,
            _item: Packages.mindustry._type.Item,
          ): void;
          public generate(
            _tiles: Packages.mindustry.world.Tiles,
            _cores: Packages.arc.struct.Seq<Packages.mindustry.world.Tile>,
            _spawn: Packages.mindustry.world.Tile,
            _team: Packages.mindustry.game.Team,
            _sector: Packages.mindustry._type.Sector,
            _difficulty: number,
          ): void;
          pass(
            _cons: Packages.arc.func.Cons<Packages.mindustry.world.Tile>,
          ): void;
          static overlaps(_x: number, _y: number): boolean;
          public static tryPlace(
            _part: Packages.mindustry.ai.BaseRegistry.BasePart,
            _x: number,
            _y: number,
            _team: Packages.mindustry.game.Team,
            _posc: Packages.arc.func.Intc2 | null,
          ): boolean;
          public static tryPlace(
            _part: Packages.mindustry.ai.BaseRegistry.BasePart,
            _x: number,
            _y: number,
            _team: Packages.mindustry.game.Team,
          ): boolean;
          public postGenerate(): void;
          public static getDifficultyWall(
            _size: number,
            _difficulty: number,
          ): Packages.mindustry.world.Block;
          static isTaken(
            _block: Packages.mindustry.world.Block,
            _x: number,
            _y: number,
          ): boolean;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace planet {
        declare class ErekirPlanetGenerator extends Packages
          .mindustry.maps.generators.PlanetGenerator {
          public heightScl: number;
          public octaves: number;
          public persistence: number;
          public heightPow: number;
          public heightMult: number;
          public static arkThresh: number;
          public static arkScl: number;
          public static arkSeed: number;
          public static arkOct: number;
          public static liqThresh: number;
          public static liqScl: number;
          public static redThresh: number;
          public static noArkThresh: number;
          public static crystalSeed: number;
          public static crystalOct: number;
          public static crystalScl: number;
          public static crystalMag: number;
          public static airThresh: number;
          public static airScl: number;
          terrain: Packages.mindustry.world.Block[];
          protected generate(): void;
          public getHeight(
            _position: Packages.arc.math.geom.Vec3,
          ): number;
          public getColor(
            _position: Packages.arc.math.geom.Vec3,
          ): Packages.arc.graphics.Color;
          public getSizeScl(): number;
          public genTile(
            _position: Packages.arc.math.geom.Vec3,
            _tile: Packages.mindustry.world.TileGen,
          ): void;
          public generateSector(
            _sector: Packages.mindustry._type.Sector,
          ): void;
          getBlock(
            _position: Packages.arc.math.geom.Vec3,
          ): Packages.mindustry.world.Block;
          rawHeight(
            _position: Packages.arc.math.geom.Vec3,
          ): number;
          rawTemp(
            _position: Packages.arc.math.geom.Vec3,
          ): number;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace planet {
        declare namespace SerpuloPlanetGenerator {
          declare class Room extends java.lang.Object {
            x: number;
            y: number;
            radius: number;
            connected: Packages.arc.struct.ObjectSet<Packages.mindustry.maps.planet.SerpuloPlanetGenerator.Room>;
            this$0: Packages.mindustry.maps.planet.SerpuloPlanetGenerator;
            join(
              _x1: number,
              _y1: number,
              _x2: number,
              _y2: number,
            ): void;
            connect(
              _to: Packages.mindustry.maps.planet.SerpuloPlanetGenerator.Room,
            ): void;
            connectLiquid(
              _to: Packages.mindustry.maps.planet.SerpuloPlanetGenerator.Room,
            ): void;
            joinLiquid(
              _x1: number,
              _y1: number,
              _x2: number,
              _y2: number,
            ): void;
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace planet {
        declare class SerpuloPlanetGenerator extends Packages
          .mindustry.maps.generators.PlanetGenerator {
          public static alt: boolean;
          basegen: Packages.mindustry.maps.generators.BaseGenerator;
          scl: number;
          waterOffset: number;
          genLakes: boolean;
          arr: Packages.mindustry.world.Block[][];
          dec: Packages.arc.struct.ObjectMap<
            Packages.mindustry.world.Block,
            Packages.mindustry.world.Block
          >;
          tars: Packages.arc.struct.ObjectMap<
            Packages.mindustry.world.Block,
            Packages.mindustry.world.Block
          >;
          water: number;
          protected generate(): void;
          public getHeight(
            _position: Packages.arc.math.geom.Vec3,
          ): number;
          public getColor(
            _position: Packages.arc.math.geom.Vec3,
          ): Packages.arc.graphics.Color;
          protected noise(
            _x: number,
            _y: number,
            _octaves: number,
            _falloff: number,
            _scl: number,
            _mag: number,
          ): number;
          public genTile(
            _position: Packages.arc.math.geom.Vec3,
            _tile: Packages.mindustry.world.TileGen,
          ): void;
          public generateSector(
            _sector: Packages.mindustry._type.Sector,
          ): void;
          public postGenerate(
            _tiles: Packages.mindustry.world.Tiles,
          ): void;
          getBlock(
            _position: Packages.arc.math.geom.Vec3,
          ): Packages.mindustry.world.Block;
          rawHeight(
            _position: Packages.arc.math.geom.Vec3,
          ): number;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace maps {
      declare namespace planet {
        declare class TantrosPlanetGenerator extends Packages
          .mindustry.maps.generators.PlanetGenerator {
          c1: Packages.arc.graphics.Color;
          c2: Packages.arc.graphics.Color;
          out: Packages.arc.graphics.Color;
          arr: Packages.mindustry.world.Block[][];
          protected generate(): void;
          public getHeight(
            _position: Packages.arc.math.geom.Vec3,
          ): number;
          public getColor(
            _position: Packages.arc.math.geom.Vec3,
          ): Packages.arc.graphics.Color;
          public getSizeScl(): number;
          public genTile(
            _position: Packages.arc.math.geom.Vec3,
            _tile: Packages.mindustry.world.TileGen,
          ): void;
          public addWeather(
            _sector: Packages.mindustry._type.Sector,
            _rules: Packages.mindustry.game.Rules,
          ): void;
          public generateSector(
            _sector: Packages.mindustry._type.Sector,
          ): void;
          getBlock(
            _position: Packages.arc.math.geom.Vec3,
          ): Packages.mindustry.world.Block;
          rawHeight(
            _position: Packages.arc.math.geom.Vec3,
          ): number;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare namespace ammo {
        declare class ItemAmmoType
          extends java.lang.Object
          implements Packages.mindustry._type.AmmoType
        {
          public range: number;
          public ammoPerItem: number;
          public item: Packages.mindustry._type.Item;
          public color(): Packages.arc.graphics.Color;
          public icon(): string;
          public barColor(): Packages.arc.graphics.Color;
          public resupply(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public constructor();
          public constructor(
            _item: Packages.mindustry._type.Item,
            _ammoPerItem: number,
          );
          public constructor(
            _item: Packages.mindustry._type.Item,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare namespace ammo {
        declare class PowerAmmoType
          extends java.lang.Object
          implements Packages.mindustry._type.AmmoType
        {
          public range: number;
          public totalPower: number;
          public color(): Packages.arc.graphics.Color;
          public icon(): string;
          public barColor(): Packages.arc.graphics.Color;
          public resupply(
            _unit: Packages.mindustry.gen.Unit,
          ): void;
          public constructor(_totalPower: number);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare namespace unit {
        declare class ErekirUnitType extends Packages
          .mindustry._type.UnitType {
          public constructor(_name: string);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare namespace unit {
        declare class MissileUnitType extends Packages
          .mindustry._type.UnitType {
          public constructor(_name: string);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare namespace unit {
        declare class NeoplasmUnitType extends Packages
          .mindustry._type.UnitType {
          public constructor(_name: string);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare namespace unit {
        declare class TankUnitType extends Packages
          .mindustry._type.unit.ErekirUnitType {
          public constructor(_name: string);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare namespace weapons {
        declare class BuildWeapon extends Packages.mindustry
          ._type.Weapon {
          public update(
            _unit: Packages.mindustry.gen.Unit,
            _mount: Packages.mindustry.entities.units.WeaponMount,
          ): void;
          public draw(
            _unit: Packages.mindustry.gen.Unit,
            _mount: Packages.mindustry.entities.units.WeaponMount,
          ): void;
          public constructor();
          public constructor(_name: string);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare namespace weapons {
        declare class PointDefenseWeapon extends Packages
          .mindustry._type.Weapon {
          public color: Packages.arc.graphics.Color;
          public beamEffect: Packages.mindustry.entities.Effect;
          protected findTarget(
            _unit: Packages.mindustry.gen.Unit,
            _x: number,
            _y: number,
            _range: number,
            _air: boolean,
            _ground: boolean,
          ): Packages.mindustry.gen.Teamc;
          protected checkTarget(
            _unit: Packages.mindustry.gen.Unit,
            _target: Packages.mindustry.gen.Teamc,
            _x: number,
            _y: number,
            _range: number,
          ): boolean;
          protected shoot(
            _unit: Packages.mindustry.gen.Unit,
            _mount: Packages.mindustry.entities.units.WeaponMount,
            _shootX: number,
            _shootY: number,
            _rotation: number,
          ): void;
          public constructor(_name: string);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare namespace weapons {
        declare class RepairBeamWeapon extends Packages
          .mindustry._type.Weapon {
          public static HealBeamMount = class extends Packages
            .mindustry.entities.units.WeaponMount {
            public offset: Packages.arc.math.geom.Vec2;
            public lastEnd: Packages.arc.math.geom.Vec2;
            public strength: number;
            public effectTimer: number;
            public constructor(
              _weapon: Packages.mindustry._type.Weapon,
            );
          };
          public targetBuildings: boolean;
          public targetUnits: boolean;
          public repairSpeed: number;
          public fractionRepairSpeed: number;
          public beamWidth: number;
          public pulseRadius: number;
          public pulseStroke: number;
          public widthSinMag: number;
          public widthSinScl: number;
          public recentDamageMultiplier: number;
          public laser: Packages.arc.graphics.g2d.TextureRegion;
          public laserEnd: Packages.arc.graphics.g2d.TextureRegion;
          public laserTop: Packages.arc.graphics.g2d.TextureRegion;
          public laserTopEnd: Packages.arc.graphics.g2d.TextureRegion;
          public laserColor: Packages.arc.graphics.Color;
          public laserTopColor: Packages.arc.graphics.Color;
          public healColor: Packages.arc.graphics.Color;
          public healEffect: Packages.mindustry.entities.Effect;
          public update(
            _unit: Packages.mindustry.gen.Unit,
            _mount: Packages.mindustry.entities.units.WeaponMount,
          ): void;
          public load(): void;
          public init(): void;
          public draw(
            _unit: Packages.mindustry.gen.Unit,
            _mount: Packages.mindustry.entities.units.WeaponMount,
          ): void;
          protected findTarget(
            _unit: Packages.mindustry.gen.Unit,
            _x: number,
            _y: number,
            _range: number,
            _air: boolean,
            _ground: boolean,
          ): Packages.mindustry.gen.Teamc;
          protected checkTarget(
            _unit: Packages.mindustry.gen.Unit,
            _target: Packages.mindustry.gen.Teamc,
            _x: number,
            _y: number,
            _range: number,
          ): boolean;
          public dps(): number;
          protected shoot(
            _unit: Packages.mindustry.gen.Unit,
            _mount: Packages.mindustry.entities.units.WeaponMount,
            _shootX: number,
            _shootY: number,
            _rotation: number,
          ): void;
          public addStats(
            _u: Packages.mindustry._type.UnitType,
            _w: Packages.arc.scene.ui.layout.Table,
          ): void;
          public constructor(_name: string);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare namespace weather {
        declare class MagneticStorm extends Packages
          .mindustry._type.Weather {
          public constructor(_name: string);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare namespace weather {
        declare class ParticleWeather extends Packages
          .mindustry._type.Weather {
          public particleRegion: string;
          public color: Packages.arc.graphics.Color;
          public region: Packages.arc.graphics.g2d.TextureRegion;
          public yspeed: number;
          public xspeed: number;
          public padding: number;
          public sizeMin: number;
          public sizeMax: number;
          public density: number;
          public minAlpha: number;
          public maxAlpha: number;
          public force: number;
          public noiseScale: number;
          public baseSpeed: number;
          public sinSclMin: number;
          public sinSclMax: number;
          public sinMagMin: number;
          public sinMagMax: number;
          public noiseColor: Packages.arc.graphics.Color;
          public drawNoise: boolean;
          public drawParticles: boolean;
          public useWindVector: boolean;
          public randomParticleRotation: boolean;
          public noiseLayers: number;
          public noiseLayerSpeedM: number;
          public noiseLayerAlphaM: number;
          public noiseLayerSclM: number;
          public noiseLayerColorM: number;
          public noisePath: string;
          public noise?: Packages.arc.graphics.Texture;
          public update(
            _state: Packages.mindustry.gen.WeatherState,
          ): void;
          public load(): void;
          public drawOver(
            _state: Packages.mindustry.gen.WeatherState,
          ): void;
          public constructor(_name: string);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare namespace weather {
        declare class RainWeather extends Packages.mindustry
          ._type.Weather {
          public yspeed: number;
          public xspeed: number;
          public padding: number;
          public density: number;
          public stroke: number;
          public sizeMin: number;
          public sizeMax: number;
          public splashTimeScale: number;
          public liquid: Packages.mindustry._type.Liquid;
          public splashes: Packages.arc.graphics.g2d.TextureRegion[];
          public color: Packages.arc.graphics.Color;
          public load(): void;
          public drawOver(
            _state: Packages.mindustry.gen.WeatherState,
          ): void;
          public drawUnder(
            _state: Packages.mindustry.gen.WeatherState,
          ): void;
          public constructor(_name: string);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace _type {
      declare namespace weather {
        declare class SolarFlare extends Packages.mindustry
          ._type.Weather {
          public constructor(_name: string);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class FileChooser extends Packages.mindustry
          .ui.dialogs.BaseDialog {
          public FileHistory = class extends java.lang
            .Object {
            private history: Packages.arc.struct.Seq<Packages.arc.files.Fi>;
            private index: number;
            this$0: Packages.mindustry.ui.dialogs.FileChooser;
            public push(_file: Packages.arc.files.Fi): void;
            public back(): void;
            public forward(): void;
            public canBack(): boolean;
            public canForward(): boolean;
            public constructor(
              _this$0: Packages.mindustry.ui.dialogs.FileChooser,
            );
          };
          private static homeDirectory: Packages.arc.files.Fi;
          static lastDirectory: Packages.arc.files.Fi;
          directory: Packages.arc.files.Fi;
          private files: Packages.arc.scene.ui.layout.Table;
          private pane: Packages.arc.scene.ui.ScrollPane;
          private navigation: Packages.arc.scene.ui.TextField;
          private filefield: Packages.arc.scene.ui.TextField;
          private ok: Packages.arc.scene.ui.TextButton;
          private stack: Packages.mindustry.ui.dialogs.FileChooser.FileHistory;
          private filter: Packages.arc.func.Boolf<Packages.arc.files.Fi>;
          private selectListener: Packages.arc.func.Cons<Packages.arc.files.Fi>;
          private open: boolean;
          public static getLastDirectory(): Packages.arc.files.Fi;
          public static setLastDirectory(
            _directory: Packages.arc.files.Fi,
          ): void;
          updateFiles(_push: boolean): void;
          private getFileNames():
            | Packages.arc.files.Fi[]
            | null;
          private updateFileFieldStatus(): void;
          private setupWidgets(): void;
          public constructor(
            _title: string,
            _filter: Packages.arc.func.Boolf<Packages.arc.files.Fi>,
            _open: boolean,
            _result: Packages.arc.func.Cons<Packages.arc.files.Fi>,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace dialogs {
        declare class PaletteDialog extends Packages.arc
          .scene.ui.Dialog {
          private cons: Packages.arc.func.Cons<Packages.arc.graphics.Color>;
          private build(): void;
          public show(
            _cons: Packages.arc.func.Cons<Packages.arc.graphics.Color>,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace fragments {
        declare class FadeInFragment extends java.lang
          .Object {
          private static duration: number;
          time: number;
          public build(
            _parent: Packages.arc.scene.Group,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace layout {
        declare abstract class TreeLayout {
          public static TreeNode = class<
            T extends
              Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
          > extends java.lang.Object {
            public width: number;
            public height: number;
            public x: number;
            public y: number;
            public children: T[];
            public parent: T;
            public mode: number;
            public prelim: number;
            public change: number;
            public shift: number;
            public cachedWidth: number;
            public number: number;
            public leaves: number;
            public thread: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>;
            public ancestor: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>;
            public isLeaf(): boolean;
            public calcWidth(): number;
            public constructor();
          };
          public layout(
            _root: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
          ): void;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace layout {
        declare class BranchTreeLayout
          extends java.lang.Object
          implements Packages.mindustry.ui.layout.TreeLayout
        {
          public static TreeLocation = class extends Packages
            .java.lang
            .Enum<Packages.mindustry.ui.layout.BranchTreeLayout.TreeLocation> {
            public static top: Packages.mindustry.ui.layout.BranchTreeLayout.TreeLocation;
            public static left: Packages.mindustry.ui.layout.BranchTreeLayout.TreeLocation;
            public static bottom: Packages.mindustry.ui.layout.BranchTreeLayout.TreeLocation;
            public static right: Packages.mindustry.ui.layout.BranchTreeLayout.TreeLocation;
            private static $VALUES: Packages.mindustry.ui.layout.BranchTreeLayout.TreeLocation[];
            public static values():
              | Packages.mindustry.ui.layout.BranchTreeLayout.TreeLocation[]
              | null;
            public static valueOf(
              _name: string,
            ): Packages.mindustry.ui.layout.BranchTreeLayout.TreeLocation;
          };
          public static TreeAlignment = class extends Packages
            .java.lang
            .Enum<Packages.mindustry.ui.layout.BranchTreeLayout.TreeAlignment> {
            public static center: Packages.mindustry.ui.layout.BranchTreeLayout.TreeAlignment;
            public static towardsRoot: Packages.mindustry.ui.layout.BranchTreeLayout.TreeAlignment;
            public static awayFromRoot: Packages.mindustry.ui.layout.BranchTreeLayout.TreeAlignment;
            private static $VALUES: Packages.mindustry.ui.layout.BranchTreeLayout.TreeAlignment[];
            public static values():
              | Packages.mindustry.ui.layout.BranchTreeLayout.TreeAlignment[]
              | null;
            public static valueOf(
              _name: string,
            ): Packages.mindustry.ui.layout.BranchTreeLayout.TreeAlignment;
          };
          public rootLocation: Packages.mindustry.ui.layout.BranchTreeLayout.TreeLocation;
          public alignment: Packages.mindustry.ui.layout.BranchTreeLayout.TreeAlignment;
          public gapBetweenLevels: number;
          public gapBetweenNodes: number;
          private sizeOfLevel: Packages.arc.struct.FloatSeq;
          private boundsLeft: number;
          private boundsRight: number;
          private boundsTop: number;
          private boundsBottom: number;
          public getBounds(): Packages.arc.math.geom.Rect;
          private getNumber(
            _node: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
            _parentNode: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
          ): number;
          public layout(
            _root: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
          ): void;
          private getDistance(
            _v: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
            _w: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
          ): number;
          private ancestor(
            _vIMinus: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
            _parentOfV: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
            _defaultAncestor: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
          ): Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>;
          private firstWalk(
            _v: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
            _leftSibling: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
          ): void;
          private calcSizeOfLevels(
            _node: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
            _level: number,
          ): void;
          private secondWalk(
            _v: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
            _m: number,
            _level: number,
            _levelStart: number,
          ): void;
          private isLevelChangeInYAxis(): boolean;
          private getWidthOrHeightOfNode(
            _treeNode: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
            _returnWidth: boolean,
          ): number;
          private getNodeThickness(
            _treeNode: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
          ): number;
          public getLevelCount(): number;
          private getNodeSize(
            _treeNode: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
          ): number;
          public getGapBetweenNodes(
            _a: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
            _b: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
          ): number;
          private getAncestor(
            _node: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
          ): Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>;
          private nextRight(
            _v: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
          ): Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>;
          private nextLeft(
            _v: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
          ): Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>;
          private moveSubtree(
            _wMinus: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
            _wPlus: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
            _parent: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
            _shift: number,
          ): void;
          private apportion(
            _v: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
            _defaultAncestor: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
            _leftSibling: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
            _parentOfV: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
          ): Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>;
          private executeShifts(
            _v: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
          ): void;
          private getLevelChangeSign(): number;
          public getSizeOfLevel(_level: number): number;
          private updateBounds(
            _node: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
            _centerX: number,
            _centerY: number,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace layout {
        declare class RadialTreeLayout
          extends java.lang.Object
          implements Packages.mindustry.ui.layout.TreeLayout
        {
          private static visited: Packages.arc.struct.ObjectSet<
            Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>
          >;
          private static queue: Packages.arc.struct.Queue<
            Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>
          >;
          public startRadius: number;
          public delta: number;
          public layout(
            _root: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
          ): void;
          bfs(
            _node: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
            _assign: boolean,
          ): number;
          radialize(
            _root: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
            _radius: number,
            _from: number,
            _to: number,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace ui {
      declare namespace layout {
        declare class RowTreeLayout
          extends java.lang.Object
          implements Packages.mindustry.ui.layout.TreeLayout
        {
          public layout(
            _root: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
          ): void;
          layout(
            _node: Packages.mindustry.ui.layout.TreeLayout.TreeNode<any>,
            _depth: number,
            _nexts: Packages.arc.struct.IntSeq,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare abstract class Autotiler {
          public static SliceMode = class extends Packages
            .java.lang
            .Enum<Packages.mindustry.world.blocks.Autotiler.SliceMode> {
            public static none: Packages.mindustry.world.blocks.Autotiler.SliceMode;
            public static bottom: Packages.mindustry.world.blocks.Autotiler.SliceMode;
            public static top: Packages.mindustry.world.blocks.Autotiler.SliceMode;
            private static $VALUES: Packages.mindustry.world.blocks.Autotiler.SliceMode[];
            public static values():
              | Packages.mindustry.world.blocks.Autotiler.SliceMode[]
              | null;
            public static valueOf(
              _name: string,
            ): Packages.mindustry.world.blocks.Autotiler.SliceMode;
          };
          public static AutotilerHolder = class extends java
            .lang.Object {
            static blendresult: number[];
            static directionals: Packages.mindustry.entities.units.BuildPlan[];
            public constructor();
          };
          public lookingAt(
            _tile: Packages.mindustry.world.Tile,
            _rotation: number,
            _otherx: number,
            _othery: number,
            _otherblock: Packages.mindustry.world.Block,
          ): boolean;
          public blends(
            _tile: Packages.mindustry.world.Tile,
            _rotation: number,
            _otherx: number,
            _othery: number,
            _otherrot: number,
            _otherblock: Packages.mindustry.world.Block,
          ): boolean;
          public blends(
            _tile: Packages.mindustry.world.Tile,
            _rotation: number,
            _directional:
              | Packages.mindustry.entities.units.BuildPlan[]
              | null,
            _direction: number,
            _checkWorld: boolean,
          ): boolean;
          public blends(
            _tile: Packages.mindustry.world.Tile,
            _rotation: number,
            _direction: number,
          ): boolean;
          public getTiling(
            _req: Packages.mindustry.entities.units.BuildPlan,
            _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
          ): number[] | null;
          public lookingAtEither(
            _tile: Packages.mindustry.world.Tile,
            _rotation: number,
            _otherx: number,
            _othery: number,
            _otherrot: number,
            _otherblock: Packages.mindustry.world.Block,
          ): boolean;
          public botHalf(
            _input: Packages.arc.graphics.g2d.TextureRegion,
          ): Packages.arc.graphics.g2d.TextureRegion;
          public topHalf(
            _input: Packages.arc.graphics.g2d.TextureRegion,
          ): Packages.arc.graphics.g2d.TextureRegion;
          public buildBlending(
            _tile: Packages.mindustry.world.Tile,
            _rotation: number,
            _directional: Packages.mindustry.entities.units.BuildPlan[],
            _world: boolean,
          ): number[] | null;
          public transformCase(
            _num: number,
            _bits: number[],
          ): void;
          public sliced(
            _input: Packages.arc.graphics.g2d.TextureRegion,
            _mode: Packages.mindustry.world.blocks.Autotiler.SliceMode,
          ): Packages.arc.graphics.g2d.TextureRegion;
          public facing(
            _x: number,
            _y: number,
            _rotation: number,
            _x2: number,
            _y2: number,
          ): boolean;
          public blendsArmored(
            _tile: Packages.mindustry.world.Tile,
            _rotation: number,
            _otherx: number,
            _othery: number,
            _otherrot: number,
            _otherblock: Packages.mindustry.world.Block,
          ): boolean;
          public notLookingAt(
            _tile: Packages.mindustry.world.Tile,
            _rotation: number,
            _otherx: number,
            _othery: number,
            _otherrot: number,
            _otherblock: Packages.mindustry.world.Block,
          ): boolean;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare class ConstructBlock extends Packages
          .mindustry.world.Block {
          public ConstructBuild = class extends Packages
            .mindustry.gen.Building {
            public current: Packages.mindustry.world.Block;
            public previous: Packages.mindustry.world.Block;
            public prevBuild?: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
            public progress: number;
            public buildCost: number;
            public lastConfig?: any;
            public lastBuilder?: Packages.mindustry.gen.Unit;
            public wasConstructing: boolean;
            public activeDeconstruct: boolean;
            public constructColor: number;
            private accumulator?: number[];
            private totalAccumulator?: number[];
            private itemsLeft?: number[];
            this$0: Packages.mindustry.world.blocks.ConstructBlock;
            public version(): string;
            public write(
              _write: Packages.arc.util.io.Writes,
            ): void;
            public read(
              _read: Packages.arc.util.io.Reads,
              _revision: string,
            ): void;
            public getDisplayName(): string;
            public draw(): void;
            public tapped(): void;
            public sense(
              _sensor: Packages.mindustry.logic.LAccess,
            ): number;
            public onDestroyed(): void;
            public updateTile(): void;
            public checkSolid(): boolean;
            public getDisplayIcon(): Packages.arc.graphics.g2d.TextureRegion;
            public getCursor(): Packages.arc.Graphics.Cursor;
            public deconstruct(
              _builder: Packages.mindustry.gen.Unit,
              _core: Packages.mindustry.world.blocks.storage.CoreBlock.CoreBuild | null,
              _amount: number,
            ): void;
            public construct(
              _builder: Packages.mindustry.gen.Unit,
              _core: Packages.mindustry.gen.Building | null,
              _amount: number,
              _config: any,
            ): void;
            public setDeconstruct(
              _previous: Packages.mindustry.world.Block,
            ): void;
            public setConstruct(
              _previous: Packages.mindustry.world.Block,
              _block: Packages.mindustry.world.Block,
            ): void;
            private checkRequired(
              _inventory: Packages.mindustry.world.modules.ItemModule,
              _amount: number,
              _remove: boolean,
            ): number;
            public progress(): number;
            public constructor(
              _this$0: Packages.mindustry.world.blocks.ConstructBlock,
            );
          };
          private static consBlocks: Packages.mindustry.world.blocks.ConstructBlock[];
          private static lastTime: Packages.long;
          private static pitchSeq: number;
          private static lastPlayed: Packages.long;
          public static get(
            _size: number,
          ): Packages.mindustry.world.blocks.ConstructBlock;
          public isHidden(): boolean;
          static shouldPlay(): boolean;
          public static constructFinish(
            _tile: Packages.mindustry.world.Tile,
            _block: Packages.mindustry.world.Block,
            _builder: Packages.mindustry.gen.Unit | null,
            _rotation: string,
            _team: Packages.mindustry.game.Team,
            _config: any,
          ): void;
          public static deconstructFinish(
            _tile: Packages.mindustry.world.Tile,
            _block: Packages.mindustry.world.Block,
            _builder: Packages.mindustry.gen.Unit,
          ): void;
          static calcPitch(_up: boolean): number;
          public static constructed(
            _tile: Packages.mindustry.world.Tile,
            _block: Packages.mindustry.world.Block,
            _builder: Packages.mindustry.gen.Unit,
            _rotation: string,
            _team: Packages.mindustry.game.Team,
            _config: any,
          ): void;
          public constructor(_size: number);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare abstract class ControlBlock {
          public unit(): Packages.mindustry.gen.Unit;
          public isControlled(): boolean;
          public canControl(): boolean;
          public shouldAutoTarget(): boolean;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare class ItemSelection extends java.lang
          .Object {
          private static search: Packages.arc.scene.ui.TextField;
          private static rowCount: number;
          public static buildTable<
            T extends
              Packages.mindustry.ctype.UnlockableContent,
          >(
            _block: Packages.mindustry.world.Block,
            _table: Packages.arc.scene.ui.layout.Table,
            _items: Packages.arc.struct.Seq<T>,
            _holder: Packages.arc.func.Prov<T>,
            _consumer: Packages.arc.func.Cons<T>,
            _closeSelect: boolean,
          ): void;
          public static buildTable<
            T extends
              Packages.mindustry.ctype.UnlockableContent,
          >(
            _block: Packages.mindustry.world.Block,
            _table: Packages.arc.scene.ui.layout.Table,
            _items: Packages.arc.struct.Seq<T>,
            _holder: Packages.arc.func.Prov<T>,
            _consumer: Packages.arc.func.Cons<T>,
            _rows: number,
            _columns: number,
          ): void;
          public static buildTable<
            T extends
              Packages.mindustry.ctype.UnlockableContent,
          >(
            _table: Packages.arc.scene.ui.layout.Table,
            _items: Packages.arc.struct.Seq<T>,
            _holder: Packages.arc.func.Prov<T>,
            _consumer: Packages.arc.func.Cons<T>,
            _rows: number,
            _columns: number,
          ): void;
          public static buildTable<
            T extends
              Packages.mindustry.ctype.UnlockableContent,
          >(
            _block: Packages.mindustry.world.Block | null,
            _table: Packages.arc.scene.ui.layout.Table,
            _items: Packages.arc.struct.Seq<T>,
            _holder: Packages.arc.func.Prov<T>,
            _consumer: Packages.arc.func.Cons<T>,
            _closeSelect: boolean,
            _rows: number,
            _columns: number,
          ): void;
          public static buildTable<
            T extends
              Packages.mindustry.ctype.UnlockableContent,
          >(
            _table: Packages.arc.scene.ui.layout.Table,
            _items: Packages.arc.struct.Seq<T>,
            _holder: Packages.arc.func.Prov<T>,
            _consumer: Packages.arc.func.Cons<T>,
          ): void;
          public static buildTable<
            T extends
              Packages.mindustry.ctype.UnlockableContent,
          >(
            _table: Packages.arc.scene.ui.layout.Table,
            _items: Packages.arc.struct.Seq<T>,
            _holder: Packages.arc.func.Prov<T>,
            _consumer: Packages.arc.func.Cons<T>,
            _closeSelect: boolean,
          ): void;
          public static buildTable<
            T extends
              Packages.mindustry.ctype.UnlockableContent,
          >(
            _table: Packages.arc.scene.ui.layout.Table,
            _items: Packages.arc.struct.Seq<T>,
            _holder: Packages.arc.func.Prov<T>,
            _consumer: Packages.arc.func.Cons<T>,
            _columns: number,
          ): void;
          public static buildTable<
            T extends
              Packages.mindustry.ctype.UnlockableContent,
          >(
            _block: Packages.mindustry.world.Block,
            _table: Packages.arc.scene.ui.layout.Table,
            _items: Packages.arc.struct.Seq<T>,
            _holder: Packages.arc.func.Prov<T>,
            _consumer: Packages.arc.func.Cons<T>,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare abstract class UnitTetherBlock {
          public spawned(_id: number): void;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace consumers {
        declare class ConsumeItemFilter extends Packages
          .mindustry.world.consumers.Consume {
          public filter: Packages.arc.func.Boolf<Packages.mindustry._type.Item>;
          public update(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public trigger(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public apply(
            _block: Packages.mindustry.world.Block,
          ): void;
          public build(
            _build: Packages.mindustry.gen.Building,
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public display(
            _stats: Packages.mindustry.world.meta.Stats,
          ): void;
          public efficiency(
            _build: Packages.mindustry.gen.Building,
          ): number;
          public getConsumed(
            _build: Packages.mindustry.gen.Building,
          ): Packages.mindustry._type.Item | null;
          public constructor(
            _item: Packages.arc.func.Boolf<Packages.mindustry._type.Item>,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace consumers {
        declare class ConsumeItemCharged extends Packages
          .mindustry.world.consumers.ConsumeItemFilter {
          public minCharge: number;
          public efficiencyMultiplier(
            _build: Packages.mindustry.gen.Building,
          ): number;
          public constructor(_minCharge: number);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace consumers {
        declare class ConsumeItemDynamic extends Packages
          .mindustry.world.consumers.Consume {
          public items: Packages.arc.func.Func<
            Packages.mindustry.gen.Building,
            Packages.mindustry._type.ItemStack[]
          >;
          public trigger(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public apply(
            _block: Packages.mindustry.world.Block,
          ): void;
          public build(
            _build: Packages.mindustry.gen.Building,
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public efficiency(
            _build: Packages.mindustry.gen.Building,
          ): number;
          private rebuild(
            _build: Packages.mindustry.gen.Building,
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public constructor<
            T extends Packages.mindustry.gen.Building,
          >(
            _items: Packages.arc.func.Func<
              T,
              Packages.mindustry._type.ItemStack[]
            >,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace consumers {
        declare class ConsumeItemExplode extends Packages
          .mindustry.world.consumers.ConsumeItemFilter {
          public damage: number;
          public threshold: number;
          public baseChance: number;
          public explodeEffect: Packages.mindustry.entities.Effect;
          public update(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public trigger(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public apply(
            _block: Packages.mindustry.world.Block,
          ): void;
          public build(
            _build: Packages.mindustry.gen.Building,
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public display(
            _stats: Packages.mindustry.world.meta.Stats,
          ): void;
          public efficiency(
            _build: Packages.mindustry.gen.Building,
          ): number;
          public constructor(_threshold: number);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace consumers {
        declare class ConsumeItemExplosive extends Packages
          .mindustry.world.consumers.ConsumeItemFilter {
          public minExplosiveness: number;
          public efficiencyMultiplier(
            _build: Packages.mindustry.gen.Building,
          ): number;
          public constructor(_minCharge: number);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace consumers {
        declare class ConsumeItemFlammable extends Packages
          .mindustry.world.consumers.ConsumeItemFilter {
          public minFlammability: number;
          public efficiencyMultiplier(
            _build: Packages.mindustry.gen.Building,
          ): number;
          public constructor(_minFlammability: number);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace consumers {
        declare class ConsumeItemRadioactive extends Packages
          .mindustry.world.consumers.ConsumeItemFilter {
          public minRadioactivity: number;
          public efficiencyMultiplier(
            _build: Packages.mindustry.gen.Building,
          ): number;
          public constructor(_minRadioactivity: number);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace consumers {
        declare class ConsumeLiquidFlammable extends Packages
          .mindustry.world.consumers.ConsumeLiquidFilter {
          public minFlammability: number;
          public efficiencyMultiplier(
            _build: Packages.mindustry.gen.Building,
          ): number;
          public constructor();
          public constructor(_amount: number);
          public constructor(
            _minFlammability: number,
            _amount: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace consumers {
        declare class ConsumePayloadDynamic extends Packages
          .mindustry.world.consumers.Consume {
          public payloads: Packages.arc.func.Func<
            Packages.mindustry.gen.Building,
            Packages.arc.struct.Seq<Packages.mindustry._type.PayloadStack>
          >;
          public trigger(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public build(
            _build: Packages.mindustry.gen.Building,
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public display(
            _stats: Packages.mindustry.world.meta.Stats,
          ): void;
          public efficiency(
            _build: Packages.mindustry.gen.Building,
          ): number;
          private rebuild(
            _build: Packages.mindustry.gen.Building,
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public constructor<
            T extends Packages.mindustry.gen.Building,
          >(
            _payloads: Packages.arc.func.Func<
              T,
              Packages.arc.struct.Seq<Packages.mindustry._type.PayloadStack>
            >,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace consumers {
        declare class ConsumePayloadFilter extends Packages
          .mindustry.world.consumers.Consume {
          protected fitting: Packages.mindustry.ctype.UnlockableContent[];
          public filter: Packages.arc.func.Boolf<Packages.mindustry.ctype.UnlockableContent>;
          public trigger(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public build(
            _build: Packages.mindustry.gen.Building,
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public display(
            _stats: Packages.mindustry.world.meta.Stats,
          ): void;
          public efficiency(
            _build: Packages.mindustry.gen.Building,
          ): number;
          public constructor(
            _filter: Packages.arc.func.Boolf<Packages.mindustry.ctype.UnlockableContent>,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace consumers {
        declare class ConsumePayloads extends Packages
          .mindustry.world.consumers.Consume {
          public payloads: Packages.arc.struct.Seq<Packages.mindustry._type.PayloadStack>;
          public trigger(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public build(
            _build: Packages.mindustry.gen.Building,
            _table: Packages.arc.scene.ui.layout.Table,
          ): void;
          public display(
            _stats: Packages.mindustry.world.meta.Stats,
          ): void;
          public efficiency(
            _build: Packages.mindustry.gen.Building,
          ): number;
          public constructor(
            _payloads: Packages.arc.struct.Seq<Packages.mindustry._type.PayloadStack>,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace consumers {
        declare class ConsumePowerCondition extends Packages
          .mindustry.world.consumers.ConsumePower {
          private consume: Packages.arc.func.Boolf<Packages.mindustry.gen.Building>;
          public requestedPower(
            _entity: Packages.mindustry.gen.Building,
          ): number;
          public constructor(
            _usage: number,
            _consume: Packages.arc.func.Boolf<Packages.mindustry.gen.Building>,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace consumers {
        declare class ConsumePowerDynamic extends Packages
          .mindustry.world.consumers.ConsumePower {
          private usage: Packages.arc.func.Floatf<Packages.mindustry.gen.Building>;
          private displayedPowerUsage: number;
          public display(
            _stats: Packages.mindustry.world.meta.Stats,
          ): void;
          public requestedPower(
            _entity: Packages.mindustry.gen.Building,
          ): number;
          public constructor(
            _usage: Packages.arc.func.Floatf<Packages.mindustry.gen.Building>,
          );
          public constructor(
            _displayed: number,
            _usage: Packages.arc.func.Floatf<Packages.mindustry.gen.Building>,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace production {
          declare class GenericCrafter extends Packages
            .mindustry.world.Block {
            public GenericCrafterBuild = class extends Packages
              .mindustry.gen.Building {
              public progress: number;
              public totalProgress: number;
              public warmup: number;
              this$0: Packages.mindustry.world.blocks.production.GenericCrafter;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public draw(): void;
              public craft(): void;
              public dumpOutputs(): void;
              public getMaximumAccepted(
                _item: Packages.mindustry._type.Item,
              ): number;
              public shouldConsume(): boolean;
              public sense(
                _sensor: Packages.mindustry.logic.LAccess,
              ): number;
              public getProgressIncrease(
                _baseTime: number,
              ): number;
              public shouldAmbientSound(): boolean;
              public updateTile(): void;
              public totalProgress(): number;
              public warmup(): number;
              public drawLight(): void;
              public warmupTarget(): number;
              public progress(): number;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.production.GenericCrafter,
              );
            };
            public outputItem?: Packages.mindustry._type.ItemStack;
            public outputItems?: Packages.mindustry._type.ItemStack[];
            public outputLiquid?: Packages.mindustry._type.LiquidStack;
            public outputLiquids?: Packages.mindustry._type.LiquidStack[];
            public liquidOutputDirections: number[];
            public dumpExtraLiquid: boolean;
            public ignoreLiquidFullness: boolean;
            public craftTime: number;
            public craftEffect: Packages.mindustry.entities.Effect;
            public updateEffect: Packages.mindustry.entities.Effect;
            public updateEffectChance: number;
            public warmupSpeed: number;
            public legacyReadWarmup: boolean;
            public drawer: Packages.mindustry.world.draw.DrawBlock;
            public load(): void;
            public init(): void;
            public drawOverlay(
              _x: number,
              _y: number,
              _rotation: number,
            ): void;
            public setBars(): void;
            public getRegionsToOutline(
              _out: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.TextureRegion>,
            ): void;
            public outputsItems(): boolean;
            public rotatedOutput(
              _fromX: number,
              _fromY: number,
              _destination: Packages.mindustry.world.Tile,
            ): boolean;
            public setStats(): void;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare abstract class DrawBlock extends java.lang
          .Object {
          protected static rand: Packages.arc.math.Rand;
          public iconOverride?: string[];
          public load(
            _block: Packages.mindustry.world.Block,
          ): void;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public expectCrafter(
            _block: Packages.mindustry.world.Block,
          ): Packages.mindustry.world.blocks.production.GenericCrafter;
          public getRegionsToOutline(
            _block: Packages.mindustry.world.Block,
            _out: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.TextureRegion>,
          ): void;
          public drawLight(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public drawPlan(
            _block: Packages.mindustry.world.Block,
            _plan: Packages.mindustry.entities.units.BuildPlan,
            _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
          ): void;
          public icons(
            _block: Packages.mindustry.world.Block,
          ):
            | Packages.arc.graphics.g2d.TextureRegion[]
            | null;
          public finalIcons(
            _block: Packages.mindustry.world.Block,
          ):
            | Packages.arc.graphics.g2d.TextureRegion[]
            | null;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawArcSmelt extends Packages
          .mindustry.world.draw.DrawBlock {
          public flameColor: Packages.arc.graphics.Color;
          public midColor: Packages.arc.graphics.Color;
          public flameRad: number;
          public circleSpace: number;
          public flameRadiusScl: number;
          public flameRadiusMag: number;
          public circleStroke: number;
          public alpha: number;
          public particles: number;
          public particleLife: number;
          public particleRad: number;
          public particleStroke: number;
          public particleLen: number;
          public drawCenter: boolean;
          public blending: Packages.arc.graphics.Blending;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawBlurSpin extends Packages
          .mindustry.world.draw.DrawBlock {
          public region: Packages.arc.graphics.g2d.TextureRegion;
          public blurRegion: Packages.arc.graphics.g2d.TextureRegion;
          public suffix: string;
          public rotateSpeed: number;
          public x: number;
          public y: number;
          public blurThresh: number;
          public load(
            _block: Packages.mindustry.world.Block,
          ): void;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public icons(
            _block: Packages.mindustry.world.Block,
          ):
            | Packages.arc.graphics.g2d.TextureRegion[]
            | null;
          public constructor(
            _suffix: string,
            _speed: number,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawBubbles extends Packages.mindustry
          .world.draw.DrawBlock {
          public color: Packages.arc.graphics.Color;
          public amount: number;
          public sides: number;
          public strokeMin: number;
          public spread: number;
          public timeScl: number;
          public recurrence: number;
          public radius: number;
          public fill: boolean;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public constructor(
            _color: Packages.arc.graphics.Color,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawCells extends Packages.mindustry
          .world.draw.DrawBlock {
          public middle: Packages.arc.graphics.g2d.TextureRegion;
          public color: Packages.arc.graphics.Color;
          public particleColorFrom: Packages.arc.graphics.Color;
          public particleColorTo: Packages.arc.graphics.Color;
          public particles: number;
          public range: number;
          public recurrence: number;
          public radius: number;
          public lifetime: number;
          public load(
            _block: Packages.mindustry.world.Block,
          ): void;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawCircles extends Packages.mindustry
          .world.draw.DrawBlock {
          public color: Packages.arc.graphics.Color;
          public amount: number;
          public sides: number;
          public strokeMin: number;
          public strokeMax: number;
          public timeScl: number;
          public radius: number;
          public radiusOffset: number;
          public x: number;
          public y: number;
          public strokeInterp: Packages.arc.math.Interp;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public constructor(
            _color: Packages.arc.graphics.Color,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawCrucibleFlame extends Packages
          .mindustry.world.draw.DrawBlock {
          public flameColor: Packages.arc.graphics.Color;
          public midColor: Packages.arc.graphics.Color;
          public flameRad: number;
          public circleSpace: number;
          public flameRadiusScl: number;
          public flameRadiusMag: number;
          public circleStroke: number;
          public alpha: number;
          public particles: number;
          public particleLife: number;
          public particleRad: number;
          public particleSize: number;
          public fadeMargin: number;
          public rotateScl: number;
          public particleInterp: Packages.arc.math.Interp;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawCultivator extends Packages
          .mindustry.world.draw.DrawBlock {
          public plantColor: Packages.arc.graphics.Color;
          public plantColorLight: Packages.arc.graphics.Color;
          public bottomColor: Packages.arc.graphics.Color;
          public bubbles: number;
          public sides: number;
          public strokeMin: number;
          public spread: number;
          public timeScl: number;
          public recurrence: number;
          public radius: number;
          public middle: Packages.arc.graphics.g2d.TextureRegion;
          public load(
            _block: Packages.mindustry.world.Block,
          ): void;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawDefault extends Packages.mindustry
          .world.draw.DrawBlock {
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public drawPlan(
            _block: Packages.mindustry.world.Block,
            _plan: Packages.mindustry.entities.units.BuildPlan,
            _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
          ): void;
          public icons(
            _block: Packages.mindustry.world.Block,
          ):
            | Packages.arc.graphics.g2d.TextureRegion[]
            | null;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawFade extends Packages.mindustry
          .world.draw.DrawBlock {
          public suffix: string;
          public alpha: number;
          public scale: number;
          public region: Packages.arc.graphics.g2d.TextureRegion;
          public load(
            _block: Packages.mindustry.world.Block,
          ): void;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawFlame extends Packages.mindustry
          .world.draw.DrawBlock {
          public flameColor: Packages.arc.graphics.Color;
          public top: Packages.arc.graphics.g2d.TextureRegion;
          public lightRadius: number;
          public lightAlpha: number;
          public lightSinScl: number;
          public lightSinMag: number;
          public flameRadius: number;
          public flameRadiusIn: number;
          public flameRadiusScl: number;
          public flameRadiusMag: number;
          public flameRadiusInMag: number;
          public flameX: number;
          public flameY: number;
          public load(
            _block: Packages.mindustry.world.Block,
          ): void;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public drawLight(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public constructor();
          public constructor(
            _flameColor: Packages.arc.graphics.Color,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawFrames extends Packages.mindustry
          .world.draw.DrawBlock {
          public frames: number;
          public interval: number;
          public sine: boolean;
          public regions: Packages.arc.graphics.g2d.TextureRegion[];
          public load(
            _block: Packages.mindustry.world.Block,
          ): void;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public icons(
            _block: Packages.mindustry.world.Block,
          ):
            | Packages.arc.graphics.g2d.TextureRegion[]
            | null;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawGlowRegion extends Packages
          .mindustry.world.draw.DrawBlock {
          public blending: Packages.arc.graphics.Blending;
          public suffix: string;
          public alpha: number;
          public glowScale: number;
          public glowIntensity: number;
          public rotateSpeed: number;
          public layer: number;
          public rotate: boolean;
          public color: Packages.arc.graphics.Color;
          public region: Packages.arc.graphics.g2d.TextureRegion;
          public load(
            _block: Packages.mindustry.world.Block,
          ): void;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public constructor(_suffix: string);
          public constructor(_rotate: boolean);
          public constructor(_layer: number);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawHeatInput extends Packages
          .mindustry.world.draw.DrawBlock {
          public suffix: string;
          public heatColor: Packages.arc.graphics.Color;
          public heatPulse: number;
          public heatPulseScl: number;
          public heat: Packages.arc.graphics.g2d.TextureRegion;
          public load(
            _block: Packages.mindustry.world.Block,
          ): void;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public drawPlan(
            _block: Packages.mindustry.world.Block,
            _plan: Packages.mindustry.entities.units.BuildPlan,
            _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
          ): void;
          public constructor(_suffix: string);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawHeatOutput extends Packages
          .mindustry.world.draw.DrawBlock {
          public heat: Packages.arc.graphics.g2d.TextureRegion;
          public glow: Packages.arc.graphics.g2d.TextureRegion;
          public top1: Packages.arc.graphics.g2d.TextureRegion;
          public top2: Packages.arc.graphics.g2d.TextureRegion;
          public heatColor: Packages.arc.graphics.Color;
          public heatPulse: number;
          public heatPulseScl: number;
          public glowMult: number;
          public rotOffset: number;
          public drawGlow: boolean;
          public load(
            _block: Packages.mindustry.world.Block,
          ): void;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public drawPlan(
            _block: Packages.mindustry.world.Block,
            _plan: Packages.mindustry.entities.units.BuildPlan,
            _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
          ): void;
          public constructor();
          public constructor(
            _rotOffset: number,
            _drawGlow: boolean,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawHeatRegion extends Packages
          .mindustry.world.draw.DrawBlock {
          public color: Packages.arc.graphics.Color;
          public pulse: number;
          public pulseScl: number;
          public layer: number;
          public heat: Packages.arc.graphics.g2d.TextureRegion;
          public suffix: string;
          public load(
            _block: Packages.mindustry.world.Block,
          ): void;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public constructor();
          public constructor(_suffix: string);
          public constructor(_layer: number);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawLiquidOutputs extends Packages
          .mindustry.world.draw.DrawBlock {
          public liquidOutputRegions: Packages.arc.graphics.g2d.TextureRegion[][];
          public load(
            _block: Packages.mindustry.world.Block,
          ): void;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public drawPlan(
            _block: Packages.mindustry.world.Block,
            _plan: Packages.mindustry.entities.units.BuildPlan,
            _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawLiquidRegion extends Packages
          .mindustry.world.draw.DrawBlock {
          public drawLiquid: Packages.mindustry._type.Liquid;
          public liquid: Packages.arc.graphics.g2d.TextureRegion;
          public suffix: string;
          public alpha: number;
          public load(
            _block: Packages.mindustry.world.Block,
          ): void;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public constructor(
            _drawLiquid: Packages.mindustry._type.Liquid,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawLiquidTile extends Packages
          .mindustry.world.draw.DrawBlock {
          public drawLiquid: Packages.mindustry._type.Liquid;
          public padding: number;
          public padLeft: number;
          public padRight: number;
          public padTop: number;
          public padBottom: number;
          public alpha: number;
          public load(
            _block: Packages.mindustry.world.Block,
          ): void;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public constructor();
          public constructor(
            _drawLiquid: Packages.mindustry._type.Liquid,
          );
          public constructor(
            _drawLiquid: Packages.mindustry._type.Liquid,
            _padding: number,
          );
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawMulti extends Packages.mindustry
          .world.draw.DrawBlock {
          public drawers: Packages.mindustry.world.draw.DrawBlock[];
          public load(
            _block: Packages.mindustry.world.Block,
          ): void;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public getRegionsToOutline(
            _block: Packages.mindustry.world.Block,
            _out: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.TextureRegion>,
          ): void;
          public drawLight(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public drawPlan(
            _block: Packages.mindustry.world.Block,
            _plan: Packages.mindustry.entities.units.BuildPlan,
            _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
          ): void;
          public icons(
            _block: Packages.mindustry.world.Block,
          ):
            | Packages.arc.graphics.g2d.TextureRegion[]
            | null;
          public constructor(
            _drawers: Packages.arc.struct.Seq<Packages.mindustry.world.draw.DrawBlock>,
          );
          public constructor(
            ..._drawers: Packages.mindustry.world.draw.DrawBlock[]
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawMultiWeave extends Packages
          .mindustry.world.draw.DrawBlock {
          public weave: Packages.arc.graphics.g2d.TextureRegion;
          public glow: Packages.arc.graphics.g2d.TextureRegion;
          public rotateSpeed: number;
          public rotateSpeed2: number;
          public fadeWeave: boolean;
          public glowColor: Packages.arc.graphics.Color;
          public weaveColor: Packages.arc.graphics.Color;
          public pulse: number;
          public pulseScl: number;
          public load(
            _block: Packages.mindustry.world.Block,
          ): void;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public icons(
            _block: Packages.mindustry.world.Block,
          ):
            | Packages.arc.graphics.g2d.TextureRegion[]
            | null;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawParticles extends Packages
          .mindustry.world.draw.DrawBlock {
          public color: Packages.arc.graphics.Color;
          public alpha: number;
          public particles: number;
          public particleLife: number;
          public particleRad: number;
          public particleSize: number;
          public fadeMargin: number;
          public rotateScl: number;
          public reverse: boolean;
          public particleInterp: Packages.arc.math.Interp;
          public particleSizeInterp: Packages.arc.math.Interp;
          public blending: Packages.arc.graphics.Blending;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawPistons extends Packages.mindustry
          .world.draw.DrawBlock {
          public sinMag: number;
          public sinScl: number;
          public sinOffset: number;
          public sideOffset: number;
          public lenOffset: number;
          public horiOffset: number;
          public angleOffset: number;
          public sides: number;
          public suffix: string;
          public region1: Packages.arc.graphics.g2d.TextureRegion;
          public region2: Packages.arc.graphics.g2d.TextureRegion;
          public regiont: Packages.arc.graphics.g2d.TextureRegion;
          public iconRegion: Packages.arc.graphics.g2d.TextureRegion;
          public load(
            _block: Packages.mindustry.world.Block,
          ): void;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public drawPlan(
            _block: Packages.mindustry.world.Block,
            _plan: Packages.mindustry.entities.units.BuildPlan,
            _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
          ): void;
          public icons(
            _block: Packages.mindustry.world.Block,
          ):
            | Packages.arc.graphics.g2d.TextureRegion[]
            | null;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawPlasma extends Packages.mindustry
          .world.draw.DrawFlame {
          public regions: Packages.arc.graphics.g2d.TextureRegion[];
          public suffix: string;
          public plasmas: number;
          public plasma1: Packages.arc.graphics.Color;
          public plasma2: Packages.arc.graphics.Color;
          public load(
            _block: Packages.mindustry.world.Block,
          ): void;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public drawLight(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawPower extends Packages.mindustry
          .world.draw.DrawBlock {
          public emptyRegion: Packages.arc.graphics.g2d.TextureRegion;
          public fullRegion: Packages.arc.graphics.g2d.TextureRegion;
          public suffix: string;
          public mixcol: boolean;
          public emptyLightColor: Packages.arc.graphics.Color;
          public fullLightColor: Packages.arc.graphics.Color;
          public layer: number;
          public load(
            _block: Packages.mindustry.world.Block,
          ): void;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public drawPlan(
            _block: Packages.mindustry.world.Block,
            _plan: Packages.mindustry.entities.units.BuildPlan,
            _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
          ): void;
          public icons(
            _block: Packages.mindustry.world.Block,
          ):
            | Packages.arc.graphics.g2d.TextureRegion[]
            | null;
          public constructor();
          public constructor(_suffix: string);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawPulseShape extends Packages
          .mindustry.world.draw.DrawBlock {
          public color: Packages.arc.graphics.Color;
          public stroke: number;
          public timeScl: number;
          public minStroke: number;
          public radiusScl: number;
          public layer: number;
          public square: boolean;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public constructor(_square: boolean);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawPumpLiquid extends Packages
          .mindustry.world.draw.DrawBlock {
          public liquid: Packages.arc.graphics.g2d.TextureRegion;
          public load(
            _block: Packages.mindustry.world.Block,
          ): void;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawRegion extends Packages.mindustry
          .world.draw.DrawBlock {
          public region: Packages.arc.graphics.g2d.TextureRegion;
          public suffix: string;
          public spinSprite: boolean;
          public buildingRotate: boolean;
          public rotateSpeed: number;
          public x: number;
          public y: number;
          public rotation: number;
          public layer: number;
          public load(
            _block: Packages.mindustry.world.Block,
          ): void;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public drawPlan(
            _block: Packages.mindustry.world.Block,
            _plan: Packages.mindustry.entities.units.BuildPlan,
            _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
          ): void;
          public icons(
            _block: Packages.mindustry.world.Block,
          ):
            | Packages.arc.graphics.g2d.TextureRegion[]
            | null;
          public constructor();
          public constructor(
            _suffix: string,
            _rotateSpeed: number,
            _spinSprite: boolean,
          );
          public constructor(
            _suffix: string,
            _rotateSpeed: number,
          );
          public constructor(_suffix: string);
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawShape extends Packages.mindustry
          .world.draw.DrawBlock {
          public color: Packages.arc.graphics.Color;
          public sides: number;
          public radius: number;
          public timeScl: number;
          public layer: number;
          public x: number;
          public y: number;
          public useWarmupRadius: boolean;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawSideRegion extends Packages
          .mindustry.world.draw.DrawBlock {
          public top1: Packages.arc.graphics.g2d.TextureRegion;
          public top2: Packages.arc.graphics.g2d.TextureRegion;
          public load(
            _block: Packages.mindustry.world.Block,
          ): void;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public drawPlan(
            _block: Packages.mindustry.world.Block,
            _plan: Packages.mindustry.entities.units.BuildPlan,
            _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
          ): void;
          public icons(
            _block: Packages.mindustry.world.Block,
          ):
            | Packages.arc.graphics.g2d.TextureRegion[]
            | null;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawSoftParticles extends Packages
          .mindustry.world.draw.DrawBlock {
          public region: Packages.arc.graphics.g2d.TextureRegion;
          public color: Packages.arc.graphics.Color;
          public color2: Packages.arc.graphics.Color;
          public alpha: number;
          public particles: number;
          public particleLife: number;
          public particleRad: number;
          public particleSize: number;
          public fadeMargin: number;
          public rotateScl: number;
          public particleInterp: Packages.arc.math.Interp;
          public load(
            _block: Packages.mindustry.world.Block,
          ): void;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawSpikes extends Packages.mindustry
          .world.draw.DrawBlock {
          public color: Packages.arc.graphics.Color;
          public amount: number;
          public layers: number;
          public stroke: number;
          public rotateSpeed: number;
          public radius: number;
          public length: number;
          public x: number;
          public y: number;
          public layerSpeed: number;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public constructor(
            _color: Packages.arc.graphics.Color,
          );
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare abstract class RotBlock {
          public buildRotation(): number;
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare namespace turrets {
            declare class BaseTurret extends Packages
              .mindustry.world.Block {
              public BaseTurretBuild = class
                extends Packages.mindustry.gen.Building
                implements
                  Packages.mindustry.logic.Ranged,
                  Packages.mindustry.world.blocks.RotBlock
              {
                public rotation: number;
                this$0: Packages.mindustry.world.blocks.defense.turrets.BaseTurret;
                public range(): number;
                public estimateDps(): number;
                public drawSelect(): void;
                public buildRotation(): number;
                public constructor(
                  _this$0: Packages.mindustry.world.blocks.defense.turrets.BaseTurret,
                );
              };
              public range: number;
              public placeOverlapMargin: number;
              public rotateSpeed: number;
              public fogRadiusMultiplier: number;
              public coolEffect: Packages.mindustry.entities.Effect;
              public coolantMultiplier: number;
              public coolant?: Packages.mindustry.world.consumers.ConsumeLiquidBase;
              public init(): void;
              public drawPlace(
                _x: number,
                _y: number,
                _rotation: number,
                _valid: boolean,
              ): void;
              public setStats(): void;
              public constructor(_name: string);
            }
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare namespace turrets {
            declare class ReloadTurret extends Packages
              .mindustry.world.blocks.defense.turrets
              .BaseTurret {
              public ReloadTurretBuild = class extends Packages
                .mindustry.world.blocks.defense.turrets
                .BaseTurret.BaseTurretBuild {
                public reloadCounter: number;
                this$0: Packages.mindustry.world.blocks.defense.turrets.ReloadTurret;
                protected updateCooling(): void;
                protected baseReloadSpeed(): number;
                public constructor(
                  _this$0: Packages.mindustry.world.blocks.defense.turrets.ReloadTurret,
                );
              };
              public reload: number;
              public setStats(): void;
              public constructor(_name: string);
            }
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare namespace turrets {
            declare class Turret extends Packages.mindustry
              .world.blocks.defense.turrets.ReloadTurret {
              public TurretBuild = class
                extends Packages.mindustry.world.blocks
                  .defense.turrets.ReloadTurret
                  .ReloadTurretBuild
                implements
                  Packages.mindustry.world.blocks
                    .ControlBlock
              {
                public recoilOffset: Packages.arc.math.geom.Vec2;
                public ammo: Packages.arc.struct.Seq<Packages.mindustry.world.blocks.defense.turrets.Turret.AmmoEntry>;
                public totalAmmo: number;
                public curRecoil: number;
                public heat: number;
                public logicControlTime: number;
                public curRecoils?: number[];
                public shootWarmup: number;
                public charge: number;
                public warmupHold: number;
                public totalShots: number;
                public barrelCounter: number;
                public logicShooting: boolean;
                public target?: Packages.mindustry.gen.Posc;
                public targetPos: Packages.arc.math.geom.Vec2;
                public unit: Packages.mindustry.gen.BlockUnitc;
                public wasShooting: boolean;
                public queuedBullets: number;
                public heatReq: number;
                public sideHeat: number[];
                this$0: Packages.mindustry.world.blocks.defense.turrets.Turret;
                public version(): string;
                public write(
                  _write: Packages.arc.util.io.Writes,
                ): void;
                public read(
                  _read: Packages.arc.util.io.Reads,
                  _revision: string,
                ): void;
                public isActive(): boolean;
                public unit(): Packages.mindustry.gen.Unit;
                public range(): number;
                public control(
                  _type: Packages.mindustry.logic.LAccess,
                  _p1: any,
                  _p2: number,
                  _p3: number,
                  _p4: number,
                ): void;
                public control(
                  _type: Packages.mindustry.logic.LAccess,
                  _p1: number,
                  _p2: number,
                  _p3: number,
                  _p4: number,
                ): void;
                public draw(): void;
                public shouldConsume(): boolean;
                public sense(
                  _sensor: Packages.mindustry.logic.LAccess,
                ): number;
                public handleLiquid(
                  _source: Packages.mindustry.gen.Building,
                  _liquid: Packages.mindustry._type.Liquid,
                  _amount: number,
                ): void;
                public drawrot(): number;
                public shouldActiveSound(): boolean;
                public activeSoundVolume(): number;
                public updateTile(): void;
                public updateEfficiencyMultiplier(): void;
                public readSync(
                  _read: Packages.arc.util.io.Reads,
                  _revision: string,
                ): void;
                protected bullet(
                  _type: Packages.mindustry.entities.bullet.BulletType,
                  _xOffset: number,
                  _yOffset: number,
                  _angleOffset: number,
                  _mover: Packages.mindustry.entities.Mover,
                ): void;
                protected findTarget(): void;
                public estimateDps(): number;
                public warmup(): number;
                protected shoot(
                  _type: Packages.mindustry.entities.bullet.BulletType,
                ): void;
                public isShooting(): boolean;
                protected canHeal(): boolean;
                public useAmmo(): Packages.mindustry.entities.bullet.BulletType;
                public charging(): boolean;
                protected handleBullet(
                  _bullet: Packages.mindustry.gen.Bullet | null,
                  _offsetX: number,
                  _offsetY: number,
                  _angleOffset: number,
                ): void;
                public canControl(): boolean;
                public hasAmmo(): boolean;
                public peekAmmo(): Packages.mindustry.entities.bullet.BulletType | null;
                public targetPosition(
                  _pos: Packages.mindustry.gen.Posc,
                ): void;
                public logicControlled(): boolean;
                protected validateTarget(): boolean;
                protected updateReload(): void;
                public shouldTurn(): boolean;
                protected turnToTarget(
                  _targetRot: number,
                ): void;
                protected updateShooting(): void;
                public progress(): number;
                public constructor(
                  _this$0: Packages.mindustry.world.blocks.defense.turrets.Turret,
                );
              };
              public static BulletEntry = class extends java
                .lang.Object {
                public bullet: Packages.mindustry.gen.Bullet;
                public x: number;
                public y: number;
                public rotation: number;
                public life: number;
                public constructor(
                  _bullet: Packages.mindustry.gen.Bullet,
                  _x: number,
                  _y: number,
                  _rotation: number,
                  _life: number,
                );
              };
              public static AmmoEntry = class extends java
                .lang.Object {
                public amount: number;
                public type(): Packages.mindustry.entities.bullet.BulletType;
                public constructor();
              };
              public static logicControlCooldown: number;
              public timerTarget: number;
              public targetInterval: number;
              public newTargetInterval: number;
              public maxAmmo: number;
              public ammoPerShot: number;
              public consumeAmmoOnce: boolean;
              public heatRequirement: number;
              public maxHeatEfficiency: number;
              public inaccuracy: number;
              public velocityRnd: number;
              public shootCone: number;
              public shootX: number;
              public shootY: number;
              public xRand: number;
              public minRange: number;
              public minWarmup: number;
              public accurateDelay: boolean;
              public moveWhileCharging: boolean;
              public warmupMaintainTime: number;
              public shoot: Packages.mindustry.entities.pattern.ShootPattern;
              public targetAir: boolean;
              public targetGround: boolean;
              public targetHealing: boolean;
              public playerControllable: boolean;
              public displayAmmoMultiplier: boolean;
              public targetUnderBlocks: boolean;
              public alwaysShooting: boolean;
              public predictTarget: boolean;
              public unitSort: Packages.mindustry.entities.Units.Sortf;
              public unitFilter: Packages.arc.func.Boolf<Packages.mindustry.gen.Unit>;
              public buildingFilter: Packages.arc.func.Boolf<Packages.mindustry.gen.Building>;
              public heatColor: Packages.arc.graphics.Color;
              public shootEffect?: Packages.mindustry.entities.Effect;
              public smokeEffect?: Packages.mindustry.entities.Effect;
              public ammoUseEffect: Packages.mindustry.entities.Effect;
              public shootSound: Packages.arc.audio.Sound;
              public chargeSound: Packages.arc.audio.Sound;
              public soundPitchMin: number;
              public soundPitchMax: number;
              public ammoEjectBack: number;
              public shootWarmupSpeed: number;
              public linearWarmup: boolean;
              public recoil: number;
              public recoils: number;
              public recoilTime: number;
              public recoilPow: number;
              public cooldownTime: number;
              public elevation: number;
              public shake: number;
              public drawer: Packages.mindustry.world.draw.DrawBlock;
              public load(): void;
              public init(): void;
              public setBars(): void;
              public getRegionsToOutline(
                _out: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.TextureRegion>,
              ): void;
              public outputsItems(): boolean;
              public setStats(): void;
              public icons():
                | Packages.arc.graphics.g2d.TextureRegion[]
                | null;
              public limitRange(
                _bullet: Packages.mindustry.entities.bullet.BulletType,
                _margin: number,
              ): void;
              public constructor(_name: string);
            }
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawTurret extends Packages.mindustry
          .world.draw.DrawBlock {
          protected static rand: Packages.arc.math.Rand;
          public parts: Packages.arc.struct.Seq<Packages.mindustry.entities.part.DrawPart>;
          public basePrefix: string;
          public liquidDraw?: Packages.mindustry._type.Liquid;
          public turretLayer: number;
          public shadowLayer: number;
          public heatLayer: number;
          public base: Packages.arc.graphics.g2d.TextureRegion;
          public liquid: Packages.arc.graphics.g2d.TextureRegion;
          public top: Packages.arc.graphics.g2d.TextureRegion;
          public heat: Packages.arc.graphics.g2d.TextureRegion;
          public preview: Packages.arc.graphics.g2d.TextureRegion;
          public outline: Packages.arc.graphics.g2d.TextureRegion;
          public load(
            _block: Packages.mindustry.world.Block,
          ): void;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public getRegionsToOutline(
            _block: Packages.mindustry.world.Block,
            _out: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.TextureRegion>,
          ): void;
          public icons(
            _block: Packages.mindustry.world.Block,
          ):
            | Packages.arc.graphics.g2d.TextureRegion[]
            | null;
          public drawTurret(
            _block: Packages.mindustry.world.blocks.defense.turrets.Turret,
            _build: Packages.mindustry.world.blocks.defense.turrets.Turret.TurretBuild,
          ): void;
          public drawHeat(
            _block: Packages.mindustry.world.blocks.defense.turrets.Turret,
            _build: Packages.mindustry.world.blocks.defense.turrets.Turret.TurretBuild,
          ): void;
          public constructor(_basePrefix: string);
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawWarmupRegion extends Packages
          .mindustry.world.draw.DrawBlock {
          public sinMag: number;
          public sinScl: number;
          public color: Packages.arc.graphics.Color;
          public region: Packages.arc.graphics.g2d.TextureRegion;
          public load(
            _block: Packages.mindustry.world.Block,
          ): void;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public drawPlan(
            _block: Packages.mindustry.world.Block,
            _plan: Packages.mindustry.entities.units.BuildPlan,
            _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
          ): void;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace draw {
        declare class DrawWeave extends Packages.mindustry
          .world.draw.DrawBlock {
          public weave: Packages.arc.graphics.g2d.TextureRegion;
          public load(
            _block: Packages.mindustry.world.Block,
          ): void;
          public draw(
            _build: Packages.mindustry.gen.Building,
          ): void;
          public icons(
            _block: Packages.mindustry.world.Block,
          ):
            | Packages.arc.graphics.g2d.TextureRegion[]
            | null;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace meta {
        declare class Env extends java.lang.Object {
          public static terrestrial: number;
          public static space: number;
          public static underwater: number;
          public static spores: number;
          public static scorching: number;
          public static groundOil: number;
          public static groundWater: number;
          public static oxygen: number;
          public static any: number;
          public static none: number;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace meta {
        declare class StatValues extends java.lang.Object {
          public static number(
            _value: number,
            _unit: Packages.mindustry.world.meta.StatUnit,
          ): Packages.mindustry.world.meta.StatValue;
          public static number(
            _value: number,
            _unit: Packages.mindustry.world.meta.StatUnit,
            _merge: boolean,
          ): Packages.mindustry.world.meta.StatValue;
          private static sep(
            _table: Packages.arc.scene.ui.layout.Table,
            _text: string,
          ): void;
          public static string(
            _value: string,
            ..._args: any[]
          ): Packages.mindustry.world.meta.StatValue;
          public static content(
            _content: Packages.mindustry.ctype.UnlockableContent,
          ): Packages.mindustry.world.meta.StatValue;
          public static content<
            T extends
              Packages.mindustry.ctype.UnlockableContent,
          >(
            _list: Packages.arc.struct.Seq<T>,
            _check: Packages.arc.func.Boolf<T>,
          ): Packages.mindustry.world.meta.StatValue;
          public static content(
            _list: Packages.arc.struct.Seq<Packages.mindustry.ctype.UnlockableContent>,
          ): Packages.mindustry.world.meta.StatValue;
          public static items(
            _timePeriod: number,
            ..._stacks: Packages.mindustry._type.ItemStack[]
          ): Packages.mindustry.world.meta.StatValue;
          public static items(
            _displayName: boolean,
            ..._stacks: Packages.mindustry._type.ItemStack[]
          ): Packages.mindustry.world.meta.StatValue;
          public static items(
            _filter: Packages.arc.func.Boolf<Packages.mindustry._type.Item>,
          ): Packages.mindustry.world.meta.StatValue;
          public static items(
            _timePeriod: number,
            _filter: Packages.arc.func.Boolf<Packages.mindustry._type.Item>,
          ): Packages.mindustry.world.meta.StatValue;
          public static items(
            ..._stacks: Packages.mindustry._type.ItemStack[]
          ): Packages.mindustry.world.meta.StatValue;
          public static bool(
            _value: boolean,
          ): Packages.mindustry.world.meta.StatValue;
          private static icon(
            _t: Packages.mindustry.ctype.UnlockableContent,
          ): Packages.arc.graphics.g2d.TextureRegion;
          public static liquids(
            _timePeriod: number,
            _perSecond: boolean,
            ..._stacks: Packages.mindustry._type.LiquidStack[]
          ): Packages.mindustry.world.meta.StatValue;
          public static liquids(
            _timePeriod: number,
            ..._stacks: Packages.mindustry._type.LiquidStack[]
          ): Packages.mindustry.world.meta.StatValue;
          public static liquids(
            _filter: Packages.arc.func.Boolf<Packages.mindustry._type.Liquid>,
            _amount: number,
            _perSecond: boolean,
          ): Packages.mindustry.world.meta.StatValue;
          public static blocks(
            _list: Packages.arc.struct.Seq<Packages.mindustry.world.Block>,
          ): Packages.mindustry.world.meta.StatValue;
          public static blocks(
            _attr: Packages.mindustry.world.meta.Attribute,
            _floating: boolean,
            _scale: number,
            _startZero: boolean,
            _checkFloors: boolean,
          ): Packages.mindustry.world.meta.StatValue;
          public static blocks(
            _attr: Packages.mindustry.world.meta.Attribute,
            _floating: boolean,
            _scale: number,
            _startZero: boolean,
          ): Packages.mindustry.world.meta.StatValue;
          public static blocks(
            _pred: Packages.arc.func.Boolf<Packages.mindustry.world.Block>,
          ): Packages.mindustry.world.meta.StatValue;
          public static liquid(
            _liquid: Packages.mindustry._type.Liquid,
            _amount: number,
            _perSecond: boolean,
          ): Packages.mindustry.world.meta.StatValue;
          public static abilities(
            _abilities: Packages.arc.struct.Seq<Packages.mindustry.entities.abilities.Ability>,
          ): Packages.mindustry.world.meta.StatValue;
          public static weapons(
            _unit: Packages.mindustry._type.UnitType,
            _weapons: Packages.arc.struct.Seq<Packages.mindustry._type.Weapon>,
          ): Packages.mindustry.world.meta.StatValue;
          public static ammo<
            T extends
              Packages.mindustry.ctype.UnlockableContent,
          >(
            _map: Packages.arc.struct.ObjectMap<
              T,
              Packages.mindustry.entities.bullet.BulletType
            >,
            _indent: number,
            _showUnit: boolean,
          ): Packages.mindustry.world.meta.StatValue;
          public static ammo<
            T extends
              Packages.mindustry.ctype.UnlockableContent,
          >(
            _map: Packages.arc.struct.ObjectMap<
              T,
              Packages.mindustry.entities.bullet.BulletType
            >,
            _showUnit: boolean,
          ): Packages.mindustry.world.meta.StatValue;
          public static ammo<
            T extends
              Packages.mindustry.ctype.UnlockableContent,
          >(
            _map: Packages.arc.struct.ObjectMap<
              T,
              Packages.mindustry.entities.bullet.BulletType
            >,
          ): Packages.mindustry.world.meta.StatValue;
          public static statusEffects(
            _list: Packages.arc.struct.Seq<Packages.mindustry._type.StatusEffect>,
          ): Packages.mindustry.world.meta.StatValue;
          public static squared(
            _value: number,
            _unit: Packages.mindustry.world.meta.StatUnit,
          ): Packages.mindustry.world.meta.StatValue;
          public static drillables(
            _drillTime: number,
            _drillMultiplier: number,
            _size: number,
            _multipliers: Packages.arc.struct.ObjectFloatMap<Packages.mindustry._type.Item>,
            _filter: Packages.arc.func.Boolf<Packages.mindustry.world.Block>,
          ): Packages.mindustry.world.meta.StatValue;
          public static itemBoosters(
            _unit: string,
            _timePeriod: number,
            _speedBoost: number,
            _rangeBoost: number,
            _items: Packages.mindustry._type.ItemStack[],
            _filter: Packages.arc.func.Boolf<Packages.mindustry._type.Item>,
          ): Packages.mindustry.world.meta.StatValue;
          public static speedBoosters(
            _unit: string,
            _amount: number,
            _speed: number,
            _strength: boolean,
            _filter: Packages.arc.func.Boolf<Packages.mindustry._type.Liquid>,
          ): Packages.mindustry.world.meta.StatValue;
          public static boosters(
            _reload: number,
            _maxUsed: number,
            _multiplier: number,
            _baseReload: boolean,
            _filter: Packages.arc.func.Boolf<Packages.mindustry._type.Liquid>,
          ): Packages.mindustry.world.meta.StatValue;
          private static ammoStat(_val: number): string;
          public static blockEfficiency(
            _floor: Packages.mindustry.world.Block,
            _multiplier: number,
            _startZero: boolean,
          ): Packages.mindustry.world.meta.StatValue;
          public static fixValue(_value: number): string;
          public constructor();
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace campaign {
          declare class Accelerator extends Packages
            .mindustry.world.Block {
            public AcceleratorBuild = class extends Packages
              .mindustry.gen.Building {
              public heat: number;
              public statusLerp: number;
              this$0: Packages.mindustry.world.blocks.campaign.Accelerator;
              public draw(): void;
              public getMaximumAccepted(
                _item: Packages.mindustry._type.Item,
              ): number;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public updateTile(): void;
              public getCursor(): Packages.arc.Graphics.Cursor;
              public buildConfiguration(
                _table: Packages.arc.scene.ui.layout.Table,
              ): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.campaign.Accelerator,
              );
            };
            public arrowRegion: Packages.arc.graphics.g2d.TextureRegion;
            public launching: Packages.mindustry.world.Block;
            public capacities: number[];
            public init(): void;
            public outputsItems(): boolean;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace campaign {
          declare class LaunchPad extends Packages.mindustry
            .world.Block {
            public LaunchPadBuild = class extends Packages
              .mindustry.gen.Building {
              public launchCounter: number;
              this$0: Packages.mindustry.world.blocks.campaign.LaunchPad;
              public version(): string;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public display(
                _table: Packages.arc.scene.ui.layout.Table,
              ): void;
              public draw(): void;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public shouldConsume(): boolean;
              public sense(
                _sensor: Packages.mindustry.logic.LAccess,
              ): number;
              public updateTile(): void;
              public getCursor(): Packages.arc.Graphics.Cursor;
              public buildConfiguration(
                _table: Packages.arc.scene.ui.layout.Table,
              ): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.campaign.LaunchPad,
              );
            };
            static LaunchPayloadComp = class
              extends java.lang.Object
              implements
                Packages.mindustry.gen.Timedc,
                Packages.mindustry.gen.Drawc,
                Packages.mindustry.gen.Teamc
            {
              x: number;
              y: number;
              stacks: Packages.arc.struct.Seq<Packages.mindustry._type.ItemStack>;
              in: Packages.arc.util.Interval;
              public remove(): void;
              public update(): void;
              cx(): number;
              public draw(): void;
              cy(): number;
            };
            public launchTime: number;
            public launchSound: Packages.arc.audio.Sound;
            public lightRegion: Packages.arc.graphics.g2d.TextureRegion;
            public podRegion: Packages.arc.graphics.g2d.TextureRegion;
            public lightColor: Packages.arc.graphics.Color;
            public setBars(): void;
            public outputsItems(): boolean;
            public setStats(): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare class Wall extends Packages.mindustry
            .world.Block {
            public WallBuild = class extends Packages
              .mindustry.gen.Building {
              public hit: number;
              this$0: Packages.mindustry.world.blocks.defense.Wall;
              public draw(): void;
              public collision(
                _bullet: Packages.mindustry.gen.Bullet,
              ): boolean;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.defense.Wall,
              );
            };
            public lightningChance: number;
            public lightningDamage: number;
            public lightningLength: number;
            public lightningColor: Packages.arc.graphics.Color;
            public lightningSound: Packages.arc.audio.Sound;
            public chanceDeflect: number;
            public flashHit: boolean;
            public flashColor: Packages.arc.graphics.Color;
            public deflectSound: Packages.arc.audio.Sound;
            public setStats(): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare class AutoDoor extends Packages.mindustry
            .world.blocks.defense.Wall {
            public AutoDoorBuild = class extends Packages
              .mindustry.gen.Building {
              public open: boolean;
              this$0: Packages.mindustry.world.blocks.defense.AutoDoor;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public draw(): void;
              public sense(
                _sensor: Packages.mindustry.logic.LAccess,
              ): number;
              public updateTile(): void;
              public checkSolid(): boolean;
              public setOpen(_open: boolean): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.defense.AutoDoor,
              );
            };
            protected static rect: Packages.arc.math.geom.Rect;
            protected static units: Packages.arc.struct.Seq<Packages.mindustry.gen.Unit>;
            protected static groundCheck: Packages.arc.func.Boolf<Packages.mindustry.gen.Unit>;
            public timerToggle: number;
            public checkInterval: number;
            public openfx: Packages.mindustry.entities.Effect;
            public closefx: Packages.mindustry.entities.Effect;
            public doorSound: Packages.arc.audio.Sound;
            public openRegion: Packages.arc.graphics.g2d.TextureRegion;
            public triggerMargin: number;
            public static autoDoorToggle(
              _tile: Packages.mindustry.world.Tile,
              _open: boolean,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare class BaseShield extends Packages
            .mindustry.world.Block {
            public BaseShieldBuild = class extends Packages
              .mindustry.gen.Building {
              public broken: boolean;
              public hit: number;
              public smoothRadius: number;
              this$0: Packages.mindustry.world.blocks.defense.BaseShield;
              public version(): string;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public draw(): void;
              public radius(): number;
              public inFogTo(
                _viewer: Packages.mindustry.game.Team,
              ): boolean;
              public updateTile(): void;
              public drawSelect(): void;
              public drawShield(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.defense.BaseShield,
              );
            };
            public radius: number;
            public sides: number;
            protected static paramBuild: Packages.mindustry.world.blocks.defense.BaseShield.BaseShieldBuild;
            protected static bulletConsumer: Packages.arc.func.Cons<Packages.mindustry.gen.Bullet>;
            protected static unitConsumer: Packages.arc.func.Cons<Packages.mindustry.gen.Unit>;
            public init(): void;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare class BuildTurret extends Packages
            .mindustry.world.blocks.defense.turrets
            .BaseTurret {
            public BuildTurretBuild = class
              extends Packages.mindustry.world.blocks
                .defense.turrets.BaseTurret.BaseTurretBuild
              implements
                Packages.mindustry.world.blocks
                  .ControlBlock,
                Packages.mindustry.world.blocks.RotBlock
            {
              public unit: Packages.mindustry.gen.BlockUnitc;
              public following?: Packages.mindustry.gen.Unit;
              public lastPlan?: Packages.mindustry.game.Teams.BlockPlan;
              public warmup: number;
              this$0: Packages.mindustry.world.blocks.defense.BuildTurret;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public unit(): Packages.mindustry.gen.Unit;
              public draw(): void;
              public shouldConsume(): boolean;
              public updateTile(): void;
              public warmup(): number;
              public canControl(): boolean;
              public buildRotation(): number;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.defense.BuildTurret,
              );
            };
            public timerTarget: number;
            public timerTarget2: number;
            public targetInterval: number;
            public baseRegion: Packages.arc.graphics.g2d.TextureRegion;
            public glowRegion: Packages.arc.graphics.g2d.TextureRegion;
            public buildSpeed: number;
            public buildBeamOffset: number;
            public unitType?: Packages.mindustry._type.UnitType;
            public elevation: number;
            public heatColor: Packages.arc.graphics.Color;
            public init(): void;
            public setStats(): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare class DirectionalForceProjector extends Packages
            .mindustry.world.Block {
            public DirectionalForceProjectorBuild = class extends Packages
              .mindustry.gen.Building {
              public broken: boolean;
              public buildup: number;
              public hit: number;
              public warmup: number;
              public shieldRadius: number;
              this$0: Packages.mindustry.world.blocks.defense.DirectionalForceProjector;
              public draw(): void;
              public shouldAmbientSound(): boolean;
              public updateTile(): void;
              public pickedUp(): void;
              public drawShield(): void;
              public deflectBullets(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.defense.DirectionalForceProjector,
              );
            };
            protected static intersectOut: Packages.arc.math.geom.Vec2;
            protected static p1: Packages.arc.math.geom.Vec2;
            protected static p2: Packages.arc.math.geom.Vec2;
            protected static paramEntity: Packages.mindustry.world.blocks.defense.DirectionalForceProjector.DirectionalForceProjectorBuild;
            protected static paramEffect: Packages.mindustry.entities.Effect;
            protected static dirShieldConsumer: Packages.arc.func.Cons<Packages.mindustry.gen.Bullet>;
            public width: number;
            public shieldHealth: number;
            public cooldownNormal: number;
            public cooldownLiquid: number;
            public cooldownBrokenBase: number;
            public absorbEffect: Packages.mindustry.entities.Effect;
            public shieldBreakEffect: Packages.mindustry.entities.Effect;
            public topRegion: Packages.arc.graphics.g2d.TextureRegion;
            public length: number;
            public padSize: number;
            public init(): void;
            public setBars(): void;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public outputsItems(): boolean;
            public setStats(): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare class Door extends Packages.mindustry
            .world.blocks.defense.Wall {
            public DoorBuild = class extends Packages
              .mindustry.gen.Building {
              public open: boolean;
              public chained: Packages.arc.struct.Seq<Packages.mindustry.world.blocks.defense.Door.DoorBuild>;
              this$0: Packages.mindustry.world.blocks.defense.Door;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public origin(): Packages.mindustry.world.blocks.defense.Door.DoorBuild;
              public control(
                _type: Packages.mindustry.logic.LAccess,
                _p1: number,
                _p2: number,
                _p3: number,
                _p4: number,
              ): void;
              public config(): any;
              public config(): boolean;
              public draw(): void;
              public tapped(): void;
              public effect(): void;
              public sense(
                _sensor: Packages.mindustry.logic.LAccess,
              ): number;
              public onProximityRemoved(): void;
              public onProximityAdded(): void;
              public checkSolid(): boolean;
              public getCursor(): Packages.arc.Graphics.Cursor;
              public updateChained(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.defense.Door,
              );
            };
            protected static rect: Packages.arc.math.geom.Rect;
            protected static doorQueue: Packages.arc.struct.Queue<Packages.mindustry.world.blocks.defense.Door.DoorBuild>;
            public timerToggle: number;
            public openfx: Packages.mindustry.entities.Effect;
            public closefx: Packages.mindustry.entities.Effect;
            public doorSound: Packages.arc.audio.Sound;
            public openRegion: Packages.arc.graphics.g2d.TextureRegion;
            public getPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): Packages.arc.graphics.g2d.TextureRegion;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare class ForceProjector extends Packages
            .mindustry.world.Block {
            public ForceBuild = class
              extends Packages.mindustry.gen.Building
              implements Packages.mindustry.logic.Ranged
            {
              public broken: boolean;
              public buildup: number;
              public radscl: number;
              public hit: number;
              public warmup: number;
              public phaseHeat: number;
              this$0: Packages.mindustry.world.blocks.defense.ForceProjector;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public range(): number;
              public draw(): void;
              public inFogTo(
                _viewer: Packages.mindustry.game.Team,
              ): boolean;
              public sense(
                _sensor: Packages.mindustry.logic.LAccess,
              ): number;
              public shouldAmbientSound(): boolean;
              public updateTile(): void;
              public onRemoved(): void;
              public pickedUp(): void;
              public drawShield(): void;
              public realRadius(): number;
              public deflectBullets(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.defense.ForceProjector,
              );
            };
            public timerUse: number;
            public phaseUseTime: number;
            public phaseRadiusBoost: number;
            public phaseShieldBoost: number;
            public radius: number;
            public sides: number;
            public shieldRotation: number;
            public shieldHealth: number;
            public cooldownNormal: number;
            public cooldownLiquid: number;
            public cooldownBrokenBase: number;
            public coolantConsumption: number;
            public consumeCoolant: boolean;
            public absorbEffect: Packages.mindustry.entities.Effect;
            public shieldBreakEffect: Packages.mindustry.entities.Effect;
            public topRegion: Packages.arc.graphics.g2d.TextureRegion;
            public itemConsumer?: Packages.mindustry.world.consumers.Consume;
            public coolantConsumer?: Packages.mindustry.world.consumers.Consume;
            protected static paramEntity: Packages.mindustry.world.blocks.defense.ForceProjector.ForceBuild;
            protected static paramEffect: Packages.mindustry.entities.Effect;
            protected static shieldConsumer: Packages.arc.func.Cons<Packages.mindustry.gen.Bullet>;
            public init(): void;
            public setBars(): void;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public outputsItems(): boolean;
            public setStats(): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare class MendProjector extends Packages
            .mindustry.world.Block {
            public MendBuild = class
              extends Packages.mindustry.gen.Building
              implements Packages.mindustry.logic.Ranged
            {
              public heat: number;
              public charge: number;
              public phaseHeat: number;
              public smoothEfficiency: number;
              this$0: Packages.mindustry.world.blocks.defense.MendProjector;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public range(): number;
              public draw(): void;
              public sense(
                _sensor: Packages.mindustry.logic.LAccess,
              ): number;
              public updateTile(): void;
              public drawLight(): void;
              public drawSelect(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.defense.MendProjector,
              );
            };
            public timerUse: number;
            public baseColor: Packages.arc.graphics.Color;
            public phaseColor: Packages.arc.graphics.Color;
            public topRegion: Packages.arc.graphics.g2d.TextureRegion;
            public reload: number;
            public range: number;
            public healPercent: number;
            public phaseBoost: number;
            public phaseRangeBoost: number;
            public useTime: number;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public outputsItems(): boolean;
            public setStats(): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare class OverdriveProjector extends Packages
            .mindustry.world.Block {
            public OverdriveBuild = class
              extends Packages.mindustry.gen.Building
              implements Packages.mindustry.logic.Ranged
            {
              public heat: number;
              public charge: number;
              public phaseHeat: number;
              public smoothEfficiency: number;
              public useProgress: number;
              this$0: Packages.mindustry.world.blocks.defense.OverdriveProjector;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public range(): number;
              public draw(): void;
              public updateTile(): void;
              public drawLight(): void;
              public drawSelect(): void;
              public realBoost(): number;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.defense.OverdriveProjector,
              );
            };
            public timerUse: number;
            public topRegion: Packages.arc.graphics.g2d.TextureRegion;
            public reload: number;
            public range: number;
            public speedBoost: number;
            public speedBoostPhase: number;
            public useTime: number;
            public phaseRangeBoost: number;
            public hasBoost: boolean;
            public baseColor: Packages.arc.graphics.Color;
            public phaseColor: Packages.arc.graphics.Color;
            public setBars(): void;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public outputsItems(): boolean;
            public setStats(): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare class Radar extends Packages.mindustry
            .world.Block {
            public RadarBuild = class extends Packages
              .mindustry.gen.Building {
              public progress: number;
              public lastRadius: number;
              public smoothEfficiency: number;
              public totalProgress: number;
              this$0: Packages.mindustry.world.blocks.defense.Radar;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public draw(): void;
              public fogRadius(): number;
              public updateTile(): void;
              public canPickup(): boolean;
              public drawSelect(): void;
              public progress(): number;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.defense.Radar,
              );
            };
            public discoveryTime: number;
            public rotateSpeed: number;
            public baseRegion: Packages.arc.graphics.g2d.TextureRegion;
            public glowRegion: Packages.arc.graphics.g2d.TextureRegion;
            public glowColor: Packages.arc.graphics.Color;
            public glowScl: number;
            public glowMag: number;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare class RegenProjector extends Packages
            .mindustry.world.Block {
            public RegenProjectorBuild = class extends Packages
              .mindustry.gen.Building {
              public targets: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>;
              public lastChange: number;
              public warmup: number;
              public totalTime: number;
              public optionalTimer: number;
              public anyTargets: boolean;
              public didRegen: boolean;
              this$0: Packages.mindustry.world.blocks.defense.RegenProjector;
              public draw(): void;
              public shouldConsume(): boolean;
              public updateTile(): void;
              public totalProgress(): number;
              public warmup(): number;
              public drawLight(): void;
              public drawSelect(): void;
              public updateTargets(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.defense.RegenProjector,
              );
            };
            private static taken: Packages.arc.struct.IntSet;
            private static mendMap: Packages.arc.struct.IntFloatMap;
            private static lastUpdateFrame: Packages.long;
            public range: number;
            public healPercent: number;
            public optionalMultiplier: number;
            public optionalUseTime: number;
            public drawer: Packages.mindustry.world.draw.DrawBlock;
            public effectChance: number;
            public baseColor: Packages.arc.graphics.Color;
            public effect: Packages.mindustry.entities.Effect;
            public load(): void;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public outputsItems(): boolean;
            public setStats(): void;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare class ShieldWall extends Packages
            .mindustry.world.blocks.defense.Wall {
            public ShieldWallBuild = class extends Packages
              .mindustry.world.blocks.defense.Wall
              .WallBuild {
              public shield: number;
              public shieldRadius: number;
              public breakTimer: number;
              this$0: Packages.mindustry.world.blocks.defense.ShieldWall;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public draw(): void;
              public damage(_damage: number): void;
              public updateTile(): void;
              public pickedUp(): void;
              public broken(): boolean;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.defense.ShieldWall,
              );
            };
            public shieldHealth: number;
            public breakCooldown: number;
            public regenSpeed: number;
            public glowColor: Packages.arc.graphics.Color;
            public glowMag: number;
            public glowScl: number;
            public glowRegion: Packages.arc.graphics.g2d.TextureRegion;
            public setStats(): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare class ShockMine extends Packages.mindustry
            .world.Block {
            public ShockMineBuild = class extends Packages
              .mindustry.gen.Building {
              this$0: Packages.mindustry.world.blocks.defense.ShockMine;
              public draw(): void;
              public drawCracks(): void;
              public drawTeam(): void;
              public unitOn(
                _unit: Packages.mindustry.gen.Unit,
              ): void;
              public triggered(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.defense.ShockMine,
              );
            };
            public timerDamage: number;
            public cooldown: number;
            public tileDamage: number;
            public damage: number;
            public length: number;
            public tendrils: number;
            public lightningColor: Packages.arc.graphics.Color;
            public shots: number;
            public inaccuracy: number;
            public bullet?: Packages.mindustry.entities.bullet.BulletType;
            public teamAlpha: number;
            public teamRegion: Packages.arc.graphics.g2d.TextureRegion;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare class ShockwaveTower extends Packages
            .mindustry.world.Block {
            public ShockwaveTowerBuild = class extends Packages
              .mindustry.gen.Building {
              public reloadCounter: number;
              public heat: number;
              public targets: Packages.arc.struct.Seq<Packages.mindustry.gen.Bullet>;
              this$0: Packages.mindustry.world.blocks.defense.ShockwaveTower;
              public draw(): void;
              public shouldConsume(): boolean;
              public updateTile(): void;
              public warmup(): number;
              public drawSelect(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.defense.ShockwaveTower,
              );
            };
            public timerCheck: number;
            public range: number;
            public reload: number;
            public bulletDamage: number;
            public falloffCount: number;
            public shake: number;
            public checkInterval: number;
            public shootSound: Packages.arc.audio.Sound;
            public waveColor: Packages.arc.graphics.Color;
            public heatColor: Packages.arc.graphics.Color;
            public shapeColor: Packages.arc.graphics.Color;
            public cooldownMultiplier: number;
            public hitEffect: Packages.mindustry.entities.Effect;
            public waveEffect: Packages.mindustry.entities.Effect;
            public shapeRotateSpeed: number;
            public shapeRadius: number;
            public shapeSides: number;
            public heatRegion: Packages.arc.graphics.g2d.TextureRegion;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public setStats(): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare class Thruster extends Packages.mindustry
            .world.blocks.defense.Wall {
            public ThrusterBuild = class extends Packages
              .mindustry.world.blocks.defense.Wall
              .WallBuild {
              this$0: Packages.mindustry.world.blocks.defense.Thruster;
              public draw(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.defense.Thruster,
              );
            };
            public topRegion: Packages.arc.graphics.g2d.TextureRegion;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace distribution {
          declare abstract class ChainedBuilding {
            public next(): Packages.mindustry.gen.Building;
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace distribution {
          declare class Conveyor
            extends Packages.mindustry.world.Block
            implements
              Packages.mindustry.world.blocks.Autotiler
          {
            public ConveyorBuild = class
              extends Packages.mindustry.gen.Building
              implements
                Packages.mindustry.world.blocks.distribution
                  .ChainedBuilding
            {
              public ids: Packages.mindustry._type.Item[];
              public xs: number[];
              public ys: number[];
              public len: number;
              public next?: Packages.mindustry.gen.Building;
              public nextc?: Packages.mindustry.world.blocks.distribution.Conveyor.ConveyorBuild;
              public aligned: boolean;
              public lastInserted: number;
              public mid: number;
              public minitem: number;
              public blendbits: number;
              public blending: number;
              public blendsclx: number;
              public blendscly: number;
              public clogHeat: number;
              this$0: Packages.mindustry.world.blocks.distribution.Conveyor;
              public add(_o: number): void;
              public remove(_o: number): void;
              public next(): Packages.mindustry.gen.Building | null;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public pass(
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public draw(): void;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public handleItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): void;
              public drawCracks(): void;
              public acceptStack(
                _item: Packages.mindustry._type.Item,
                _amount: number,
                _source: Packages.mindustry.gen.Teamc,
              ): number;
              public handleStack(
                _item: Packages.mindustry._type.Item,
                _amount: number,
                _source: Packages.mindustry.gen.Teamc,
              ): void;
              public removeStack(
                _item: Packages.mindustry._type.Item,
                _amount: number,
              ): number;
              public shouldAmbientSound(): boolean;
              public updateTile(): void;
              public onProximityUpdate(): void;
              public senseObject(
                _sensor: Packages.mindustry.logic.LAccess,
              ): any;
              public getStackOffset(
                _item: Packages.mindustry._type.Item,
                _trns: Packages.arc.math.geom.Vec2,
              ): void;
              public overwrote(
                _builds: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>,
              ): void;
              public payloadDraw(): void;
              public unitOn(
                _unit: Packages.mindustry.gen.Unit,
              ): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.distribution.Conveyor,
              );
            };
            private static itemSpace: number;
            private static capacity: number;
            public regions: Packages.arc.graphics.g2d.TextureRegion[][];
            public speed: number;
            public displayedSpeed: number;
            public junctionReplacement?: Packages.mindustry.world.Block;
            public bridgeReplacement?: Packages.mindustry.world.Block;
            public init(): void;
            public isAccessible(): boolean;
            public canReplace(
              _other: Packages.mindustry.world.Block,
            ): boolean;
            public getReplacement(
              _req: Packages.mindustry.entities.units.BuildPlan,
              _plans: Packages.arc.struct.Seq<Packages.mindustry.entities.units.BuildPlan>,
            ): Packages.mindustry.world.Block;
            public handlePlacementLine(
              _plans: Packages.arc.struct.Seq<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public setStats(): void;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public blends(
              _tile: Packages.mindustry.world.Tile,
              _rotation: number,
              _otherx: number,
              _othery: number,
              _otherrot: number,
              _otherblock: Packages.mindustry.world.Block,
            ): boolean;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace distribution {
          declare class ArmoredConveyor extends Packages
            .mindustry.world.blocks.distribution.Conveyor {
            public ArmoredConveyorBuild = class extends Packages
              .mindustry.world.blocks.distribution.Conveyor
              .ConveyorBuild {
              this$0: Packages.mindustry.world.blocks.distribution.ArmoredConveyor;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.distribution.ArmoredConveyor,
              );
            };
            public blends(
              _tile: Packages.mindustry.world.Tile,
              _rotation: number,
              _otherx: number,
              _othery: number,
              _otherrot: number,
              _otherblock: Packages.mindustry.world.Block,
            ): boolean;
            public blendsArmored(
              _tile: Packages.mindustry.world.Tile,
              _rotation: number,
              _otherx: number,
              _othery: number,
              _otherrot: number,
              _otherblock: Packages.mindustry.world.Block,
            ): boolean;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace distribution {
          declare class BufferedItemBridge extends Packages
            .mindustry.world.blocks.distribution
            .ItemBridge {
            public BufferedItemBridgeBuild = class extends Packages
              .mindustry.world.blocks.distribution
              .ItemBridge.ItemBridgeBuild {
              buffer: Packages.mindustry.world.ItemBuffer;
              this$0: Packages.mindustry.world.blocks.distribution.BufferedItemBridge;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public doDump(): void;
              public updateTransport(
                _other: Packages.mindustry.gen.Building,
              ): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.distribution.BufferedItemBridge,
              );
            };
            public timerAccept: number;
            public speed: number;
            public bufferCapacity: number;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace distribution {
          declare class DirectionLiquidBridge extends Packages
            .mindustry.world.blocks.distribution
            .DirectionBridge {
            public DuctBridgeBuild = class extends Packages
              .mindustry.world.blocks.distribution
              .DirectionBridge.DirectionBridgeBuild {
              this$0: Packages.mindustry.world.blocks.distribution.DirectionLiquidBridge;
              public draw(): void;
              public acceptLiquid(
                _source: Packages.mindustry.gen.Building,
                _liquid: Packages.mindustry._type.Liquid,
              ): boolean;
              public updateTile(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.distribution.DirectionLiquidBridge,
              );
            };
            public timerFlow: number;
            public speed: number;
            public liquidPadding: number;
            public bottomRegion: Packages.arc.graphics.g2d.TextureRegion;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace distribution {
          declare class DirectionalUnloader extends Packages
            .mindustry.world.Block {
            public DirectionalUnloaderBuild = class extends Packages
              .mindustry.gen.Building {
              public unloadTimer: number;
              public unloadItem: Packages.mindustry._type.Item;
              public offset: number;
              this$0: Packages.mindustry.world.blocks.distribution.DirectionalUnloader;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public config(): any;
              public config(): Packages.mindustry._type.Item;
              public draw(): void;
              public updateTile(): void;
              public buildConfiguration(
                _table: Packages.arc.scene.ui.layout.Table,
              ): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.distribution.DirectionalUnloader,
              );
            };
            public centerRegion: Packages.arc.graphics.g2d.TextureRegion;
            public topRegion: Packages.arc.graphics.g2d.TextureRegion;
            public arrowRegion: Packages.arc.graphics.g2d.TextureRegion;
            public speed: number;
            public allowCoreUnload: boolean;
            public setBars(): void;
            public setStats(): void;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public drawPlanConfig(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace distribution {
          declare class Duct
            extends Packages.mindustry.world.Block
            implements
              Packages.mindustry.world.blocks.Autotiler
          {
            public DuctBuild = class extends Packages
              .mindustry.gen.Building {
              public progress: number;
              public current?: Packages.mindustry._type.Item;
              public recDir: number;
              public blendbits: number;
              public xscl: number;
              public yscl: number;
              public blending: number;
              public next?: Packages.mindustry.gen.Building;
              public nextc?: Packages.mindustry.world.blocks.distribution.Duct.DuctBuild;
              this$0: Packages.mindustry.world.blocks.distribution.Duct;
              public version(): string;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public draw(): void;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public handleItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): void;
              public handleStack(
                _item: Packages.mindustry._type.Item,
                _amount: number,
                _source: Packages.mindustry.gen.Teamc,
              ): void;
              public removeStack(
                _item: Packages.mindustry._type.Item,
                _amount: number,
              ): number;
              public updateTile(): void;
              public onProximityUpdate(): void;
              public payloadDraw(): void;
              protected drawAt(
                _x: number,
                _y: number,
                _bits: number,
                _rotation: number,
                _slice: Packages.mindustry.world.blocks.Autotiler.SliceMode,
              ): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.distribution.Duct,
              );
            };
            public speed: number;
            public armored: boolean;
            public transparentColor: Packages.arc.graphics.Color;
            public topRegions: Packages.arc.graphics.g2d.TextureRegion[];
            public botRegions: Packages.arc.graphics.g2d.TextureRegion[];
            public bridgeReplacement?: Packages.mindustry.world.Block;
            public init(): void;
            public handlePlacementLine(
              _plans: Packages.arc.struct.Seq<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public setStats(): void;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public blends(
              _tile: Packages.mindustry.world.Tile,
              _rotation: number,
              _otherx: number,
              _othery: number,
              _otherrot: number,
              _otherblock: Packages.mindustry.world.Block,
            ): boolean;
            public blendsArmored(
              _tile: Packages.mindustry.world.Tile,
              _rotation: number,
              _otherx: number,
              _othery: number,
              _otherrot: number,
              _otherblock: Packages.mindustry.world.Block,
            ): boolean;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace distribution {
          declare class DuctBridge extends Packages
            .mindustry.world.blocks.distribution
            .DirectionBridge {
            public DuctBridgeBuild = class extends Packages
              .mindustry.world.blocks.distribution
              .DirectionBridge.DirectionBridgeBuild {
              public progress: number;
              this$0: Packages.mindustry.world.blocks.distribution.DuctBridge;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public updateTile(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.distribution.DuctBridge,
              );
            };
            public speed: number;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace distribution {
          declare class DuctRouter extends Packages
            .mindustry.world.Block {
            public DuctRouterBuild = class extends Packages
              .mindustry.gen.Building {
              public sortItem?: Packages.mindustry._type.Item;
              public progress: number;
              public current?: Packages.mindustry._type.Item;
              this$0: Packages.mindustry.world.blocks.distribution.DuctRouter;
              public target(): Packages.mindustry.gen.Building | null;
              public version(): string;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public config(): Packages.mindustry._type.Item;
              public config(): any;
              public draw(): void;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public handleItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): void;
              public handleStack(
                _item: Packages.mindustry._type.Item,
                _amount: number,
                _source: Packages.mindustry.gen.Teamc,
              ): void;
              public removeStack(
                _item: Packages.mindustry._type.Item,
                _amount: number,
              ): number;
              public updateTile(): void;
              public buildConfiguration(
                _table: Packages.arc.scene.ui.layout.Table,
              ): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.distribution.DuctRouter,
              );
            };
            public speed: number;
            public topRegion: Packages.arc.graphics.g2d.TextureRegion;
            public minimapColor(
              _tile: Packages.mindustry.world.Tile,
            ): number;
            public rotatedOutput(
              _x: number,
              _y: number,
            ): boolean;
            public setStats(): void;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace distribution {
          declare class Junction extends Packages.mindustry
            .world.Block {
            public JunctionBuild = class extends Packages
              .mindustry.gen.Building {
              public buffer: Packages.mindustry.world.DirectionalItemBuffer;
              this$0: Packages.mindustry.world.blocks.distribution.Junction;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public handleItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): void;
              public acceptStack(
                _item: Packages.mindustry._type.Item,
                _amount: number,
                _source: Packages.mindustry.gen.Teamc,
              ): number;
              public updateTile(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.distribution.Junction,
              );
            };
            public speed: number;
            public capacity: number;
            public outputsItems(): boolean;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace distribution {
          declare class MassDriver extends Packages
            .mindustry.world.Block {
            public MassDriverBuild = class
              extends Packages.mindustry.gen.Building
              implements
                Packages.mindustry.world.blocks.RotBlock
            {
              public link: number;
              public rotation: number;
              public reloadCounter: number;
              public state: Packages.mindustry.world.blocks.distribution.MassDriver.DriverState;
              public waitingShooters: Packages.arc.struct.OrderedSet<Packages.mindustry.gen.Building>;
              this$0: Packages.mindustry.world.blocks.distribution.MassDriver;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public config(): Packages.arc.math.geom.Point2;
              public config(): any;
              public draw(): void;
              protected fire(
                _target: Packages.mindustry.world.blocks.distribution.MassDriver.MassDriverBuild,
              ): void;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public handlePayload(
                _bullet: Packages.mindustry.gen.Bullet,
                _data: Packages.mindustry.world.blocks.distribution.MassDriver.DriverBulletData,
              ): void;
              public sense(
                _sensor: Packages.mindustry.logic.LAccess,
              ): number;
              public updateTile(): void;
              public onConfigureBuildTapped(
                _other: Packages.mindustry.gen.Building,
              ): boolean;
              public drawConfigure(): void;
              protected linkValid(): boolean;
              public buildRotation(): number;
              public currentShooter(): Packages.mindustry.gen.Building;
              protected shooterValid(
                _other: Packages.mindustry.gen.Building,
              ): boolean;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.distribution.MassDriver,
              );
            };
            public static DriverState = class extends Packages
              .java.lang
              .Enum<Packages.mindustry.world.blocks.distribution.MassDriver.DriverState> {
              public static idle: Packages.mindustry.world.blocks.distribution.MassDriver.DriverState;
              public static accepting: Packages.mindustry.world.blocks.distribution.MassDriver.DriverState;
              public static shooting: Packages.mindustry.world.blocks.distribution.MassDriver.DriverState;
              public static all: Packages.mindustry.world.blocks.distribution.MassDriver.DriverState[];
              private static $VALUES: Packages.mindustry.world.blocks.distribution.MassDriver.DriverState[];
              public static values():
                | Packages.mindustry.world.blocks.distribution.MassDriver.DriverState[]
                | null;
              public static valueOf(
                _name: string,
              ): Packages.mindustry.world.blocks.distribution.MassDriver.DriverState;
            };
            public static DriverBulletData = class
              extends java.lang.Object
              implements
                Packages.arc.util.pooling.Pool.Poolable
            {
              public from: Packages.mindustry.world.blocks.distribution.MassDriver.MassDriverBuild;
              public to: Packages.mindustry.world.blocks.distribution.MassDriver.MassDriverBuild;
              public items: number[];
              public reset(): void;
              public constructor();
            };
            public range: number;
            public rotateSpeed: number;
            public translation: number;
            public minDistribute: number;
            public knockback: number;
            public reload: number;
            public bullet: Packages.mindustry.entities.bullet.MassDriverBolt;
            public bulletSpeed: number;
            public bulletLifetime: number;
            public shootEffect: Packages.mindustry.entities.Effect;
            public smokeEffect: Packages.mindustry.entities.Effect;
            public receiveEffect: Packages.mindustry.entities.Effect;
            public shootSound: Packages.arc.audio.Sound;
            public shake: number;
            public baseRegion: Packages.arc.graphics.g2d.TextureRegion;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public setStats(): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace distribution {
          declare class OverflowDuct extends Packages
            .mindustry.world.Block {
            public OverflowDuctBuild = class extends Packages
              .mindustry.gen.Building {
              public progress: number;
              public current?: Packages.mindustry._type.Item;
              this$0: Packages.mindustry.world.blocks.distribution.OverflowDuct;
              public target(): Packages.mindustry.gen.Building | null;
              public draw(): void;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public handleItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): void;
              public handleStack(
                _item: Packages.mindustry._type.Item,
                _amount: number,
                _source: Packages.mindustry.gen.Teamc,
              ): void;
              public removeStack(
                _item: Packages.mindustry._type.Item,
                _amount: number,
              ): number;
              public updateTile(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.distribution.OverflowDuct,
              );
            };
            public speed: number;
            public invert: boolean;
            public topRegion: Packages.arc.graphics.g2d.TextureRegion;
            public rotatedOutput(
              _x: number,
              _y: number,
            ): boolean;
            public setStats(): void;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace distribution {
          declare class OverflowGate extends Packages
            .mindustry.world.Block {
            public OverflowGateBuild = class extends Packages
              .mindustry.gen.Building {
              this$0: Packages.mindustry.world.blocks.distribution.OverflowGate;
              public version(): string;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public handleItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): void;
              public getTileTarget(
                _item: Packages.mindustry._type.Item,
                _src: Packages.mindustry.gen.Building,
                _flip: boolean,
              ): Packages.mindustry.gen.Building | null;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.distribution.OverflowGate,
              );
            };
            public speed: number;
            public invert: boolean;
            public outputsItems(): boolean;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace distribution {
          declare class Router extends Packages.mindustry
            .world.Block {
            public RouterBuild = class
              extends Packages.mindustry.gen.Building
              implements
                Packages.mindustry.world.blocks.ControlBlock
            {
              public lastItem: Packages.mindustry._type.Item;
              public lastInput: Packages.mindustry.world.Tile;
              public time: number;
              public unit?: Packages.mindustry.gen.BlockUnitc;
              this$0: Packages.mindustry.world.blocks.distribution.Router;
              public unit(): Packages.mindustry.gen.Unit;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public handleItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): void;
              public acceptStack(
                _item: Packages.mindustry._type.Item,
                _amount: number,
                _source: Packages.mindustry.gen.Teamc,
              ): number;
              public removeStack(
                _item: Packages.mindustry._type.Item,
                _amount: number,
              ): number;
              public updateTile(): void;
              public canControl(): boolean;
              public shouldAutoTarget(): boolean;
              public getTileTarget(
                _item: Packages.mindustry._type.Item,
                _from: Packages.mindustry.world.Tile,
                _set: boolean,
              ): Packages.mindustry.gen.Building;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.distribution.Router,
              );
            };
            public speed: number;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace distribution {
          declare class Sorter extends Packages.mindustry
            .world.Block {
            public SorterBuild = class extends Packages
              .mindustry.gen.Building {
              public sortItem?: Packages.mindustry._type.Item;
              this$0: Packages.mindustry.world.blocks.distribution.Sorter;
              public version(): string;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public config(): Packages.mindustry._type.Item;
              public config(): any;
              public draw(): void;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public handleItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): void;
              public configured(
                _player: Packages.mindustry.gen.Unit,
                _value: any,
              ): void;
              public buildConfiguration(
                _table: Packages.arc.scene.ui.layout.Table,
              ): void;
              public getTileTarget(
                _item: Packages.mindustry._type.Item,
                _source: Packages.mindustry.gen.Building,
                _flip: boolean,
              ): Packages.mindustry.gen.Building;
              public isSame(
                _other: Packages.mindustry.gen.Building,
              ): boolean;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.distribution.Sorter,
              );
            };
            public cross: Packages.arc.graphics.g2d.TextureRegion;
            public invert: boolean;
            public minimapColor(
              _tile: Packages.mindustry.world.Tile,
            ): number;
            public outputsItems(): boolean;
            public drawPlanConfig(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            protected icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace distribution {
          declare class StackConveyor
            extends Packages.mindustry.world.Block
            implements
              Packages.mindustry.world.blocks.Autotiler
          {
            public StackConveyorBuild = class extends Packages
              .mindustry.gen.Building {
              public state: number;
              public blendprox: number;
              public link: number;
              public cooldown: number;
              public lastItem: Packages.mindustry._type.Item;
              proxUpdating: boolean;
              this$0: Packages.mindustry.world.blocks.distribution.StackConveyor;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public dropped(): void;
              public draw(): void;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public handleItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): void;
              public drawCracks(): void;
              public acceptStack(
                _item: Packages.mindustry._type.Item,
                _amount: number,
                _source: Packages.mindustry.gen.Teamc,
              ): number;
              public handleStack(
                _item: Packages.mindustry._type.Item,
                _amount: number,
                _source: Packages.mindustry.gen.Teamc,
              ): void;
              public removeStack(
                _item: Packages.mindustry._type.Item,
                _amount: number,
              ): number;
              public shouldAmbientSound(): boolean;
              public updateTile(): void;
              public onProximityUpdate(): void;
              public canUnload(): boolean;
              public itemTaken(
                _item: Packages.mindustry._type.Item,
              ): void;
              public overwrote(
                _builds: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>,
              ): void;
              public payloadDraw(): void;
              protected poofOut(): void;
              protected poofIn(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.distribution.StackConveyor,
              );
            };
            protected static stateMove: number;
            protected static stateLoad: number;
            protected static stateUnload: number;
            public regions: Packages.arc.graphics.g2d.TextureRegion[];
            public edgeRegion: Packages.arc.graphics.g2d.TextureRegion;
            public stackRegion: Packages.arc.graphics.g2d.TextureRegion;
            public glowRegion: Packages.arc.graphics.g2d.TextureRegion;
            public edgeGlowRegion: Packages.arc.graphics.g2d.TextureRegion;
            public glowAlpha: number;
            public glowColor: Packages.arc.graphics.Color;
            public baseEfficiency: number;
            public speed: number;
            public outputRouter: boolean;
            public recharge: number;
            public loadEffect: Packages.mindustry.entities.Effect;
            public unloadEffect: Packages.mindustry.entities.Effect;
            public rotatedOutput(
              _x: number,
              _y: number,
            ): boolean;
            public setStats(): void;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public blends(
              _tile: Packages.mindustry.world.Tile,
              _rotation: number,
              _otherx: number,
              _othery: number,
              _otherrot: number,
              _otherblock: Packages.mindustry.world.Block,
            ): boolean;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace distribution {
          declare class StackRouter extends Packages
            .mindustry.world.blocks.distribution
            .DuctRouter {
            public StackRouterBuild = class extends Packages
              .mindustry.world.blocks.distribution
              .DuctRouter.DuctRouterBuild {
              public unloading: boolean;
              this$0: Packages.mindustry.world.blocks.distribution.StackRouter;
              public draw(): void;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public updateTile(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.distribution.StackRouter,
              );
            };
            public baseEfficiency: number;
            public glowRegion: Packages.arc.graphics.g2d.TextureRegion;
            public glowAlpha: number;
            public glowColor: Packages.arc.graphics.Color;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace environment {
          declare class AirBlock extends Packages.mindustry
            .world.blocks.environment.Floor {
            public isHidden(): boolean;
            public load(): void;
            public init(): void;
            public variantRegions():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public drawBase(
              _tile: Packages.mindustry.world.Tile,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace environment {
          declare class Cliff extends Packages.mindustry
            .world.Block {
            public size: number;
            public cliffs: Packages.arc.graphics.g2d.TextureRegion[];
            public editorCliffs: Packages.arc.graphics.g2d.TextureRegion[];
            public drawBase(
              _tile: Packages.mindustry.world.Tile,
            ): void;
            public minimapColor(
              _tile: Packages.mindustry.world.Tile,
            ): number;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace environment {
          declare class EmptyFloor extends Packages
            .mindustry.world.blocks.environment.Floor {
            public drawBase(
              _tile: Packages.mindustry.world.Tile,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace environment {
          declare class Prop extends Packages.mindustry
            .world.Block {
            public layer: number;
            public drawBase(
              _tile: Packages.mindustry.world.Tile,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace environment {
          declare class SeaBush extends Packages.mindustry
            .world.blocks.environment.Prop {
            public botRegion: Packages.arc.graphics.g2d.TextureRegion;
            public centerRegion: Packages.arc.graphics.g2d.TextureRegion;
            public lobesMin: number;
            public lobesMax: number;
            public botAngle: number;
            public origin: number;
            public sclMin: number;
            public sclMax: number;
            public magMin: number;
            public magMax: number;
            public timeRange: number;
            public spread: number;
            static rand: Packages.arc.math.Rand;
            public drawBase(
              _tile: Packages.mindustry.world.Tile,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace environment {
          declare class Seaweed extends Packages.mindustry
            .world.blocks.environment.Prop {
            public drawBase(
              _tile: Packages.mindustry.world.Tile,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace environment {
          declare class ShallowLiquid extends Packages
            .mindustry.world.blocks.environment.Floor {
            public liquidBase?: Packages.mindustry.world.blocks.environment.Floor;
            public floorBase?: Packages.mindustry.world.blocks.environment.Floor;
            public liquidOpacity: number;
            public set(
              _liquid: Packages.mindustry.world.Block,
              _floor: Packages.mindustry.world.Block,
            ): void;
            public createIcons(
              _packer: Packages.mindustry.graphics.MultiPacker,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace environment {
          declare class SpawnBlock extends Packages
            .mindustry.world.blocks.environment
            .OverlayFloor {
            public drawBase(
              _tile: Packages.mindustry.world.Tile,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace environment {
          declare class StaticWall extends Packages
            .mindustry.world.blocks.environment.Prop {
            public large: Packages.arc.graphics.g2d.TextureRegion;
            public split: Packages.arc.graphics.g2d.TextureRegion[][];
            public load(): void;
            eq(_rx: number, _ry: number): boolean;
            public drawBase(
              _tile: Packages.mindustry.world.Tile,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace environment {
          declare class StaticTree extends Packages
            .mindustry.world.blocks.environment.StaticWall {
            public drawBase(
              _tile: Packages.mindustry.world.Tile,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace environment {
          declare class SteamVent extends Packages.mindustry
            .world.blocks.environment.Floor {
            public static offsets: Packages.arc.math.geom.Point2[];
            public parent: Packages.mindustry.world.Block;
            public effect: Packages.mindustry.entities.Effect;
            public effectColor: Packages.arc.graphics.Color;
            public effectSpacing: number;
            public drawBase(
              _tile: Packages.mindustry.world.Tile,
            ): void;
            public updateRender(
              _tile: Packages.mindustry.world.Tile,
            ): boolean;
            public renderUpdate(
              _state: Packages.mindustry.world.blocks.environment.Floor.UpdateRenderState,
            ): void;
            public checkAdjacent(
              _tile: Packages.mindustry.world.Tile,
            ): boolean;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace environment {
          declare class TallBlock extends Packages.mindustry
            .world.Block {
            public shadowOffset: number;
            public layer: number;
            public shadowLayer: number;
            public rotationRand: number;
            public shadowAlpha: number;
            public init(): void;
            public drawBase(
              _tile: Packages.mindustry.world.Tile,
            ): void;
            public drawShadow(
              _tile: Packages.mindustry.world.Tile,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace environment {
          declare class TreeBlock extends Packages.mindustry
            .world.Block {
            public shadowOffset: number;
            public shadow: Packages.arc.graphics.g2d.TextureRegion;
            public drawBase(
              _tile: Packages.mindustry.world.Tile,
            ): void;
            public drawShadow(
              _tile: Packages.mindustry.world.Tile,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace environment {
          declare class WobbleProp extends Packages
            .mindustry.world.blocks.environment.Prop {
            public wscl: number;
            public wmag: number;
            public wtscl: number;
            public wmag2: number;
            public drawBase(
              _tile: Packages.mindustry.world.Tile,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace heat {
          declare abstract class HeatBlock {
            public heat(): number;
            public heatFrac(): number;
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace heat {
          declare abstract class HeatConsumer {
            public sideHeat(): number[] | null;
            public heatRequirement(): number;
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace heat {
          declare class HeatConductor extends Packages
            .mindustry.world.Block {
            public HeatConductorBuild = class
              extends Packages.mindustry.gen.Building
              implements
                Packages.mindustry.world.blocks.heat
                  .HeatBlock,
                Packages.mindustry.world.blocks.heat
                  .HeatConsumer
            {
              public heat: number;
              public sideHeat: number[];
              public cameFrom: Packages.arc.struct.IntSet;
              public lastHeatUpdate: Packages.long;
              this$0: Packages.mindustry.world.blocks.heat.HeatConductor;
              public draw(): void;
              public heat(): number;
              public updateHeat(): void;
              public updateTile(): void;
              public sideHeat(): number[] | null;
              public warmup(): number;
              public drawLight(): void;
              public heatRequirement(): number;
              public heatFrac(): number;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.heat.HeatConductor,
              );
            };
            public visualMaxHeat: number;
            public drawer: Packages.mindustry.world.draw.DrawBlock;
            public splitHeat: boolean;
            public load(): void;
            public setBars(): void;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace heat {
          declare class HeatProducer extends Packages
            .mindustry.world.blocks.production
            .GenericCrafter {
            public HeatProducerBuild = class
              extends Packages.mindustry.world.blocks
                .production.GenericCrafter
                .GenericCrafterBuild
              implements
                Packages.mindustry.world.blocks.heat
                  .HeatBlock
            {
              public heat: number;
              this$0: Packages.mindustry.world.blocks.heat.HeatProducer;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public heat(): number;
              public updateTile(): void;
              public heatFrac(): number;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.heat.HeatProducer,
              );
            };
            public heatOutput: number;
            public warmupRate: number;
            public setBars(): void;
            public setStats(): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace legacy {
          declare class LegacyBlock extends Packages
            .mindustry.world.Block {
            public removeSelf(
              _tile: Packages.mindustry.world.Tile,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace legacy {
          declare class LegacyCommandCenter extends Packages
            .mindustry.world.blocks.legacy.LegacyBlock {
            public CommandBuild = class extends Packages
              .mindustry.gen.Building {
              this$0: Packages.mindustry.world.blocks.legacy.LegacyCommandCenter;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _version: string,
              ): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.legacy.LegacyCommandCenter,
              );
            };
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace legacy {
          declare class LegacyMechPad extends Packages
            .mindustry.world.blocks.legacy.LegacyBlock {
            public LegacyMechPadBuild = class extends Packages
              .mindustry.gen.Building {
              this$0: Packages.mindustry.world.blocks.legacy.LegacyMechPad;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.legacy.LegacyMechPad,
              );
            };
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace legacy {
          declare class LegacyUnitFactory extends Packages
            .mindustry.world.blocks.legacy.LegacyBlock {
            public LegacyUnitFactoryBuild = class extends Packages
              .mindustry.gen.Building {
              this$0: Packages.mindustry.world.blocks.legacy.LegacyUnitFactory;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.legacy.LegacyUnitFactory,
              );
            };
            public replacement: Packages.mindustry.world.Block;
            public removeSelf(
              _tile: Packages.mindustry.world.Tile,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace liquid {
          declare class LiquidBlock extends Packages
            .mindustry.world.Block {
            public LiquidBuild = class extends Packages
              .mindustry.gen.Building {
              this$0: Packages.mindustry.world.blocks.liquid.LiquidBlock;
              public draw(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.liquid.LiquidBlock,
              );
            };
            public liquidRegion: Packages.arc.graphics.g2d.TextureRegion;
            public topRegion: Packages.arc.graphics.g2d.TextureRegion;
            public bottomRegion: Packages.arc.graphics.g2d.TextureRegion;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public static drawTiledFrames(
              _size: number,
              _x: number,
              _y: number,
              _padLeft: number,
              _padRight: number,
              _padTop: number,
              _padBottom: number,
              _liquid: Packages.mindustry._type.Liquid,
              _alpha: number,
            ): void;
            public static drawTiledFrames(
              _size: number,
              _x: number,
              _y: number,
              _padding: number,
              _liquid: Packages.mindustry._type.Liquid,
              _alpha: number,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace liquid {
          declare class Conduit
            extends Packages.mindustry.world.blocks.liquid
              .LiquidBlock
            implements
              Packages.mindustry.world.blocks.Autotiler
          {
            public ConduitBuild = class
              extends Packages.mindustry.world.blocks.liquid
                .LiquidBlock.LiquidBuild
              implements
                Packages.mindustry.world.blocks.distribution
                  .ChainedBuilding
            {
              public smoothLiquid: number;
              public blendbits: number;
              public xscl: number;
              public yscl: number;
              public blending: number;
              public capped: boolean;
              public backCapped: boolean;
              this$0: Packages.mindustry.world.blocks.liquid.Conduit;
              public next(): Packages.mindustry.gen.Building | null;
              public draw(): void;
              public acceptLiquid(
                _source: Packages.mindustry.gen.Building,
                _liquid: Packages.mindustry._type.Liquid,
              ): boolean;
              public updateTile(): void;
              public onProximityUpdate(): void;
              protected drawAt(
                _x: number,
                _y: number,
                _bits: number,
                _rotation: number,
                _slice: Packages.mindustry.world.blocks.Autotiler.SliceMode,
              ): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.liquid.Conduit,
              );
            };
            static rotatePad: number;
            static hpad: number;
            static rotateOffsets: number[][];
            public timerFlow: number;
            public botColor: Packages.arc.graphics.Color;
            public topRegions: Packages.arc.graphics.g2d.TextureRegion[];
            public botRegions: Packages.arc.graphics.g2d.TextureRegion[];
            public capRegion: Packages.arc.graphics.g2d.TextureRegion;
            public rotateRegions: Packages.arc.graphics.g2d.TextureRegion[][][];
            public padCorners: boolean;
            public leaks: boolean;
            public junctionReplacement?: Packages.mindustry.world.Block;
            public bridgeReplacement?: Packages.mindustry.world.Block;
            public rotBridgeReplacement?: Packages.mindustry.world.Block;
            public load(): void;
            public init(): void;
            public getReplacement(
              _req: Packages.mindustry.entities.units.BuildPlan,
              _plans: Packages.arc.struct.Seq<Packages.mindustry.entities.units.BuildPlan>,
            ): Packages.mindustry.world.Block;
            public handlePlacementLine(
              _plans: Packages.arc.struct.Seq<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public blends(
              _tile: Packages.mindustry.world.Tile,
              _rotation: number,
              _otherx: number,
              _othery: number,
              _otherrot: number,
              _otherblock: Packages.mindustry.world.Block,
            ): boolean;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace liquid {
          declare class ArmoredConduit extends Packages
            .mindustry.world.blocks.liquid.Conduit {
            public ArmoredConduitBuild = class extends Packages
              .mindustry.world.blocks.liquid.Conduit
              .ConduitBuild {
              this$0: Packages.mindustry.world.blocks.liquid.ArmoredConduit;
              public acceptLiquid(
                _source: Packages.mindustry.gen.Building,
                _liquid: Packages.mindustry._type.Liquid,
              ): boolean;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.liquid.ArmoredConduit,
              );
            };
            public blends(
              _tile: Packages.mindustry.world.Tile,
              _rotation: number,
              _otherx: number,
              _othery: number,
              _otherrot: number,
              _otherblock: Packages.mindustry.world.Block,
            ): boolean;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace liquid {
          declare class LiquidBridge extends Packages
            .mindustry.world.blocks.distribution
            .ItemBridge {
            public LiquidBridgeBuild = class extends Packages
              .mindustry.world.blocks.distribution
              .ItemBridge.ItemBridgeBuild {
              this$0: Packages.mindustry.world.blocks.liquid.LiquidBridge;
              public doDump(): void;
              public updateTransport(
                _other: Packages.mindustry.gen.Building,
              ): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.liquid.LiquidBridge,
              );
            };
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace liquid {
          declare class LiquidJunction extends Packages
            .mindustry.world.blocks.liquid.LiquidBlock {
            public LiquidJunctionBuild = class extends Packages
              .mindustry.gen.Building {
              this$0: Packages.mindustry.world.blocks.liquid.LiquidJunction;
              public draw(): void;
              public getLiquidDestination(
                _source: Packages.mindustry.gen.Building,
                _liquid: Packages.mindustry._type.Liquid,
              ): Packages.mindustry.gen.Building;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.liquid.LiquidJunction,
              );
            };
            public setBars(): void;
            public setStats(): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace liquid {
          declare class LiquidRouter extends Packages
            .mindustry.world.blocks.liquid.LiquidBlock {
            public LiquidRouterBuild = class extends Packages
              .mindustry.world.blocks.liquid.LiquidBlock
              .LiquidBuild {
              this$0: Packages.mindustry.world.blocks.liquid.LiquidRouter;
              public draw(): void;
              public acceptLiquid(
                _source: Packages.mindustry.gen.Building,
                _liquid: Packages.mindustry._type.Liquid,
              ): boolean;
              public updateTile(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.liquid.LiquidRouter,
              );
            };
            public liquidPadding: number;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace logic {
          declare class CanvasBlock extends Packages
            .mindustry.world.Block {
            public CanvasBuild = class extends Packages
              .mindustry.gen.Building {
              public texture?: Packages.arc.graphics.Texture;
              public data: string[];
              public blending: number;
              this$0: Packages.mindustry.world.blocks.logic.CanvasBlock;
              public remove(): void;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              protected setByte(
                _bytes: string[],
                _bitOffset: number,
                _value: number,
              ): void;
              public config(): string[] | null;
              public config(): any;
              public draw(): void;
              public updateTexture(): void;
              public onProximityUpdate(): void;
              public onConfigureBuildTapped(
                _other: Packages.mindustry.gen.Building,
              ): boolean;
              public buildConfiguration(
                _table: Packages.arc.scene.ui.layout.Table,
              ): void;
              blends(
                _other: Packages.mindustry.world.Tile,
              ): boolean;
              public packPixmap(
                _pixmap: Packages.arc.graphics.Pixmap,
              ): string[] | null;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.logic.CanvasBlock,
              );
            };
            public padding: number;
            public canvasSize: number;
            public palette: number[];
            public bitsPerPixel: number;
            public colorToIndex: Packages.arc.struct.IntIntMap;
            public side1: Packages.arc.graphics.g2d.TextureRegion;
            public side2: Packages.arc.graphics.g2d.TextureRegion;
            public corner1: Packages.arc.graphics.g2d.TextureRegion;
            public corner2: Packages.arc.graphics.g2d.TextureRegion;
            protected previewPixmap?: Packages.arc.graphics.Pixmap;
            protected previewTexture?: Packages.arc.graphics.Texture;
            protected tempBlend: number;
            protected getByte(
              _data: string[],
              _bitOffset: number,
            ): number;
            public init(): void;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public makePixmap(
              _data: string[],
            ): Packages.arc.graphics.Pixmap;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace logic {
          declare class LogicDisplay extends Packages
            .mindustry.world.Block {
            static DisplayCmdStruct = class extends java
              .lang.Object {
              public type: number;
              public x: number;
              public y: number;
              public p1: number;
              public p2: number;
              public p3: number;
              public p4: number;
            };
            public static GraphicsType = class extends Packages
              .java.lang
              .Enum<Packages.mindustry.world.blocks.logic.LogicDisplay.GraphicsType> {
              public static clear: Packages.mindustry.world.blocks.logic.LogicDisplay.GraphicsType;
              public static color: Packages.mindustry.world.blocks.logic.LogicDisplay.GraphicsType;
              public static col: Packages.mindustry.world.blocks.logic.LogicDisplay.GraphicsType;
              public static stroke: Packages.mindustry.world.blocks.logic.LogicDisplay.GraphicsType;
              public static line: Packages.mindustry.world.blocks.logic.LogicDisplay.GraphicsType;
              public static rect: Packages.mindustry.world.blocks.logic.LogicDisplay.GraphicsType;
              public static lineRect: Packages.mindustry.world.blocks.logic.LogicDisplay.GraphicsType;
              public static poly: Packages.mindustry.world.blocks.logic.LogicDisplay.GraphicsType;
              public static linePoly: Packages.mindustry.world.blocks.logic.LogicDisplay.GraphicsType;
              public static triangle: Packages.mindustry.world.blocks.logic.LogicDisplay.GraphicsType;
              public static image: Packages.mindustry.world.blocks.logic.LogicDisplay.GraphicsType;
              public static print: Packages.mindustry.world.blocks.logic.LogicDisplay.GraphicsType;
              public static translate: Packages.mindustry.world.blocks.logic.LogicDisplay.GraphicsType;
              public static scale: Packages.mindustry.world.blocks.logic.LogicDisplay.GraphicsType;
              public static rotate: Packages.mindustry.world.blocks.logic.LogicDisplay.GraphicsType;
              public static reset: Packages.mindustry.world.blocks.logic.LogicDisplay.GraphicsType;
              public static all: Packages.mindustry.world.blocks.logic.LogicDisplay.GraphicsType[];
              private static $VALUES: Packages.mindustry.world.blocks.logic.LogicDisplay.GraphicsType[];
              public static values():
                | Packages.mindustry.world.blocks.logic.LogicDisplay.GraphicsType[]
                | null;
              public static valueOf(
                _name: string,
              ): Packages.mindustry.world.blocks.logic.LogicDisplay.GraphicsType;
            };
            public LogicDisplayBuild = class extends Packages
              .mindustry.gen.Building {
              public buffer: Packages.arc.graphics.gl.FrameBuffer;
              public color: number;
              public stroke: number;
              public commands: Packages.arc.struct.LongQueue;
              public transform?: Packages.arc.math.Mat;
              this$0: Packages.mindustry.world.blocks.logic.LogicDisplay;
              public remove(): void;
              public version(): string;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public draw(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.logic.LogicDisplay,
              );
            };
            public static commandClear: string;
            public static commandColor: string;
            public static commandColorPack: string;
            public static commandStroke: string;
            public static commandLine: string;
            public static commandRect: string;
            public static commandLineRect: string;
            public static commandPoly: string;
            public static commandLinePoly: string;
            public static commandTriangle: string;
            public static commandImage: string;
            public static commandPrint: string;
            public static commandTranslate: string;
            public static commandScale: string;
            public static commandRotate: string;
            public static commandResetTransform: string;
            public static scaleStep: number;
            public maxSides: number;
            public displaySize: number;
            public scaleFactor: number;
            public setStats(): void;
            static unpackSign(_value: number): number;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace logic {
          declare class MemoryBlock extends Packages
            .mindustry.world.Block {
            public MemoryBuild = class extends Packages
              .mindustry.gen.Building {
              public memory: number[];
              this$0: Packages.mindustry.world.blocks.logic.MemoryBlock;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public collide(
                _other: Packages.mindustry.gen.Bullet,
              ): boolean;
              public damage(_damage: number): void;
              public displayable(): boolean;
              public canPickup(): boolean;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.logic.MemoryBlock,
              );
            };
            public memoryCapacity: number;
            public canBreak(
              _tile: Packages.mindustry.world.Tile,
            ): boolean;
            public setStats(): void;
            public accessible(): boolean;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace logic {
          declare class MessageBlock extends Packages
            .mindustry.world.Block {
            public MessageBuild = class extends Packages
              .mindustry.gen.Building {
              public message: Packages.java.lang.StringBuilder;
              this$0: Packages.mindustry.world.blocks.logic.MessageBlock;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public collide(
                _other: Packages.mindustry.gen.Bullet,
              ): boolean;
              public config(): any;
              public config(): string;
              public damage(_damage: number): void;
              public getCursor(): Packages.arc.Graphics.Cursor;
              public canPickup(): boolean;
              public onConfigureBuildTapped(
                _other: Packages.mindustry.gen.Building,
              ): boolean;
              public shouldShowConfigure(
                _player: Packages.mindustry.gen.Player,
              ): boolean;
              public buildConfiguration(
                _table: Packages.arc.scene.ui.layout.Table,
              ): void;
              public drawSelect(): void;
              public handleString(_value: any): void;
              public updateTableAlign(
                _table: Packages.arc.scene.ui.layout.Table,
              ): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.logic.MessageBlock,
              );
            };
            public maxTextLength: number;
            public maxNewlines: number;
            public canBreak(
              _tile: Packages.mindustry.world.Tile,
            ): boolean;
            public accessible(): boolean;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace logic {
          declare class SwitchBlock extends Packages
            .mindustry.world.Block {
            public SwitchBuild = class extends Packages
              .mindustry.gen.Building {
              this$0: Packages.mindustry.world.blocks.logic.SwitchBlock;
              public version(): string;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public collide(
                _other: Packages.mindustry.gen.Bullet,
              ): boolean;
              public config(): boolean;
              public config(): any;
              public draw(): void;
              public damage(_damage: number): void;
              public readAll(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public canPickup(): boolean;
              public configTapped(): boolean;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.logic.SwitchBlock,
              );
            };
            public clickSound: Packages.arc.audio.Sound;
            public onRegion: Packages.arc.graphics.g2d.TextureRegion;
            public canBreak(
              _tile: Packages.mindustry.world.Tile,
            ): boolean;
            public accessible(): boolean;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace payloads {
          declare class PayloadBlock extends Packages
            .mindustry.world.Block {
            public PayloadBlockBuild = class<
              T extends
                Packages.mindustry.world.blocks.payloads.Payload,
            > extends Packages.mindustry.gen.Building {
              public payload?: T;
              public payVector: Packages.arc.math.geom.Vec2;
              public payRotation: number;
              public carried: boolean;
              this$0: Packages.mindustry.world.blocks.payloads.PayloadBlock;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public getPayload(): Packages.mindustry.world.blocks.payloads.Payload;
              public acceptPayload(
                _source: Packages.mindustry.gen.Building,
                _payload: Packages.mindustry.world.blocks.payloads.Payload,
              ): boolean;
              public handlePayload(
                _source: Packages.mindustry.gen.Building,
                _payload: Packages.mindustry.world.blocks.payloads.Payload,
              ): void;
              public drawTeamTop(): void;
              public onDestroyed(): void;
              public updateTile(): void;
              public onRemoved(): void;
              public canControlSelect(
                _unit: Packages.mindustry.gen.Unit,
              ): boolean;
              public dumpPayload(): void;
              public takePayload(): Packages.mindustry.world.blocks.payloads.Payload;
              public onControlSelect(
                _player: Packages.mindustry.gen.Unit,
              ): void;
              public pickedUp(): void;
              public updatePayload(): void;
              public drawPayload(): void;
              public blends(_direction: number): boolean;
              public acceptUnitPayload(
                _unit: Packages.mindustry.gen.Unit,
              ): boolean;
              public moveInPayload(
                _rotate: boolean,
              ): boolean;
              public moveInPayload(): boolean;
              public hasArrived(): boolean;
              public moveOutPayload(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.payloads.PayloadBlock,
              );
            };
            public payloadSpeed: number;
            public payloadRotateSpeed: number;
            public regionSuffix: string;
            public topRegion: Packages.arc.graphics.g2d.TextureRegion;
            public outRegion: Packages.arc.graphics.g2d.TextureRegion;
            public inRegion: Packages.arc.graphics.g2d.TextureRegion;
            public load(): void;
            protected findFactoryRegion(
              _suf: string,
            ): Packages.arc.graphics.g2d.TextureRegion;
            public static blends(
              _build: Packages.mindustry.gen.Building,
              _direction: number,
            ): boolean;
            public static pushOutput(
              _payload: Packages.mindustry.world.blocks.payloads.Payload,
              _progress: number,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace payloads {
          declare abstract class BlockProducer extends Packages
            .mindustry.world.blocks.payloads.PayloadBlock {
            public BlockProducerBuild = class extends Packages
              .mindustry.world.blocks.payloads.PayloadBlock
              .PayloadBlockBuild<Packages.mindustry.world.blocks.payloads.BuildPayload> {
              public progress: number;
              public time: number;
              public heat: number;
              this$0: Packages.mindustry.world.blocks.payloads.BlockProducer;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public recipe(): Packages.mindustry.world.Block | null;
              public draw(): void;
              public getMaximumAccepted(
                _item: Packages.mindustry._type.Item,
              ): number;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public acceptPayload(
                _source: Packages.mindustry.gen.Building,
                _payload: Packages.mindustry.world.blocks.payloads.Payload,
              ): boolean;
              public shouldConsume(): boolean;
              public sense(
                _sensor: Packages.mindustry.logic.LAccess,
              ): number;
              public updateTile(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.payloads.BlockProducer,
              );
            };
            public buildSpeed: number;
            public setBars(): void;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace payloads {
          declare class Constructor extends Packages
            .mindustry.world.blocks.payloads.BlockProducer {
            public ConstructorBuild = class extends Packages
              .mindustry.world.blocks.payloads.BlockProducer
              .BlockProducerBuild {
              public recipe?: Packages.mindustry.world.Block;
              this$0: Packages.mindustry.world.blocks.payloads.Constructor;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public recipe(): Packages.mindustry.world.Block | null;
              public config(): any;
              public buildConfiguration(
                _table: Packages.arc.scene.ui.layout.Table,
              ): void;
              public drawSelect(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.payloads.Constructor,
              );
            };
            public filter: Packages.arc.struct.Seq<Packages.mindustry.world.Block>;
            public minBlockSize: number;
            public maxBlockSize: number;
            public setStats(): void;
            public canProduce(
              _b: Packages.mindustry.world.Block,
            ): boolean;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace payloads {
          declare class PayloadConveyor extends Packages
            .mindustry.world.Block {
            public PayloadConveyorBuild = class extends Packages
              .mindustry.gen.Building {
              public item?: Packages.mindustry.world.blocks.payloads.Payload;
              public progress: number;
              public itemRotation: number;
              public animation: number;
              public curInterp: number;
              public lastInterp: number;
              public next?: Packages.mindustry.gen.Building;
              public blocked: boolean;
              public step: number;
              public stepAccepted: number;
              this$0: Packages.mindustry.world.blocks.payloads.PayloadConveyor;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public getPayload(): Packages.mindustry.world.blocks.payloads.Payload;
              public time(): number;
              public draw(): void;
              public moved(): void;
              public acceptPayload(
                _source: Packages.mindustry.gen.Building,
                _payload: Packages.mindustry.world.blocks.payloads.Payload,
              ): boolean;
              public handlePayload(
                _source: Packages.mindustry.gen.Building,
                _payload: Packages.mindustry.world.blocks.payloads.Payload,
              ): void;
              public onDestroyed(): void;
              public updateTile(): void;
              public onProximityUpdate(): void;
              public onRemoved(): void;
              public canControlSelect(
                _unit: Packages.mindustry.gen.Unit,
              ): boolean;
              public fract(): number;
              public takePayload(): Packages.mindustry.world.blocks.payloads.Payload;
              public onControlSelect(
                _player: Packages.mindustry.gen.Unit,
              ): void;
              public payloadDraw(): void;
              public unitOn(
                _unit: Packages.mindustry.gen.Unit,
              ): void;
              public updatePayload(): void;
              protected blends(_direction: number): boolean;
              public drawBottom(): void;
              public curStep(): number;
              public moveFailed(): void;
              protected clipRegion(
                _bounds: Packages.arc.math.geom.Rect,
                _sprite: Packages.arc.math.geom.Rect,
                _region: Packages.arc.graphics.g2d.TextureRegion,
              ): Packages.arc.graphics.g2d.TextureRegion;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.payloads.PayloadConveyor,
              );
            };
            public moveTime: number;
            public moveForce: number;
            public topRegion: Packages.arc.graphics.g2d.TextureRegion;
            public edgeRegion: Packages.arc.graphics.g2d.TextureRegion;
            public interp: Packages.arc.math.Interp;
            public payloadLimit: number;
            public init(): void;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public setStats(): void;
            protected icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace payloads {
          declare class PayloadDeconstructor extends Packages
            .mindustry.world.blocks.payloads.PayloadBlock {
            public PayloadDeconstructorBuild = class extends Packages
              .mindustry.world.blocks.payloads.PayloadBlock
              .PayloadBlockBuild<Packages.mindustry.world.blocks.payloads.Payload> {
              public deconstructing?: Packages.mindustry.world.blocks.payloads.Payload;
              public accum?: number[];
              public progress: number;
              public time: number;
              public speedScl: number;
              this$0: Packages.mindustry.world.blocks.payloads.PayloadDeconstructor;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public draw(): void;
              public acceptPayload(
                _source: Packages.mindustry.gen.Building,
                _payload: Packages.mindustry.world.blocks.payloads.Payload,
              ): boolean;
              public handlePayload(
                _source: Packages.mindustry.gen.Building,
                _payload: Packages.mindustry.world.blocks.payloads.Payload,
              ): void;
              public shouldConsume(): boolean;
              public sense(
                _sensor: Packages.mindustry.logic.LAccess,
              ): number;
              public updateTile(): void;
              public acceptUnitPayload(
                _unit: Packages.mindustry.gen.Unit,
              ): boolean;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.payloads.PayloadDeconstructor,
              );
            };
            public maxPayloadSize: number;
            public deconstructSpeed: number;
            public dumpRate: number;
            public setBars(): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace payloads {
          declare class PayloadLoader extends Packages
            .mindustry.world.blocks.payloads.PayloadBlock {
            public PayloadLoaderBuild = class extends Packages
              .mindustry.world.blocks.payloads.PayloadBlock
              .PayloadBlockBuild<Packages.mindustry.world.blocks.payloads.BuildPayload> {
              public exporting: boolean;
              this$0: Packages.mindustry.world.blocks.payloads.PayloadLoader;
              public version(): string;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public fraction(): number;
              public draw(): void;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public acceptPayload(
                _source: Packages.mindustry.gen.Building,
                _payload: Packages.mindustry.world.blocks.payloads.Payload,
              ): boolean;
              public handlePayload(
                _source: Packages.mindustry.gen.Building,
                _payload: Packages.mindustry.world.blocks.payloads.Payload,
              ): void;
              public shouldConsume(): boolean;
              public acceptLiquid(
                _source: Packages.mindustry.gen.Building,
                _liquid: Packages.mindustry._type.Liquid,
              ): boolean;
              public updateTile(): void;
              public hasBattery(): boolean;
              public shouldExport(): boolean;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.payloads.PayloadLoader,
              );
            };
            public timerLoad: number;
            public loadTime: number;
            public itemsLoaded: number;
            public liquidsLoaded: number;
            public maxBlockSize: number;
            public maxPowerConsumption: number;
            public loadPowerDynamic: boolean;
            public overRegion: Packages.arc.graphics.g2d.TextureRegion;
            protected basePowerUse: number;
            public init(): void;
            public setBars(): void;
            public outputsItems(): boolean;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace payloads {
          declare class PayloadMassDriver extends Packages
            .mindustry.world.blocks.payloads.PayloadBlock {
            public PayloadDriverBuild = class
              extends Packages.mindustry.world.blocks
                .payloads.PayloadBlock
                .PayloadBlockBuild<Packages.mindustry.world.blocks.payloads.Payload>
              implements
                Packages.mindustry.world.blocks.RotBlock
            {
              public link: number;
              public turretRotation: number;
              public reloadCounter: number;
              public charge: number;
              public targetSize: number;
              public curSize: number;
              public payLength: number;
              public effectDelayTimer: number;
              public lastOther: Packages.mindustry.world.blocks.payloads.PayloadMassDriver.PayloadDriverBuild;
              public loaded: boolean;
              public charging: boolean;
              public state: Packages.mindustry.world.blocks.payloads.PayloadMassDriver.PayloadDriverState;
              public waitingShooters: Packages.arc.struct.Queue<Packages.mindustry.gen.Building>;
              public recPayload: Packages.mindustry.world.blocks.payloads.Payload;
              this$0: Packages.mindustry.world.blocks.payloads.PayloadMassDriver;
              public version(): string;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public config(): any;
              public config(): Packages.arc.math.geom.Point2;
              public draw(): void;
              public acceptPayload(
                _source: Packages.mindustry.gen.Building,
                _payload: Packages.mindustry.world.blocks.payloads.Payload,
              ): boolean;
              public sense(
                _sensor: Packages.mindustry.logic.LAccess,
              ): number;
              public updateTile(): void;
              public onConfigureBuildTapped(
                _other: Packages.mindustry.gen.Building,
              ): boolean;
              public drawConfigure(): void;
              public updatePayload(): void;
              protected linkValid(): boolean;
              public buildRotation(): number;
              public currentShooter(): Packages.mindustry.gen.Building;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.payloads.PayloadMassDriver,
              );
            };
            public static PayloadMassDriverData = class extends java
              .lang.Object {
              public x: number;
              public y: number;
              public ox: number;
              public oy: number;
              public payload: Packages.mindustry.world.blocks.payloads.Payload;
              public constructor(
                _x: number,
                _y: number,
                _ox: number,
                _oy: number,
                _payload: Packages.mindustry.world.blocks.payloads.Payload,
              );
            };
            public static PayloadDriverState = class extends Packages
              .java.lang
              .Enum<Packages.mindustry.world.blocks.payloads.PayloadMassDriver.PayloadDriverState> {
              public static idle: Packages.mindustry.world.blocks.payloads.PayloadMassDriver.PayloadDriverState;
              public static accepting: Packages.mindustry.world.blocks.payloads.PayloadMassDriver.PayloadDriverState;
              public static shooting: Packages.mindustry.world.blocks.payloads.PayloadMassDriver.PayloadDriverState;
              public static all: Packages.mindustry.world.blocks.payloads.PayloadMassDriver.PayloadDriverState[];
              private static $VALUES: Packages.mindustry.world.blocks.payloads.PayloadMassDriver.PayloadDriverState[];
              public static values():
                | Packages.mindustry.world.blocks.payloads.PayloadMassDriver.PayloadDriverState[]
                | null;
              public static valueOf(
                _name: string,
              ): Packages.mindustry.world.blocks.payloads.PayloadMassDriver.PayloadDriverState;
            };
            public range: number;
            public rotateSpeed: number;
            public length: number;
            public knockback: number;
            public reload: number;
            public chargeTime: number;
            public maxPayloadSize: number;
            public grabWidth: number;
            public grabHeight: number;
            public shootEffect: Packages.mindustry.entities.Effect;
            public smokeEffect: Packages.mindustry.entities.Effect;
            public receiveEffect: Packages.mindustry.entities.Effect;
            public shootSound: Packages.arc.audio.Sound;
            public shake: number;
            public transferEffect: Packages.mindustry.entities.Effect;
            public baseRegion: Packages.arc.graphics.g2d.TextureRegion;
            public capRegion: Packages.arc.graphics.g2d.TextureRegion;
            public leftRegion: Packages.arc.graphics.g2d.TextureRegion;
            public rightRegion: Packages.arc.graphics.g2d.TextureRegion;
            public capOutlineRegion: Packages.arc.graphics.g2d.TextureRegion;
            public leftOutlineRegion: Packages.arc.graphics.g2d.TextureRegion;
            public rightOutlineRegion: Packages.arc.graphics.g2d.TextureRegion;
            public arrow: Packages.arc.graphics.g2d.TextureRegion;
            public init(): void;
            public getRegionsToOutline(
              _out: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.TextureRegion>,
            ): void;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public setStats(): void;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace payloads {
          declare class PayloadRouter extends Packages
            .mindustry.world.blocks.payloads
            .PayloadConveyor {
            public PayloadRouterBuild = class extends Packages
              .mindustry.world.blocks.payloads
              .PayloadConveyor.PayloadConveyorBuild {
              public sorted?: Packages.mindustry.ctype.UnlockableContent;
              public recDir: number;
              public matches: boolean;
              public smoothRot: number;
              public controlTime: number;
              this$0: Packages.mindustry.world.blocks.payloads.PayloadRouter;
              public add(): void;
              public version(): string;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public control(
                _type: Packages.mindustry.logic.LAccess,
                _p1: number,
                _p2: number,
                _p3: number,
                _p4: number,
              ): void;
              public config(): any;
              public draw(): void;
              public handlePayload(
                _source: Packages.mindustry.gen.Building,
                _payload: Packages.mindustry.world.blocks.payloads.Payload,
              ): void;
              public updateTile(): void;
              public buildConfiguration(
                _table: Packages.arc.scene.ui.layout.Table,
              ): void;
              public drawSelect(): void;
              public onControlSelect(
                _player: Packages.mindustry.gen.Unit,
              ): void;
              public checkMatch(): void;
              public pickNext(): void;
              public moveFailed(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.payloads.PayloadRouter,
              );
            };
            public invert: boolean;
            public overRegion: Packages.arc.graphics.g2d.TextureRegion;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public canSort(
              _t: Packages.mindustry._type.UnitType,
            ): boolean;
            public canSort(
              _b: Packages.mindustry.world.Block,
            ): boolean;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace payloads {
          declare class PayloadSource extends Packages
            .mindustry.world.blocks.payloads.PayloadBlock {
            public PayloadSourceBuild = class extends Packages
              .mindustry.world.blocks.payloads.PayloadBlock
              .PayloadBlockBuild<Packages.mindustry.world.blocks.payloads.Payload> {
              public unit: Packages.mindustry._type.UnitType;
              public configBlock: Packages.mindustry.world.Block;
              public commandPos?: Packages.arc.math.geom.Vec2;
              public scl: number;
              this$0: Packages.mindustry.world.blocks.payloads.PayloadSource;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public config(): any;
              public draw(): void;
              public acceptPayload(
                _source: Packages.mindustry.gen.Building,
                _payload: Packages.mindustry.world.blocks.payloads.Payload,
              ): boolean;
              public updateTile(): void;
              public getCommandPosition(): Packages.arc.math.geom.Vec2;
              public buildConfiguration(
                _table: Packages.arc.scene.ui.layout.Table,
              ): void;
              public onCommand(
                _target: Packages.arc.math.geom.Vec2,
              ): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.payloads.PayloadSource,
              );
            };
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public canProduce(
              _b: Packages.mindustry.world.Block,
            ): boolean;
            public canProduce(
              _t: Packages.mindustry._type.UnitType,
            ): boolean;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace payloads {
          declare class PayloadUnloader extends Packages
            .mindustry.world.blocks.payloads.PayloadLoader {
            public PayloadUnloaderBuild = class extends Packages
              .mindustry.world.blocks.payloads.PayloadLoader
              .PayloadLoaderBuild {
              public lastOutputPower: number;
              this$0: Packages.mindustry.world.blocks.payloads.PayloadUnloader;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public acceptLiquid(
                _source: Packages.mindustry.gen.Building,
                _liquid: Packages.mindustry._type.Liquid,
              ): boolean;
              public updateTile(): void;
              public getPowerProduction(): number;
              public shouldExport(): boolean;
              public full(): boolean;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.payloads.PayloadUnloader,
              );
            };
            public offloadSpeed: number;
            public maxPowerUnload: number;
            public outputsItems(): boolean;
            public rotatedOutput(
              _x: number,
              _y: number,
            ): boolean;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace payloads {
          declare class PayloadVoid extends Packages
            .mindustry.world.blocks.payloads.PayloadBlock {
            public PayloadVoidBuild = class extends Packages
              .mindustry.world.blocks.payloads.PayloadBlock
              .PayloadBlockBuild<Packages.mindustry.world.blocks.payloads.Payload> {
              this$0: Packages.mindustry.world.blocks.payloads.PayloadVoid;
              public draw(): void;
              public updateTile(): void;
              public acceptUnitPayload(
                _unit: Packages.mindustry.gen.Unit,
              ): boolean;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.payloads.PayloadVoid,
              );
            };
            public incinerateEffect: Packages.mindustry.entities.Effect;
            public incinerateSound: Packages.arc.audio.Sound;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace power {
          declare class PowerBlock extends Packages
            .mindustry.world.Block {
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace power {
          declare class PowerDistributor extends Packages
            .mindustry.world.blocks.power.PowerBlock {
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace power {
          declare class Battery extends Packages.mindustry
            .world.blocks.power.PowerDistributor {
            public BatteryBuild = class extends Packages
              .mindustry.gen.Building {
              this$0: Packages.mindustry.world.blocks.power.Battery;
              public status(): Packages.mindustry.world.meta.BlockStatus;
              public draw(): void;
              public warmup(): number;
              public drawLight(): void;
              public overwrote(
                _previous: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>,
              ): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.power.Battery,
              );
            };
            public drawer?: Packages.mindustry.world.draw.DrawBlock;
            public emptyLightColor: Packages.arc.graphics.Color;
            public fullLightColor: Packages.arc.graphics.Color;
            public topRegion: Packages.arc.graphics.g2d.TextureRegion;
            public load(): void;
            public init(): void;
            public getRegionsToOutline(
              _out: Packages.arc.struct.Seq<Packages.arc.graphics.g2d.TextureRegion>,
            ): void;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            checkDrawDefault(): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace power {
          declare class BeamNode extends Packages.mindustry
            .world.blocks.power.PowerBlock {
            public BeamNodeBuild = class extends Packages
              .mindustry.gen.Building {
              public links: Packages.mindustry.gen.Building[];
              public dests: Packages.mindustry.world.Tile[];
              public lastChange: number;
              this$0: Packages.mindustry.world.blocks.power.BeamNode;
              public status(): Packages.mindustry.world.meta.BlockStatus;
              public draw(): void;
              public updateTile(): void;
              public pickedUp(): void;
              public couldConnect(
                _direction: number,
                _target: Packages.mindustry.world.Block,
                _targetX: number,
                _targetY: number,
              ): boolean;
              public updateDirections(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.power.BeamNode,
              );
            };
            private static maxRange: number;
            public range: number;
            public laser: Packages.arc.graphics.g2d.TextureRegion;
            public laserEnd: Packages.arc.graphics.g2d.TextureRegion;
            public laserColor1: Packages.arc.graphics.Color;
            public laserColor2: Packages.arc.graphics.Color;
            public pulseScl: number;
            public pulseMag: number;
            public laserWidth: number;
            public init(): void;
            public static getNodeLinks(
              _tile: Packages.mindustry.world.Tile,
              _block: Packages.mindustry.world.Block,
              _team: Packages.mindustry.game.Team,
              _others: Packages.arc.func.Cons<Packages.mindustry.gen.Building>,
            ): void;
            public setBars(): void;
            public drawLaser(
              _x1: number,
              _y1: number,
              _x2: number,
              _y2: number,
              _size1: number,
              _size2: number,
            ): void;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public setStats(): void;
            public changePlacementPath(
              _points: Packages.arc.struct.Seq<Packages.arc.math.geom.Point2>,
              _rotation: number,
              _diagonal: boolean,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace power {
          declare class PowerGenerator extends Packages
            .mindustry.world.blocks.power.PowerDistributor {
            public GeneratorBuild = class extends Packages
              .mindustry.gen.Building {
              public generateTime: number;
              public productionEfficiency: number;
              this$0: Packages.mindustry.world.blocks.power.PowerGenerator;
              public version(): string;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public draw(): void;
              public onDestroyed(): void;
              public ambientVolume(): number;
              public getPowerProduction(): number;
              public warmup(): number;
              public drawLight(): void;
              public createExplosion(): void;
              public shouldExplode(): boolean;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.power.PowerGenerator,
              );
            };
            public powerProduction: number;
            public generationType: Packages.mindustry.world.meta.Stat;
            public drawer: Packages.mindustry.world.draw.DrawBlock;
            public explosionRadius: number;
            public explosionDamage: number;
            public explodeEffect: Packages.mindustry.entities.Effect;
            public explodeSound: Packages.arc.audio.Sound;
            public explosionPuddles: number;
            public explosionPuddleRange: number;
            public explosionPuddleAmount: number;
            public explosionPuddleLiquid?: Packages.mindustry._type.Liquid;
            public explosionMinWarmup: number;
            public explosionShake: number;
            public explosionShakeDuration: number;
            public load(): void;
            public getDisplayedPowerProduction(): number;
            public setBars(): void;
            public outputsItems(): boolean;
            public setStats(): void;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace power {
          declare class ConsumeGenerator extends Packages
            .mindustry.world.blocks.power.PowerGenerator {
            public ConsumeGeneratorBuild = class extends Packages
              .mindustry.world.blocks.power.PowerGenerator
              .GeneratorBuild {
              public warmup: number;
              public totalTime: number;
              public efficiencyMultiplier: number;
              this$0: Packages.mindustry.world.blocks.power.ConsumeGenerator;
              public updateTile(): void;
              public updateEfficiencyMultiplier(): void;
              public consumeTriggerValid(): boolean;
              public totalProgress(): number;
              public warmup(): number;
              public drawLight(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.power.ConsumeGenerator,
              );
            };
            public itemDuration: number;
            public warmupSpeed: number;
            public effectChance: number;
            public generateEffect: Packages.mindustry.entities.Effect;
            public consumeEffect: Packages.mindustry.entities.Effect;
            public generateEffectRange: number;
            public outputLiquid?: Packages.mindustry._type.LiquidStack;
            public explodeOnFull: boolean;
            public filterItem?: Packages.mindustry.world.consumers.ConsumeItemFilter;
            public filterLiquid?: Packages.mindustry.world.consumers.ConsumeLiquidFilter;
            public init(): void;
            public setBars(): void;
            public setStats(): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace power {
          declare class HeaterGenerator extends Packages
            .mindustry.world.blocks.power.ConsumeGenerator {
            public HeaterGeneratorBuild = class
              extends Packages.mindustry.world.blocks.power
                .ConsumeGenerator.ConsumeGeneratorBuild
              implements
                Packages.mindustry.world.blocks.heat
                  .HeatBlock
            {
              public heat: number;
              this$0: Packages.mindustry.world.blocks.power.HeaterGenerator;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public heat(): number;
              public updateTile(): void;
              public heatFrac(): number;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.power.HeaterGenerator,
              );
            };
            public heatOutput: number;
            public warmupRate: number;
            public setBars(): void;
            public rotatedOutput(
              _x: number,
              _y: number,
            ): boolean;
            public setStats(): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace power {
          declare class ImpactReactor extends Packages
            .mindustry.world.blocks.power.PowerGenerator {
            public ImpactReactorBuild = class extends Packages
              .mindustry.world.blocks.power.PowerGenerator
              .GeneratorBuild {
              public warmup: number;
              public totalProgress: number;
              this$0: Packages.mindustry.world.blocks.power.ImpactReactor;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public sense(
                _sensor: Packages.mindustry.logic.LAccess,
              ): number;
              public ambientVolume(): number;
              public updateTile(): void;
              public totalProgress(): number;
              public warmup(): number;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.power.ImpactReactor,
              );
            };
            public timerUse: number;
            public warmupSpeed: number;
            public itemDuration: number;
            public setBars(): void;
            public setStats(): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace power {
          declare class LightBlock extends Packages
            .mindustry.world.Block {
            public LightBuild = class extends Packages
              .mindustry.gen.Building {
              public color: number;
              public smoothTime: number;
              this$0: Packages.mindustry.world.blocks.power.LightBlock;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public control(
                _type: Packages.mindustry.logic.LAccess,
                _p1: number,
                _p2: number,
                _p3: number,
                _p4: number,
              ): void;
              public config(): number;
              public config(): any;
              public draw(): void;
              public sense(
                _sensor: Packages.mindustry.logic.LAccess,
              ): number;
              public updateTile(): void;
              public onConfigureBuildTapped(
                _other: Packages.mindustry.gen.Building,
              ): boolean;
              public buildConfiguration(
                _table: Packages.arc.scene.ui.layout.Table,
              ): void;
              public drawLight(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.power.LightBlock,
              );
            };
            public brightness: number;
            public radius: number;
            public topRegion: Packages.arc.graphics.g2d.TextureRegion;
            public init(): void;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public changePlacementPath(
              _points: Packages.arc.struct.Seq<Packages.arc.math.geom.Point2>,
              _rotation: number,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace power {
          declare class PowerNode extends Packages.mindustry
            .world.blocks.power.PowerBlock {
            public PowerNodeBuild = class extends Packages
              .mindustry.gen.Building {
              this$0: Packages.mindustry.world.blocks.power.PowerNode;
              public created(): void;
              public dropped(): void;
              public config(): any;
              public config():
                | Packages.arc.math.geom.Point2[]
                | null;
              public draw(): void;
              protected linked(
                _other: Packages.mindustry.gen.Building,
              ): boolean;
              public placed(): void;
              public onConfigureBuildTapped(
                _other: Packages.mindustry.gen.Building,
              ): boolean;
              public drawConfigure(): void;
              public drawSelect(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.power.PowerNode,
              );
            };
            protected static otherReq: Packages.mindustry.entities.units.BuildPlan;
            protected static returnInt: number;
            protected static graphs: Packages.arc.struct.ObjectSet<Packages.mindustry.world.blocks.power.PowerGraph>;
            protected static maxRange: number;
            public laser: Packages.arc.graphics.g2d.TextureRegion;
            public laserEnd: Packages.arc.graphics.g2d.TextureRegion;
            public laserRange: number;
            public maxNodes: number;
            public autolink: boolean;
            public drawRange: boolean;
            public laserScale: number;
            public laserColor1: Packages.arc.graphics.Color;
            public laserColor2: Packages.arc.graphics.Color;
            public init(): void;
            protected overlaps(
              _src: Packages.mindustry.world.Tile,
              _other: Packages.mindustry.world.Tile,
              _range: number,
            ): boolean;
            public overlaps(
              _src: Packages.mindustry.world.Tile | null,
              _other: Packages.mindustry.world.Tile | null,
            ): boolean;
            protected overlaps(
              _srcx: number,
              _srcy: number,
              _other: Packages.mindustry.world.Tile,
              _otherBlock: Packages.mindustry.world.Block,
              _range: number,
            ): boolean;
            protected overlaps(
              _src: Packages.mindustry.gen.Building,
              _other: Packages.mindustry.gen.Building,
              _range: number,
            ): boolean;
            protected overlaps(
              _srcx: number,
              _srcy: number,
              _other: Packages.mindustry.world.Tile,
              _range: number,
            ): boolean;
            public static getNodeLinks(
              _tile: Packages.mindustry.world.Tile,
              _block: Packages.mindustry.world.Block,
              _team: Packages.mindustry.game.Team,
              _others: Packages.arc.func.Cons<Packages.mindustry.gen.Building>,
            ): void;
            public static insulated(
              _x: number,
              _y: number,
              _x2: number,
              _y2: number,
            ): boolean;
            public static insulated(
              _tile: Packages.mindustry.gen.Building,
              _other: Packages.mindustry.gen.Building,
            ): boolean;
            public static insulated(
              _tile: Packages.mindustry.world.Tile,
              _other: Packages.mindustry.world.Tile,
            ): boolean;
            public setBars(): void;
            public drawLaser(
              _x1: number,
              _y1: number,
              _x2: number,
              _y2: number,
              _size1: number,
              _size2: number,
            ): void;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public drawPlanConfigTop(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public setStats(): void;
            public changePlacementPath(
              _points: Packages.arc.struct.Seq<Packages.arc.math.geom.Point2>,
              _rotation: number,
            ): void;
            public linkValid(
              _tile: Packages.mindustry.gen.Building,
              _link: Packages.mindustry.gen.Building,
              _checkMaxNodes: boolean,
            ): boolean;
            public linkValid(
              _tile: Packages.mindustry.gen.Building,
              _link: Packages.mindustry.gen.Building,
            ): boolean;
            public static makePowerBalance(): Packages.arc.func.Func<
              Packages.mindustry.gen.Building,
              Packages.mindustry.ui.Bar
            >;
            public static makeBatteryBalance(): Packages.arc.func.Func<
              Packages.mindustry.gen.Building,
              Packages.mindustry.ui.Bar
            >;
            protected getPotentialLinks(
              _tile: Packages.mindustry.world.Tile,
              _team: Packages.mindustry.game.Team,
              _others: Packages.arc.func.Cons<Packages.mindustry.gen.Building>,
            ): void;
            protected setupColor(
              _satisfaction: number,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace power {
          declare class LongPowerNode extends Packages
            .mindustry.world.blocks.power.PowerNode {
            public LongPowerNodeBuild = class extends Packages
              .mindustry.world.blocks.power.PowerNode
              .PowerNodeBuild {
              public warmup: number;
              this$0: Packages.mindustry.world.blocks.power.LongPowerNode;
              public draw(): void;
              public updateTile(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.power.LongPowerNode,
              );
            };
            public glow: Packages.arc.graphics.g2d.TextureRegion;
            public glowColor: Packages.arc.graphics.Color;
            public glowScl: number;
            public glowMag: number;
            public load(): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace power {
          declare class NuclearReactor extends Packages
            .mindustry.world.blocks.power.PowerGenerator {
            public NuclearReactorBuild = class extends Packages
              .mindustry.world.blocks.power.PowerGenerator
              .GeneratorBuild {
              public heat: number;
              public flash: number;
              public smoothLight: number;
              this$0: Packages.mindustry.world.blocks.power.NuclearReactor;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public draw(): void;
              public sense(
                _sensor: Packages.mindustry.logic.LAccess,
              ): number;
              public updateTile(): void;
              public drawLight(): void;
              public shouldExplode(): boolean;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.power.NuclearReactor,
              );
            };
            public timerFuel: number;
            public lightColor: Packages.arc.graphics.Color;
            public coolColor: Packages.arc.graphics.Color;
            public hotColor: Packages.arc.graphics.Color;
            public itemDuration: number;
            public heating: number;
            public smokeThreshold: number;
            public flashThreshold: number;
            public coolantPower: number;
            public fuelItem: Packages.mindustry._type.Item;
            public topRegion: Packages.arc.graphics.g2d.TextureRegion;
            public lightsRegion: Packages.arc.graphics.g2d.TextureRegion;
            public setBars(): void;
            public setStats(): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace power {
          declare class PowerDiode extends Packages
            .mindustry.world.Block {
            public PowerDiodeBuild = class extends Packages
              .mindustry.gen.Building {
              this$0: Packages.mindustry.world.blocks.power.PowerDiode;
              public draw(): void;
              public updateTile(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.power.PowerDiode,
              );
            };
            public arrow: Packages.arc.graphics.g2d.TextureRegion;
            public setBars(): void;
            public bar(
              _tile: Packages.mindustry.gen.Building,
            ): number;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace power {
          declare class SolarGenerator extends Packages
            .mindustry.world.blocks.power.PowerGenerator {
            public SolarGeneratorBuild = class extends Packages
              .mindustry.world.blocks.power.PowerGenerator
              .GeneratorBuild {
              this$0: Packages.mindustry.world.blocks.power.SolarGenerator;
              public updateTile(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.power.SolarGenerator,
              );
            };
            public setStats(): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace power {
          declare class ThermalGenerator extends Packages
            .mindustry.world.blocks.power.PowerGenerator {
            public ThermalGeneratorBuild = class extends Packages
              .mindustry.world.blocks.power.PowerGenerator
              .GeneratorBuild {
              public sum: number;
              this$0: Packages.mindustry.world.blocks.power.ThermalGenerator;
              public updateTile(): void;
              public onProximityAdded(): void;
              public totalProgress(): number;
              public drawLight(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.power.ThermalGenerator,
              );
            };
            public generateEffect: Packages.mindustry.entities.Effect;
            public effectChance: number;
            public minEfficiency: number;
            public displayEfficiencyScale: number;
            public displayEfficiency: boolean;
            public outputLiquid?: Packages.mindustry._type.LiquidStack;
            public attribute: Packages.mindustry.world.meta.Attribute;
            public init(): void;
            public getDisplayedPowerProduction(): number;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public canPlaceOn(
              _tile: Packages.mindustry.world.Tile,
              _team: Packages.mindustry.game.Team,
              _rotation: number,
            ): boolean;
            public setStats(): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace power {
          declare class VariableReactor extends Packages
            .mindustry.world.blocks.power.PowerGenerator {
            public VariableReactorBuild = class
              extends Packages.mindustry.world.blocks.power
                .PowerGenerator.GeneratorBuild
              implements
                Packages.mindustry.world.blocks.heat
                  .HeatConsumer
            {
              public sideHeat: number[];
              public heat: number;
              public instability: number;
              public totalProgress: number;
              public warmup: number;
              public flash: number;
              this$0: Packages.mindustry.world.blocks.power.VariableReactor;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public draw(): void;
              public updateTile(): void;
              public updateEfficiencyMultiplier(): void;
              public sideHeat(): number[] | null;
              public totalProgress(): number;
              public warmup(): number;
              public heatRequirement(): number;
              public shouldExplode(): boolean;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.power.VariableReactor,
              );
            };
            public maxHeat: number;
            public unstableSpeed: number;
            public warmupSpeed: number;
            public effect: Packages.mindustry.entities.Effect;
            public effectChance: number;
            public effectColor: Packages.arc.graphics.Color;
            public flashThreshold: number;
            public flashAlpha: number;
            public flashSpeed: number;
            public flashColor1: Packages.arc.graphics.Color;
            public flashColor2: Packages.arc.graphics.Color;
            public lightsRegion: Packages.arc.graphics.g2d.TextureRegion;
            public setBars(): void;
            public setStats(): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace production {
          declare class AttributeCrafter extends Packages
            .mindustry.world.blocks.production
            .GenericCrafter {
            public AttributeCrafterBuild = class extends Packages
              .mindustry.world.blocks.production
              .GenericCrafter.GenericCrafterBuild {
              public attrsum: number;
              this$0: Packages.mindustry.world.blocks.production.AttributeCrafter;
              public getProgressIncrease(
                _base: number,
              ): number;
              public efficiencyScale(): number;
              public onProximityUpdate(): void;
              public pickedUp(): void;
              public efficiencyMultiplier(): number;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.production.AttributeCrafter,
              );
            };
            public attribute: Packages.mindustry.world.meta.Attribute;
            public baseEfficiency: number;
            public boostScale: number;
            public maxBoost: number;
            public minEfficiency: number;
            public displayEfficiencyScale: number;
            public displayEfficiency: boolean;
            public scaleLiquidConsumption: boolean;
            public setBars(): void;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public canPlaceOn(
              _tile: Packages.mindustry.world.Tile,
              _team: Packages.mindustry.game.Team,
              _rotation: number,
            ): boolean;
            public setStats(): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace production {
          declare class BeamDrill extends Packages.mindustry
            .world.Block {
            public BeamDrillBuild = class extends Packages
              .mindustry.gen.Building {
              public facing: Packages.mindustry.world.Tile[];
              public lasers: Packages.arc.math.geom.Point2[];
              public lastItem?: Packages.mindustry._type.Item;
              public time: number;
              public warmup: number;
              public boostWarmup: number;
              public lastDrillSpeed: number;
              public facingAmount: number;
              this$0: Packages.mindustry.world.blocks.production.BeamDrill;
              public version(): string;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public draw(): void;
              public shouldConsume(): boolean;
              public updateTile(): void;
              public onProximityUpdate(): void;
              public drawSelect(): void;
              protected updateLasers(): void;
              protected updateFacing(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.production.BeamDrill,
              );
            };
            protected rand: Packages.arc.math.Rand;
            public laser: Packages.arc.graphics.g2d.TextureRegion;
            public laserEnd: Packages.arc.graphics.g2d.TextureRegion;
            public laserCenter: Packages.arc.graphics.g2d.TextureRegion;
            public laserBoost: Packages.arc.graphics.g2d.TextureRegion;
            public laserEndBoost: Packages.arc.graphics.g2d.TextureRegion;
            public laserCenterBoost: Packages.arc.graphics.g2d.TextureRegion;
            public topRegion: Packages.arc.graphics.g2d.TextureRegion;
            public glowRegion: Packages.arc.graphics.g2d.TextureRegion;
            public drillTime: number;
            public range: number;
            public tier: number;
            public laserWidth: number;
            public optionalBoostIntensity: number;
            public drillMultipliers: Packages.arc.struct.ObjectFloatMap<Packages.mindustry._type.Item>;
            public sparkColor: Packages.arc.graphics.Color;
            public glowColor: Packages.arc.graphics.Color;
            public glowIntensity: number;
            public pulseIntensity: number;
            public glowScl: number;
            public sparks: number;
            public sparkRange: number;
            public sparkLife: number;
            public sparkRecurrence: number;
            public sparkSpread: number;
            public sparkSize: number;
            public boostHeatColor: Packages.arc.graphics.Color;
            public heatColor: Packages.arc.graphics.Color;
            public heatPulse: number;
            public heatPulseScl: number;
            public init(): void;
            public setBars(): void;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public outputsItems(): boolean;
            public canPlaceOn(
              _tile: Packages.mindustry.world.Tile,
              _team: Packages.mindustry.game.Team,
              _rotation: number,
            ): boolean;
            public rotatedOutput(
              _x: number,
              _y: number,
            ): boolean;
            public setStats(): void;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public getDrillTime(
              _item: Packages.mindustry._type.Item,
            ): number;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace production {
          declare class Drill extends Packages.mindustry
            .world.Block {
            public DrillBuild = class extends Packages
              .mindustry.gen.Building {
              public progress: number;
              public warmup: number;
              public timeDrilled: number;
              public lastDrillSpeed: number;
              public dominantItems: number;
              public dominantItem: Packages.mindustry._type.Item;
              this$0: Packages.mindustry.world.blocks.production.Drill;
              public version(): string;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public draw(): void;
              public shouldConsume(): boolean;
              public sense(
                _sensor: Packages.mindustry.logic.LAccess,
              ): number;
              public drawCracks(): void;
              public shouldAmbientSound(): boolean;
              public ambientVolume(): number;
              public updateTile(): void;
              public onProximityUpdate(): void;
              public senseObject(
                _sensor: Packages.mindustry.logic.LAccess,
              ): any;
              public drawSelect(): void;
              public pickedUp(): void;
              public drawDefaultCracks(): void;
              public progress(): number;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.production.Drill,
              );
            };
            public hardnessDrillMultiplier: number;
            protected oreCount: Packages.arc.struct.ObjectIntMap<Packages.mindustry._type.Item>;
            protected itemArray: Packages.arc.struct.Seq<Packages.mindustry._type.Item>;
            public tier: number;
            public drillTime: number;
            public liquidBoostIntensity: number;
            public warmupSpeed: number;
            public blockedItem?: Packages.mindustry._type.Item;
            protected returnItem?: Packages.mindustry._type.Item;
            protected returnCount: number;
            public drawMineItem: boolean;
            public drillEffect: Packages.mindustry.entities.Effect;
            public drillEffectRnd: number;
            public drillEffectChance: number;
            public rotateSpeed: number;
            public updateEffect: Packages.mindustry.entities.Effect;
            public updateEffectChance: number;
            public drillMultipliers: Packages.arc.struct.ObjectFloatMap<Packages.mindustry._type.Item>;
            public drawRim: boolean;
            public drawSpinSprite: boolean;
            public heatColor: Packages.arc.graphics.Color;
            public rimRegion: Packages.arc.graphics.g2d.TextureRegion;
            public rotatorRegion: Packages.arc.graphics.g2d.TextureRegion;
            public topRegion: Packages.arc.graphics.g2d.TextureRegion;
            public itemRegion: Packages.arc.graphics.g2d.TextureRegion;
            public init(): void;
            public setBars(): void;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public canPlaceOn(
              _tile: Packages.mindustry.world.Tile,
              _team: Packages.mindustry.game.Team,
              _rotation: number,
            ): boolean;
            public drawPlanConfigTop(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public setStats(): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public canMine(
              _tile: Packages.mindustry.world.Tile,
            ): boolean;
            protected countOre(
              _tile: Packages.mindustry.world.Tile,
            ): void;
            public getDrillTime(
              _item: Packages.mindustry._type.Item,
            ): number;
            public getDrop(
              _tile: Packages.mindustry.world.Tile,
            ): Packages.mindustry._type.Item;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace production {
          declare class BurstDrill extends Packages
            .mindustry.world.blocks.production.Drill {
            public BurstDrillBuild = class extends Packages
              .mindustry.world.blocks.production.Drill
              .DrillBuild {
              public smoothProgress: number;
              public invertTime: number;
              this$0: Packages.mindustry.world.blocks.production.BurstDrill;
              public draw(): void;
              public shouldConsume(): boolean;
              public ambientVolume(): number;
              public updateTile(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.production.BurstDrill,
              );
            };
            public shake: number;
            public speedCurve: Packages.arc.math.Interp;
            public topInvertRegion: Packages.arc.graphics.g2d.TextureRegion;
            public glowRegion: Packages.arc.graphics.g2d.TextureRegion;
            public arrowRegion: Packages.arc.graphics.g2d.TextureRegion;
            public arrowBlurRegion: Packages.arc.graphics.g2d.TextureRegion;
            public invertedTime: number;
            public arrowSpacing: number;
            public arrowOffset: number;
            public arrows: number;
            public arrowColor: Packages.arc.graphics.Color;
            public baseArrowColor: Packages.arc.graphics.Color;
            public glowColor: Packages.arc.graphics.Color;
            public drillSound: Packages.arc.audio.Sound;
            public drillSoundVolume: number;
            public drillSoundPitchRand: number;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public getDrillTime(
              _item: Packages.mindustry._type.Item,
            ): number;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace production {
          declare class Pump extends Packages.mindustry
            .world.blocks.liquid.LiquidBlock {
            public PumpBuild = class extends Packages
              .mindustry.world.blocks.liquid.LiquidBlock
              .LiquidBuild {
              public warmup: number;
              public totalProgress: number;
              public consTimer: number;
              public amount: number;
              public liquidDrop?: Packages.mindustry._type.Liquid;
              this$0: Packages.mindustry.world.blocks.production.Pump;
              public draw(): void;
              public shouldConsume(): boolean;
              public sense(
                _sensor: Packages.mindustry.logic.LAccess,
              ): number;
              public updateTile(): void;
              public onProximityUpdate(): void;
              public totalProgress(): number;
              public warmup(): number;
              public drawLight(): void;
              public pickedUp(): void;
              public progress(): number;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.production.Pump,
              );
            };
            public pumpAmount: number;
            public consumeTime: number;
            public warmupSpeed: number;
            public drawer: Packages.mindustry.world.draw.DrawBlock;
            public load(): void;
            public setBars(): void;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public canPlaceOn(
              _tile: Packages.mindustry.world.Tile,
              _team: Packages.mindustry.game.Team,
              _rotation: number,
            ): boolean;
            public setStats(): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            protected canPump(
              _tile: Packages.mindustry.world.Tile,
            ): boolean;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace production {
          declare class SolidPump extends Packages.mindustry
            .world.blocks.production.Pump {
            public SolidPumpBuild = class extends Packages
              .mindustry.world.blocks.production.Pump
              .PumpBuild {
              public warmup: number;
              public pumpTime: number;
              public boost: number;
              public validTiles: number;
              public lastPump: number;
              this$0: Packages.mindustry.world.blocks.production.SolidPump;
              public draw(): void;
              public shouldConsume(): boolean;
              public drawCracks(): void;
              public updateTile(): void;
              public onProximityUpdate(): void;
              public pickedUp(): void;
              public typeLiquid(): number;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.production.SolidPump,
              );
            };
            public result: Packages.mindustry._type.Liquid;
            public updateEffect: Packages.mindustry.entities.Effect;
            public updateEffectChance: number;
            public rotateSpeed: number;
            public baseEfficiency: number;
            public attribute?: Packages.mindustry.world.meta.Attribute;
            public rotatorRegion: Packages.arc.graphics.g2d.TextureRegion;
            public setBars(): void;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public outputsItems(): boolean;
            public canPlaceOn(
              _tile: Packages.mindustry.world.Tile,
              _team: Packages.mindustry.game.Team,
              _rotation: number,
            ): boolean;
            public setStats(): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            protected canPump(
              _tile: Packages.mindustry.world.Tile,
            ): boolean;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace production {
          declare class Fracker extends Packages.mindustry
            .world.blocks.production.SolidPump {
            public FrackerBuild = class extends Packages
              .mindustry.world.blocks.production.SolidPump
              .SolidPumpBuild {
              public accumulator: number;
              this$0: Packages.mindustry.world.blocks.production.Fracker;
              public updateTile(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.production.Fracker,
              );
            };
            public itemUseTime: number;
            public setStats(): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace production {
          declare class HeatCrafter extends Packages
            .mindustry.world.blocks.production
            .GenericCrafter {
            public HeatCrafterBuild = class
              extends Packages.mindustry.world.blocks
                .production.GenericCrafter
                .GenericCrafterBuild
              implements
                Packages.mindustry.world.blocks.heat
                  .HeatConsumer
            {
              public sideHeat: number[];
              public heat: number;
              this$0: Packages.mindustry.world.blocks.production.HeatCrafter;
              public updateTile(): void;
              public efficiencyScale(): number;
              public sideHeat(): number[] | null;
              public warmupTarget(): number;
              public heatRequirement(): number;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.production.HeatCrafter,
              );
            };
            public heatRequirement: number;
            public overheatScale: number;
            public maxEfficiency: number;
            public setBars(): void;
            public setStats(): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace production {
          declare class Incinerator extends Packages
            .mindustry.world.Block {
            public IncineratorBuild = class extends Packages
              .mindustry.gen.Building {
              public heat: number;
              this$0: Packages.mindustry.world.blocks.production.Incinerator;
              public status(): Packages.mindustry.world.meta.BlockStatus;
              public draw(): void;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public handleItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): void;
              public acceptLiquid(
                _source: Packages.mindustry.gen.Building,
                _liquid: Packages.mindustry._type.Liquid,
              ): boolean;
              public handleLiquid(
                _source: Packages.mindustry.gen.Building,
                _liquid: Packages.mindustry._type.Liquid,
                _amount: number,
              ): void;
              public updateTile(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.production.Incinerator,
              );
            };
            public effect: Packages.mindustry.entities.Effect;
            public flameColor: Packages.arc.graphics.Color;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace production {
          declare class ItemIncinerator extends Packages
            .mindustry.world.Block {
            public ItemIncineratorBuild = class extends Packages
              .mindustry.gen.Building {
              this$0: Packages.mindustry.world.blocks.production.ItemIncinerator;
              public status(): Packages.mindustry.world.meta.BlockStatus;
              public draw(): void;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public handleItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): void;
              public updateTile(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.production.ItemIncinerator,
              );
            };
            public effect: Packages.mindustry.entities.Effect;
            public effectChance: number;
            public liquidRegion: Packages.arc.graphics.g2d.TextureRegion;
            public topRegion: Packages.arc.graphics.g2d.TextureRegion;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace production {
          declare class Separator extends Packages.mindustry
            .world.Block {
            public SeparatorBuild = class extends Packages
              .mindustry.gen.Building {
              public progress: number;
              public totalProgress: number;
              public warmup: number;
              public seed: number;
              this$0: Packages.mindustry.world.blocks.production.Separator;
              public version(): string;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public created(): void;
              public draw(): void;
              public canDump(
                _to: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public shouldConsume(): boolean;
              public sense(
                _sensor: Packages.mindustry.logic.LAccess,
              ): number;
              public shouldAmbientSound(): boolean;
              public updateTile(): void;
              public totalProgress(): number;
              public warmup(): number;
              public drawLight(): void;
              public progress(): number;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.production.Separator,
              );
            };
            protected consItems?: Packages.mindustry.world.consumers.ConsumeItems;
            public results: Packages.mindustry._type.ItemStack[];
            public craftTime: number;
            public drawer: Packages.mindustry.world.draw.DrawBlock;
            public load(): void;
            public init(): void;
            public setStats(): void;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace production {
          declare class SingleBlockProducer extends Packages
            .mindustry.world.blocks.payloads.BlockProducer {
            public SingleBlockProducerBuild = class extends Packages
              .mindustry.world.blocks.payloads.BlockProducer
              .BlockProducerBuild {
              this$0: Packages.mindustry.world.blocks.production.SingleBlockProducer;
              public recipe(): Packages.mindustry.world.Block | null;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.production.SingleBlockProducer,
              );
            };
            public result: Packages.mindustry.world.Block;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace production {
          declare class WallCrafter extends Packages
            .mindustry.world.Block {
            public WallCrafterBuild = class extends Packages
              .mindustry.gen.Building {
              public time: number;
              public warmup: number;
              public totalTime: number;
              public lastEfficiency: number;
              this$0: Packages.mindustry.world.blocks.production.WallCrafter;
              public draw(): void;
              public shouldConsume(): boolean;
              public updateTile(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.production.WallCrafter,
              );
            };
            static idx: number;
            public topRegion: Packages.arc.graphics.g2d.TextureRegion;
            public rotatorBottomRegion: Packages.arc.graphics.g2d.TextureRegion;
            public rotatorRegion: Packages.arc.graphics.g2d.TextureRegion;
            public drillTime: number;
            public updateEffect: Packages.mindustry.entities.Effect;
            public updateEffectChance: number;
            public rotateSpeed: number;
            public attribute: Packages.mindustry.world.meta.Attribute;
            public output: Packages.mindustry._type.Item;
            public setBars(): void;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public outputsItems(): boolean;
            public canPlaceOn(
              _tile: Packages.mindustry.world.Tile,
              _team: Packages.mindustry.game.Team,
              _rotation: number,
            ): boolean;
            public rotatedOutput(
              _x: number,
              _y: number,
            ): boolean;
            public setStats(): void;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            getEfficiency(
              _tx: number,
              _ty: number,
              _rotation: number,
              _ctile: Packages.arc.func.Cons<Packages.mindustry.world.Tile> | null,
              _cpos: Packages.arc.func.Intc2 | null,
            ): number;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace sandbox {
          declare class ItemSource extends Packages
            .mindustry.world.Block {
            public ItemSourceBuild = class extends Packages
              .mindustry.gen.Building {
              public counter: number;
              public outputItem: Packages.mindustry._type.Item;
              this$0: Packages.mindustry.world.blocks.sandbox.ItemSource;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public config(): any;
              public config(): Packages.mindustry._type.Item;
              public draw(): void;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public updateTile(): void;
              public buildConfiguration(
                _table: Packages.arc.scene.ui.layout.Table,
              ): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.sandbox.ItemSource,
              );
            };
            public itemsPerSecond: number;
            public setBars(): void;
            public outputsItems(): boolean;
            public setStats(): void;
            public drawPlanConfig(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            protected icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace sandbox {
          declare class ItemVoid extends Packages.mindustry
            .world.Block {
            public ItemVoidBuild = class extends Packages
              .mindustry.gen.Building {
              public flowItems: Packages.mindustry.world.modules.ItemModule;
              this$0: Packages.mindustry.world.blocks.sandbox.ItemVoid;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public handleItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): void;
              public flowItems(): Packages.mindustry.world.modules.ItemModule;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.sandbox.ItemVoid,
              );
            };
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace sandbox {
          declare class LiquidSource extends Packages
            .mindustry.world.Block {
            public LiquidSourceBuild = class extends Packages
              .mindustry.gen.Building {
              public source?: Packages.mindustry._type.Liquid;
              this$0: Packages.mindustry.world.blocks.sandbox.LiquidSource;
              public version(): string;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public config(): Packages.mindustry._type.Liquid;
              public config(): any;
              public draw(): void;
              public updateTile(): void;
              public buildConfiguration(
                _table: Packages.arc.scene.ui.layout.Table,
              ): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.sandbox.LiquidSource,
              );
            };
            public crossRegion: Packages.arc.graphics.g2d.TextureRegion;
            public bottomRegion: Packages.arc.graphics.g2d.TextureRegion;
            public setBars(): void;
            public drawPlanConfig(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace sandbox {
          declare class LiquidVoid extends Packages
            .mindustry.world.Block {
            public LiquidVoidBuild = class extends Packages
              .mindustry.gen.Building {
              this$0: Packages.mindustry.world.blocks.sandbox.LiquidVoid;
              public acceptLiquid(
                _source: Packages.mindustry.gen.Building,
                _liquid: Packages.mindustry._type.Liquid,
              ): boolean;
              public handleLiquid(
                _source: Packages.mindustry.gen.Building,
                _liquid: Packages.mindustry._type.Liquid,
                _amount: number,
              ): void;
              public placed(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.sandbox.LiquidVoid,
              );
            };
            public setBars(): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace sandbox {
          declare class PowerSource extends Packages
            .mindustry.world.blocks.power.PowerNode {
            public PowerSourceBuild = class extends Packages
              .mindustry.world.blocks.power.PowerNode
              .PowerNodeBuild {
              this$0: Packages.mindustry.world.blocks.sandbox.PowerSource;
              public onProximityUpdate(): void;
              public getPowerProduction(): number;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.sandbox.PowerSource,
              );
            };
            public powerProduction: number;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace sandbox {
          declare class PowerVoid extends Packages.mindustry
            .world.blocks.power.PowerBlock {
            public setStats(): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace storage {
          declare class Unloader extends Packages.mindustry
            .world.Block {
            public UnloaderBuild = class extends Packages
              .mindustry.gen.Building {
              public unloadTimer: number;
              public rotations: number;
              public sortItem: Packages.mindustry._type.Item;
              public dumpingFrom: Packages.mindustry.world.blocks.storage.Unloader.ContainerStat;
              public dumpingTo: Packages.mindustry.world.blocks.storage.Unloader.ContainerStat;
              public possibleBlocks: Packages.arc.struct.Seq<Packages.mindustry.world.blocks.storage.Unloader.ContainerStat>;
              protected comparator: Packages.java.util.Comparator<Packages.mindustry.world.blocks.storage.Unloader.ContainerStat>;
              this$0: Packages.mindustry.world.blocks.storage.Unloader;
              public version(): string;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public config(): any;
              public config(): Packages.mindustry._type.Item;
              public draw(): void;
              public updateTile(): void;
              public onProximityUpdate(): void;
              public buildConfiguration(
                _table: Packages.arc.scene.ui.layout.Table,
              ): void;
              private isPossibleItem(
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.storage.Unloader,
              );
            };
            public static ContainerStat = class
              extends java.lang.Object
              implements
                Packages.arc.util.pooling.Pool.Poolable
            {
              building: Packages.mindustry.gen.Building;
              loadFactor: number;
              canLoad: boolean;
              canUnload: boolean;
              notStorage: boolean;
              lastUsed: number;
              public reset(): void;
              public constructor();
            };
            public centerRegion: Packages.arc.graphics.g2d.TextureRegion;
            public speed: number;
            static allItems: Packages.mindustry._type.Item[];
            public init(): void;
            public setBars(): void;
            public setStats(): void;
            public drawPlanConfig(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace units {
          declare class DroneCenter extends Packages
            .mindustry.world.Block {
            public EffectDroneAI = class extends Packages
              .mindustry.entities.units.AIController {
              this$0: Packages.mindustry.world.blocks.units.DroneCenter;
              public updateUnit(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.units.DroneCenter,
              );
            };
            public DroneCenterBuild = class extends Packages
              .mindustry.gen.Building {
              protected readUnits: Packages.arc.struct.IntSeq;
              protected readTarget: number;
              public units: Packages.arc.struct.Seq<Packages.mindustry.gen.Unit>;
              public target?: Packages.mindustry.gen.Unit;
              public droneProgress: number;
              public droneWarmup: number;
              public totalDroneProgress: number;
              this$0: Packages.mindustry.world.blocks.units.DroneCenter;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public draw(): void;
              public updateTile(): void;
              public drawConfigure(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.units.DroneCenter,
              );
            };
            public unitsSpawned: number;
            public droneType: Packages.mindustry._type.UnitType;
            public status: Packages.mindustry._type.StatusEffect;
            public droneConstructTime: number;
            public statusDuration: number;
            public droneRange: number;
            public init(): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace units {
          declare class UnitBlock extends Packages.mindustry
            .world.blocks.payloads.PayloadBlock {
            public UnitBuild = class extends Packages
              .mindustry.world.blocks.payloads.PayloadBlock
              .PayloadBlockBuild<Packages.mindustry.world.blocks.payloads.UnitPayload> {
              public progress: number;
              public time: number;
              public speedScl: number;
              this$0: Packages.mindustry.world.blocks.units.UnitBlock;
              public dumpPayload(): void;
              public spawned(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.units.UnitBlock,
              );
            };
            public static unitBlockSpawn(
              _tile: Packages.mindustry.world.Tile,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace units {
          declare class Reconstructor extends Packages
            .mindustry.world.blocks.units.UnitBlock {
            public ReconstructorBuild = class extends Packages
              .mindustry.world.blocks.units.UnitBlock
              .UnitBuild {
              public commandPos?: Packages.arc.math.geom.Vec2;
              public command?: Packages.mindustry.ai.UnitCommand;
              this$0: Packages.mindustry.world.blocks.units.Reconstructor;
              public version(): string;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public unit(): Packages.mindustry._type.UnitType;
              public fraction(): number;
              public config(): any;
              public draw(): void;
              public getMaximumAccepted(
                _item: Packages.mindustry._type.Item,
              ): number;
              public acceptPayload(
                _source: Packages.mindustry.gen.Building,
                _payload: Packages.mindustry.world.blocks.payloads.Payload,
              ): boolean;
              public shouldConsume(): boolean;
              public sense(
                _sensor: Packages.mindustry.logic.LAccess,
              ): number;
              public shouldActiveSound(): boolean;
              public updateTile(): void;
              public getCursor(): Packages.arc.Graphics.Cursor;
              public getCommandPosition(): Packages.arc.math.geom.Vec2;
              public shouldShowConfigure(
                _player: Packages.mindustry.gen.Player,
              ): boolean;
              public senseObject(
                _sensor: Packages.mindustry.logic.LAccess,
              ): any;
              public buildConfiguration(
                _table: Packages.arc.scene.ui.layout.Table,
              ): void;
              public onCommand(
                _target: Packages.arc.math.geom.Vec2,
              ): void;
              public overwrote(
                _builds: Packages.arc.struct.Seq<Packages.mindustry.gen.Building>,
              ): void;
              public upgrade(
                _type: Packages.mindustry._type.UnitType,
              ): Packages.mindustry._type.UnitType;
              public acceptUnitPayload(
                _unit: Packages.mindustry.gen.Unit,
              ): boolean;
              public hasUpgrade(
                _type: Packages.mindustry._type.UnitType,
              ): boolean;
              public canSetCommand(): boolean;
              public constructing(): boolean;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.units.Reconstructor,
              );
            };
            public constructTime: number;
            public upgrades: Packages.arc.struct.Seq<
              Packages.mindustry._type.UnitType[]
            >;
            public capacities: number[];
            public init(): void;
            public setBars(): void;
            public setStats(): void;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public addUpgrade(
              _from: Packages.mindustry._type.UnitType,
              _to: Packages.mindustry._type.UnitType,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace units {
          declare class RepairTower extends Packages
            .mindustry.world.Block {
            public RepairTowerBuild = class
              extends Packages.mindustry.gen.Building
              implements Packages.mindustry.logic.Ranged
            {
              public refresh: number;
              public warmup: number;
              public totalProgress: number;
              public targets: Packages.arc.struct.Seq<Packages.mindustry.gen.Unit>;
              this$0: Packages.mindustry.world.blocks.units.RepairTower;
              public range(): number;
              public draw(): void;
              public shouldConsume(): boolean;
              public updateTile(): void;
              public warmup(): number;
              public drawSelect(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.units.RepairTower,
              );
            };
            static refreshInterval: number;
            public range: number;
            public circleColor: Packages.arc.graphics.Color;
            public glowColor: Packages.arc.graphics.Color;
            public circleSpeed: number;
            public circleStroke: number;
            public squareRad: number;
            public squareSpinScl: number;
            public glowMag: number;
            public glowScl: number;
            public healAmount: number;
            public glow: Packages.arc.graphics.g2d.TextureRegion;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public setStats(): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace units {
          declare class RepairTurret extends Packages
            .mindustry.world.Block {
            public RepairPointBuild = class
              extends Packages.mindustry.gen.Building
              implements
                Packages.mindustry.logic.Ranged,
                Packages.mindustry.world.blocks.RotBlock
            {
              public target: Packages.mindustry.gen.Unit;
              public offset: Packages.arc.math.geom.Vec2;
              public lastEnd: Packages.arc.math.geom.Vec2;
              public strength: number;
              public rotation: number;
              this$0: Packages.mindustry.world.blocks.units.RepairTurret;
              public version(): string;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public status(): Packages.mindustry.world.meta.BlockStatus;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public range(): number;
              public draw(): void;
              public shouldConsume(): boolean;
              public updateTile(): void;
              public drawSelect(): void;
              public buildRotation(): number;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.units.RepairTurret,
              );
            };
            static rect: Packages.arc.math.geom.Rect;
            static rand: Packages.arc.math.Rand;
            public timerTarget: number;
            public timerEffect: number;
            public repairRadius: number;
            public repairSpeed: number;
            public powerUse: number;
            public length: number;
            public beamWidth: number;
            public pulseRadius: number;
            public pulseStroke: number;
            public acceptCoolant: boolean;
            public coolantUse: number;
            public coolEffect: Packages.mindustry.entities.Effect;
            public coolantMultiplier: number;
            public baseRegion: Packages.arc.graphics.g2d.TextureRegion;
            public laser: Packages.arc.graphics.g2d.TextureRegion;
            public laserEnd: Packages.arc.graphics.g2d.TextureRegion;
            public laserTop: Packages.arc.graphics.g2d.TextureRegion;
            public laserTopEnd: Packages.arc.graphics.g2d.TextureRegion;
            public laserColor: Packages.arc.graphics.Color;
            public laserTopColor: Packages.arc.graphics.Color;
            public init(): void;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public setStats(): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public static drawBeam(
              _x: number,
              _y: number,
              _rotation: number,
              _length: number,
              _id: number,
              _target: Packages.mindustry.entities.Sized | null,
              _team: Packages.mindustry.game.Team,
              _strength: number,
              _pulseStroke: number,
              _pulseRadius: number,
              _beamWidth: number,
              _lastEnd: Packages.arc.math.geom.Vec2,
              _offset: Packages.arc.math.geom.Vec2,
              _laserColor: Packages.arc.graphics.Color,
              _laserTopColor: Packages.arc.graphics.Color,
              _laser: Packages.arc.graphics.g2d.TextureRegion,
              _laserEnd: Packages.arc.graphics.g2d.TextureRegion,
              _laserTop: Packages.arc.graphics.g2d.TextureRegion,
              _laserTopEnd: Packages.arc.graphics.g2d.TextureRegion,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace units {
          declare class UnitAssemblerModule extends Packages
            .mindustry.world.blocks.payloads.PayloadBlock {
            public UnitAssemblerModuleBuild = class extends Packages
              .mindustry.world.blocks.payloads.PayloadBlock
              .PayloadBlockBuild<Packages.mindustry.world.blocks.payloads.Payload> {
              public link: Packages.mindustry.world.blocks.units.UnitAssembler.UnitAssemblerBuild;
              public lastChange: number;
              this$0: Packages.mindustry.world.blocks.units.UnitAssemblerModule;
              public draw(): void;
              public acceptPayload(
                _source: Packages.mindustry.gen.Building,
                _payload: Packages.mindustry.world.blocks.payloads.Payload,
              ): boolean;
              public updateTile(): void;
              public onRemoved(): void;
              public tier(): number;
              public drawSelect(): void;
              public findLink(): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.units.UnitAssemblerModule,
              );
            };
            public sideRegion1: Packages.arc.graphics.g2d.TextureRegion;
            public sideRegion2: Packages.arc.graphics.g2d.TextureRegion;
            public tier: number;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public canPlaceOn(
              _tile: Packages.mindustry.world.Tile,
              _team: Packages.mindustry.game.Team,
              _rotation: number,
            ): boolean;
            public setStats(): void;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public getLink(
              _team: Packages.mindustry.game.Team,
              _x: number,
              _y: number,
              _rotation: number,
            ): Packages.mindustry.world.blocks.units.UnitAssembler.UnitAssemblerBuild | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace units {
          declare class UnitAssembler extends Packages
            .mindustry.world.blocks.payloads.PayloadBlock {
            public UnitAssemblerBuild = class extends Packages
              .mindustry.world.blocks.payloads.PayloadBlock
              .PayloadBlockBuild<Packages.mindustry.world.blocks.payloads.Payload> {
              protected readUnits: Packages.arc.struct.IntSeq;
              protected whenSyncedUnits: Packages.arc.struct.IntSeq;
              public commandPos?: Packages.arc.math.geom.Vec2;
              public units: Packages.arc.struct.Seq<Packages.mindustry.gen.Unit>;
              public modules: Packages.arc.struct.Seq<Packages.mindustry.world.blocks.units.UnitAssemblerModule.UnitAssemblerModuleBuild>;
              public blocks: Packages.mindustry._type.PayloadSeq;
              public progress: number;
              public warmup: number;
              public droneWarmup: number;
              public powerWarmup: number;
              public sameTypeWarmup: number;
              public invalidWarmup: number;
              public currentTier: number;
              public lastTier: number;
              public wasOccupied: boolean;
              public droneProgress: number;
              public totalDroneProgress: number;
              this$0: Packages.mindustry.world.blocks.units.UnitAssembler;
              public version(): string;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public unit(): Packages.mindustry._type.UnitType;
              public display(
                _table: Packages.arc.scene.ui.layout.Table,
              ): void;
              public draw(): void;
              public acceptPayload(
                _source: Packages.mindustry.gen.Building,
                _payload: Packages.mindustry.world.blocks.payloads.Payload,
              ): boolean;
              public shouldConsume(): boolean;
              public sense(
                _sensor: Packages.mindustry.logic.LAccess,
              ): number;
              public updateTile(): void;
              public checkSolid(
                _v: Packages.arc.math.geom.Vec2,
                _same: boolean,
              ): boolean;
              public plan(): Packages.mindustry.world.blocks.units.UnitAssembler.AssemblerUnitPlan;
              public getCommandPosition(): Packages.arc.math.geom.Vec2;
              public getPayloads(): Packages.mindustry._type.PayloadSeq;
              public drawSelect(): void;
              public onCommand(
                _target: Packages.arc.math.geom.Vec2,
              ): void;
              public spawned(): void;
              public droneSpawned(_id: number): void;
              public moduleFits(
                _other: Packages.mindustry.world.Block,
                _ox: number,
                _oy: number,
                _rotation: number,
              ): boolean;
              public removeModule(
                _build: Packages.mindustry.world.blocks.units.UnitAssemblerModule.UnitAssemblerModuleBuild,
              ): void;
              public getUnitSpawn(): Packages.arc.math.geom.Vec2;
              public checkTier(): void;
              public yeetPayload(
                _payload: Packages.mindustry.world.blocks.payloads.Payload,
              ): void;
              public updateModules(
                _build: Packages.mindustry.world.blocks.units.UnitAssemblerModule.UnitAssemblerModuleBuild,
              ): void;
              public ready(): boolean;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.units.UnitAssembler,
              );
            };
            public static AssemblerUnitPlan = class extends java
              .lang.Object {
              public unit: Packages.mindustry._type.UnitType;
              public requirements: Packages.arc.struct.Seq<Packages.mindustry._type.PayloadStack>;
              public time: number;
              public constructor(
                _unit: Packages.mindustry._type.UnitType,
                _time: number,
                _requirements: Packages.arc.struct.Seq<Packages.mindustry._type.PayloadStack>,
              );
            };
            public static YeetData = class extends java.lang
              .Object {
              public target: Packages.arc.math.geom.Vec2;
              public item: Packages.mindustry.ctype.UnlockableContent;
              public constructor(
                _target: Packages.arc.math.geom.Vec2,
                _item: Packages.mindustry.ctype.UnlockableContent,
              );
            };
            public sideRegion1: Packages.arc.graphics.g2d.TextureRegion;
            public sideRegion2: Packages.arc.graphics.g2d.TextureRegion;
            public areaSize: number;
            public droneType: Packages.mindustry._type.UnitType;
            public dronesCreated: number;
            public droneConstructTime: number;
            public plans: Packages.arc.struct.Seq<Packages.mindustry.world.blocks.units.UnitAssembler.AssemblerUnitPlan>;
            protected consPayload?: Packages.mindustry.world.consumers.ConsumePayloadDynamic;
            public init(): void;
            public getRect(
              _rect: Packages.arc.math.geom.Rect,
              _x: number,
              _y: number,
              _rotation: number,
            ): Packages.arc.math.geom.Rect;
            public setBars(): void;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public canPlaceOn(
              _tile: Packages.mindustry.world.Tile,
              _team: Packages.mindustry.game.Team,
              _rotation: number,
            ): boolean;
            public setStats(): void;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public static assemblerUnitSpawned(
              _tile: Packages.mindustry.world.Tile,
            ): void;
            public static assemblerDroneSpawned(
              _tile: Packages.mindustry.world.Tile,
              _id: number,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace units {
          declare class UnitCargoLoader extends Packages
            .mindustry.world.Block {
            public UnitTransportSourceBuild = class
              extends Packages.mindustry.gen.Building
              implements
                Packages.mindustry.world.blocks
                  .UnitTetherBlock
            {
              public readUnitId: number;
              public buildProgress: number;
              public totalProgress: number;
              public warmup: number;
              public readyness: number;
              public unit?: Packages.mindustry.gen.Unit;
              this$0: Packages.mindustry.world.blocks.units.UnitCargoLoader;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public draw(): void;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public shouldConsume(): boolean;
              public shouldActiveSound(): boolean;
              public updateTile(): void;
              public totalProgress(): number;
              public spawned(_id: number): void;
              public progress(): number;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.units.UnitCargoLoader,
              );
            };
            public unitType: Packages.mindustry._type.UnitType;
            public buildTime: number;
            public polyStroke: number;
            public polyRadius: number;
            public polySides: number;
            public polyRotateSpeed: number;
            public polyColor: Packages.arc.graphics.Color;
            public setBars(): void;
            public drawPlace(
              _x: number,
              _y: number,
              _rotation: number,
              _valid: boolean,
            ): void;
            public outputsItems(): boolean;
            public canPlaceOn(
              _tile: Packages.mindustry.world.Tile,
              _team: Packages.mindustry.game.Team,
              _rotation: number,
            ): boolean;
            public static unitTetherBlockSpawned(
              _tile: Packages.mindustry.world.Tile,
              _id: number,
            ): void;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace units {
          declare class UnitFactory extends Packages
            .mindustry.world.blocks.units.UnitBlock {
            public static UnitPlan = class extends java.lang
              .Object {
              public unit: Packages.mindustry._type.UnitType;
              public requirements: Packages.mindustry._type.ItemStack[];
              public time: number;
              public constructor(
                _unit: Packages.mindustry._type.UnitType,
                _time: number,
                _requirements: Packages.mindustry._type.ItemStack[],
              );
            };
            public UnitFactoryBuild = class extends Packages
              .mindustry.world.blocks.units.UnitBlock
              .UnitBuild {
              public commandPos?: Packages.arc.math.geom.Vec2;
              public currentPlan: number;
              this$0: Packages.mindustry.world.blocks.units.UnitFactory;
              public version(): string;
              public write(
                _write: Packages.arc.util.io.Writes,
              ): void;
              public read(
                _read: Packages.arc.util.io.Reads,
                _revision: string,
              ): void;
              public unit(): Packages.mindustry._type.UnitType | null;
              public display(
                _table: Packages.arc.scene.ui.layout.Table,
              ): void;
              public fraction(): number;
              public config(): any;
              public draw(): void;
              public getMaximumAccepted(
                _item: Packages.mindustry._type.Item,
              ): number;
              public acceptItem(
                _source: Packages.mindustry.gen.Building,
                _item: Packages.mindustry._type.Item,
              ): boolean;
              public acceptPayload(
                _source: Packages.mindustry.gen.Building,
                _payload: Packages.mindustry.world.blocks.payloads.Payload,
              ): boolean;
              public shouldConsume(): boolean;
              public sense(
                _sensor: Packages.mindustry.logic.LAccess,
              ): number;
              public shouldActiveSound(): boolean;
              public updateTile(): void;
              public getCommandPosition(): Packages.arc.math.geom.Vec2;
              public senseObject(
                _sensor: Packages.mindustry.logic.LAccess,
              ): any;
              public buildConfiguration(
                _table: Packages.arc.scene.ui.layout.Table,
              ): void;
              public onCommand(
                _target: Packages.arc.math.geom.Vec2,
              ): void;
              public constructor(
                _this$0: Packages.mindustry.world.blocks.units.UnitFactory,
              );
            };
            public capacities: number[];
            public plans: Packages.arc.struct.Seq<Packages.mindustry.world.blocks.units.UnitFactory.UnitPlan>;
            public init(): void;
            public setBars(): void;
            public outputsItems(): boolean;
            public setStats(): void;
            public drawPlanRegion(
              _plan: Packages.mindustry.entities.units.BuildPlan,
              _list: Packages.arc.util.Eachable<Packages.mindustry.entities.units.BuildPlan>,
            ): void;
            public icons():
              | Packages.arc.graphics.g2d.TextureRegion[]
              | null;
            public constructor(_name: string);
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare namespace turrets {
            declare class ContinuousTurret extends Packages
              .mindustry.world.blocks.defense.turrets
              .Turret {
              public ContinuousTurretBuild = class extends Packages
                .mindustry.world.blocks.defense.turrets
                .Turret.TurretBuild {
                public bullets: Packages.arc.struct.Seq<Packages.mindustry.world.blocks.defense.turrets.Turret.BulletEntry>;
                public lastLength: number;
                this$0: Packages.mindustry.world.blocks.defense.turrets.ContinuousTurret;
                public version(): string;
                public write(
                  _write: Packages.arc.util.io.Writes,
                ): void;
                public read(
                  _read: Packages.arc.util.io.Reads,
                  _revision: string,
                ): void;
                public shouldConsume(): boolean;
                public shouldActiveSound(): boolean;
                public activeSoundVolume(): number;
                public updateTile(): void;
                public estimateDps(): number;
                public useAmmo(): Packages.mindustry.entities.bullet.BulletType;
                protected handleBullet(
                  _bullet: Packages.mindustry.gen.Bullet | null,
                  _offsetX: number,
                  _offsetY: number,
                  _angleOffset: number,
                ): void;
                public hasAmmo(): boolean;
                public peekAmmo(): Packages.mindustry.entities.bullet.BulletType;
                protected updateReload(): void;
                protected turnToTarget(
                  _targetRot: number,
                ): void;
                protected updateShooting(): void;
                protected updateCooling(): void;
                protected updateBullet(
                  _entry: Packages.mindustry.world.blocks.defense.turrets.Turret.BulletEntry,
                ): void;
                public constructor(
                  _this$0: Packages.mindustry.world.blocks.defense.turrets.ContinuousTurret,
                );
              };
              public shootType: Packages.mindustry.entities.bullet.BulletType;
              public aimChangeSpeed: number;
              public setStats(): void;
              public constructor(_name: string);
            }
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare namespace turrets {
            declare class ContinuousLiquidTurret extends Packages
              .mindustry.world.blocks.defense.turrets
              .ContinuousTurret {
              public ContinuousLiquidTurretBuild = class extends Packages
                .mindustry.world.blocks.defense.turrets
                .ContinuousTurret.ContinuousTurretBuild {
                this$0: Packages.mindustry.world.blocks.defense.turrets.ContinuousLiquidTurret;
                public acceptItem(
                  _source: Packages.mindustry.gen.Building,
                  _item: Packages.mindustry._type.Item,
                ): boolean;
                public acceptLiquid(
                  _source: Packages.mindustry.gen.Building,
                  _liquid: Packages.mindustry._type.Liquid,
                ): boolean;
                public shouldActiveSound(): boolean;
                public updateTile(): void;
                public canConsume(): boolean;
                public senseObject(
                  _sensor: Packages.mindustry.logic.LAccess,
                ): any;
                public useAmmo(): Packages.mindustry.entities.bullet.BulletType;
                public hasAmmo(): boolean;
                public peekAmmo(): Packages.mindustry.entities.bullet.BulletType;
                public hasCorrectAmmo(): boolean;
                public constructor(
                  _this$0: Packages.mindustry.world.blocks.defense.turrets.ContinuousLiquidTurret,
                );
              };
              public ammoTypes: Packages.arc.struct.ObjectMap<
                Packages.mindustry._type.Liquid,
                Packages.mindustry.entities.bullet.BulletType
              >;
              public liquidConsumed: number;
              public init(): void;
              public setStats(): void;
              public ammo(..._objects: any[]): void;
              public constructor(_name: string);
            }
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare namespace turrets {
            declare class ItemTurret extends Packages
              .mindustry.world.blocks.defense.turrets
              .Turret {
              public ItemTurretBuild = class extends Packages
                .mindustry.world.blocks.defense.turrets
                .Turret.TurretBuild {
                this$0: Packages.mindustry.world.blocks.defense.turrets.ItemTurret;
                public version(): string;
                public write(
                  _write: Packages.arc.util.io.Writes,
                ): void;
                public read(
                  _read: Packages.arc.util.io.Reads,
                  _revision: string,
                ): void;
                public acceptItem(
                  _source: Packages.mindustry.gen.Building,
                  _item: Packages.mindustry._type.Item,
                ): boolean;
                public handleItem(
                  _source: Packages.mindustry.gen.Building,
                  _item: Packages.mindustry._type.Item,
                ): void;
                public acceptStack(
                  _item: Packages.mindustry._type.Item,
                  _amount: number,
                  _source: Packages.mindustry.gen.Teamc,
                ): number;
                public handleStack(
                  _item: Packages.mindustry._type.Item,
                  _amount: number,
                  _source: Packages.mindustry.gen.Teamc,
                ): void;
                public removeStack(
                  _item: Packages.mindustry._type.Item,
                  _amount: number,
                ): number;
                public updateTile(): void;
                public onProximityAdded(): void;
                public senseObject(
                  _sensor: Packages.mindustry.logic.LAccess,
                ): any;
                public constructor(
                  _this$0: Packages.mindustry.world.blocks.defense.turrets.ItemTurret,
                );
              };
              public ItemEntry = class extends Packages
                .mindustry.world.blocks.defense.turrets
                .Turret.AmmoEntry {
                public item: Packages.mindustry._type.Item;
                this$0: Packages.mindustry.world.blocks.defense.turrets.ItemTurret;
                public type(): Packages.mindustry.entities.bullet.BulletType;
                public toString(): string;
              };
              public ammoTypes: Packages.arc.struct.ObjectMap<
                Packages.mindustry._type.Item,
                Packages.mindustry.entities.bullet.BulletType
              >;
              public init(): void;
              public setBars(): void;
              public setStats(): void;
              public ammo(..._objects: any[]): void;
              public limitRange(): void;
              public limitRange(_margin: number): void;
              public constructor(_name: string);
            }
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare namespace turrets {
            declare class PowerTurret extends Packages
              .mindustry.world.blocks.defense.turrets
              .Turret {
              public PowerTurretBuild = class extends Packages
                .mindustry.world.blocks.defense.turrets
                .Turret.TurretBuild {
                this$0: Packages.mindustry.world.blocks.defense.turrets.PowerTurret;
                public sense(
                  _sensor: Packages.mindustry.logic.LAccess,
                ): number;
                public updateTile(): void;
                public useAmmo(): Packages.mindustry.entities.bullet.BulletType;
                public hasAmmo(): boolean;
                public peekAmmo(): Packages.mindustry.entities.bullet.BulletType;
                public constructor(
                  _this$0: Packages.mindustry.world.blocks.defense.turrets.PowerTurret,
                );
              };
              public shootType: Packages.mindustry.entities.bullet.BulletType;
              public setStats(): void;
              public limitRange(_margin: number): void;
              public constructor(_name: string);
            }
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare namespace turrets {
            declare class LaserTurret extends Packages
              .mindustry.world.blocks.defense.turrets
              .PowerTurret {
              public LaserTurretBuild = class extends Packages
                .mindustry.world.blocks.defense.turrets
                .PowerTurret.PowerTurretBuild {
                public bullets: Packages.arc.struct.Seq<Packages.mindustry.world.blocks.defense.turrets.Turret.BulletEntry>;
                this$0: Packages.mindustry.world.blocks.defense.turrets.LaserTurret;
                public shouldConsume(): boolean;
                public shouldActiveSound(): boolean;
                public activeSoundVolume(): number;
                public updateTile(): void;
                public placed(): void;
                protected handleBullet(
                  _bullet: Packages.mindustry.gen.Bullet | null,
                  _offsetX: number,
                  _offsetY: number,
                  _angleOffset: number,
                ): void;
                protected updateReload(): void;
                protected turnToTarget(
                  _targetRot: number,
                ): void;
                protected updateShooting(): void;
                protected updateCooling(): void;
                public progress(): number;
                public constructor(
                  _this$0: Packages.mindustry.world.blocks.defense.turrets.LaserTurret,
                );
              };
              public firingMoveFract: number;
              public shootDuration: number;
              public init(): void;
              public setStats(): void;
              public constructor(_name: string);
            }
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare namespace turrets {
            declare class LiquidTurret extends Packages
              .mindustry.world.blocks.defense.turrets
              .Turret {
              public LiquidTurretBuild = class extends Packages
                .mindustry.world.blocks.defense.turrets
                .Turret.TurretBuild {
                this$0: Packages.mindustry.world.blocks.defense.turrets.LiquidTurret;
                public acceptItem(
                  _source: Packages.mindustry.gen.Building,
                  _item: Packages.mindustry._type.Item,
                ): boolean;
                public acceptLiquid(
                  _source: Packages.mindustry.gen.Building,
                  _liquid: Packages.mindustry._type.Liquid,
                ): boolean;
                public shouldActiveSound(): boolean;
                public updateTile(): void;
                protected findTarget(): void;
                public senseObject(
                  _sensor: Packages.mindustry.logic.LAccess,
                ): any;
                public useAmmo(): Packages.mindustry.entities.bullet.BulletType;
                public hasAmmo(): boolean;
                public peekAmmo(): Packages.mindustry.entities.bullet.BulletType;
                public constructor(
                  _this$0: Packages.mindustry.world.blocks.defense.turrets.LiquidTurret,
                );
              };
              public ammoTypes: Packages.arc.struct.ObjectMap<
                Packages.mindustry._type.Liquid,
                Packages.mindustry.entities.bullet.BulletType
              >;
              public extinguish: boolean;
              public init(): void;
              public setStats(): void;
              public ammo(..._objects: any[]): void;
              public constructor(_name: string);
            }
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare namespace turrets {
            declare class PayloadAmmoTurret extends Packages
              .mindustry.world.blocks.defense.turrets
              .Turret {
              public PayloadTurretBuild = class extends Packages
                .mindustry.world.blocks.defense.turrets
                .Turret.TurretBuild {
                public payloads: Packages.mindustry._type.PayloadSeq;
                this$0: Packages.mindustry.world.blocks.defense.turrets.PayloadAmmoTurret;
                public write(
                  _write: Packages.arc.util.io.Writes,
                ): void;
                public read(
                  _read: Packages.arc.util.io.Reads,
                  _revision: string,
                ): void;
                public acceptPayload(
                  _source: Packages.mindustry.gen.Building,
                  _payload: Packages.mindustry.world.blocks.payloads.Payload,
                ): boolean;
                public handlePayload(
                  _source: Packages.mindustry.gen.Building,
                  _payload: Packages.mindustry.world.blocks.payloads.Payload,
                ): void;
                public updateTile(): void;
                public displayBars(
                  _bars: Packages.arc.scene.ui.layout.Table,
                ): void;
                public getPayloads(): Packages.mindustry._type.PayloadSeq;
                public useAmmo(): Packages.mindustry.entities.bullet.BulletType;
                public hasAmmo(): boolean;
                public peekAmmo(): Packages.mindustry.entities.bullet.BulletType;
                public currentAmmo(): Packages.mindustry.ctype.UnlockableContent;
                public constructor(
                  _this$0: Packages.mindustry.world.blocks.defense.turrets.PayloadAmmoTurret,
                );
              };
              public ammoTypes: Packages.arc.struct.ObjectMap<
                Packages.mindustry.ctype.UnlockableContent,
                Packages.mindustry.entities.bullet.BulletType
              >;
              protected ammoKeys: Packages.mindustry.ctype.UnlockableContent[];
              public init(): void;
              public setStats(): void;
              public ammo(..._objects: any[]): void;
              public limitRange(): void;
              public limitRange(_margin: number): void;
              public constructor(_name: string);
            }
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare namespace turrets {
            declare class PointDefenseTurret extends Packages
              .mindustry.world.blocks.defense.turrets
              .ReloadTurret {
              public PointDefenseBuild = class extends Packages
                .mindustry.world.blocks.defense.turrets
                .ReloadTurret.ReloadTurretBuild {
                public target?: Packages.mindustry.gen.Bullet;
                this$0: Packages.mindustry.world.blocks.defense.turrets.PointDefenseTurret;
                public write(
                  _write: Packages.arc.util.io.Writes,
                ): void;
                public read(
                  _read: Packages.arc.util.io.Reads,
                  _revision: string,
                ): void;
                public draw(): void;
                public shouldConsume(): boolean;
                public updateTile(): void;
                public constructor(
                  _this$0: Packages.mindustry.world.blocks.defense.turrets.PointDefenseTurret,
                );
              };
              public timerTarget: number;
              public retargetTime: number;
              public baseRegion: Packages.arc.graphics.g2d.TextureRegion;
              public color: Packages.arc.graphics.Color;
              public beamEffect: Packages.mindustry.entities.Effect;
              public hitEffect: Packages.mindustry.entities.Effect;
              public shootEffect: Packages.mindustry.entities.Effect;
              public shootSound: Packages.arc.audio.Sound;
              public shootCone: number;
              public bulletDamage: number;
              public shootLength: number;
              public setStats(): void;
              public icons():
                | Packages.arc.graphics.g2d.TextureRegion[]
                | null;
              public constructor(_name: string);
            }
          }
        }
      }
    }
  }
}
declare namespace Packages {
  declare namespace mindustry {
    declare namespace world {
      declare namespace blocks {
        declare namespace defense {
          declare namespace turrets {
            declare class TractorBeamTurret extends Packages
              .mindustry.world.blocks.defense.turrets
              .BaseTurret {
              public TractorBeamBuild = class extends Packages
                .mindustry.world.blocks.defense.turrets
                .BaseTurret.BaseTurretBuild {
                public target?: Packages.mindustry.gen.Unit;
                public lastX: number;
                public lastY: number;
                public strength: number;
                public any: boolean;
                public coolantMultiplier: number;
                this$0: Packages.mindustry.world.blocks.defense.turrets.TractorBeamTurret;
                public write(
                  _write: Packages.arc.util.io.Writes,
                ): void;
                public read(
                  _read: Packages.arc.util.io.Reads,
                  _revision: string,
                ): void;
                public draw(): void;
                public shouldConsume(): boolean;
                public updateTile(): void;
                public estimateDps(): number;
                public constructor(
                  _this$0: Packages.mindustry.world.blocks.defense.turrets.TractorBeamTurret,
                );
              };
              public timerTarget: number;
              public retargetTime: number;
              public shootCone: number;
              public shootLength: number;
              public laserWidth: number;
              public force: number;
              public scaledForce: number;
              public damage: number;
              public targetAir: boolean;
              public targetGround: boolean;
              public laserColor: Packages.arc.graphics.Color;
              public status: Packages.mindustry._type.StatusEffect;
              public statusDuration: number;
              public shootSound: Packages.arc.audio.Sound;
              public shootSoundVolume: number;
              public baseRegion: Packages.arc.graphics.g2d.TextureRegion;
              public laser: Packages.arc.graphics.g2d.TextureRegion;
              public laserStart: Packages.arc.graphics.g2d.TextureRegion;
              public laserEnd: Packages.arc.graphics.g2d.TextureRegion;
              public init(): void;
              public setStats(): void;
              public icons():
                | Packages.arc.graphics.g2d.TextureRegion[]
                | null;
              public constructor(_name: string);
            }
          }
        }
      }
    }
  }
}
declare const long = Packages.long;
declare type long = Packages.long;
declare type Object = any;
declare const Serializable = Packages.java.io.Serializable;
declare type Serializable = Packages.java.io.Serializable;
declare const Annotation =
  Packages.java.lang.annotation.Annotation;
declare type Annotation =
  Packages.java.lang.annotation.Annotation;
declare const AnnotatedElement =
  Packages.java.lang.reflect.AnnotatedElement;
declare type AnnotatedElement =
  Packages.java.lang.reflect.AnnotatedElement;
declare const TypeVariable =
  Packages.java.lang.reflect.TypeVariable;
declare type TypeVariable =
  Packages.java.lang.reflect.TypeVariable;
declare const GenericDeclaration =
  Packages.java.lang.reflect.GenericDeclaration;
declare type GenericDeclaration =
  Packages.java.lang.reflect.GenericDeclaration;
declare const Type = Packages.java.lang.reflect.Type;
declare type Type = Packages.java.lang.reflect.Type;
declare const TypeDescriptor =
  Packages.java.lang.invoke.TypeDescriptor;
declare type TypeDescriptor =
  Packages.java.lang.invoke.TypeDescriptor;
declare const Optional = Packages.java.util.Optional;
declare type Optional = Packages.java.util.Optional;
declare const ConstantDesc =
  Packages.java.lang.constant.ConstantDesc;
declare type ConstantDesc =
  Packages.java.lang.constant.ConstantDesc;
declare const Constable =
  Packages.java.lang.constant.Constable;
declare type Constable =
  Packages.java.lang.constant.Constable;
declare const Constructor =
  Packages.java.lang.reflect.Constructor;
declare type Constructor =
  Packages.java.lang.reflect.Constructor;
declare const Module = Packages.java.lang.Module;
declare type Module = Packages.java.lang.Module;
declare const ProtectionDomain =
  Packages.java.security.ProtectionDomain;
declare type ProtectionDomain =
  Packages.java.security.ProtectionDomain;
declare const SoftReference =
  Packages.java.lang.ref.SoftReference;
declare type SoftReference =
  Packages.java.lang.ref.SoftReference;
declare const ClassRepository =
  Packages.sun.reflect.generics.repository.ClassRepository;
declare type ClassRepository =
  Packages.sun.reflect.generics.repository.ClassRepository;
declare const ObjectStreamField =
  Packages.java.io.ObjectStreamField;
declare type ObjectStreamField =
  Packages.java.io.ObjectStreamField;
declare const ReflectionFactory =
  Packages.jdk.internal.reflect.ReflectionFactory;
declare type ReflectionFactory =
  Packages.jdk.internal.reflect.ReflectionFactory;
declare const Map = Packages.java.util.Map;
declare type Map = Packages.java.util.Map;
declare const AnnotationType =
  Packages.sun.reflect.annotation.AnnotationType;
declare type AnnotationType =
  Packages.sun.reflect.annotation.AnnotationType;
declare const SecurityManager =
  Packages.java.lang.SecurityManager;
declare type SecurityManager =
  Packages.java.lang.SecurityManager;
declare const ClassLoader = Packages.java.lang.ClassLoader;
declare type ClassLoader = Packages.java.lang.ClassLoader;
declare const ClassDesc =
  Packages.java.lang.constant.ClassDesc;
declare type ClassDesc =
  Packages.java.lang.constant.ClassDesc;
declare const GenericsFactory =
  Packages.sun.reflect.generics.factory.GenericsFactory;
declare type GenericsFactory =
  Packages.sun.reflect.generics.factory.GenericsFactory;
declare const Method = Packages.java.lang.reflect.Method;
declare type Method = Packages.java.lang.reflect.Method;
declare const Field = Packages.java.lang.reflect.Field;
declare type Field = Packages.java.lang.reflect.Field;
declare const RecordComponent =
  Packages.java.lang.reflect.RecordComponent;
declare type RecordComponent =
  Packages.java.lang.reflect.RecordComponent;
declare const InputStream = Packages.java.io.InputStream;
declare type InputStream = Packages.java.io.InputStream;
declare const URL = Packages.java.net.URL;
declare type URL = Packages.java.net.URL;
declare const Executable =
  Packages.java.lang.reflect.Executable;
declare type Executable =
  Packages.java.lang.reflect.Executable;
declare const Collection = Packages.java.util.Collection;
declare type Collection = Packages.java.util.Collection;
declare const ConstantPool =
  Packages.jdk.internal.reflect.ConstantPool;
declare type ConstantPool =
  Packages.jdk.internal.reflect.ConstantPool;
declare const Package = Packages.java.lang.Package;
declare type Package = Packages.java.lang.Package;
declare const List = Packages.java.util.List;
declare type List = Packages.java.util.List;
declare const AnnotatedType =
  Packages.java.lang.reflect.AnnotatedType;
declare type AnnotatedType =
  Packages.java.lang.reflect.AnnotatedType;
declare const Class = Packages.java.lang.Class;
declare type Class = Packages.java.lang.Class;
declare const Disposable = Packages.arc.util.Disposable;
declare type Disposable = Packages.arc.util.Disposable;
declare const Enum = Packages.java.lang.Enum;
declare type Enum = Packages.java.lang.Enum;
declare const Comparable = Packages.java.lang.Comparable;
declare type Comparable = Packages.java.lang.Comparable;
declare const ObjectInputStream =
  Packages.java.io.ObjectInputStream;
declare type ObjectInputStream =
  Packages.java.io.ObjectInputStream;
declare const Enum = Packages.java.lang.Enum;
declare type Enum = Packages.java.lang.Enum;
declare const Runnable = Packages.java.lang.Runnable;
declare type Runnable = Packages.java.lang.Runnable;
declare const Iterator = Packages.java.util.Iterator;
declare type Iterator = Packages.java.util.Iterator;
declare const Spliterator = Packages.java.util.Spliterator;
declare type Spliterator = Packages.java.util.Spliterator;
declare const Consumer =
  Packages.java.util._function.Consumer;
declare type Consumer =
  Packages.java.util._function.Consumer;
declare const Iterable = Packages.java.lang.Iterable;
declare type Iterable = Packages.java.lang.Iterable;
declare const Cons = Packages.arc.func.Cons;
declare type Cons = Packages.arc.func.Cons;
declare const Eachable = Packages.arc.util.Eachable;
declare type Eachable = Packages.arc.util.Eachable;
declare const Iterator = Packages.java.util.Iterator;
declare type Iterator = Packages.java.util.Iterator;
declare const Boolf = Packages.arc.func.Boolf;
declare type Boolf = Packages.arc.func.Boolf;
declare const Func = Packages.arc.func.Func;
declare type Func = Packages.arc.func.Func;
declare const Comparator = Packages.java.util.Comparator;
declare type Comparator = Packages.java.util.Comparator;
declare const Floatf = Packages.arc.func.Floatf;
declare type Floatf = Packages.arc.func.Floatf;
declare const ArrayList = Packages.java.util.ArrayList;
declare type ArrayList = Packages.java.util.ArrayList;
declare const Intf = Packages.arc.func.Intf;
declare type Intf = Packages.arc.func.Intf;
declare const Func2 = Packages.arc.func.Func2;
declare type Func2 = Packages.arc.func.Func2;
declare const IntStream =
  Packages.java.util.stream.IntStream;
declare type IntStream =
  Packages.java.util.stream.IntStream;
declare const LongStream =
  Packages.java.util.stream.LongStream;
declare type LongStream =
  Packages.java.util.stream.LongStream;
declare const DoubleStream =
  Packages.java.util.stream.DoubleStream;
declare type DoubleStream =
  Packages.java.util.stream.DoubleStream;
declare const RandomGenerator =
  Packages.java.util.random.RandomGenerator;
declare type RandomGenerator =
  Packages.java.util.random.RandomGenerator;
declare const AtomicLong =
  Packages.java.util.concurrent.atomic.AtomicLong;
declare type AtomicLong =
  Packages.java.util.concurrent.atomic.AtomicLong;
declare const Unsafe = Packages.jdk.internal.misc.Unsafe;
declare type Unsafe = Packages.jdk.internal.misc.Unsafe;
declare const ObjectOutputStream =
  Packages.java.io.ObjectOutputStream;
declare type ObjectOutputStream =
  Packages.java.io.ObjectOutputStream;
declare const Random = Packages.java.util.Random;
declare type Random = Packages.java.util.Random;
declare const Rand = Packages.arc.math.Rand;
declare type Rand = Packages.arc.math.Rand;
declare const Prov = Packages.arc.func.Prov;
declare type Prov = Packages.arc.func.Prov;
declare const Cons2 = Packages.arc.func.Cons2;
declare type Cons2 = Packages.arc.func.Cons2;
declare const RuntimeException =
  Packages.java.lang.RuntimeException;
declare type RuntimeException =
  Packages.java.lang.RuntimeException;
declare const ObjectMap = Packages.arc.struct.ObjectMap;
declare type ObjectMap = Packages.arc.struct.ObjectMap;
declare const ObjectSet = Packages.arc.struct.ObjectSet;
declare type ObjectSet = Packages.arc.struct.ObjectSet;
declare const Intc = Packages.arc.func.Intc;
declare type Intc = Packages.arc.func.Intc;
declare const IntSeq = Packages.arc.struct.IntSeq;
declare type IntSeq = Packages.arc.struct.IntSeq;
declare const Interp = Packages.arc.math.Interp;
declare type Interp = Packages.arc.math.Interp;
declare const Vector = Packages.arc.math.geom.Vector;
declare type Vector = Packages.arc.math.geom.Vector;
declare const Vector = Packages.arc.math.geom.Vector;
declare type Vector = Packages.arc.math.geom.Vector;
declare const Position = Packages.arc.math.geom.Position;
declare type Position = Packages.arc.math.geom.Position;
declare const Affine2 = Packages.arc.math.Affine2;
declare type Affine2 = Packages.arc.math.Affine2;
declare const Mat = Packages.arc.math.Mat;
declare type Mat = Packages.arc.math.Mat;
declare const Vec3 = Packages.arc.math.geom.Vec3;
declare type Vec3 = Packages.arc.math.geom.Vec3;
declare const Vec2 = Packages.arc.math.geom.Vec2;
declare type Vec2 = Packages.arc.math.geom.Vec2;
declare const FloatSeq = Packages.arc.struct.FloatSeq;
declare type FloatSeq = Packages.arc.struct.FloatSeq;
declare const Seq = Packages.arc.struct.Seq;
declare type Seq = Packages.arc.struct.Seq;
declare const File = Packages.java.io.File;
declare type File = Packages.java.io.File;
declare const Enum = Packages.java.lang.Enum;
declare type Enum = Packages.java.lang.Enum;
declare const ByteBuffer = Packages.java.nio.ByteBuffer;
declare type ByteBuffer = Packages.java.nio.ByteBuffer;
declare const FileFilter = Packages.java.io.FileFilter;
declare type FileFilter = Packages.java.io.FileFilter;
declare const FilenameFilter =
  Packages.java.io.FilenameFilter;
declare type FilenameFilter =
  Packages.java.io.FilenameFilter;
declare const OutputStream = Packages.java.io.OutputStream;
declare type OutputStream = Packages.java.io.OutputStream;
declare const BufferedInputStream =
  Packages.java.io.BufferedInputStream;
declare type BufferedInputStream =
  Packages.java.io.BufferedInputStream;
declare const Reader = Packages.java.io.Reader;
declare type Reader = Packages.java.io.Reader;
declare const BufferedReader =
  Packages.java.io.BufferedReader;
declare type BufferedReader =
  Packages.java.io.BufferedReader;
declare const Writer = Packages.java.io.Writer;
declare type Writer = Packages.java.io.Writer;
declare const AutoCloseable =
  Packages.java.lang.AutoCloseable;
declare type AutoCloseable =
  Packages.java.lang.AutoCloseable;
declare const Closeable = Packages.java.io.Closeable;
declare type Closeable = Packages.java.io.Closeable;
declare const DataInput = Packages.java.io.DataInput;
declare type DataInput = Packages.java.io.DataInput;
declare const short = Packages.short;
declare type short = Packages.short;
declare const Reads = Packages.arc.util.io.Reads;
declare type Reads = Packages.arc.util.io.Reads;
declare const DataOutput = Packages.java.io.DataOutput;
declare type DataOutput = Packages.java.io.DataOutput;
declare const Writes = Packages.arc.util.io.Writes;
declare type Writes = Packages.arc.util.io.Writes;
declare const IntIntf = Packages.arc.func.IntIntf;
declare type IntIntf = Packages.arc.func.IntIntf;
declare const StringBuilder =
  Packages.java.lang.StringBuilder;
declare type StringBuilder =
  Packages.java.lang.StringBuilder;
declare const Color = Packages.arc.graphics.Color;
declare type Color = Packages.arc.graphics.Color;
declare const Intc2 = Packages.arc.func.Intc2;
declare type Intc2 = Packages.arc.func.Intc2;
declare const PixmapRegion =
  Packages.arc.graphics.g2d.PixmapRegion;
declare type PixmapRegion =
  Packages.arc.graphics.g2d.PixmapRegion;
declare const Pixmap = Packages.arc.graphics.Pixmap;
declare type Pixmap = Packages.arc.graphics.Pixmap;
declare const ByteArrayInputStream =
  Packages.java.io.ByteArrayInputStream;
declare type ByteArrayInputStream =
  Packages.java.io.ByteArrayInputStream;
declare const Fi = Packages.arc.files.Fi;
declare type Fi = Packages.arc.files.Fi;
declare const ApplicationListener =
  Packages.arc.ApplicationListener;
declare type ApplicationListener =
  Packages.arc.ApplicationListener;
declare const InetSocketAddress =
  Packages.java.net.InetSocketAddress;
declare type InetSocketAddress =
  Packages.java.net.InetSocketAddress;
declare const Application = Packages.arc.Application;
declare type Application = Packages.arc.Application;
declare const ApplicationCore =
  Packages.arc.ApplicationCore;
declare type ApplicationCore = Packages.arc.ApplicationCore;
declare const Buffer = Packages.java.nio.Buffer;
declare type Buffer = Packages.java.nio.Buffer;
declare const IntBuffer = Packages.java.nio.IntBuffer;
declare type IntBuffer = Packages.java.nio.IntBuffer;
declare const FloatBuffer = Packages.java.nio.FloatBuffer;
declare type FloatBuffer = Packages.java.nio.FloatBuffer;
declare const GL20 = Packages.arc.graphics.GL20;
declare type GL20 = Packages.arc.graphics.GL20;
declare const LongBuffer = Packages.java.nio.LongBuffer;
declare type LongBuffer = Packages.java.nio.LongBuffer;
declare const GL30 = Packages.arc.graphics.GL30;
declare type GL30 = Packages.arc.graphics.GL30;
declare const GLVersion =
  Packages.arc.graphics.gl.GLVersion;
declare type GLVersion = Packages.arc.graphics.gl.GLVersion;
declare const Graphics = Packages.arc.Graphics;
declare type Graphics = Packages.arc.Graphics;
declare const AudioFilter = Packages.arc.audio.AudioFilter;
declare type AudioFilter = Packages.arc.audio.AudioFilter;
declare const AudioSource = Packages.arc.audio.AudioSource;
declare type AudioSource = Packages.arc.audio.AudioSource;
declare const AudioBus = Packages.arc.audio.AudioBus;
declare type AudioBus = Packages.arc.audio.AudioBus;
declare const Sound = Packages.arc.audio.Sound;
declare type Sound = Packages.arc.audio.Sound;
declare const Music = Packages.arc.audio.Music;
declare type Music = Packages.arc.audio.Music;
declare const Audio = Packages.arc.audio.Audio;
declare type Audio = Packages.arc.audio.Audio;
declare const KeyCode = Packages.arc.input.KeyCode;
declare type KeyCode = Packages.arc.input.KeyCode;
declare const InputDevice = Packages.arc.input.InputDevice;
declare type InputDevice = Packages.arc.input.InputDevice;
declare const InputProcessor =
  Packages.arc.input.InputProcessor;
declare type InputProcessor =
  Packages.arc.input.InputProcessor;
declare const IntSet = Packages.arc.struct.IntSet;
declare type IntSet = Packages.arc.struct.IntSet;
declare const IntFloatMap = Packages.arc.struct.IntFloatMap;
declare type IntFloatMap = Packages.arc.struct.IntFloatMap;
declare const KeyboardDevice =
  Packages.arc.input.KeyboardDevice;
declare type KeyboardDevice =
  Packages.arc.input.KeyboardDevice;
declare const SnapshotSeq = Packages.arc.struct.SnapshotSeq;
declare type SnapshotSeq = Packages.arc.struct.SnapshotSeq;
declare const InputMultiplexer =
  Packages.arc.input.InputMultiplexer;
declare type InputMultiplexer =
  Packages.arc.input.InputMultiplexer;
declare const Input = Packages.arc.Input;
declare type Input = Packages.arc.Input;
declare const Files = Packages.arc.Files;
declare type Files = Packages.arc.Files;
declare const HashMap = Packages.java.util.HashMap;
declare type HashMap = Packages.java.util.HashMap;
declare const Throwable = Packages.java.lang.Throwable;
declare type Throwable = Packages.java.lang.Throwable;
declare const ExecutorService =
  Packages.java.util.concurrent.ExecutorService;
declare type ExecutorService =
  Packages.java.util.concurrent.ExecutorService;
declare const ByteArrayOutputStream =
  Packages.java.io.ByteArrayOutputStream;
declare type ByteArrayOutputStream =
  Packages.java.io.ByteArrayOutputStream;
declare const ReusableByteInStream =
  Packages.arc.util.io.ReusableByteInStream;
declare type ReusableByteInStream =
  Packages.arc.util.io.ReusableByteInStream;
declare const Pattern = Packages.java.util.regex.Pattern;
declare type Pattern = Packages.java.util.regex.Pattern;
declare const JsonValue =
  Packages.arc.util.serialization.JsonValue;
declare type JsonValue =
  Packages.arc.util.serialization.JsonValue;
declare const BaseJsonReader =
  Packages.arc.util.serialization.BaseJsonReader;
declare type BaseJsonReader =
  Packages.arc.util.serialization.BaseJsonReader;
declare const DataInputStream =
  Packages.java.io.DataInputStream;
declare type DataInputStream =
  Packages.java.io.DataInputStream;
declare const UBJsonReader =
  Packages.arc.util.serialization.UBJsonReader;
declare type UBJsonReader =
  Packages.arc.util.serialization.UBJsonReader;
declare const OrderedMap = Packages.arc.struct.OrderedMap;
declare type OrderedMap = Packages.arc.struct.OrderedMap;
declare const BaseJsonWriter =
  Packages.arc.util.serialization.BaseJsonWriter;
declare type BaseJsonWriter =
  Packages.arc.util.serialization.BaseJsonWriter;
declare const Json = Packages.arc.util.serialization.Json;
declare type Json = Packages.arc.util.serialization.Json;
declare const Long = Packages.java.lang.Long;
declare type Long = Packages.java.lang.Long;
declare const Settings = Packages.arc.Settings;
declare type Settings = Packages.arc.Settings;
declare const KeyBinds = Packages.arc.KeyBinds;
declare type KeyBinds = Packages.arc.KeyBinds;
declare const Locale = Packages.java.util.Locale;
declare type Locale = Packages.java.util.Locale;
declare const MessageFormat =
  Packages.java.text.MessageFormat;
declare type MessageFormat =
  Packages.java.text.MessageFormat;
declare const TextFormatter =
  Packages.arc.util.TextFormatter;
declare type TextFormatter =
  Packages.arc.util.TextFormatter;
declare const I18NBundle = Packages.arc.util.I18NBundle;
declare type I18NBundle = Packages.arc.util.I18NBundle;
declare const Shape2D = Packages.arc.math.geom.Shape2D;
declare type Shape2D = Packages.arc.math.geom.Shape2D;
declare const Circle = Packages.arc.math.geom.Circle;
declare type Circle = Packages.arc.math.geom.Circle;
declare const Rect = Packages.arc.math.geom.Rect;
declare type Rect = Packages.arc.math.geom.Rect;
declare const Camera = Packages.arc.graphics.Camera;
declare type Camera = Packages.arc.graphics.Camera;
declare const TextureData =
  Packages.arc.graphics.TextureData;
declare type TextureData =
  Packages.arc.graphics.TextureData;
declare const GLTexture = Packages.arc.graphics.GLTexture;
declare type GLTexture = Packages.arc.graphics.GLTexture;
declare const Texture = Packages.arc.graphics.Texture;
declare type Texture = Packages.arc.graphics.Texture;
declare const Blending = Packages.arc.graphics.Blending;
declare type Blending = Packages.arc.graphics.Blending;
declare const ObjectIntMap =
  Packages.arc.struct.ObjectIntMap;
declare type ObjectIntMap =
  Packages.arc.struct.ObjectIntMap;
declare const Shader = Packages.arc.graphics.gl.Shader;
declare type Shader = Packages.arc.graphics.gl.Shader;
declare const TextureRegion =
  Packages.arc.graphics.g2d.TextureRegion;
declare type TextureRegion =
  Packages.arc.graphics.g2d.TextureRegion;
declare const Batch = Packages.arc.graphics.g2d.Batch;
declare type Batch = Packages.arc.graphics.g2d.Batch;
declare const Touchable =
  Packages.arc.scene.event.Touchable;
declare type Touchable = Packages.arc.scene.event.Touchable;
declare const Cullable = Packages.arc.scene.utils.Cullable;
declare type Cullable = Packages.arc.scene.utils.Cullable;
declare const Drawable = Packages.arc.scene.style.Drawable;
declare type Drawable = Packages.arc.scene.style.Drawable;
declare const WidgetGroup =
  Packages.arc.scene.ui.layout.WidgetGroup;
declare type WidgetGroup =
  Packages.arc.scene.ui.layout.WidgetGroup;
declare const Pool = Packages.arc.util.pooling.Pool;
declare type Pool = Packages.arc.util.pooling.Pool;
declare const Disableable =
  Packages.arc.scene.utils.Disableable;
declare type Disableable =
  Packages.arc.scene.utils.Disableable;
declare const Style = Packages.arc.scene.style.Style;
declare type Style = Packages.arc.scene.style.Style;
declare const ButtonGroup =
  Packages.arc.scene.ui.ButtonGroup;
declare type ButtonGroup =
  Packages.arc.scene.ui.ButtonGroup;
declare const Boolp = Packages.arc.func.Boolp;
declare type Boolp = Packages.arc.func.Boolp;
declare const InputEvent =
  Packages.arc.scene.event.InputEvent;
declare type InputEvent =
  Packages.arc.scene.event.InputEvent;
declare const InputListener =
  Packages.arc.scene.event.InputListener;
declare type InputListener =
  Packages.arc.scene.event.InputListener;
declare const ClickListener =
  Packages.arc.scene.event.ClickListener;
declare type ClickListener =
  Packages.arc.scene.event.ClickListener;
declare const Button = Packages.arc.scene.ui.Button;
declare type Button = Packages.arc.scene.ui.Button;
declare const Scaling = Packages.arc.util.Scaling;
declare type Scaling = Packages.arc.util.Scaling;
declare const Cell = Packages.arc.scene.ui.layout.Cell;
declare type Cell = Packages.arc.scene.ui.layout.Cell;
declare const CharSequence =
  Packages.java.lang.CharSequence;
declare type CharSequence = Packages.java.lang.CharSequence;
declare const GlyphLayout =
  Packages.arc.graphics.g2d.GlyphLayout;
declare type GlyphLayout =
  Packages.arc.graphics.g2d.GlyphLayout;
declare const FontCache =
  Packages.arc.graphics.g2d.FontCache;
declare type FontCache =
  Packages.arc.graphics.g2d.FontCache;
declare const Font = Packages.arc.graphics.g2d.Font;
declare type Font = Packages.arc.graphics.g2d.Font;
declare const Label = Packages.arc.scene.ui.Label;
declare type Label = Packages.arc.scene.ui.Label;
declare const Timer = Packages.arc.util.Timer;
declare type Timer = Packages.arc.util.Timer;
declare const TextField = Packages.arc.scene.ui.TextField;
declare type TextField = Packages.arc.scene.ui.TextField;
declare const Stack = Packages.arc.scene.ui.layout.Stack;
declare type Stack = Packages.arc.scene.ui.layout.Stack;
declare const TextButton = Packages.arc.scene.ui.TextButton;
declare type TextButton = Packages.arc.scene.ui.TextButton;
declare const NinePatch =
  Packages.arc.graphics.g2d.NinePatch;
declare type NinePatch =
  Packages.arc.graphics.g2d.NinePatch;
declare const Image = Packages.arc.scene.ui.Image;
declare type Image = Packages.arc.scene.ui.Image;
declare const CheckBox = Packages.arc.scene.ui.CheckBox;
declare type CheckBox = Packages.arc.scene.ui.CheckBox;
declare const Boolc = Packages.arc.func.Boolc;
declare type Boolc = Packages.arc.func.Boolc;
declare const ImageButton =
  Packages.arc.scene.ui.ImageButton;
declare type ImageButton =
  Packages.arc.scene.ui.ImageButton;
declare const TextArea = Packages.arc.scene.ui.TextArea;
declare type TextArea = Packages.arc.scene.ui.TextArea;
declare const Action = Packages.arc.scene.Action;
declare type Action = Packages.arc.scene.Action;
declare const Collapser =
  Packages.arc.scene.ui.layout.Collapser;
declare type Collapser =
  Packages.arc.scene.ui.layout.Collapser;
declare const GestureDetector =
  Packages.arc.input.GestureDetector;
declare type GestureDetector =
  Packages.arc.input.GestureDetector;
declare const ElementGestureListener =
  Packages.arc.scene.event.ElementGestureListener;
declare type ElementGestureListener =
  Packages.arc.scene.event.ElementGestureListener;
declare const ScrollPane = Packages.arc.scene.ui.ScrollPane;
declare type ScrollPane = Packages.arc.scene.ui.ScrollPane;
declare const ProgressBar =
  Packages.arc.scene.ui.ProgressBar;
declare type ProgressBar =
  Packages.arc.scene.ui.ProgressBar;
declare const Floatc = Packages.arc.func.Floatc;
declare type Floatc = Packages.arc.func.Floatc;
declare const Slider = Packages.arc.scene.ui.Slider;
declare type Slider = Packages.arc.scene.ui.Slider;
declare const Table = Packages.arc.scene.ui.layout.Table;
declare type Table = Packages.arc.scene.ui.layout.Table;
declare const Group = Packages.arc.scene.Group;
declare type Group = Packages.arc.scene.Group;
declare const DelayedRemovalSeq =
  Packages.arc.struct.DelayedRemovalSeq;
declare type DelayedRemovalSeq =
  Packages.arc.struct.DelayedRemovalSeq;
declare const Floatc2 = Packages.arc.func.Floatc2;
declare type Floatc2 = Packages.arc.func.Floatc2;
declare const Element = Packages.arc.scene.Element;
declare type Element = Packages.arc.scene.Element;
declare const SceneEvent =
  Packages.arc.scene.event.SceneEvent;
declare type SceneEvent =
  Packages.arc.scene.event.SceneEvent;
declare const EventListener =
  Packages.arc.scene.event.EventListener;
declare type EventListener =
  Packages.arc.scene.event.EventListener;
declare const Viewport =
  Packages.arc.util.viewport.Viewport;
declare type Viewport = Packages.arc.util.viewport.Viewport;
declare const FocusListener =
  Packages.arc.scene.event.FocusListener;
declare type FocusListener =
  Packages.arc.scene.event.FocusListener;
declare const Dialog = Packages.arc.scene.ui.Dialog;
declare type Dialog = Packages.arc.scene.ui.Dialog;
declare const Scene = Packages.arc.scene.Scene;
declare type Scene = Packages.arc.scene.Scene;
declare const AssetLoaderParameters =
  Packages.arc.assets.AssetLoaderParameters;
declare type AssetLoaderParameters =
  Packages.arc.assets.AssetLoaderParameters;
declare const FileHandleResolver =
  Packages.arc.assets.loaders.FileHandleResolver;
declare type FileHandleResolver =
  Packages.arc.assets.loaders.FileHandleResolver;
declare const AssetDescriptor =
  Packages.arc.assets.AssetDescriptor;
declare type AssetDescriptor =
  Packages.arc.assets.AssetDescriptor;
declare const AssetLoader =
  Packages.arc.assets.loaders.AssetLoader;
declare type AssetLoader =
  Packages.arc.assets.loaders.AssetLoader;
declare const Callable =
  Packages.java.util.concurrent.Callable;
declare type Callable =
  Packages.java.util.concurrent.Callable;
declare const Future = Packages.java.util.concurrent.Future;
declare type Future = Packages.java.util.concurrent.Future;
declare const AssetLoadingTask =
  Packages.arc.assets.AssetLoadingTask;
declare type AssetLoadingTask =
  Packages.arc.assets.AssetLoadingTask;
declare const AssetErrorListener =
  Packages.arc.assets.AssetErrorListener;
declare type AssetErrorListener =
  Packages.arc.assets.AssetErrorListener;
declare const Loadable = Packages.arc.assets.Loadable;
declare type Loadable = Packages.arc.assets.Loadable;
declare const AssetManager =
  Packages.arc.assets.AssetManager;
declare type AssetManager =
  Packages.arc.assets.AssetManager;
declare const TextureAtlas =
  Packages.arc.graphics.g2d.TextureAtlas;
declare type TextureAtlas =
  Packages.arc.graphics.g2d.TextureAtlas;
declare const Core = Packages.arc.Core;
declare type Core = Packages.arc.Core;
declare const Events = Packages.arc.Events;
declare type Events = Packages.arc.Events;
declare const Filters = Packages.arc.audio.Filters;
declare type Filters = Packages.arc.audio.Filters;
declare const Soloud = Packages.arc.audio.Soloud;
declare type Soloud = Packages.arc.audio.Soloud;
declare const ZipEntry = Packages.java.util.zip.ZipEntry;
declare type ZipEntry = Packages.java.util.zip.ZipEntry;
declare const ZipFile = Packages.java.util.zip.ZipFile;
declare type ZipFile = Packages.java.util.zip.ZipFile;
declare const ZipFi = Packages.arc.files.ZipFi;
declare type ZipFi = Packages.arc.files.ZipFi;
declare const ObjectFloatMap =
  Packages.arc.struct.ObjectFloatMap;
declare type ObjectFloatMap =
  Packages.arc.struct.ObjectFloatMap;
declare const FListener = Packages.arc.flabel.FListener;
declare type FListener = Packages.arc.flabel.FListener;
declare const FGlyph = Packages.arc.flabel.FGlyph;
declare type FGlyph = Packages.arc.flabel.FGlyph;
declare const FLabel = Packages.arc.flabel.FLabel;
declare type FLabel = Packages.arc.flabel.FLabel;
declare const FEffect = Packages.arc.flabel.FEffect;
declare type FEffect = Packages.arc.flabel.FEffect;
declare const FConfig = Packages.arc.flabel.FConfig;
declare type FConfig = Packages.arc.flabel.FConfig;
declare const LongSeq = Packages.arc.struct.LongSeq;
declare type LongSeq = Packages.arc.struct.LongSeq;
declare const LongMap = Packages.arc.struct.LongMap;
declare type LongMap = Packages.arc.struct.LongMap;
declare const FreeType = Packages.arc.freetype.FreeType;
declare type FreeType = Packages.arc.freetype.FreeType;
declare const PixmapPacker =
  Packages.arc.graphics.g2d.PixmapPacker;
declare type PixmapPacker =
  Packages.arc.graphics.g2d.PixmapPacker;
declare const FreeTypeFontGenerator =
  Packages.arc.freetype.FreeTypeFontGenerator;
declare type FreeTypeFontGenerator =
  Packages.arc.freetype.FreeTypeFontGenerator;
declare const SynchronousAssetLoader =
  Packages.arc.assets.loaders.SynchronousAssetLoader;
declare type SynchronousAssetLoader =
  Packages.arc.assets.loaders.SynchronousAssetLoader;
declare const FreeTypeFontGeneratorLoader =
  Packages.arc.freetype.FreeTypeFontGeneratorLoader;
declare type FreeTypeFontGeneratorLoader =
  Packages.arc.freetype.FreeTypeFontGeneratorLoader;
declare const AsynchronousAssetLoader =
  Packages.arc.assets.loaders.AsynchronousAssetLoader;
declare type AsynchronousAssetLoader =
  Packages.arc.assets.loaders.AsynchronousAssetLoader;
declare const FreetypeFontLoader =
  Packages.arc.freetype.FreetypeFontLoader;
declare type FreetypeFontLoader =
  Packages.arc.freetype.FreetypeFontLoader;
declare const Boolf2 = Packages.arc.func.Boolf2;
declare type Boolf2 = Packages.arc.func.Boolf2;
declare const Boolf3 = Packages.arc.func.Boolf3;
declare type Boolf3 = Packages.arc.func.Boolf3;
declare const Cons3 = Packages.arc.func.Cons3;
declare type Cons3 = Packages.arc.func.Cons3;
declare const Cons4 = Packages.arc.func.Cons4;
declare type Cons4 = Packages.arc.func.Cons4;
declare const ConsT = Packages.arc.func.ConsT;
declare type ConsT = Packages.arc.func.ConsT;
declare const FloatFloatf = Packages.arc.func.FloatFloatf;
declare type FloatFloatf = Packages.arc.func.FloatFloatf;
declare const Floatc4 = Packages.arc.func.Floatc4;
declare type Floatc4 = Packages.arc.func.Floatc4;
declare const Floatp = Packages.arc.func.Floatp;
declare type Floatp = Packages.arc.func.Floatp;
declare const Func3 = Packages.arc.func.Func3;
declare type Func3 = Packages.arc.func.Func3;
declare const Intc4 = Packages.arc.func.Intc4;
declare type Intc4 = Packages.arc.func.Intc4;
declare const Intp = Packages.arc.func.Intp;
declare type Intp = Packages.arc.func.Intp;
declare const Longf = Packages.arc.func.Longf;
declare type Longf = Packages.arc.func.Longf;
declare const CubemapData =
  Packages.arc.graphics.CubemapData;
declare type CubemapData =
  Packages.arc.graphics.CubemapData;
declare const Cubemap = Packages.arc.graphics.Cubemap;
declare type Cubemap = Packages.arc.graphics.Cubemap;
declare const FrameBufferCubemap =
  Packages.arc.graphics.gl.FrameBufferCubemap;
declare type FrameBufferCubemap =
  Packages.arc.graphics.gl.FrameBufferCubemap;
declare const FloatFrameBuffer =
  Packages.arc.graphics.gl.FloatFrameBuffer;
declare type FloatFrameBuffer =
  Packages.arc.graphics.gl.FloatFrameBuffer;
declare const GLFrameBuffer =
  Packages.arc.graphics.gl.GLFrameBuffer;
declare type GLFrameBuffer =
  Packages.arc.graphics.gl.GLFrameBuffer;
declare const FrameBuffer =
  Packages.arc.graphics.gl.FrameBuffer;
declare type FrameBuffer =
  Packages.arc.graphics.gl.FrameBuffer;
declare const FxFilter = Packages.arc.fx.FxFilter;
declare type FxFilter = Packages.arc.fx.FxFilter;
declare const FxBufferRenderer =
  Packages.arc.fx.util.FxBufferRenderer;
declare type FxBufferRenderer =
  Packages.arc.fx.util.FxBufferRenderer;
declare const PingPongBuffer =
  Packages.arc.fx.util.PingPongBuffer;
declare type PingPongBuffer =
  Packages.arc.fx.util.PingPongBuffer;
declare const FxProcessor = Packages.arc.fx.FxProcessor;
declare type FxProcessor = Packages.arc.fx.FxProcessor;
declare const Colors = Packages.arc.graphics.Colors;
declare type Colors = Packages.arc.graphics.Colors;
declare const Bits = Packages.arc.struct.Bits;
declare type Bits = Packages.arc.struct.Bits;
declare const Gl = Packages.arc.graphics.Gl;
declare type Gl = Packages.arc.graphics.Gl;
declare const VertexAttribute =
  Packages.arc.graphics.VertexAttribute;
declare type VertexAttribute =
  Packages.arc.graphics.VertexAttribute;
declare const ShortBuffer = Packages.java.nio.ShortBuffer;
declare type ShortBuffer = Packages.java.nio.ShortBuffer;
declare const IndexData =
  Packages.arc.graphics.gl.IndexData;
declare type IndexData = Packages.arc.graphics.gl.IndexData;
declare const VertexData =
  Packages.arc.graphics.gl.VertexData;
declare type VertexData =
  Packages.arc.graphics.gl.VertexData;
declare const Mesh = Packages.arc.graphics.Mesh;
declare type Mesh = Packages.arc.graphics.Mesh;
declare const FilterOutputStream =
  Packages.java.io.FilterOutputStream;
declare type FilterOutputStream =
  Packages.java.io.FilterOutputStream;
declare const DataOutputStream =
  Packages.java.io.DataOutputStream;
declare type DataOutputStream =
  Packages.java.io.DataOutputStream;
declare const CRC32 = Packages.java.util.zip.CRC32;
declare type CRC32 = Packages.java.util.zip.CRC32;
declare const Deflater = Packages.java.util.zip.Deflater;
declare type Deflater = Packages.java.util.zip.Deflater;
declare const PixmapIO = Packages.arc.graphics.PixmapIO;
declare type PixmapIO = Packages.arc.graphics.PixmapIO;
declare const Pixmaps = Packages.arc.graphics.Pixmaps;
declare type Pixmaps = Packages.arc.graphics.Pixmaps;
declare const TextureArrayData =
  Packages.arc.graphics.TextureArrayData;
declare type TextureArrayData =
  Packages.arc.graphics.TextureArrayData;
declare const TextureArray =
  Packages.arc.graphics.TextureArray;
declare type TextureArray =
  Packages.arc.graphics.TextureArray;
declare const Controller = Packages.arc.input.Controller;
declare type Controller = Packages.arc.input.Controller;
declare const InputEventQueue =
  Packages.arc.input.InputEventQueue;
declare type InputEventQueue =
  Packages.arc.input.InputEventQueue;
declare const Angles = Packages.arc.math.Angles;
declare type Angles = Packages.arc.math.Angles;
declare const CumulativeDistribution =
  Packages.arc.math.CumulativeDistribution;
declare type CumulativeDistribution =
  Packages.arc.math.CumulativeDistribution;
declare const ShortSeq = Packages.arc.struct.ShortSeq;
declare type ShortSeq = Packages.arc.struct.ShortSeq;
declare const BoolSeq = Packages.arc.struct.BoolSeq;
declare type BoolSeq = Packages.arc.struct.BoolSeq;
declare const DelaunayTriangulator =
  Packages.arc.math.DelaunayTriangulator;
declare type DelaunayTriangulator =
  Packages.arc.math.DelaunayTriangulator;
declare const EarClippingTriangulator =
  Packages.arc.math.EarClippingTriangulator;
declare type EarClippingTriangulator =
  Packages.arc.math.EarClippingTriangulator;
declare const Extrapolator = Packages.arc.math.Extrapolator;
declare type Extrapolator = Packages.arc.math.Extrapolator;
declare const WindowedMean = Packages.arc.math.WindowedMean;
declare type WindowedMean = Packages.arc.math.WindowedMean;
declare const FloatCounter = Packages.arc.math.FloatCounter;
declare type FloatCounter = Packages.arc.math.FloatCounter;
declare const LinearRegression =
  Packages.arc.math.LinearRegression;
declare type LinearRegression =
  Packages.arc.math.LinearRegression;
declare const Mathf = Packages.arc.math.Mathf;
declare type Mathf = Packages.arc.math.Mathf;
declare const Scaled = Packages.arc.math.Scaled;
declare type Scaled = Packages.arc.math.Scaled;
declare const MockApplication =
  Packages.arc.mock.MockApplication;
declare type MockApplication =
  Packages.arc.mock.MockApplication;
declare const MockAudio = Packages.arc.mock.MockAudio;
declare type MockAudio = Packages.arc.mock.MockAudio;
declare const MockFiles = Packages.arc.mock.MockFiles;
declare type MockFiles = Packages.arc.mock.MockFiles;
declare const MockGL20 = Packages.arc.mock.MockGL20;
declare type MockGL20 = Packages.arc.mock.MockGL20;
declare const MockGraphics = Packages.arc.mock.MockGraphics;
declare type MockGraphics = Packages.arc.mock.MockGraphics;
declare const MockInput = Packages.arc.mock.MockInput;
declare type MockInput = Packages.arc.mock.MockInput;
declare const MockSettings = Packages.arc.mock.MockSettings;
declare type MockSettings = Packages.arc.mock.MockSettings;
declare const ArcNet = Packages.arc.net.ArcNet;
declare type ArcNet = Packages.arc.net.ArcNet;
declare const ArcNetException =
  Packages.arc.net.ArcNetException;
declare type ArcNetException =
  Packages.arc.net.ArcNetException;
declare const DcReason = Packages.arc.net.DcReason;
declare type DcReason = Packages.arc.net.DcReason;
declare const ScheduledExecutorService =
  Packages.java.util.concurrent.ScheduledExecutorService;
declare type ScheduledExecutorService =
  Packages.java.util.concurrent.ScheduledExecutorService;
declare const LinkedList = Packages.java.util.LinkedList;
declare type LinkedList = Packages.java.util.LinkedList;
declare const NetListener = Packages.arc.net.NetListener;
declare type NetListener = Packages.arc.net.NetListener;
declare const Thread = Packages.java.lang.Thread;
declare type Thread = Packages.java.lang.Thread;
declare const EndPoint = Packages.arc.net.EndPoint;
declare type EndPoint = Packages.arc.net.EndPoint;
declare const SocketChannel =
  Packages.java.nio.channels.SocketChannel;
declare type SocketChannel =
  Packages.java.nio.channels.SocketChannel;
declare const NetSerializer =
  Packages.arc.net.NetSerializer;
declare type NetSerializer = Packages.arc.net.NetSerializer;
declare const SelectionKey =
  Packages.java.nio.channels.SelectionKey;
declare type SelectionKey =
  Packages.java.nio.channels.SelectionKey;
declare const Selector =
  Packages.java.nio.channels.Selector;
declare type Selector = Packages.java.nio.channels.Selector;
declare const SocketAddress =
  Packages.java.net.SocketAddress;
declare type SocketAddress =
  Packages.java.net.SocketAddress;
declare const TcpConnection =
  Packages.arc.net.TcpConnection;
declare type TcpConnection = Packages.arc.net.TcpConnection;
declare const DatagramChannel =
  Packages.java.nio.channels.DatagramChannel;
declare type DatagramChannel =
  Packages.java.nio.channels.DatagramChannel;
declare const UdpConnection =
  Packages.arc.net.UdpConnection;
declare type UdpConnection = Packages.arc.net.UdpConnection;
declare const Connection = Packages.arc.net.Connection;
declare type Connection = Packages.arc.net.Connection;
declare const InetAddress = Packages.java.net.InetAddress;
declare type InetAddress = Packages.java.net.InetAddress;
declare const DatagramPacket =
  Packages.java.net.DatagramPacket;
declare type DatagramPacket =
  Packages.java.net.DatagramPacket;
declare const DatagramSocket =
  Packages.java.net.DatagramSocket;
declare type DatagramSocket =
  Packages.java.net.DatagramSocket;
declare const Client = Packages.arc.net.Client;
declare type Client = Packages.arc.net.Client;
declare const ClientDiscoveryHandler =
  Packages.arc.net.ClientDiscoveryHandler;
declare type ClientDiscoveryHandler =
  Packages.arc.net.ClientDiscoveryHandler;
declare const FrameworkMessage =
  Packages.arc.net.FrameworkMessage;
declare type FrameworkMessage =
  Packages.arc.net.FrameworkMessage;
declare const TcpIdleSender =
  Packages.arc.net.TcpIdleSender;
declare type TcpIdleSender = Packages.arc.net.TcpIdleSender;
declare const InputStreamSender =
  Packages.arc.net.InputStreamSender;
declare type InputStreamSender =
  Packages.arc.net.InputStreamSender;
declare const MulticastSocket =
  Packages.java.net.MulticastSocket;
declare type MulticastSocket =
  Packages.java.net.MulticastSocket;
declare const ServerSocketChannel =
  Packages.java.nio.channels.ServerSocketChannel;
declare type ServerSocketChannel =
  Packages.java.nio.channels.ServerSocketChannel;
declare const IntMap = Packages.arc.struct.IntMap;
declare type IntMap = Packages.arc.struct.IntMap;
declare const ServerDiscoveryHandler =
  Packages.arc.net.ServerDiscoveryHandler;
declare type ServerDiscoveryHandler =
  Packages.arc.net.ServerDiscoveryHandler;
declare const Server = Packages.arc.net.Server;
declare type Server = Packages.arc.net.Server;
declare const ArrayMap = Packages.arc.struct.ArrayMap;
declare type ArrayMap = Packages.arc.struct.ArrayMap;
declare const BinaryHeap = Packages.arc.struct.BinaryHeap;
declare type BinaryHeap = Packages.arc.struct.BinaryHeap;
declare const ByteSeq = Packages.arc.struct.ByteSeq;
declare type ByteSeq = Packages.arc.struct.ByteSeq;
declare const EnumSet = Packages.arc.struct.EnumSet;
declare type EnumSet = Packages.arc.struct.EnumSet;
declare const GridBits = Packages.arc.struct.GridBits;
declare type GridBits = Packages.arc.struct.GridBits;
declare const GridMap = Packages.arc.struct.GridMap;
declare type GridMap = Packages.arc.struct.GridMap;
declare const IntIntMap = Packages.arc.struct.IntIntMap;
declare type IntIntMap = Packages.arc.struct.IntIntMap;
declare const IntQueue = Packages.arc.struct.IntQueue;
declare type IntQueue = Packages.arc.struct.IntQueue;
declare const LongQueue = Packages.arc.struct.LongQueue;
declare type LongQueue = Packages.arc.struct.LongQueue;
declare const OrderedSet = Packages.arc.struct.OrderedSet;
declare type OrderedSet = Packages.arc.struct.OrderedSet;
declare const PQueue = Packages.arc.struct.PQueue;
declare type PQueue = Packages.arc.struct.PQueue;
declare const Queue = Packages.arc.struct.Queue;
declare type Queue = Packages.arc.struct.Queue;
declare const ThreadLocal = Packages.java.lang.ThreadLocal;
declare type ThreadLocal = Packages.java.lang.ThreadLocal;
declare const TimSort = Packages.arc.struct.TimSort;
declare type TimSort = Packages.arc.struct.TimSort;
declare const ComparableTimSort =
  Packages.arc.struct.ComparableTimSort;
declare type ComparableTimSort =
  Packages.arc.struct.ComparableTimSort;
declare const Sort = Packages.arc.struct.Sort;
declare type Sort = Packages.arc.struct.Sort;
declare const StringMap = Packages.arc.struct.StringMap;
declare type StringMap = Packages.arc.struct.StringMap;
declare const Align = Packages.arc.util.Align;
declare type Align = Packages.arc.util.Align;
declare const ArcNativesLoader =
  Packages.arc.util.ArcNativesLoader;
declare type ArcNativesLoader =
  Packages.arc.util.ArcNativesLoader;
declare const ArcRuntimeException =
  Packages.arc.util.ArcRuntimeException;
declare type ArcRuntimeException =
  Packages.arc.util.ArcRuntimeException;
declare const Bench = Packages.arc.util.Bench;
declare type Bench = Packages.arc.util.Bench;
declare const Buffers = Packages.arc.util.Buffers;
declare type Buffers = Packages.arc.util.Buffers;
declare const ColorCodes = Packages.arc.util.ColorCodes;
declare type ColorCodes = Packages.arc.util.ColorCodes;
declare const CommandHandler =
  Packages.arc.util.CommandHandler;
declare type CommandHandler =
  Packages.arc.util.CommandHandler;
declare const HttpURLConnection =
  Packages.java.net.HttpURLConnection;
declare type HttpURLConnection =
  Packages.java.net.HttpURLConnection;
declare const Exception = Packages.java.lang.Exception;
declare type Exception = Packages.java.lang.Exception;
declare const Http = Packages.arc.util.Http;
declare type Http = Packages.arc.util.Http;
declare const Interval = Packages.arc.util.Interval;
declare type Interval = Packages.arc.util.Interval;
declare const Log = Packages.arc.util.Log;
declare type Log = Packages.arc.util.Log;
declare const Nullable = Packages.arc.util.Nullable;
declare type Nullable = Packages.arc.util.Nullable;
declare const OS = Packages.arc.util.OS;
declare type OS = Packages.arc.util.OS;
declare const Pack = Packages.arc.util.Pack;
declare type Pack = Packages.arc.util.Pack;
declare const PerformanceCounter =
  Packages.arc.util.PerformanceCounter;
declare type PerformanceCounter =
  Packages.arc.util.PerformanceCounter;
declare const PerformanceCounters =
  Packages.arc.util.PerformanceCounters;
declare type PerformanceCounters =
  Packages.arc.util.PerformanceCounters;
declare const QuickSelect = Packages.arc.util.QuickSelect;
declare type QuickSelect = Packages.arc.util.QuickSelect;
declare const Ratekeeper = Packages.arc.util.Ratekeeper;
declare type Ratekeeper = Packages.arc.util.Ratekeeper;
declare const Reflect = Packages.arc.util.Reflect;
declare type Reflect = Packages.arc.util.Reflect;
declare const ScreenRecorder =
  Packages.arc.util.ScreenRecorder;
declare type ScreenRecorder =
  Packages.arc.util.ScreenRecorder;
declare const ScreenUtils = Packages.arc.util.ScreenUtils;
declare type ScreenUtils = Packages.arc.util.ScreenUtils;
declare const Select = Packages.arc.util.Select;
declare type Select = Packages.arc.util.Select;
declare const HashSet = Packages.java.util.HashSet;
declare type HashSet = Packages.java.util.HashSet;
declare const SharedLibraryLoader =
  Packages.arc.util.SharedLibraryLoader;
declare type SharedLibraryLoader =
  Packages.arc.util.SharedLibraryLoader;
declare const Charset = Packages.java.nio.charset.Charset;
declare type Charset = Packages.java.nio.charset.Charset;
declare const Strings = Packages.arc.util.Strings;
declare type Strings = Packages.arc.util.Strings;
declare const Structs = Packages.arc.util.Structs;
declare type Structs = Packages.arc.util.Structs;
declare const TaskQueue = Packages.arc.util.TaskQueue;
declare type TaskQueue = Packages.arc.util.TaskQueue;
declare const Threads = Packages.arc.util.Threads;
declare type Threads = Packages.arc.util.Threads;
declare const Time = Packages.arc.util.Time;
declare type Time = Packages.arc.util.Time;
declare const Timekeeper = Packages.arc.util.Timekeeper;
declare type Timekeeper = Packages.arc.util.Timekeeper;
declare const Point2 = Packages.arc.math.geom.Point2;
declare type Point2 = Packages.arc.math.geom.Point2;
declare const Path = Packages.arc.math.geom.Path;
declare type Path = Packages.arc.math.geom.Path;
declare const Bezier = Packages.arc.math.geom.Bezier;
declare type Bezier = Packages.arc.math.geom.Bezier;
declare const Tmp = Packages.arc.util.Tmp;
declare type Tmp = Packages.arc.util.Tmp;
declare const UnsafeRunnable =
  Packages.arc.util.UnsafeRunnable;
declare type UnsafeRunnable =
  Packages.arc.util.UnsafeRunnable;
declare const CubemapLoader =
  Packages.arc.assets.loaders.CubemapLoader;
declare type CubemapLoader =
  Packages.arc.assets.loaders.CubemapLoader;
declare const CustomLoader =
  Packages.arc.assets.loaders.CustomLoader;
declare type CustomLoader =
  Packages.arc.assets.loaders.CustomLoader;
declare const FontLoader =
  Packages.arc.assets.loaders.FontLoader;
declare type FontLoader =
  Packages.arc.assets.loaders.FontLoader;
declare const I18NBundleLoader =
  Packages.arc.assets.loaders.I18NBundleLoader;
declare type I18NBundleLoader =
  Packages.arc.assets.loaders.I18NBundleLoader;
declare const MusicLoader =
  Packages.arc.assets.loaders.MusicLoader;
declare type MusicLoader =
  Packages.arc.assets.loaders.MusicLoader;
declare const PixmapLoader =
  Packages.arc.assets.loaders.PixmapLoader;
declare type PixmapLoader =
  Packages.arc.assets.loaders.PixmapLoader;
declare const ShaderProgramLoader =
  Packages.arc.assets.loaders.ShaderProgramLoader;
declare type ShaderProgramLoader =
  Packages.arc.assets.loaders.ShaderProgramLoader;
declare const SoundLoader =
  Packages.arc.assets.loaders.SoundLoader;
declare type SoundLoader =
  Packages.arc.assets.loaders.SoundLoader;
declare const TextureAtlasLoader =
  Packages.arc.assets.loaders.TextureAtlasLoader;
declare type TextureAtlasLoader =
  Packages.arc.assets.loaders.TextureAtlasLoader;
declare const TextureLoader =
  Packages.arc.assets.loaders.TextureLoader;
declare type TextureLoader =
  Packages.arc.assets.loaders.TextureLoader;
declare const BlinkEffect =
  Packages.arc.flabel.effects.BlinkEffect;
declare type BlinkEffect =
  Packages.arc.flabel.effects.BlinkEffect;
declare const EaseEffect =
  Packages.arc.flabel.effects.EaseEffect;
declare type EaseEffect =
  Packages.arc.flabel.effects.EaseEffect;
declare const FadeEffect =
  Packages.arc.flabel.effects.FadeEffect;
declare type FadeEffect =
  Packages.arc.flabel.effects.FadeEffect;
declare const GradientEffect =
  Packages.arc.flabel.effects.GradientEffect;
declare type GradientEffect =
  Packages.arc.flabel.effects.GradientEffect;
declare const JumpEffect =
  Packages.arc.flabel.effects.JumpEffect;
declare type JumpEffect =
  Packages.arc.flabel.effects.JumpEffect;
declare const RainbowEffect =
  Packages.arc.flabel.effects.RainbowEffect;
declare type RainbowEffect =
  Packages.arc.flabel.effects.RainbowEffect;
declare const ShakeEffect =
  Packages.arc.flabel.effects.ShakeEffect;
declare type ShakeEffect =
  Packages.arc.flabel.effects.ShakeEffect;
declare const SickEffect =
  Packages.arc.flabel.effects.SickEffect;
declare type SickEffect =
  Packages.arc.flabel.effects.SickEffect;
declare const WaveEffect =
  Packages.arc.flabel.effects.WaveEffect;
declare type WaveEffect =
  Packages.arc.flabel.effects.WaveEffect;
declare const WindEffect =
  Packages.arc.flabel.effects.WindEffect;
declare type WindEffect =
  Packages.arc.flabel.effects.WindEffect;
declare const BiasFilter =
  Packages.arc.fx.filters.BiasFilter;
declare type BiasFilter =
  Packages.arc.fx.filters.BiasFilter;
declare const MultipassVfxFilter =
  Packages.arc.fx.filters.MultipassVfxFilter;
declare type MultipassVfxFilter =
  Packages.arc.fx.filters.MultipassVfxFilter;
declare const Convolve1dFilter =
  Packages.arc.fx.filters.Convolve1dFilter;
declare type Convolve1dFilter =
  Packages.arc.fx.filters.Convolve1dFilter;
declare const Convolve2dFilter =
  Packages.arc.fx.filters.Convolve2dFilter;
declare type Convolve2dFilter =
  Packages.arc.fx.filters.Convolve2dFilter;
declare const GaussianBlurFilter =
  Packages.arc.fx.filters.GaussianBlurFilter;
declare type GaussianBlurFilter =
  Packages.arc.fx.filters.GaussianBlurFilter;
declare const ThresholdFilter =
  Packages.arc.fx.filters.ThresholdFilter;
declare type ThresholdFilter =
  Packages.arc.fx.filters.ThresholdFilter;
declare const CombineFilter =
  Packages.arc.fx.filters.CombineFilter;
declare type CombineFilter =
  Packages.arc.fx.filters.CombineFilter;
declare const BloomFilter =
  Packages.arc.fx.filters.BloomFilter;
declare type BloomFilter =
  Packages.arc.fx.filters.BloomFilter;
declare const CopyFilter =
  Packages.arc.fx.filters.CopyFilter;
declare type CopyFilter =
  Packages.arc.fx.filters.CopyFilter;
declare const BlurFilter =
  Packages.arc.fx.filters.BlurFilter;
declare type BlurFilter =
  Packages.arc.fx.filters.BlurFilter;
declare const ChromaticAberrationFilter =
  Packages.arc.fx.filters.ChromaticAberrationFilter;
declare type ChromaticAberrationFilter =
  Packages.arc.fx.filters.ChromaticAberrationFilter;
declare const CrtFilter = Packages.arc.fx.filters.CrtFilter;
declare type CrtFilter = Packages.arc.fx.filters.CrtFilter;
declare const FilmGrainFilter =
  Packages.arc.fx.filters.FilmGrainFilter;
declare type FilmGrainFilter =
  Packages.arc.fx.filters.FilmGrainFilter;
declare const FisheyeDistortionFilter =
  Packages.arc.fx.filters.FisheyeDistortionFilter;
declare type FisheyeDistortionFilter =
  Packages.arc.fx.filters.FisheyeDistortionFilter;
declare const FxaaFilter =
  Packages.arc.fx.filters.FxaaFilter;
declare type FxaaFilter =
  Packages.arc.fx.filters.FxaaFilter;
declare const HdrFilter = Packages.arc.fx.filters.HdrFilter;
declare type HdrFilter = Packages.arc.fx.filters.HdrFilter;
declare const LensFlareFilter =
  Packages.arc.fx.filters.LensFlareFilter;
declare type LensFlareFilter =
  Packages.arc.fx.filters.LensFlareFilter;
declare const LevelsFilter =
  Packages.arc.fx.filters.LevelsFilter;
declare type LevelsFilter =
  Packages.arc.fx.filters.LevelsFilter;
declare const MixFilter = Packages.arc.fx.filters.MixFilter;
declare type MixFilter = Packages.arc.fx.filters.MixFilter;
declare const FxBufferQueue =
  Packages.arc.fx.util.FxBufferQueue;
declare type FxBufferQueue =
  Packages.arc.fx.util.FxBufferQueue;
declare const MotionBlurFilter =
  Packages.arc.fx.filters.MotionBlurFilter;
declare type MotionBlurFilter =
  Packages.arc.fx.filters.MotionBlurFilter;
declare const NfaaFilter =
  Packages.arc.fx.filters.NfaaFilter;
declare type NfaaFilter =
  Packages.arc.fx.filters.NfaaFilter;
declare const NoiseFilter =
  Packages.arc.fx.filters.NoiseFilter;
declare type NoiseFilter =
  Packages.arc.fx.filters.NoiseFilter;
declare const OldTvFilter =
  Packages.arc.fx.filters.OldTvFilter;
declare type OldTvFilter =
  Packages.arc.fx.filters.OldTvFilter;
declare const RadialBlurFilter =
  Packages.arc.fx.filters.RadialBlurFilter;
declare type RadialBlurFilter =
  Packages.arc.fx.filters.RadialBlurFilter;
declare const RadialDistortionFilter =
  Packages.arc.fx.filters.RadialDistortionFilter;
declare type RadialDistortionFilter =
  Packages.arc.fx.filters.RadialDistortionFilter;
declare const RippleFilter =
  Packages.arc.fx.filters.RippleFilter;
declare type RippleFilter =
  Packages.arc.fx.filters.RippleFilter;
declare const VignettingFilter =
  Packages.arc.fx.filters.VignettingFilter;
declare type VignettingFilter =
  Packages.arc.fx.filters.VignettingFilter;
declare const ZoomFilter =
  Packages.arc.fx.filters.ZoomFilter;
declare type ZoomFilter =
  Packages.arc.fx.filters.ZoomFilter;
declare const FxWidgetGroup =
  Packages.arc.fx.util.FxWidgetGroup;
declare type FxWidgetGroup =
  Packages.arc.fx.util.FxWidgetGroup;
declare const Animation =
  Packages.arc.graphics.g2d.Animation;
declare type Animation =
  Packages.arc.graphics.g2d.Animation;
declare const Bloom = Packages.arc.graphics.g2d.Bloom;
declare type Bloom = Packages.arc.graphics.g2d.Bloom;
declare const SpriteCache =
  Packages.arc.graphics.g2d.SpriteCache;
declare type SpriteCache =
  Packages.arc.graphics.g2d.SpriteCache;
declare const CacheBatch =
  Packages.arc.graphics.g2d.CacheBatch;
declare type CacheBatch =
  Packages.arc.graphics.g2d.CacheBatch;
declare const DistanceFieldFont =
  Packages.arc.graphics.g2d.DistanceFieldFont;
declare type DistanceFieldFont =
  Packages.arc.graphics.g2d.DistanceFieldFont;
declare const ScreenQuad =
  Packages.arc.graphics.g2d.ScreenQuad;
declare type ScreenQuad =
  Packages.arc.graphics.g2d.ScreenQuad;
declare const Draw = Packages.arc.graphics.g2d.Draw;
declare type Draw = Packages.arc.graphics.g2d.Draw;
declare const Polygon = Packages.arc.math.geom.Polygon;
declare type Polygon = Packages.arc.math.geom.Polygon;
declare const Fill = Packages.arc.graphics.g2d.Fill;
declare type Fill = Packages.arc.graphics.g2d.Fill;
declare const ForkJoinPool =
  Packages.java.util.concurrent.ForkJoinPool;
declare type ForkJoinPool =
  Packages.java.util.concurrent.ForkJoinPool;
declare const TimeUnit =
  Packages.java.util.concurrent.TimeUnit;
declare type TimeUnit =
  Packages.java.util.concurrent.TimeUnit;
declare const Future = Packages.java.util.concurrent.Future;
declare type Future = Packages.java.util.concurrent.Future;
declare const VarHandle =
  Packages.java.lang.invoke.VarHandle;
declare type VarHandle =
  Packages.java.lang.invoke.VarHandle;
declare const ForkJoinTask =
  Packages.java.util.concurrent.ForkJoinTask;
declare type ForkJoinTask =
  Packages.java.util.concurrent.ForkJoinTask;
declare const RecursiveAction =
  Packages.java.util.concurrent.RecursiveAction;
declare type RecursiveAction =
  Packages.java.util.concurrent.RecursiveAction;
declare const ForkJoinHolder =
  Packages.arc.graphics.g2d.ForkJoinHolder;
declare type ForkJoinHolder =
  Packages.arc.graphics.g2d.ForkJoinHolder;
declare const Lines = Packages.arc.graphics.g2d.Lines;
declare type Lines = Packages.arc.graphics.g2d.Lines;
declare const SpriteBatch =
  Packages.arc.graphics.g2d.SpriteBatch;
declare type SpriteBatch =
  Packages.arc.graphics.g2d.SpriteBatch;
declare const Quat = Packages.arc.math.geom.Quat;
declare type Quat = Packages.arc.math.geom.Quat;
declare const Mat3D = Packages.arc.math.geom.Mat3D;
declare type Mat3D = Packages.arc.math.geom.Mat3D;
declare const Plane = Packages.arc.math.geom.Plane;
declare type Plane = Packages.arc.math.geom.Plane;
declare const BoundingBox =
  Packages.arc.math.geom.BoundingBox;
declare type BoundingBox =
  Packages.arc.math.geom.BoundingBox;
declare const Frustum = Packages.arc.math.geom.Frustum;
declare type Frustum = Packages.arc.math.geom.Frustum;
declare const Ray = Packages.arc.math.geom.Ray;
declare type Ray = Packages.arc.math.geom.Ray;
declare const Camera3D = Packages.arc.graphics.g3d.Camera3D;
declare type Camera3D = Packages.arc.graphics.g3d.Camera3D;
declare const VertexBatch3D =
  Packages.arc.graphics.g3d.VertexBatch3D;
declare type VertexBatch3D =
  Packages.arc.graphics.g3d.VertexBatch3D;
declare const PlaneBatch3D =
  Packages.arc.graphics.g3d.PlaneBatch3D;
declare type PlaneBatch3D =
  Packages.arc.graphics.g3d.PlaneBatch3D;
declare const FacedCubemapData =
  Packages.arc.graphics.gl.FacedCubemapData;
declare type FacedCubemapData =
  Packages.arc.graphics.gl.FacedCubemapData;
declare const FileTextureArrayData =
  Packages.arc.graphics.gl.FileTextureArrayData;
declare type FileTextureArrayData =
  Packages.arc.graphics.gl.FileTextureArrayData;
declare const FileTextureData =
  Packages.arc.graphics.gl.FileTextureData;
declare type FileTextureData =
  Packages.arc.graphics.gl.FileTextureData;
declare const FloatTextureData =
  Packages.arc.graphics.gl.FloatTextureData;
declare type FloatTextureData =
  Packages.arc.graphics.gl.FloatTextureData;
declare const GLOnlyTextureData =
  Packages.arc.graphics.gl.GLOnlyTextureData;
declare type GLOnlyTextureData =
  Packages.arc.graphics.gl.GLOnlyTextureData;
declare const HdpiMode = Packages.arc.graphics.gl.HdpiMode;
declare type HdpiMode = Packages.arc.graphics.gl.HdpiMode;
declare const HdpiUtils =
  Packages.arc.graphics.gl.HdpiUtils;
declare type HdpiUtils = Packages.arc.graphics.gl.HdpiUtils;
declare const IndexArray =
  Packages.arc.graphics.gl.IndexArray;
declare type IndexArray =
  Packages.arc.graphics.gl.IndexArray;
declare const IndexBufferObject =
  Packages.arc.graphics.gl.IndexBufferObject;
declare type IndexBufferObject =
  Packages.arc.graphics.gl.IndexBufferObject;
declare const IndexBufferObjectSubData =
  Packages.arc.graphics.gl.IndexBufferObjectSubData;
declare type IndexBufferObjectSubData =
  Packages.arc.graphics.gl.IndexBufferObjectSubData;
declare const MipMapGenerator =
  Packages.arc.graphics.gl.MipMapGenerator;
declare type MipMapGenerator =
  Packages.arc.graphics.gl.MipMapGenerator;
declare const MipMapTextureData =
  Packages.arc.graphics.gl.MipMapTextureData;
declare type MipMapTextureData =
  Packages.arc.graphics.gl.MipMapTextureData;
declare const PixmapTextureData =
  Packages.arc.graphics.gl.PixmapTextureData;
declare type PixmapTextureData =
  Packages.arc.graphics.gl.PixmapTextureData;
declare const VertexArray =
  Packages.arc.graphics.gl.VertexArray;
declare type VertexArray =
  Packages.arc.graphics.gl.VertexArray;
declare const VertexBufferObject =
  Packages.arc.graphics.gl.VertexBufferObject;
declare type VertexBufferObject =
  Packages.arc.graphics.gl.VertexBufferObject;
declare const VertexBufferObjectWithVAO =
  Packages.arc.graphics.gl.VertexBufferObjectWithVAO;
declare type VertexBufferObjectWithVAO =
  Packages.arc.graphics.gl.VertexBufferObjectWithVAO;
declare const BSpline = Packages.arc.math.geom.BSpline;
declare type BSpline = Packages.arc.math.geom.BSpline;
declare const Bresenham2 =
  Packages.arc.math.geom.Bresenham2;
declare type Bresenham2 = Packages.arc.math.geom.Bresenham2;
declare const CatmullRomSpline =
  Packages.arc.math.geom.CatmullRomSpline;
declare type CatmullRomSpline =
  Packages.arc.math.geom.CatmullRomSpline;
declare const ConvexHull =
  Packages.arc.math.geom.ConvexHull;
declare type ConvexHull = Packages.arc.math.geom.ConvexHull;
declare const Ellipse = Packages.arc.math.geom.Ellipse;
declare type Ellipse = Packages.arc.math.geom.Ellipse;
declare const Geometry = Packages.arc.math.geom.Geometry;
declare type Geometry = Packages.arc.math.geom.Geometry;
declare const MeshResult =
  Packages.arc.math.geom.MeshResult;
declare type MeshResult = Packages.arc.math.geom.MeshResult;
declare const Icosphere = Packages.arc.math.geom.Icosphere;
declare type Icosphere = Packages.arc.math.geom.Icosphere;
declare const Intersector =
  Packages.arc.math.geom.Intersector;
declare type Intersector =
  Packages.arc.math.geom.Intersector;
declare const Intersector3D =
  Packages.arc.math.geom.Intersector3D;
declare type Intersector3D =
  Packages.arc.math.geom.Intersector3D;
declare const Point3 = Packages.arc.math.geom.Point3;
declare type Point3 = Packages.arc.math.geom.Point3;
declare const Polyline = Packages.arc.math.geom.Polyline;
declare type Polyline = Packages.arc.math.geom.Polyline;
declare const QuadTree = Packages.arc.math.geom.QuadTree;
declare type QuadTree = Packages.arc.math.geom.QuadTree;
declare const Segment = Packages.arc.math.geom.Segment;
declare type Segment = Packages.arc.math.geom.Segment;
declare const Sphere = Packages.arc.math.geom.Sphere;
declare type Sphere = Packages.arc.math.geom.Sphere;
declare const Spring1D = Packages.arc.math.geom.Spring1D;
declare type Spring1D = Packages.arc.math.geom.Spring1D;
declare const Spring2D = Packages.arc.math.geom.Spring2D;
declare type Spring2D = Packages.arc.math.geom.Spring2D;
declare const RunnableAction =
  Packages.arc.scene.actions.RunnableAction;
declare type RunnableAction =
  Packages.arc.scene.actions.RunnableAction;
declare const RemoveActorAction =
  Packages.arc.scene.actions.RemoveActorAction;
declare type RemoveActorAction =
  Packages.arc.scene.actions.RemoveActorAction;
declare const DelegateAction =
  Packages.arc.scene.actions.DelegateAction;
declare type DelegateAction =
  Packages.arc.scene.actions.DelegateAction;
declare const RepeatAction =
  Packages.arc.scene.actions.RepeatAction;
declare type RepeatAction =
  Packages.arc.scene.actions.RepeatAction;
declare const DelayAction =
  Packages.arc.scene.actions.DelayAction;
declare type DelayAction =
  Packages.arc.scene.actions.DelayAction;
declare const TemporalAction =
  Packages.arc.scene.actions.TemporalAction;
declare type TemporalAction =
  Packages.arc.scene.actions.TemporalAction;
declare const ColorAction =
  Packages.arc.scene.actions.ColorAction;
declare type ColorAction =
  Packages.arc.scene.actions.ColorAction;
declare const AfterAction =
  Packages.arc.scene.actions.AfterAction;
declare type AfterAction =
  Packages.arc.scene.actions.AfterAction;
declare const ParallelAction =
  Packages.arc.scene.actions.ParallelAction;
declare type ParallelAction =
  Packages.arc.scene.actions.ParallelAction;
declare const SequenceAction =
  Packages.arc.scene.actions.SequenceAction;
declare type SequenceAction =
  Packages.arc.scene.actions.SequenceAction;
declare const VisibleAction =
  Packages.arc.scene.actions.VisibleAction;
declare type VisibleAction =
  Packages.arc.scene.actions.VisibleAction;
declare const AddListenerAction =
  Packages.arc.scene.actions.AddListenerAction;
declare type AddListenerAction =
  Packages.arc.scene.actions.AddListenerAction;
declare const RemoveListenerAction =
  Packages.arc.scene.actions.RemoveListenerAction;
declare type RemoveListenerAction =
  Packages.arc.scene.actions.RemoveListenerAction;
declare const RotateToAction =
  Packages.arc.scene.actions.RotateToAction;
declare type RotateToAction =
  Packages.arc.scene.actions.RotateToAction;
declare const AlphaAction =
  Packages.arc.scene.actions.AlphaAction;
declare type AlphaAction =
  Packages.arc.scene.actions.AlphaAction;
declare const MoveToAction =
  Packages.arc.scene.actions.MoveToAction;
declare type MoveToAction =
  Packages.arc.scene.actions.MoveToAction;
declare const TouchableAction =
  Packages.arc.scene.actions.TouchableAction;
declare type TouchableAction =
  Packages.arc.scene.actions.TouchableAction;
declare const AddAction =
  Packages.arc.scene.actions.AddAction;
declare type AddAction =
  Packages.arc.scene.actions.AddAction;
declare const LayoutAction =
  Packages.arc.scene.actions.LayoutAction;
declare type LayoutAction =
  Packages.arc.scene.actions.LayoutAction;
declare const RemoveAction =
  Packages.arc.scene.actions.RemoveAction;
declare type RemoveAction =
  Packages.arc.scene.actions.RemoveAction;
declare const RelativeTemporalAction =
  Packages.arc.scene.actions.RelativeTemporalAction;
declare type RelativeTemporalAction =
  Packages.arc.scene.actions.RelativeTemporalAction;
declare const MoveByAction =
  Packages.arc.scene.actions.MoveByAction;
declare type MoveByAction =
  Packages.arc.scene.actions.MoveByAction;
declare const SizeByAction =
  Packages.arc.scene.actions.SizeByAction;
declare type SizeByAction =
  Packages.arc.scene.actions.SizeByAction;
declare const ScaleByAction =
  Packages.arc.scene.actions.ScaleByAction;
declare type ScaleByAction =
  Packages.arc.scene.actions.ScaleByAction;
declare const RotateByAction =
  Packages.arc.scene.actions.RotateByAction;
declare type RotateByAction =
  Packages.arc.scene.actions.RotateByAction;
declare const TranslateByAction =
  Packages.arc.scene.actions.TranslateByAction;
declare type TranslateByAction =
  Packages.arc.scene.actions.TranslateByAction;
declare const SizeToAction =
  Packages.arc.scene.actions.SizeToAction;
declare type SizeToAction =
  Packages.arc.scene.actions.SizeToAction;
declare const ScaleToAction =
  Packages.arc.scene.actions.ScaleToAction;
declare type ScaleToAction =
  Packages.arc.scene.actions.ScaleToAction;
declare const TimeScaleAction =
  Packages.arc.scene.actions.TimeScaleAction;
declare type TimeScaleAction =
  Packages.arc.scene.actions.TimeScaleAction;
declare const Actions = Packages.arc.scene.actions.Actions;
declare type Actions = Packages.arc.scene.actions.Actions;
declare const FloatAction =
  Packages.arc.scene.actions.FloatAction;
declare type FloatAction =
  Packages.arc.scene.actions.FloatAction;
declare const IntAction =
  Packages.arc.scene.actions.IntAction;
declare type IntAction =
  Packages.arc.scene.actions.IntAction;
declare const OriginAction =
  Packages.arc.scene.actions.OriginAction;
declare type OriginAction =
  Packages.arc.scene.actions.OriginAction;
declare const ChangeListener =
  Packages.arc.scene.event.ChangeListener;
declare type ChangeListener =
  Packages.arc.scene.event.ChangeListener;
declare const DragListener =
  Packages.arc.scene.event.DragListener;
declare type DragListener =
  Packages.arc.scene.event.DragListener;
declare const DragScrollListener =
  Packages.arc.scene.event.DragScrollListener;
declare type DragScrollListener =
  Packages.arc.scene.event.DragScrollListener;
declare const HandCursorListener =
  Packages.arc.scene.event.HandCursorListener;
declare type HandCursorListener =
  Packages.arc.scene.event.HandCursorListener;
declare const IbeamCursorListener =
  Packages.arc.scene.event.IbeamCursorListener;
declare type IbeamCursorListener =
  Packages.arc.scene.event.IbeamCursorListener;
declare const ResizeListener =
  Packages.arc.scene.event.ResizeListener;
declare type ResizeListener =
  Packages.arc.scene.event.ResizeListener;
declare const SceneResizeEvent =
  Packages.arc.scene.event.SceneResizeEvent;
declare type SceneResizeEvent =
  Packages.arc.scene.event.SceneResizeEvent;
declare const VisibilityEvent =
  Packages.arc.scene.event.VisibilityEvent;
declare type VisibilityEvent =
  Packages.arc.scene.event.VisibilityEvent;
declare const VisibilityListener =
  Packages.arc.scene.event.VisibilityListener;
declare type VisibilityListener =
  Packages.arc.scene.event.VisibilityListener;
declare const BaseDrawable =
  Packages.arc.scene.style.BaseDrawable;
declare type BaseDrawable =
  Packages.arc.scene.style.BaseDrawable;
declare const TransformDrawable =
  Packages.arc.scene.style.TransformDrawable;
declare type TransformDrawable =
  Packages.arc.scene.style.TransformDrawable;
declare const NinePatchDrawable =
  Packages.arc.scene.style.NinePatchDrawable;
declare type NinePatchDrawable =
  Packages.arc.scene.style.NinePatchDrawable;
declare const ScaledNinePatchDrawable =
  Packages.arc.scene.style.ScaledNinePatchDrawable;
declare type ScaledNinePatchDrawable =
  Packages.arc.scene.style.ScaledNinePatchDrawable;
declare const TextureRegionDrawable =
  Packages.arc.scene.style.TextureRegionDrawable;
declare type TextureRegionDrawable =
  Packages.arc.scene.style.TextureRegionDrawable;
declare const TiledDrawable =
  Packages.arc.scene.style.TiledDrawable;
declare type TiledDrawable =
  Packages.arc.scene.style.TiledDrawable;
declare const ColorImage = Packages.arc.scene.ui.ColorImage;
declare type ColorImage = Packages.arc.scene.ui.ColorImage;
declare const Tooltip = Packages.arc.scene.ui.Tooltip;
declare type Tooltip = Packages.arc.scene.ui.Tooltip;
declare const Touchpad = Packages.arc.scene.ui.Touchpad;
declare type Touchpad = Packages.arc.scene.ui.Touchpad;
declare const Selection =
  Packages.arc.scene.utils.Selection;
declare type Selection = Packages.arc.scene.utils.Selection;
declare const TreeElement =
  Packages.arc.scene.ui.TreeElement;
declare type TreeElement =
  Packages.arc.scene.ui.TreeElement;
declare const Elem = Packages.arc.scene.utils.Elem;
declare type Elem = Packages.arc.scene.utils.Elem;
declare const ByteBufferInput =
  Packages.arc.util.io.ByteBufferInput;
declare type ByteBufferInput =
  Packages.arc.util.io.ByteBufferInput;
declare const ByteBufferOutput =
  Packages.arc.util.io.ByteBufferOutput;
declare type ByteBufferOutput =
  Packages.arc.util.io.ByteBufferOutput;
declare const CRC = Packages.arc.util.io.CRC;
declare type CRC = Packages.arc.util.io.CRC;
declare const FilterInputStream =
  Packages.java.io.FilterInputStream;
declare type FilterInputStream =
  Packages.java.io.FilterInputStream;
declare const CounterInputStream =
  Packages.arc.util.io.CounterInputStream;
declare type CounterInputStream =
  Packages.arc.util.io.CounterInputStream;
declare const DeflaterOutputStream =
  Packages.java.util.zip.DeflaterOutputStream;
declare type DeflaterOutputStream =
  Packages.java.util.zip.DeflaterOutputStream;
declare const FastDeflaterOutputStream =
  Packages.arc.util.io.FastDeflaterOutputStream;
declare type FastDeflaterOutputStream =
  Packages.arc.util.io.FastDeflaterOutputStream;
declare const LittleEndianInputStream =
  Packages.arc.util.io.LittleEndianInputStream;
declare type LittleEndianInputStream =
  Packages.arc.util.io.LittleEndianInputStream;
declare const PropertiesUtils =
  Packages.arc.util.io.PropertiesUtils;
declare type PropertiesUtils =
  Packages.arc.util.io.PropertiesUtils;
declare const ReusableByteOutStream =
  Packages.arc.util.io.ReusableByteOutStream;
declare type ReusableByteOutStream =
  Packages.arc.util.io.ReusableByteOutStream;
declare const Streams = Packages.arc.util.io.Streams;
declare type Streams = Packages.arc.util.io.Streams;
declare const Noise = Packages.arc.util.noise.Noise;
declare type Noise = Packages.arc.util.noise.Noise;
declare const Ridged = Packages.arc.util.noise.Ridged;
declare type Ridged = Packages.arc.util.noise.Ridged;
declare const Simplex = Packages.arc.util.noise.Simplex;
declare type Simplex = Packages.arc.util.noise.Simplex;
declare const VectorTable =
  Packages.arc.util.noise.VectorTable;
declare type VectorTable =
  Packages.arc.util.noise.VectorTable;
declare const VoronoiNoise =
  Packages.arc.util.noise.VoronoiNoise;
declare type VoronoiNoise =
  Packages.arc.util.noise.VoronoiNoise;
declare const Pools = Packages.arc.util.pooling.Pools;
declare type Pools = Packages.arc.util.pooling.Pools;
declare const Base64Coder =
  Packages.arc.util.serialization.Base64Coder;
declare type Base64Coder =
  Packages.arc.util.serialization.Base64Coder;
declare const JsonReader =
  Packages.arc.util.serialization.JsonReader;
declare type JsonReader =
  Packages.arc.util.serialization.JsonReader;
declare const JsonWriter =
  Packages.arc.util.serialization.JsonWriter;
declare type JsonWriter =
  Packages.arc.util.serialization.JsonWriter;
declare const Number = Packages.java.lang.Number;
declare type Number = Packages.java.lang.Number;
declare const Jval = Packages.arc.util.serialization.Jval;
declare type Jval = Packages.arc.util.serialization.Jval;
declare const SerializationException =
  Packages.arc.util.serialization.SerializationException;
declare type SerializationException =
  Packages.arc.util.serialization.SerializationException;
declare const UBJsonWriter =
  Packages.arc.util.serialization.UBJsonWriter;
declare type UBJsonWriter =
  Packages.arc.util.serialization.UBJsonWriter;
declare const ExtendViewport =
  Packages.arc.util.viewport.ExtendViewport;
declare type ExtendViewport =
  Packages.arc.util.viewport.ExtendViewport;
declare const ScalingViewport =
  Packages.arc.util.viewport.ScalingViewport;
declare type ScalingViewport =
  Packages.arc.util.viewport.ScalingViewport;
declare const FillViewport =
  Packages.arc.util.viewport.FillViewport;
declare type FillViewport =
  Packages.arc.util.viewport.FillViewport;
declare const FitViewport =
  Packages.arc.util.viewport.FitViewport;
declare type FitViewport =
  Packages.arc.util.viewport.FitViewport;
declare const ScreenViewport =
  Packages.arc.util.viewport.ScreenViewport;
declare type ScreenViewport =
  Packages.arc.util.viewport.ScreenViewport;
declare const StretchViewport =
  Packages.arc.util.viewport.StretchViewport;
declare type StretchViewport =
  Packages.arc.util.viewport.StretchViewport;
declare const Scl = Packages.arc.scene.ui.layout.Scl;
declare type Scl = Packages.arc.scene.ui.layout.Scl;
declare const Publishable =
  Packages.mindustry._type.Publishable;
declare type Publishable =
  Packages.mindustry._type.Publishable;
declare const Entityc = Packages.mindustry.gen.Entityc;
declare type Entityc = Packages.mindustry.gen.Entityc;
declare const Displayable =
  Packages.mindustry.ui.Displayable;
declare type Displayable =
  Packages.mindustry.ui.Displayable;
declare const Sized = Packages.mindustry.entities.Sized;
declare type Sized = Packages.mindustry.entities.Sized;
declare const Healthc = Packages.mindustry.gen.Healthc;
declare type Healthc = Packages.mindustry.gen.Healthc;
declare const Mod = Packages.mindustry.mod.Mod;
declare type Mod = Packages.mindustry.mod.Mod;
declare const ContentType =
  Packages.mindustry.ctype.ContentType;
declare type ContentType =
  Packages.mindustry.ctype.ContentType;
declare const Content = Packages.mindustry.ctype.Content;
declare type Content = Packages.mindustry.ctype.Content;
declare const MappableContent =
  Packages.mindustry.ctype.MappableContent;
declare type MappableContent =
  Packages.mindustry.ctype.MappableContent;
declare const StatCat =
  Packages.mindustry.world.meta.StatCat;
declare type StatCat =
  Packages.mindustry.world.meta.StatCat;
declare const Stat = Packages.mindustry.world.meta.Stat;
declare type Stat = Packages.mindustry.world.meta.Stat;
declare const StatValue =
  Packages.mindustry.world.meta.StatValue;
declare type StatValue =
  Packages.mindustry.world.meta.StatValue;
declare const Attribute =
  Packages.mindustry.world.meta.Attribute;
declare type Attribute =
  Packages.mindustry.world.meta.Attribute;
declare const LAccess = Packages.mindustry.logic.LAccess;
declare type LAccess = Packages.mindustry.logic.LAccess;
declare const Senseable =
  Packages.mindustry.logic.Senseable;
declare type Senseable = Packages.mindustry.logic.Senseable;
declare const Hitboxc = Packages.mindustry.gen.Hitboxc;
declare type Hitboxc = Packages.mindustry.gen.Hitboxc;
declare const Velc = Packages.mindustry.gen.Velc;
declare type Velc = Packages.mindustry.gen.Velc;
declare const WrapEffect =
  Packages.mindustry.entities.effect.WrapEffect;
declare type WrapEffect =
  Packages.mindustry.entities.effect.WrapEffect;
declare const Effect = Packages.mindustry.entities.Effect;
declare type Effect = Packages.mindustry.entities.Effect;
declare const MultiPacker =
  Packages.mindustry.graphics.MultiPacker;
declare type MultiPacker =
  Packages.mindustry.graphics.MultiPacker;
declare const CacheLayer =
  Packages.mindustry.graphics.CacheLayer;
declare type CacheLayer =
  Packages.mindustry.graphics.CacheLayer;
declare const Floor =
  Packages.mindustry.world.blocks.environment.Floor;
declare type Floor =
  Packages.mindustry.world.blocks.environment.Floor;
declare const Flyingc = Packages.mindustry.gen.Flyingc;
declare type Flyingc = Packages.mindustry.gen.Flyingc;
declare const Boundedc = Packages.mindustry.gen.Boundedc;
declare type Boundedc = Packages.mindustry.gen.Boundedc;
declare const Rotc = Packages.mindustry.gen.Rotc;
declare type Rotc = Packages.mindustry.gen.Rotc;
declare const StatusEntry =
  Packages.mindustry.entities.units.StatusEntry;
declare type StatusEntry =
  Packages.mindustry.entities.units.StatusEntry;
declare const Statusc = Packages.mindustry.gen.Statusc;
declare type Statusc = Packages.mindustry.gen.Statusc;
declare const BuildPlan =
  Packages.mindustry.entities.units.BuildPlan;
declare type BuildPlan =
  Packages.mindustry.entities.units.BuildPlan;
declare const Builderc = Packages.mindustry.gen.Builderc;
declare type Builderc = Packages.mindustry.gen.Builderc;
declare const IndexableEntity__all =
  Packages.mindustry.gen.IndexableEntity__all;
declare type IndexableEntity__all =
  Packages.mindustry.gen.IndexableEntity__all;
declare const IndexableEntity__draw =
  Packages.mindustry.gen.IndexableEntity__draw;
declare type IndexableEntity__draw =
  Packages.mindustry.gen.IndexableEntity__draw;
declare const IndexableEntity__sync =
  Packages.mindustry.gen.IndexableEntity__sync;
declare type IndexableEntity__sync =
  Packages.mindustry.gen.IndexableEntity__sync;
declare const IndexableEntity__unit =
  Packages.mindustry.gen.IndexableEntity__unit;
declare type IndexableEntity__unit =
  Packages.mindustry.gen.IndexableEntity__unit;
declare const PlanetParams =
  Packages.mindustry.graphics.g3d.PlanetParams;
declare type PlanetParams =
  Packages.mindustry.graphics.g3d.PlanetParams;
declare const GenericMesh =
  Packages.mindustry.graphics.g3d.GenericMesh;
declare type GenericMesh =
  Packages.mindustry.graphics.g3d.GenericMesh;
declare const PlanetGrid =
  Packages.mindustry.graphics.g3d.PlanetGrid;
declare type PlanetGrid =
  Packages.mindustry.graphics.g3d.PlanetGrid;
declare const IndexableEntity__puddle =
  Packages.mindustry.gen.IndexableEntity__puddle;
declare type IndexableEntity__puddle =
  Packages.mindustry.gen.IndexableEntity__puddle;
declare const Syncc = Packages.mindustry.gen.Syncc;
declare type Syncc = Packages.mindustry.gen.Syncc;
declare const Puddlec = Packages.mindustry.gen.Puddlec;
declare type Puddlec = Packages.mindustry.gen.Puddlec;
declare const Puddle = Packages.mindustry.gen.Puddle;
declare type Puddle = Packages.mindustry.gen.Puddle;
declare const Timedc = Packages.mindustry.gen.Timedc;
declare type Timedc = Packages.mindustry.gen.Timedc;
declare const Firec = Packages.mindustry.gen.Firec;
declare type Firec = Packages.mindustry.gen.Firec;
declare const IndexableEntity__fire =
  Packages.mindustry.gen.IndexableEntity__fire;
declare type IndexableEntity__fire =
  Packages.mindustry.gen.IndexableEntity__fire;
declare const Fire = Packages.mindustry.gen.Fire;
declare type Fire = Packages.mindustry.gen.Fire;
declare const Tiles = Packages.mindustry.world.Tiles;
declare type Tiles = Packages.mindustry.world.Tiles;
declare const WorldGenerator =
  Packages.mindustry.maps.generators.WorldGenerator;
declare type WorldGenerator =
  Packages.mindustry.maps.generators.WorldGenerator;
declare const BasicGenerator =
  Packages.mindustry.maps.generators.BasicGenerator;
declare type BasicGenerator =
  Packages.mindustry.maps.generators.BasicGenerator;
declare const HexMesher =
  Packages.mindustry.graphics.g3d.HexMesher;
declare type HexMesher =
  Packages.mindustry.graphics.g3d.HexMesher;
declare const Cloneable = Packages.java.lang.Cloneable;
declare type Cloneable = Packages.java.lang.Cloneable;
declare const BaseDialog =
  Packages.mindustry.ui.dialogs.BaseDialog;
declare type BaseDialog =
  Packages.mindustry.ui.dialogs.BaseDialog;
declare const FilterOption =
  Packages.mindustry.maps.filters.FilterOption;
declare type FilterOption =
  Packages.mindustry.maps.filters.FilterOption;
declare const GenerateFilter =
  Packages.mindustry.maps.filters.GenerateFilter;
declare type GenerateFilter =
  Packages.mindustry.maps.filters.GenerateFilter;
declare const Attributes =
  Packages.mindustry.world.blocks.Attributes;
declare type Attributes =
  Packages.mindustry.world.blocks.Attributes;
declare const Damagec = Packages.mindustry.gen.Damagec;
declare type Damagec = Packages.mindustry.gen.Damagec;
declare const Ownerc = Packages.mindustry.gen.Ownerc;
declare type Ownerc = Packages.mindustry.gen.Ownerc;
declare const Shielderc = Packages.mindustry.gen.Shielderc;
declare type Shielderc = Packages.mindustry.gen.Shielderc;
declare const Timerc = Packages.mindustry.gen.Timerc;
declare type Timerc = Packages.mindustry.gen.Timerc;
declare const DrawPart =
  Packages.mindustry.entities.part.DrawPart;
declare type DrawPart =
  Packages.mindustry.entities.part.DrawPart;
declare const Mover = Packages.mindustry.entities.Mover;
declare type Mover = Packages.mindustry.entities.Mover;
declare const BulletType =
  Packages.mindustry.entities.bullet.BulletType;
declare type BulletType =
  Packages.mindustry.entities.bullet.BulletType;
declare const Trail = Packages.mindustry.graphics.Trail;
declare type Trail = Packages.mindustry.graphics.Trail;
declare const Bulletc = Packages.mindustry.gen.Bulletc;
declare type Bulletc = Packages.mindustry.gen.Bulletc;
declare const IndexableEntity__bullet =
  Packages.mindustry.gen.IndexableEntity__bullet;
declare type IndexableEntity__bullet =
  Packages.mindustry.gen.IndexableEntity__bullet;
declare const StorageBlock =
  Packages.mindustry.world.blocks.storage.StorageBlock;
declare type StorageBlock =
  Packages.mindustry.world.blocks.storage.StorageBlock;
declare const BlockModule =
  Packages.mindustry.world.modules.BlockModule;
declare type BlockModule =
  Packages.mindustry.world.modules.BlockModule;
declare const ItemSeq = Packages.mindustry._type.ItemSeq;
declare type ItemSeq = Packages.mindustry._type.ItemSeq;
declare const ItemModule =
  Packages.mindustry.world.modules.ItemModule;
declare type ItemModule =
  Packages.mindustry.world.modules.ItemModule;
declare const Bar = Packages.mindustry.ui.Bar;
declare type Bar = Packages.mindustry.ui.Bar;
declare const CoreBlock =
  Packages.mindustry.world.blocks.storage.CoreBlock;
declare type CoreBlock =
  Packages.mindustry.world.blocks.storage.CoreBlock;
declare const Bullet = Packages.mindustry.gen.Bullet;
declare type Bullet = Packages.mindustry.gen.Bullet;
declare const UnitController =
  Packages.mindustry.entities.units.UnitController;
declare type UnitController =
  Packages.mindustry.entities.units.UnitController;
declare const Ability =
  Packages.mindustry.entities.abilities.Ability;
declare type Ability =
  Packages.mindustry.entities.abilities.Ability;
declare const ShootPattern =
  Packages.mindustry.entities.pattern.ShootPattern;
declare type ShootPattern =
  Packages.mindustry.entities.pattern.ShootPattern;
declare const SoundLoop =
  Packages.mindustry.audio.SoundLoop;
declare type SoundLoop = Packages.mindustry.audio.SoundLoop;
declare const WeaponMount =
  Packages.mindustry.entities.units.WeaponMount;
declare type WeaponMount =
  Packages.mindustry.entities.units.WeaponMount;
declare const Weapon = Packages.mindustry._type.Weapon;
declare type Weapon = Packages.mindustry._type.Weapon;
declare const BlockFlag =
  Packages.mindustry.world.meta.BlockFlag;
declare type BlockFlag =
  Packages.mindustry.world.meta.BlockFlag;
declare const AIController =
  Packages.mindustry.entities.units.AIController;
declare type AIController =
  Packages.mindustry.entities.units.AIController;
declare const Binding = Packages.mindustry.input.Binding;
declare type Binding = Packages.mindustry.input.Binding;
declare const UnitCommand =
  Packages.mindustry.ai.UnitCommand;
declare type UnitCommand =
  Packages.mindustry.ai.UnitCommand;
declare const UnitStance = Packages.mindustry.ai.UnitStance;
declare type UnitStance = Packages.mindustry.ai.UnitStance;
declare const AmmoType = Packages.mindustry._type.AmmoType;
declare type AmmoType = Packages.mindustry._type.AmmoType;
declare const Minerc = Packages.mindustry.gen.Minerc;
declare type Minerc = Packages.mindustry.gen.Minerc;
declare const Physicsc = Packages.mindustry.gen.Physicsc;
declare type Physicsc = Packages.mindustry.gen.Physicsc;
declare const Shieldc = Packages.mindustry.gen.Shieldc;
declare type Shieldc = Packages.mindustry.gen.Shieldc;
declare const Weaponsc = Packages.mindustry.gen.Weaponsc;
declare type Weaponsc = Packages.mindustry.gen.Weaponsc;
declare const Ranged = Packages.mindustry.logic.Ranged;
declare type Ranged = Packages.mindustry.logic.Ranged;
declare const Settable = Packages.mindustry.logic.Settable;
declare type Settable = Packages.mindustry.logic.Settable;
declare const Payload =
  Packages.mindustry.world.blocks.payloads.Payload;
declare type Payload =
  Packages.mindustry.world.blocks.payloads.Payload;
declare const UnitPayload =
  Packages.mindustry.world.blocks.payloads.UnitPayload;
declare type UnitPayload =
  Packages.mindustry.world.blocks.payloads.UnitPayload;
declare const UnitGroup = Packages.mindustry.ai.UnitGroup;
declare type UnitGroup = Packages.mindustry.ai.UnitGroup;
declare const CommandAI =
  Packages.mindustry.ai._types.CommandAI;
declare type CommandAI =
  Packages.mindustry.ai._types.CommandAI;
declare const Unitc = Packages.mindustry.gen.Unitc;
declare type Unitc = Packages.mindustry.gen.Unitc;
declare const BuildPayload =
  Packages.mindustry.world.blocks.payloads.BuildPayload;
declare type BuildPayload =
  Packages.mindustry.world.blocks.payloads.BuildPayload;
declare const Payloadc = Packages.mindustry.gen.Payloadc;
declare type Payloadc = Packages.mindustry.gen.Payloadc;
declare const ElevationMovec =
  Packages.mindustry.gen.ElevationMovec;
declare type ElevationMovec =
  Packages.mindustry.gen.ElevationMovec;
declare const Mechc = Packages.mindustry.gen.Mechc;
declare type Mechc = Packages.mindustry.gen.Mechc;
declare const Tankc = Packages.mindustry.gen.Tankc;
declare type Tankc = Packages.mindustry.gen.Tankc;
declare const Leg = Packages.mindustry.entities.Leg;
declare type Leg = Packages.mindustry.entities.Leg;
declare const Legsc = Packages.mindustry.gen.Legsc;
declare type Legsc = Packages.mindustry.gen.Legsc;
declare const Crawlc = Packages.mindustry.gen.Crawlc;
declare type Crawlc = Packages.mindustry.gen.Crawlc;
declare const PayloadStack =
  Packages.mindustry._type.PayloadStack;
declare type PayloadStack =
  Packages.mindustry._type.PayloadStack;
declare const Consume =
  Packages.mindustry.world.consumers.Consume;
declare type Consume =
  Packages.mindustry.world.consumers.Consume;
declare const UnitType = Packages.mindustry._type.UnitType;
declare type UnitType = Packages.mindustry._type.UnitType;
declare const SpawnGroup =
  Packages.mindustry.game.SpawnGroup;
declare type SpawnGroup =
  Packages.mindustry.game.SpawnGroup;
declare const IndexableEntity__weather =
  Packages.mindustry.gen.IndexableEntity__weather;
declare type IndexableEntity__weather =
  Packages.mindustry.gen.IndexableEntity__weather;
declare const WeatherStatec =
  Packages.mindustry.gen.WeatherStatec;
declare type WeatherStatec =
  Packages.mindustry.gen.WeatherStatec;
declare const WeatherState =
  Packages.mindustry.gen.WeatherState;
declare type WeatherState =
  Packages.mindustry.gen.WeatherState;
declare const Weather = Packages.mindustry._type.Weather;
declare type Weather = Packages.mindustry._type.Weather;
declare const LMarkerControl =
  Packages.mindustry.logic.LMarkerControl;
declare type LMarkerControl =
  Packages.mindustry.logic.LMarkerControl;
declare const MapObjectives =
  Packages.mindustry.game.MapObjectives;
declare type MapObjectives =
  Packages.mindustry.game.MapObjectives;
declare const Gamemode = Packages.mindustry.game.Gamemode;
declare type Gamemode = Packages.mindustry.game.Gamemode;
declare const Rules = Packages.mindustry.game.Rules;
declare type Rules = Packages.mindustry.game.Rules;
declare const Map = Packages.mindustry.maps.Map;
declare type Map = Packages.mindustry.maps.Map;
declare const SaveMeta = Packages.mindustry.io.SaveMeta;
declare type SaveMeta = Packages.mindustry.io.SaveMeta;
declare const DateFormat = Packages.java.text.DateFormat;
declare type DateFormat = Packages.java.text.DateFormat;
declare const Saves = Packages.mindustry.game.Saves;
declare type Saves = Packages.mindustry.game.Saves;
declare const FileMapGenerator =
  Packages.mindustry.maps.generators.FileMapGenerator;
declare type FileMapGenerator =
  Packages.mindustry.maps.generators.FileMapGenerator;
declare const SectorPreset =
  Packages.mindustry._type.SectorPreset;
declare type SectorPreset =
  Packages.mindustry._type.SectorPreset;
declare const SectorInfo =
  Packages.mindustry.game.SectorInfo;
declare type SectorInfo =
  Packages.mindustry.game.SectorInfo;
declare const Sector = Packages.mindustry._type.Sector;
declare type Sector = Packages.mindustry._type.Sector;
declare const TileGen = Packages.mindustry.world.TileGen;
declare type TileGen = Packages.mindustry.world.TileGen;
declare const PlanetGenerator =
  Packages.mindustry.maps.generators.PlanetGenerator;
declare type PlanetGenerator =
  Packages.mindustry.maps.generators.PlanetGenerator;
declare const Planet = Packages.mindustry._type.Planet;
declare type Planet = Packages.mindustry._type.Planet;
declare const Item = Packages.mindustry._type.Item;
declare type Item = Packages.mindustry._type.Item;
declare const ItemStack =
  Packages.mindustry._type.ItemStack;
declare type ItemStack = Packages.mindustry._type.ItemStack;
declare const Itemsc = Packages.mindustry.gen.Itemsc;
declare type Itemsc = Packages.mindustry.gen.Itemsc;
declare const Unit = Packages.mindustry.gen.Unit;
declare type Unit = Packages.mindustry.gen.Unit;
declare const StatusEffect =
  Packages.mindustry._type.StatusEffect;
declare type StatusEffect =
  Packages.mindustry._type.StatusEffect;
declare const Liquid = Packages.mindustry._type.Liquid;
declare type Liquid = Packages.mindustry._type.Liquid;
declare const StatUnit =
  Packages.mindustry.world.meta.StatUnit;
declare type StatUnit =
  Packages.mindustry.world.meta.StatUnit;
declare const Stats = Packages.mindustry.world.meta.Stats;
declare type Stats = Packages.mindustry.world.meta.Stats;
declare const UnlockableContent =
  Packages.mindustry.ctype.UnlockableContent;
declare type UnlockableContent =
  Packages.mindustry.ctype.UnlockableContent;
declare const BlockGroup =
  Packages.mindustry.world.meta.BlockGroup;
declare type BlockGroup =
  Packages.mindustry.world.meta.BlockGroup;
declare const Category = Packages.mindustry._type.Category;
declare type Category = Packages.mindustry._type.Category;
declare const BuildVisibility =
  Packages.mindustry.world.meta.BuildVisibility;
declare type BuildVisibility =
  Packages.mindustry.world.meta.BuildVisibility;
declare const ConsumePower =
  Packages.mindustry.world.consumers.ConsumePower;
declare type ConsumePower =
  Packages.mindustry.world.consumers.ConsumePower;
declare const ConsumeItems =
  Packages.mindustry.world.consumers.ConsumeItems;
declare type ConsumeItems =
  Packages.mindustry.world.consumers.ConsumeItems;
declare const ConsumeLiquidBase =
  Packages.mindustry.world.consumers.ConsumeLiquidBase;
declare type ConsumeLiquidBase =
  Packages.mindustry.world.consumers.ConsumeLiquidBase;
declare const ConsumeLiquid =
  Packages.mindustry.world.consumers.ConsumeLiquid;
declare type ConsumeLiquid =
  Packages.mindustry.world.consumers.ConsumeLiquid;
declare const LiquidStack =
  Packages.mindustry._type.LiquidStack;
declare type LiquidStack =
  Packages.mindustry._type.LiquidStack;
declare const ConsumeLiquids =
  Packages.mindustry.world.consumers.ConsumeLiquids;
declare type ConsumeLiquids =
  Packages.mindustry.world.consumers.ConsumeLiquids;
declare const ReqImage = Packages.mindustry.ui.ReqImage;
declare type ReqImage = Packages.mindustry.ui.ReqImage;
declare const MultiReqImage =
  Packages.mindustry.ui.MultiReqImage;
declare type MultiReqImage =
  Packages.mindustry.ui.MultiReqImage;
declare const ConsumeLiquidFilter =
  Packages.mindustry.world.consumers.ConsumeLiquidFilter;
declare type ConsumeLiquidFilter =
  Packages.mindustry.world.consumers.ConsumeLiquidFilter;
declare const ConsumeCoolant =
  Packages.mindustry.world.consumers.ConsumeCoolant;
declare type ConsumeCoolant =
  Packages.mindustry.world.consumers.ConsumeCoolant;
declare const Block = Packages.mindustry.world.Block;
declare type Block = Packages.mindustry.world.Block;
declare const Schematic = Packages.mindustry.game.Schematic;
declare type Schematic = Packages.mindustry.game.Schematic;
declare const BaseBuilderAI =
  Packages.mindustry.ai.BaseBuilderAI;
declare type BaseBuilderAI =
  Packages.mindustry.ai.BaseBuilderAI;
declare const RtsAI = Packages.mindustry.ai.RtsAI;
declare type RtsAI = Packages.mindustry.ai.RtsAI;
declare const Team = Packages.mindustry.game.Team;
declare type Team = Packages.mindustry.game.Team;
declare const Teamc = Packages.mindustry.gen.Teamc;
declare type Teamc = Packages.mindustry.gen.Teamc;
declare const LVar = Packages.mindustry.logic.LVar;
declare type LVar = Packages.mindustry.logic.LVar;
declare const Controllable =
  Packages.mindustry.logic.Controllable;
declare type Controllable =
  Packages.mindustry.logic.Controllable;
declare const BlockStatus =
  Packages.mindustry.world.meta.BlockStatus;
declare type BlockStatus =
  Packages.mindustry.world.meta.BlockStatus;
declare const IndexableEntity__powerGraph =
  Packages.mindustry.gen.IndexableEntity__powerGraph;
declare type IndexableEntity__powerGraph =
  Packages.mindustry.gen.IndexableEntity__powerGraph;
declare const PowerGraphUpdaterc =
  Packages.mindustry.gen.PowerGraphUpdaterc;
declare type PowerGraphUpdaterc =
  Packages.mindustry.gen.PowerGraphUpdaterc;
declare const PowerGraphUpdater =
  Packages.mindustry.gen.PowerGraphUpdater;
declare type PowerGraphUpdater =
  Packages.mindustry.gen.PowerGraphUpdater;
declare const PowerGraph =
  Packages.mindustry.world.blocks.power.PowerGraph;
declare type PowerGraph =
  Packages.mindustry.world.blocks.power.PowerGraph;
declare const PowerModule =
  Packages.mindustry.world.modules.PowerModule;
declare type PowerModule =
  Packages.mindustry.world.modules.PowerModule;
declare const LiquidModule =
  Packages.mindustry.world.modules.LiquidModule;
declare type LiquidModule =
  Packages.mindustry.world.modules.LiquidModule;
declare const PayloadSeq =
  Packages.mindustry._type.PayloadSeq;
declare type PayloadSeq =
  Packages.mindustry._type.PayloadSeq;
declare const Buildingc = Packages.mindustry.gen.Buildingc;
declare type Buildingc = Packages.mindustry.gen.Buildingc;
declare const IndexableEntity__build =
  Packages.mindustry.gen.IndexableEntity__build;
declare type IndexableEntity__build =
  Packages.mindustry.gen.IndexableEntity__build;
declare const Building = Packages.mindustry.gen.Building;
declare type Building = Packages.mindustry.gen.Building;
declare const Tile = Packages.mindustry.world.Tile;
declare type Tile = Packages.mindustry.world.Tile;
declare const Posc = Packages.mindustry.gen.Posc;
declare type Posc = Packages.mindustry.gen.Posc;
declare const Drawc = Packages.mindustry.gen.Drawc;
declare type Drawc = Packages.mindustry.gen.Drawc;
declare const IndexableEntity__player =
  Packages.mindustry.gen.IndexableEntity__player;
declare type IndexableEntity__player =
  Packages.mindustry.gen.IndexableEntity__player;
declare const Playerc = Packages.mindustry.gen.Playerc;
declare type Playerc = Packages.mindustry.gen.Playerc;
declare const Player = Packages.mindustry.gen.Player;
declare type Player = Packages.mindustry.gen.Player;
declare const Packet = Packages.mindustry.net.Packet;
declare type Packet = Packages.mindustry.net.Packet;
declare const Streamable =
  Packages.mindustry.net.Streamable;
declare type Streamable = Packages.mindustry.net.Streamable;
declare const NetConnection =
  Packages.mindustry.net.NetConnection;
declare type NetConnection =
  Packages.mindustry.net.NetConnection;
declare const Host = Packages.mindustry.net.Host;
declare type Host = Packages.mindustry.net.Host;
declare const ModuleSource =
  Packages.rhino.module.provider.ModuleSource;
declare type ModuleSource =
  Packages.rhino.module.provider.ModuleSource;
declare const URI = Packages.java.net.URI;
declare type URI = Packages.java.net.URI;
declare const Scriptable = Packages.rhino.Scriptable;
declare type Scriptable = Packages.rhino.Scriptable;
declare const ModuleSourceProvider =
  Packages.rhino.module.provider.ModuleSourceProvider;
declare type ModuleSourceProvider =
  Packages.rhino.module.provider.ModuleSourceProvider;
declare const ModuleSourceProviderBase =
  Packages.rhino.module.provider.ModuleSourceProviderBase;
declare type ModuleSourceProviderBase =
  Packages.rhino.module.provider.ModuleSourceProviderBase;
declare const UrlConnectionExpiryCalculator =
  Packages.rhino.module.provider
    .UrlConnectionExpiryCalculator;
declare type UrlConnectionExpiryCalculator =
  Packages.rhino.module.provider.UrlConnectionExpiryCalculator;
declare const URLConnection =
  Packages.java.net.URLConnection;
declare type URLConnection =
  Packages.java.net.URLConnection;
declare const IOException = Packages.java.io.IOException;
declare type IOException = Packages.java.io.IOException;
declare const UrlModuleSourceProvider =
  Packages.rhino.module.provider.UrlModuleSourceProvider;
declare type UrlModuleSourceProvider =
  Packages.rhino.module.provider.UrlModuleSourceProvider;
declare const Context = Packages.rhino.Context;
declare type Context = Packages.rhino.Context;
declare const Scripts = Packages.mindustry.mod.Scripts;
declare type Scripts = Packages.mindustry.mod.Scripts;
declare const Platform = Packages.mindustry.core.Platform;
declare type Platform = Packages.mindustry.core.Platform;
declare const LoadRenderer =
  Packages.mindustry.graphics.LoadRenderer;
declare type LoadRenderer =
  Packages.mindustry.graphics.LoadRenderer;
declare const ClientLauncher =
  Packages.mindustry.ClientLauncher;
declare type ClientLauncher =
  Packages.mindustry.ClientLauncher;
declare const ServerGroup =
  Packages.mindustry.net.ServerGroup;
declare type ServerGroup =
  Packages.mindustry.net.ServerGroup;
declare const FileTree = Packages.mindustry.core.FileTree;
declare type FileTree = Packages.mindustry.core.FileTree;
declare const Net = Packages.mindustry.net.Net;
declare type Net = Packages.mindustry.net.Net;
declare const ContentLoader =
  Packages.mindustry.core.ContentLoader;
declare type ContentLoader =
  Packages.mindustry.core.ContentLoader;
declare const GameStats = Packages.mindustry.game.GameStats;
declare type GameStats = Packages.mindustry.game.GameStats;
declare const MapMarkers =
  Packages.mindustry.game.MapMarkers;
declare type MapMarkers =
  Packages.mindustry.game.MapMarkers;
declare const MapLocales =
  Packages.mindustry._type.MapLocales;
declare type MapLocales =
  Packages.mindustry._type.MapLocales;
declare const Teams = Packages.mindustry.game.Teams;
declare type Teams = Packages.mindustry.game.Teams;
declare const GameState = Packages.mindustry.core.GameState;
declare type GameState = Packages.mindustry.core.GameState;
declare const EntityIndexer =
  Packages.mindustry.entities.EntityIndexer;
declare type EntityIndexer =
  Packages.mindustry.entities.EntityIndexer;
declare const EntityGroup =
  Packages.mindustry.entities.EntityGroup;
declare type EntityGroup =
  Packages.mindustry.entities.EntityGroup;
declare const EntityCollisions =
  Packages.mindustry.entities.EntityCollisions;
declare type EntityCollisions =
  Packages.mindustry.entities.EntityCollisions;
declare const Waves = Packages.mindustry.game.Waves;
declare type Waves = Packages.mindustry.game.Waves;
declare const TeamEntry =
  Packages.mindustry._type.TeamEntry;
declare type TeamEntry = Packages.mindustry._type.TeamEntry;
declare const ContentParser =
  Packages.mindustry.mod.ContentParser;
declare type ContentParser =
  Packages.mindustry.mod.ContentParser;
declare const ModClassLoader =
  Packages.mindustry.mod.ModClassLoader;
declare type ModClassLoader =
  Packages.mindustry.mod.ModClassLoader;
declare const RegionEntry =
  Packages.mindustry.mod.Mods.RegionEntry;
declare type RegionEntry =
  Packages.mindustry.mod.Mods.RegionEntry;
declare const Mods = Packages.mindustry.mod.Mods;
declare type Mods = Packages.mindustry.mod.Mods;
declare const Schematics =
  Packages.mindustry.game.Schematics;
declare type Schematics =
  Packages.mindustry.game.Schematics;
declare const BeControl = Packages.mindustry.net.BeControl;
declare type BeControl = Packages.mindustry.net.BeControl;
declare const AsyncProcess =
  Packages.mindustry.async.AsyncProcess;
declare type AsyncProcess =
  Packages.mindustry.async.AsyncProcess;
declare const AsyncCore =
  Packages.mindustry.async.AsyncCore;
declare type AsyncCore = Packages.mindustry.async.AsyncCore;
declare const OverlayFloor =
  Packages.mindustry.world.blocks.environment.OverlayFloor;
declare type OverlayFloor =
  Packages.mindustry.world.blocks.environment.OverlayFloor;
declare const OreBlock =
  Packages.mindustry.world.blocks.environment.OreBlock;
declare type OreBlock =
  Packages.mindustry.world.blocks.environment.OreBlock;
declare const BaseRegistry =
  Packages.mindustry.ai.BaseRegistry;
declare type BaseRegistry =
  Packages.mindustry.ai.BaseRegistry;
declare const GlobalVars =
  Packages.mindustry.logic.GlobalVars;
declare type GlobalVars =
  Packages.mindustry.logic.GlobalVars;
declare const WorldContext =
  Packages.mindustry.world.WorldContext;
declare type WorldContext =
  Packages.mindustry.world.WorldContext;
declare const IndexedRenderer =
  Packages.mindustry.graphics.IndexedRenderer;
declare type IndexedRenderer =
  Packages.mindustry.graphics.IndexedRenderer;
declare const MapRenderer =
  Packages.mindustry.editor.MapRenderer;
declare type MapRenderer =
  Packages.mindustry.editor.MapRenderer;
declare const DrawOperation =
  Packages.mindustry.editor.DrawOperation;
declare type DrawOperation =
  Packages.mindustry.editor.DrawOperation;
declare const OperationStack =
  Packages.mindustry.editor.OperationStack;
declare type OperationStack =
  Packages.mindustry.editor.OperationStack;
declare const MapEditor =
  Packages.mindustry.editor.MapEditor;
declare type MapEditor =
  Packages.mindustry.editor.MapEditor;
declare const SStat = Packages.mindustry.service.SStat;
declare type SStat = Packages.mindustry.service.SStat;
declare const Achievement =
  Packages.mindustry.service.Achievement;
declare type Achievement =
  Packages.mindustry.service.Achievement;
declare const GameService =
  Packages.mindustry.service.GameService;
declare type GameService =
  Packages.mindustry.service.GameService;
declare const Universe = Packages.mindustry.game.Universe;
declare type Universe = Packages.mindustry.game.Universe;
declare const World = Packages.mindustry.core.World;
declare type World = Packages.mindustry.core.World;
declare const Maps = Packages.mindustry.maps.Maps;
declare type Maps = Packages.mindustry.maps.Maps;
declare const WaveSpawner =
  Packages.mindustry.ai.WaveSpawner;
declare type WaveSpawner =
  Packages.mindustry.ai.WaveSpawner;
declare const BlockIndexer =
  Packages.mindustry.ai.BlockIndexer;
declare type BlockIndexer =
  Packages.mindustry.ai.BlockIndexer;
declare const Pathfinder = Packages.mindustry.ai.Pathfinder;
declare type Pathfinder = Packages.mindustry.ai.Pathfinder;
declare const PathfindQueue =
  Packages.mindustry.ai.PathfindQueue;
declare type PathfindQueue =
  Packages.mindustry.ai.PathfindQueue;
declare const ControlPathfinder =
  Packages.mindustry.ai.ControlPathfinder;
declare type ControlPathfinder =
  Packages.mindustry.ai.ControlPathfinder;
declare const FogControl =
  Packages.mindustry.game.FogControl;
declare type FogControl =
  Packages.mindustry.game.FogControl;
declare const SoundControl =
  Packages.mindustry.audio.SoundControl;
declare type SoundControl =
  Packages.mindustry.audio.SoundControl;
declare const BlockInventoryFragment =
  Packages.mindustry.ui.fragments.BlockInventoryFragment;
declare type BlockInventoryFragment =
  Packages.mindustry.ui.fragments.BlockInventoryFragment;
declare const BlockConfigFragment =
  Packages.mindustry.ui.fragments.BlockConfigFragment;
declare type BlockConfigFragment =
  Packages.mindustry.ui.fragments.BlockConfigFragment;
declare const InputHandler =
  Packages.mindustry.input.InputHandler;
declare type InputHandler =
  Packages.mindustry.input.InputHandler;
declare const AttackIndicators =
  Packages.mindustry.game.AttackIndicators;
declare type AttackIndicators =
  Packages.mindustry.game.AttackIndicators;
declare const WorldReloader =
  Packages.mindustry.net.WorldReloader;
declare type WorldReloader =
  Packages.mindustry.net.WorldReloader;
declare const Control = Packages.mindustry.core.Control;
declare type Control = Packages.mindustry.core.Control;
declare const Logic = Packages.mindustry.core.Logic;
declare type Logic = Packages.mindustry.core.Logic;
declare const FloorRenderer =
  Packages.mindustry.graphics.FloorRenderer;
declare type FloorRenderer =
  Packages.mindustry.graphics.FloorRenderer;
declare const BlockRenderer =
  Packages.mindustry.graphics.BlockRenderer;
declare type BlockRenderer =
  Packages.mindustry.graphics.BlockRenderer;
declare const FogRenderer =
  Packages.mindustry.graphics.FogRenderer;
declare type FogRenderer =
  Packages.mindustry.graphics.FogRenderer;
declare const MinimapRenderer =
  Packages.mindustry.graphics.MinimapRenderer;
declare type MinimapRenderer =
  Packages.mindustry.graphics.MinimapRenderer;
declare const OverlayRenderer =
  Packages.mindustry.graphics.OverlayRenderer;
declare type OverlayRenderer =
  Packages.mindustry.graphics.OverlayRenderer;
declare const LightRenderer =
  Packages.mindustry.graphics.LightRenderer;
declare type LightRenderer =
  Packages.mindustry.graphics.LightRenderer;
declare const Pixelator =
  Packages.mindustry.graphics.Pixelator;
declare type Pixelator =
  Packages.mindustry.graphics.Pixelator;
declare const CubemapMesh =
  Packages.mindustry.graphics.CubemapMesh;
declare type CubemapMesh =
  Packages.mindustry.graphics.CubemapMesh;
declare const PlanetRenderer =
  Packages.mindustry.graphics.g3d.PlanetRenderer;
declare type PlanetRenderer =
  Packages.mindustry.graphics.g3d.PlanetRenderer;
declare const Renderer = Packages.mindustry.core.Renderer;
declare type Renderer = Packages.mindustry.core.Renderer;
declare const MenuRenderer =
  Packages.mindustry.graphics.MenuRenderer;
declare type MenuRenderer =
  Packages.mindustry.graphics.MenuRenderer;
declare const MobileButton =
  Packages.mindustry.ui.MobileButton;
declare type MobileButton =
  Packages.mindustry.ui.MobileButton;
declare const MenuFragment =
  Packages.mindustry.ui.fragments.MenuFragment;
declare type MenuFragment =
  Packages.mindustry.ui.fragments.MenuFragment;
declare const ItemImage = Packages.mindustry.ui.ItemImage;
declare type ItemImage = Packages.mindustry.ui.ItemImage;
declare const PlacementFragment =
  Packages.mindustry.ui.fragments.PlacementFragment;
declare type PlacementFragment =
  Packages.mindustry.ui.fragments.PlacementFragment;
declare const CoreItemsDisplay =
  Packages.mindustry.ui.CoreItemsDisplay;
declare type CoreItemsDisplay =
  Packages.mindustry.ui.CoreItemsDisplay;
declare const IntFormat = Packages.mindustry.ui.IntFormat;
declare type IntFormat = Packages.mindustry.ui.IntFormat;
declare const SideBar =
  Packages.mindustry.ui.fragments.HudFragment.SideBar;
declare type SideBar =
  Packages.mindustry.ui.fragments.HudFragment.SideBar;
declare const HudFragment =
  Packages.mindustry.ui.fragments.HudFragment;
declare type HudFragment =
  Packages.mindustry.ui.fragments.HudFragment;
declare const ChatFragment =
  Packages.mindustry.ui.fragments.ChatFragment;
declare type ChatFragment =
  Packages.mindustry.ui.fragments.ChatFragment;
declare const ConsoleFragment =
  Packages.mindustry.ui.fragments.ConsoleFragment;
declare type ConsoleFragment =
  Packages.mindustry.ui.fragments.ConsoleFragment;
declare const MinimapFragment =
  Packages.mindustry.ui.fragments.MinimapFragment;
declare type MinimapFragment =
  Packages.mindustry.ui.fragments.MinimapFragment;
declare const PlayerListFragment =
  Packages.mindustry.ui.fragments.PlayerListFragment;
declare type PlayerListFragment =
  Packages.mindustry.ui.fragments.PlayerListFragment;
declare const LoadingFragment =
  Packages.mindustry.ui.fragments.LoadingFragment;
declare type LoadingFragment =
  Packages.mindustry.ui.fragments.LoadingFragment;
declare const HintsFragment =
  Packages.mindustry.ui.fragments.HintsFragment;
declare type HintsFragment =
  Packages.mindustry.ui.fragments.HintsFragment;
declare const AboutDialog =
  Packages.mindustry.ui.dialogs.AboutDialog;
declare type AboutDialog =
  Packages.mindustry.ui.dialogs.AboutDialog;
declare const GameOverDialog =
  Packages.mindustry.ui.dialogs.GameOverDialog;
declare type GameOverDialog =
  Packages.mindustry.ui.dialogs.GameOverDialog;
declare const MapListDialog =
  Packages.mindustry.ui.dialogs.MapListDialog;
declare type MapListDialog =
  Packages.mindustry.ui.dialogs.MapListDialog;
declare const LoadoutDialog =
  Packages.mindustry.ui.dialogs.LoadoutDialog;
declare type LoadoutDialog =
  Packages.mindustry.ui.dialogs.LoadoutDialog;
declare const CustomRulesDialog =
  Packages.mindustry.ui.dialogs.CustomRulesDialog;
declare type CustomRulesDialog =
  Packages.mindustry.ui.dialogs.CustomRulesDialog;
declare const MapPlayDialog =
  Packages.mindustry.ui.dialogs.MapPlayDialog;
declare type MapPlayDialog =
  Packages.mindustry.ui.dialogs.MapPlayDialog;
declare const CustomGameDialog =
  Packages.mindustry.ui.dialogs.CustomGameDialog;
declare type CustomGameDialog =
  Packages.mindustry.ui.dialogs.CustomGameDialog;
declare const EditorMapsDialog =
  Packages.mindustry.ui.dialogs.EditorMapsDialog;
declare type EditorMapsDialog =
  Packages.mindustry.ui.dialogs.EditorMapsDialog;
declare const BorderImage =
  Packages.mindustry.ui.BorderImage;
declare type BorderImage =
  Packages.mindustry.ui.BorderImage;
declare const LoadDialog =
  Packages.mindustry.ui.dialogs.LoadDialog;
declare type LoadDialog =
  Packages.mindustry.ui.dialogs.LoadDialog;
declare const DiscordDialog =
  Packages.mindustry.ui.dialogs.DiscordDialog;
declare type DiscordDialog =
  Packages.mindustry.ui.dialogs.DiscordDialog;
declare const JoinDialog =
  Packages.mindustry.ui.dialogs.JoinDialog;
declare type JoinDialog =
  Packages.mindustry.ui.dialogs.JoinDialog;
declare const HostDialog =
  Packages.mindustry.ui.dialogs.HostDialog;
declare type HostDialog =
  Packages.mindustry.ui.dialogs.HostDialog;
declare const IconSelectDialog =
  Packages.mindustry.ui.dialogs.IconSelectDialog;
declare type IconSelectDialog =
  Packages.mindustry.ui.dialogs.IconSelectDialog;
declare const MessageType =
  Packages.mindustry.logic.MessageType;
declare type MessageType =
  Packages.mindustry.logic.MessageType;
declare const LogicRule =
  Packages.mindustry.logic.LogicRule;
declare type LogicRule = Packages.mindustry.logic.LogicRule;
declare const TileLayer =
  Packages.mindustry.logic.TileLayer;
declare type TileLayer = Packages.mindustry.logic.TileLayer;
declare const FetchType =
  Packages.mindustry.logic.FetchType;
declare type FetchType = Packages.mindustry.logic.FetchType;
declare const CutsceneAction =
  Packages.mindustry.logic.CutsceneAction;
declare type CutsceneAction =
  Packages.mindustry.logic.CutsceneAction;
declare const ConditionOp =
  Packages.mindustry.logic.ConditionOp;
declare type ConditionOp =
  Packages.mindustry.logic.ConditionOp;
declare const LogicOp = Packages.mindustry.logic.LogicOp;
declare type LogicOp = Packages.mindustry.logic.LogicOp;
declare const RadarTarget =
  Packages.mindustry.logic.RadarTarget;
declare type RadarTarget =
  Packages.mindustry.logic.RadarTarget;
declare const RadarSort =
  Packages.mindustry.logic.RadarSort;
declare type RadarSort = Packages.mindustry.logic.RadarSort;
declare const LUnitControl =
  Packages.mindustry.logic.LUnitControl;
declare type LUnitControl =
  Packages.mindustry.logic.LUnitControl;
declare const PosTeam = Packages.mindustry.gen.PosTeam;
declare type PosTeam = Packages.mindustry.gen.PosTeam;
declare const LogicAI =
  Packages.mindustry.ai._types.LogicAI;
declare type LogicAI = Packages.mindustry.ai._types.LogicAI;
declare const LLocate = Packages.mindustry.logic.LLocate;
declare type LLocate = Packages.mindustry.logic.LLocate;
declare const LCanvas = Packages.mindustry.logic.LCanvas;
declare type LCanvas = Packages.mindustry.logic.LCanvas;
declare const LCategory =
  Packages.mindustry.logic.LCategory;
declare type LCategory = Packages.mindustry.logic.LCategory;
declare const LStatement =
  Packages.mindustry.logic.LStatement;
declare type LStatement =
  Packages.mindustry.logic.LStatement;
declare const LAssembler =
  Packages.mindustry.logic.LAssembler;
declare type LAssembler =
  Packages.mindustry.logic.LAssembler;
declare const LExecutor =
  Packages.mindustry.logic.LExecutor;
declare type LExecutor = Packages.mindustry.logic.LExecutor;
declare const LogicBlock =
  Packages.mindustry.world.blocks.logic.LogicBlock;
declare type LogicBlock =
  Packages.mindustry.world.blocks.logic.LogicBlock;
declare const MapProcessorsDialog =
  Packages.mindustry.editor.MapProcessorsDialog;
declare type MapProcessorsDialog =
  Packages.mindustry.editor.MapProcessorsDialog;
declare const SaveDialog =
  Packages.mindustry.ui.dialogs.SaveDialog;
declare type SaveDialog =
  Packages.mindustry.ui.dialogs.SaveDialog;
declare const PausedDialog =
  Packages.mindustry.ui.dialogs.PausedDialog;
declare type PausedDialog =
  Packages.mindustry.ui.dialogs.PausedDialog;
declare const SettingsMenuDialog =
  Packages.mindustry.ui.dialogs.SettingsMenuDialog;
declare type SettingsMenuDialog =
  Packages.mindustry.ui.dialogs.SettingsMenuDialog;
declare const KeybindDialog =
  Packages.mindustry.ui.dialogs.KeybindDialog;
declare type KeybindDialog =
  Packages.mindustry.ui.dialogs.KeybindDialog;
declare const EditorTool =
  Packages.mindustry.editor.EditorTool;
declare type EditorTool =
  Packages.mindustry.editor.EditorTool;
declare const GridImage = Packages.mindustry.ui.GridImage;
declare type GridImage = Packages.mindustry.ui.GridImage;
declare const MapView = Packages.mindustry.editor.MapView;
declare type MapView = Packages.mindustry.editor.MapView;
declare const WaveGraph =
  Packages.mindustry.editor.WaveGraph;
declare type WaveGraph =
  Packages.mindustry.editor.WaveGraph;
declare const WaveInfoDialog =
  Packages.mindustry.editor.WaveInfoDialog;
declare type WaveInfoDialog =
  Packages.mindustry.editor.WaveInfoDialog;
declare const CachedTile =
  Packages.mindustry.world.CachedTile;
declare type CachedTile =
  Packages.mindustry.world.CachedTile;
declare const MapGenerateDialog =
  Packages.mindustry.editor.MapGenerateDialog;
declare type MapGenerateDialog =
  Packages.mindustry.editor.MapGenerateDialog;
declare const MapObjectivesCanvas =
  Packages.mindustry.editor.MapObjectivesCanvas;
declare type MapObjectivesCanvas =
  Packages.mindustry.editor.MapObjectivesCanvas;
declare const MapObjectivesDialog =
  Packages.mindustry.editor.MapObjectivesDialog;
declare type MapObjectivesDialog =
  Packages.mindustry.editor.MapObjectivesDialog;
declare const MapLocalesDialog =
  Packages.mindustry.editor.MapLocalesDialog;
declare type MapLocalesDialog =
  Packages.mindustry.editor.MapLocalesDialog;
declare const MapInfoDialog =
  Packages.mindustry.editor.MapInfoDialog;
declare type MapInfoDialog =
  Packages.mindustry.editor.MapInfoDialog;
declare const MapLoadDialog =
  Packages.mindustry.editor.MapLoadDialog;
declare type MapLoadDialog =
  Packages.mindustry.editor.MapLoadDialog;
declare const MapResizeDialog =
  Packages.mindustry.editor.MapResizeDialog;
declare type MapResizeDialog =
  Packages.mindustry.editor.MapResizeDialog;
declare const SectorGenerateDialog =
  Packages.mindustry.editor.SectorGenerateDialog;
declare type SectorGenerateDialog =
  Packages.mindustry.editor.SectorGenerateDialog;
declare const MapEditorDialog =
  Packages.mindustry.editor.MapEditorDialog;
declare type MapEditorDialog =
  Packages.mindustry.editor.MapEditorDialog;
declare const LanguageDialog =
  Packages.mindustry.ui.dialogs.LanguageDialog;
declare type LanguageDialog =
  Packages.mindustry.ui.dialogs.LanguageDialog;
declare const BansDialog =
  Packages.mindustry.ui.dialogs.BansDialog;
declare type BansDialog =
  Packages.mindustry.ui.dialogs.BansDialog;
declare const AdminsDialog =
  Packages.mindustry.ui.dialogs.AdminsDialog;
declare type AdminsDialog =
  Packages.mindustry.ui.dialogs.AdminsDialog;
declare const TraceDialog =
  Packages.mindustry.ui.dialogs.TraceDialog;
declare type TraceDialog =
  Packages.mindustry.ui.dialogs.TraceDialog;
declare const DatabaseDialog =
  Packages.mindustry.ui.dialogs.DatabaseDialog;
declare type DatabaseDialog =
  Packages.mindustry.ui.dialogs.DatabaseDialog;
declare const ContentInfoDialog =
  Packages.mindustry.ui.dialogs.ContentInfoDialog;
declare type ContentInfoDialog =
  Packages.mindustry.ui.dialogs.ContentInfoDialog;
declare const LaunchLoadoutDialog =
  Packages.mindustry.ui.dialogs.LaunchLoadoutDialog;
declare type LaunchLoadoutDialog =
  Packages.mindustry.ui.dialogs.LaunchLoadoutDialog;
declare const PlanetDialog =
  Packages.mindustry.ui.dialogs.PlanetDialog;
declare type PlanetDialog =
  Packages.mindustry.ui.dialogs.PlanetDialog;
declare const ItemsDisplay =
  Packages.mindustry.ui.ItemsDisplay;
declare type ItemsDisplay =
  Packages.mindustry.ui.ItemsDisplay;
declare const ResearchDialog =
  Packages.mindustry.ui.dialogs.ResearchDialog;
declare type ResearchDialog =
  Packages.mindustry.ui.dialogs.ResearchDialog;
declare const SchematicsDialog =
  Packages.mindustry.ui.dialogs.SchematicsDialog;
declare type SchematicsDialog =
  Packages.mindustry.ui.dialogs.SchematicsDialog;
declare const ModListing =
  Packages.mindustry.mod.ModListing;
declare type ModListing = Packages.mindustry.mod.ModListing;
declare const Date = Packages.java.util.Date;
declare type Date = Packages.java.util.Date;
declare const SimpleDateFormat =
  Packages.java.text.SimpleDateFormat;
declare type SimpleDateFormat =
  Packages.java.text.SimpleDateFormat;
declare const ModsDialog =
  Packages.mindustry.ui.dialogs.ModsDialog;
declare type ModsDialog =
  Packages.mindustry.ui.dialogs.ModsDialog;
declare const ColorPicker =
  Packages.mindustry.ui.dialogs.ColorPicker;
declare type ColorPicker =
  Packages.mindustry.ui.dialogs.ColorPicker;
declare const EffectsDialog =
  Packages.mindustry.ui.dialogs.EffectsDialog;
declare type EffectsDialog =
  Packages.mindustry.ui.dialogs.EffectsDialog;
declare const GlobalVarsDialog =
  Packages.mindustry.logic.GlobalVarsDialog;
declare type GlobalVarsDialog =
  Packages.mindustry.logic.GlobalVarsDialog;
declare const LogicDialog =
  Packages.mindustry.logic.LogicDialog;
declare type LogicDialog =
  Packages.mindustry.logic.LogicDialog;
declare const FullTextDialog =
  Packages.mindustry.ui.dialogs.FullTextDialog;
declare type FullTextDialog =
  Packages.mindustry.ui.dialogs.FullTextDialog;
declare const CampaignCompleteDialog =
  Packages.mindustry.ui.dialogs.CampaignCompleteDialog;
declare type CampaignCompleteDialog =
  Packages.mindustry.ui.dialogs.CampaignCompleteDialog;
declare const UI = Packages.mindustry.core.UI;
declare type UI = Packages.mindustry.core.UI;
declare const Administration =
  Packages.mindustry.net.Administration;
declare type Administration =
  Packages.mindustry.net.Administration;
declare const NetServer = Packages.mindustry.core.NetServer;
declare type NetServer = Packages.mindustry.core.NetServer;
declare const NetClient = Packages.mindustry.core.NetClient;
declare type NetClient = Packages.mindustry.core.NetClient;
declare const Vars = Packages.mindustry.Vars;
declare type Vars = Packages.mindustry.Vars;
declare const Astar = Packages.mindustry.ai.Astar;
declare type Astar = Packages.mindustry.ai.Astar;
declare const PhysicsProcess =
  Packages.mindustry.async.PhysicsProcess;
declare type PhysicsProcess =
  Packages.mindustry.async.PhysicsProcess;
declare const Blocks = Packages.mindustry.content.Blocks;
declare type Blocks = Packages.mindustry.content.Blocks;
declare const Bullets = Packages.mindustry.content.Bullets;
declare type Bullets = Packages.mindustry.content.Bullets;
declare const ErekirTechTree =
  Packages.mindustry.content.ErekirTechTree;
declare type ErekirTechTree =
  Packages.mindustry.content.ErekirTechTree;
declare const Fx = Packages.mindustry.content.Fx;
declare type Fx = Packages.mindustry.content.Fx;
declare const Items = Packages.mindustry.content.Items;
declare type Items = Packages.mindustry.content.Items;
declare const Liquids = Packages.mindustry.content.Liquids;
declare type Liquids = Packages.mindustry.content.Liquids;
declare const Loadouts =
  Packages.mindustry.content.Loadouts;
declare type Loadouts = Packages.mindustry.content.Loadouts;
declare const BlankPlanetGenerator =
  Packages.mindustry.maps.generators.BlankPlanetGenerator;
declare type BlankPlanetGenerator =
  Packages.mindustry.maps.generators.BlankPlanetGenerator;
declare const AsteroidGenerator =
  Packages.mindustry.maps.planet.AsteroidGenerator;
declare type AsteroidGenerator =
  Packages.mindustry.maps.planet.AsteroidGenerator;
declare const Planets = Packages.mindustry.content.Planets;
declare type Planets = Packages.mindustry.content.Planets;
declare const SectorPresets =
  Packages.mindustry.content.SectorPresets;
declare type SectorPresets =
  Packages.mindustry.content.SectorPresets;
declare const SerpuloTechTree =
  Packages.mindustry.content.SerpuloTechTree;
declare type SerpuloTechTree =
  Packages.mindustry.content.SerpuloTechTree;
declare const StatusEffects =
  Packages.mindustry.content.StatusEffects;
declare type StatusEffects =
  Packages.mindustry.content.StatusEffects;
declare const TeamEntries =
  Packages.mindustry.content.TeamEntries;
declare type TeamEntries =
  Packages.mindustry.content.TeamEntries;
declare const TechTree =
  Packages.mindustry.content.TechTree;
declare type TechTree = Packages.mindustry.content.TechTree;
declare const UnitTypes =
  Packages.mindustry.content.UnitTypes;
declare type UnitTypes =
  Packages.mindustry.content.UnitTypes;
declare const Weathers =
  Packages.mindustry.content.Weathers;
declare type Weathers = Packages.mindustry.content.Weathers;
declare const Version = Packages.mindustry.core.Version;
declare type Version = Packages.mindustry.core.Version;
declare const EditorTile =
  Packages.mindustry.editor.EditorTile;
declare type EditorTile =
  Packages.mindustry.editor.EditorTile;
declare const Damage = Packages.mindustry.entities.Damage;
declare type Damage = Packages.mindustry.entities.Damage;
declare const Fires = Packages.mindustry.entities.Fires;
declare type Fires = Packages.mindustry.entities.Fires;
declare const LegDestroyData =
  Packages.mindustry.entities.LegDestroyData;
declare type LegDestroyData =
  Packages.mindustry.entities.LegDestroyData;
declare const Lightning =
  Packages.mindustry.entities.Lightning;
declare type Lightning =
  Packages.mindustry.entities.Lightning;
declare const Predict = Packages.mindustry.entities.Predict;
declare type Predict = Packages.mindustry.entities.Predict;
declare const Puddles = Packages.mindustry.entities.Puddles;
declare type Puddles = Packages.mindustry.entities.Puddles;
declare const TargetPriority =
  Packages.mindustry.entities.TargetPriority;
declare type TargetPriority =
  Packages.mindustry.entities.TargetPriority;
declare const UnitSorts =
  Packages.mindustry.entities.UnitSorts;
declare type UnitSorts =
  Packages.mindustry.entities.UnitSorts;
declare const Units = Packages.mindustry.entities.Units;
declare type Units = Packages.mindustry.entities.Units;
declare const EventType = Packages.mindustry.game.EventType;
declare type EventType = Packages.mindustry.game.EventType;
declare const Objectives =
  Packages.mindustry.game.Objectives;
declare type Objectives =
  Packages.mindustry.game.Objectives;
declare const AdminRequestCallPacket =
  Packages.mindustry.gen.AdminRequestCallPacket;
declare type AdminRequestCallPacket =
  Packages.mindustry.gen.AdminRequestCallPacket;
declare const AnnounceCallPacket =
  Packages.mindustry.gen.AnnounceCallPacket;
declare type AnnounceCallPacket =
  Packages.mindustry.gen.AnnounceCallPacket;
declare const AssemblerDroneSpawnedCallPacket =
  Packages.mindustry.gen.AssemblerDroneSpawnedCallPacket;
declare type AssemblerDroneSpawnedCallPacket =
  Packages.mindustry.gen.AssemblerDroneSpawnedCallPacket;
declare const AssemblerUnitSpawnedCallPacket =
  Packages.mindustry.gen.AssemblerUnitSpawnedCallPacket;
declare type AssemblerUnitSpawnedCallPacket =
  Packages.mindustry.gen.AssemblerUnitSpawnedCallPacket;
declare const AutoDoorToggleCallPacket =
  Packages.mindustry.gen.AutoDoorToggleCallPacket;
declare type AutoDoorToggleCallPacket =
  Packages.mindustry.gen.AutoDoorToggleCallPacket;
declare const BeginBreakCallPacket =
  Packages.mindustry.gen.BeginBreakCallPacket;
declare type BeginBreakCallPacket =
  Packages.mindustry.gen.BeginBreakCallPacket;
declare const BeginPlaceCallPacket =
  Packages.mindustry.gen.BeginPlaceCallPacket;
declare type BeginPlaceCallPacket =
  Packages.mindustry.gen.BeginPlaceCallPacket;
declare const BlockSnapshotCallPacket =
  Packages.mindustry.gen.BlockSnapshotCallPacket;
declare type BlockSnapshotCallPacket =
  Packages.mindustry.gen.BlockSnapshotCallPacket;
declare const BlockUnitc =
  Packages.mindustry.gen.BlockUnitc;
declare type BlockUnitc = Packages.mindustry.gen.BlockUnitc;
declare const BlockUnitUnit =
  Packages.mindustry.gen.BlockUnitUnit;
declare type BlockUnitUnit =
  Packages.mindustry.gen.BlockUnitUnit;
declare const BufferItem =
  Packages.mindustry.gen.BufferItem;
declare type BufferItem = Packages.mindustry.gen.BufferItem;
declare const BuildDestroyedCallPacket =
  Packages.mindustry.gen.BuildDestroyedCallPacket;
declare type BuildDestroyedCallPacket =
  Packages.mindustry.gen.BuildDestroyedCallPacket;
declare const BuildHealthUpdateCallPacket =
  Packages.mindustry.gen.BuildHealthUpdateCallPacket;
declare type BuildHealthUpdateCallPacket =
  Packages.mindustry.gen.BuildHealthUpdateCallPacket;
declare const BuildingControlSelectCallPacket =
  Packages.mindustry.gen.BuildingControlSelectCallPacket;
declare type BuildingControlSelectCallPacket =
  Packages.mindustry.gen.BuildingControlSelectCallPacket;
declare const BuildingTetherc =
  Packages.mindustry.gen.BuildingTetherc;
declare type BuildingTetherc =
  Packages.mindustry.gen.BuildingTetherc;
declare const BuildingTetherPayloadUnit =
  Packages.mindustry.gen.BuildingTetherPayloadUnit;
declare type BuildingTetherPayloadUnit =
  Packages.mindustry.gen.BuildingTetherPayloadUnit;
declare const Call = Packages.mindustry.gen.Call;
declare type Call = Packages.mindustry.gen.Call;
declare const Childc = Packages.mindustry.gen.Childc;
declare type Childc = Packages.mindustry.gen.Childc;
declare const ClearItemsCallPacket =
  Packages.mindustry.gen.ClearItemsCallPacket;
declare type ClearItemsCallPacket =
  Packages.mindustry.gen.ClearItemsCallPacket;
declare const ClientPacketReliableCallPacket =
  Packages.mindustry.gen.ClientPacketReliableCallPacket;
declare type ClientPacketReliableCallPacket =
  Packages.mindustry.gen.ClientPacketReliableCallPacket;
declare const ClientPacketUnreliableCallPacket =
  Packages.mindustry.gen.ClientPacketUnreliableCallPacket;
declare type ClientPacketUnreliableCallPacket =
  Packages.mindustry.gen.ClientPacketUnreliableCallPacket;
declare const ClientSnapshotCallPacket =
  Packages.mindustry.gen.ClientSnapshotCallPacket;
declare type ClientSnapshotCallPacket =
  Packages.mindustry.gen.ClientSnapshotCallPacket;
declare const CommandBuildingCallPacket =
  Packages.mindustry.gen.CommandBuildingCallPacket;
declare type CommandBuildingCallPacket =
  Packages.mindustry.gen.CommandBuildingCallPacket;
declare const CommandUnitsCallPacket =
  Packages.mindustry.gen.CommandUnitsCallPacket;
declare type CommandUnitsCallPacket =
  Packages.mindustry.gen.CommandUnitsCallPacket;
declare const ConnectCallPacket =
  Packages.mindustry.gen.ConnectCallPacket;
declare type ConnectCallPacket =
  Packages.mindustry.gen.ConnectCallPacket;
declare const ConnectConfirmCallPacket =
  Packages.mindustry.gen.ConnectConfirmCallPacket;
declare type ConnectConfirmCallPacket =
  Packages.mindustry.gen.ConnectConfirmCallPacket;
declare const ConstructFinishCallPacket =
  Packages.mindustry.gen.ConstructFinishCallPacket;
declare type ConstructFinishCallPacket =
  Packages.mindustry.gen.ConstructFinishCallPacket;
declare const ContentRegions =
  Packages.mindustry.gen.ContentRegions;
declare type ContentRegions =
  Packages.mindustry.gen.ContentRegions;
declare const CrawlUnit = Packages.mindustry.gen.CrawlUnit;
declare type CrawlUnit = Packages.mindustry.gen.CrawlUnit;
declare const CreateBulletCallPacket =
  Packages.mindustry.gen.CreateBulletCallPacket;
declare type CreateBulletCallPacket =
  Packages.mindustry.gen.CreateBulletCallPacket;
declare const CreateWeatherCallPacket =
  Packages.mindustry.gen.CreateWeatherCallPacket;
declare type CreateWeatherCallPacket =
  Packages.mindustry.gen.CreateWeatherCallPacket;
declare const DebugStatusClientCallPacket =
  Packages.mindustry.gen.DebugStatusClientCallPacket;
declare type DebugStatusClientCallPacket =
  Packages.mindustry.gen.DebugStatusClientCallPacket;
declare const DebugStatusClientUnreliableCallPacket =
  Packages.mindustry.gen
    .DebugStatusClientUnreliableCallPacket;
declare type DebugStatusClientUnreliableCallPacket =
  Packages.mindustry.gen.DebugStatusClientUnreliableCallPacket;
declare const Decalc = Packages.mindustry.gen.Decalc;
declare type Decalc = Packages.mindustry.gen.Decalc;
declare const Decal = Packages.mindustry.gen.Decal;
declare type Decal = Packages.mindustry.gen.Decal;
declare const DeconstructFinishCallPacket =
  Packages.mindustry.gen.DeconstructFinishCallPacket;
declare type DeconstructFinishCallPacket =
  Packages.mindustry.gen.DeconstructFinishCallPacket;
declare const DeletePlansCallPacket =
  Packages.mindustry.gen.DeletePlansCallPacket;
declare type DeletePlansCallPacket =
  Packages.mindustry.gen.DeletePlansCallPacket;
declare const DisplayCmd =
  Packages.mindustry.gen.DisplayCmd;
declare type DisplayCmd = Packages.mindustry.gen.DisplayCmd;
declare const DropItemCallPacket =
  Packages.mindustry.gen.DropItemCallPacket;
declare type DropItemCallPacket =
  Packages.mindustry.gen.DropItemCallPacket;
declare const EffectCallPacket =
  Packages.mindustry.gen.EffectCallPacket;
declare type EffectCallPacket =
  Packages.mindustry.gen.EffectCallPacket;
declare const EffectCallPacket2 =
  Packages.mindustry.gen.EffectCallPacket2;
declare type EffectCallPacket2 =
  Packages.mindustry.gen.EffectCallPacket2;
declare const EffectReliableCallPacket =
  Packages.mindustry.gen.EffectReliableCallPacket;
declare type EffectReliableCallPacket =
  Packages.mindustry.gen.EffectReliableCallPacket;
declare const EffectStatec =
  Packages.mindustry.gen.EffectStatec;
declare type EffectStatec =
  Packages.mindustry.gen.EffectStatec;
declare const EffectState =
  Packages.mindustry.gen.EffectState;
declare type EffectState =
  Packages.mindustry.gen.EffectState;
declare const ElevationMoveUnit =
  Packages.mindustry.gen.ElevationMoveUnit;
declare type ElevationMoveUnit =
  Packages.mindustry.gen.ElevationMoveUnit;
declare const EntityMapping =
  Packages.mindustry.gen.EntityMapping;
declare type EntityMapping =
  Packages.mindustry.gen.EntityMapping;
declare const EntitySnapshotCallPacket =
  Packages.mindustry.gen.EntitySnapshotCallPacket;
declare type EntitySnapshotCallPacket =
  Packages.mindustry.gen.EntitySnapshotCallPacket;
declare const FogEvent = Packages.mindustry.gen.FogEvent;
declare type FogEvent = Packages.mindustry.gen.FogEvent;
declare const FollowUpMenuCallPacket =
  Packages.mindustry.gen.FollowUpMenuCallPacket;
declare type FollowUpMenuCallPacket =
  Packages.mindustry.gen.FollowUpMenuCallPacket;
declare const GameOverCallPacket =
  Packages.mindustry.gen.GameOverCallPacket;
declare type GameOverCallPacket =
  Packages.mindustry.gen.GameOverCallPacket;
declare const IndexableEntity__label =
  Packages.mindustry.gen.IndexableEntity__label;
declare type IndexableEntity__label =
  Packages.mindustry.gen.IndexableEntity__label;
declare const WorldLabelc =
  Packages.mindustry.gen.WorldLabelc;
declare type WorldLabelc =
  Packages.mindustry.gen.WorldLabelc;
declare const WorldLabel =
  Packages.mindustry.gen.WorldLabel;
declare type WorldLabel = Packages.mindustry.gen.WorldLabel;
declare const Groups = Packages.mindustry.gen.Groups;
declare type Groups = Packages.mindustry.gen.Groups;
declare const HiddenSnapshotCallPacket =
  Packages.mindustry.gen.HiddenSnapshotCallPacket;
declare type HiddenSnapshotCallPacket =
  Packages.mindustry.gen.HiddenSnapshotCallPacket;
declare const HideFollowUpMenuCallPacket =
  Packages.mindustry.gen.HideFollowUpMenuCallPacket;
declare type HideFollowUpMenuCallPacket =
  Packages.mindustry.gen.HideFollowUpMenuCallPacket;
declare const HideHudTextCallPacket =
  Packages.mindustry.gen.HideHudTextCallPacket;
declare type HideHudTextCallPacket =
  Packages.mindustry.gen.HideHudTextCallPacket;
declare const Icon = Packages.mindustry.gen.Icon;
declare type Icon = Packages.mindustry.gen.Icon;
declare const Iconc = Packages.mindustry.gen.Iconc;
declare type Iconc = Packages.mindustry.gen.Iconc;
declare const Indicator = Packages.mindustry.gen.Indicator;
declare type Indicator = Packages.mindustry.gen.Indicator;
declare const InfoMessageCallPacket =
  Packages.mindustry.gen.InfoMessageCallPacket;
declare type InfoMessageCallPacket =
  Packages.mindustry.gen.InfoMessageCallPacket;
declare const InfoPopupCallPacket =
  Packages.mindustry.gen.InfoPopupCallPacket;
declare type InfoPopupCallPacket =
  Packages.mindustry.gen.InfoPopupCallPacket;
declare const InfoPopupReliableCallPacket =
  Packages.mindustry.gen.InfoPopupReliableCallPacket;
declare type InfoPopupReliableCallPacket =
  Packages.mindustry.gen.InfoPopupReliableCallPacket;
declare const InfoToastCallPacket =
  Packages.mindustry.gen.InfoToastCallPacket;
declare type InfoToastCallPacket =
  Packages.mindustry.gen.InfoToastCallPacket;
declare const KickCallPacket =
  Packages.mindustry.gen.KickCallPacket;
declare type KickCallPacket =
  Packages.mindustry.gen.KickCallPacket;
declare const KickCallPacket2 =
  Packages.mindustry.gen.KickCallPacket2;
declare type KickCallPacket2 =
  Packages.mindustry.gen.KickCallPacket2;
declare const LabelCallPacket =
  Packages.mindustry.gen.LabelCallPacket;
declare type LabelCallPacket =
  Packages.mindustry.gen.LabelCallPacket;
declare const LabelReliableCallPacket =
  Packages.mindustry.gen.LabelReliableCallPacket;
declare type LabelReliableCallPacket =
  Packages.mindustry.gen.LabelReliableCallPacket;
declare const LaunchCorec =
  Packages.mindustry.gen.LaunchCorec;
declare type LaunchCorec =
  Packages.mindustry.gen.LaunchCorec;
declare const LaunchCore =
  Packages.mindustry.gen.LaunchCore;
declare type LaunchCore = Packages.mindustry.gen.LaunchCore;
declare const LaunchPayloadc =
  Packages.mindustry.gen.LaunchPayloadc;
declare type LaunchPayloadc =
  Packages.mindustry.gen.LaunchPayloadc;
declare const LaunchPayload =
  Packages.mindustry.gen.LaunchPayload;
declare type LaunchPayload =
  Packages.mindustry.gen.LaunchPayload;
declare const LegsUnit = Packages.mindustry.gen.LegsUnit;
declare type LegsUnit = Packages.mindustry.gen.LegsUnit;
declare const LegsUnitLegacyArkyid =
  Packages.mindustry.gen.LegsUnitLegacyArkyid;
declare type LegsUnitLegacyArkyid =
  Packages.mindustry.gen.LegsUnitLegacyArkyid;
declare const LegsUnitLegacySpiroct =
  Packages.mindustry.gen.LegsUnitLegacySpiroct;
declare type LegsUnitLegacySpiroct =
  Packages.mindustry.gen.LegsUnitLegacySpiroct;
declare const LegsUnitLegacyToxopid =
  Packages.mindustry.gen.LegsUnitLegacyToxopid;
declare type LegsUnitLegacyToxopid =
  Packages.mindustry.gen.LegsUnitLegacyToxopid;
declare const LogicExplosionCallPacket =
  Packages.mindustry.gen.LogicExplosionCallPacket;
declare type LogicExplosionCallPacket =
  Packages.mindustry.gen.LogicExplosionCallPacket;
declare const LogicIO = Packages.mindustry.gen.LogicIO;
declare type LogicIO = Packages.mindustry.gen.LogicIO;
declare const MechUnit = Packages.mindustry.gen.MechUnit;
declare type MechUnit = Packages.mindustry.gen.MechUnit;
declare const MechUnitLegacyNova =
  Packages.mindustry.gen.MechUnitLegacyNova;
declare type MechUnitLegacyNova =
  Packages.mindustry.gen.MechUnitLegacyNova;
declare const MechUnitLegacyPulsar =
  Packages.mindustry.gen.MechUnitLegacyPulsar;
declare type MechUnitLegacyPulsar =
  Packages.mindustry.gen.MechUnitLegacyPulsar;
declare const MechUnitLegacyQuasar =
  Packages.mindustry.gen.MechUnitLegacyQuasar;
declare type MechUnitLegacyQuasar =
  Packages.mindustry.gen.MechUnitLegacyQuasar;
declare const MenuCallPacket =
  Packages.mindustry.gen.MenuCallPacket;
declare type MenuCallPacket =
  Packages.mindustry.gen.MenuCallPacket;
declare const MenuChooseCallPacket =
  Packages.mindustry.gen.MenuChooseCallPacket;
declare type MenuChooseCallPacket =
  Packages.mindustry.gen.MenuChooseCallPacket;
declare const Musics = Packages.mindustry.gen.Musics;
declare type Musics = Packages.mindustry.gen.Musics;
declare const OpenURICallPacket =
  Packages.mindustry.gen.OpenURICallPacket;
declare type OpenURICallPacket =
  Packages.mindustry.gen.OpenURICallPacket;
declare const PackTile = Packages.mindustry.gen.PackTile;
declare type PackTile = Packages.mindustry.gen.PackTile;
declare const PathTile = Packages.mindustry.gen.PathTile;
declare type PathTile = Packages.mindustry.gen.PathTile;
declare const PayloadDroppedCallPacket =
  Packages.mindustry.gen.PayloadDroppedCallPacket;
declare type PayloadDroppedCallPacket =
  Packages.mindustry.gen.PayloadDroppedCallPacket;
declare const PayloadUnit =
  Packages.mindustry.gen.PayloadUnit;
declare type PayloadUnit =
  Packages.mindustry.gen.PayloadUnit;
declare const PayloadUnitLegacyOct =
  Packages.mindustry.gen.PayloadUnitLegacyOct;
declare type PayloadUnitLegacyOct =
  Packages.mindustry.gen.PayloadUnitLegacyOct;
declare const PayloadUnitLegacyQuad =
  Packages.mindustry.gen.PayloadUnitLegacyQuad;
declare type PayloadUnitLegacyQuad =
  Packages.mindustry.gen.PayloadUnitLegacyQuad;
declare const PickedBuildPayloadCallPacket =
  Packages.mindustry.gen.PickedBuildPayloadCallPacket;
declare type PickedBuildPayloadCallPacket =
  Packages.mindustry.gen.PickedBuildPayloadCallPacket;
declare const PickedUnitPayloadCallPacket =
  Packages.mindustry.gen.PickedUnitPayloadCallPacket;
declare type PickedUnitPayloadCallPacket =
  Packages.mindustry.gen.PickedUnitPayloadCallPacket;
declare const PingCallPacket =
  Packages.mindustry.gen.PingCallPacket;
declare type PingCallPacket =
  Packages.mindustry.gen.PingCallPacket;
declare const PingResponseCallPacket =
  Packages.mindustry.gen.PingResponseCallPacket;
declare type PingResponseCallPacket =
  Packages.mindustry.gen.PingResponseCallPacket;
declare const PlayerDisconnectCallPacket =
  Packages.mindustry.gen.PlayerDisconnectCallPacket;
declare type PlayerDisconnectCallPacket =
  Packages.mindustry.gen.PlayerDisconnectCallPacket;
declare const PlayerSpawnCallPacket =
  Packages.mindustry.gen.PlayerSpawnCallPacket;
declare type PlayerSpawnCallPacket =
  Packages.mindustry.gen.PlayerSpawnCallPacket;
declare const RemoveQueueBlockCallPacket =
  Packages.mindustry.gen.RemoveQueueBlockCallPacket;
declare type RemoveQueueBlockCallPacket =
  Packages.mindustry.gen.RemoveQueueBlockCallPacket;
declare const RemoveTileCallPacket =
  Packages.mindustry.gen.RemoveTileCallPacket;
declare type RemoveTileCallPacket =
  Packages.mindustry.gen.RemoveTileCallPacket;
declare const RemoveWorldLabelCallPacket =
  Packages.mindustry.gen.RemoveWorldLabelCallPacket;
declare type RemoveWorldLabelCallPacket =
  Packages.mindustry.gen.RemoveWorldLabelCallPacket;
declare const RequestBuildPayloadCallPacket =
  Packages.mindustry.gen.RequestBuildPayloadCallPacket;
declare type RequestBuildPayloadCallPacket =
  Packages.mindustry.gen.RequestBuildPayloadCallPacket;
declare const RequestDebugStatusCallPacket =
  Packages.mindustry.gen.RequestDebugStatusCallPacket;
declare type RequestDebugStatusCallPacket =
  Packages.mindustry.gen.RequestDebugStatusCallPacket;
declare const RequestDropPayloadCallPacket =
  Packages.mindustry.gen.RequestDropPayloadCallPacket;
declare type RequestDropPayloadCallPacket =
  Packages.mindustry.gen.RequestDropPayloadCallPacket;
declare const RequestItemCallPacket =
  Packages.mindustry.gen.RequestItemCallPacket;
declare type RequestItemCallPacket =
  Packages.mindustry.gen.RequestItemCallPacket;
declare const RequestUnitPayloadCallPacket =
  Packages.mindustry.gen.RequestUnitPayloadCallPacket;
declare type RequestUnitPayloadCallPacket =
  Packages.mindustry.gen.RequestUnitPayloadCallPacket;
declare const ResearchedCallPacket =
  Packages.mindustry.gen.ResearchedCallPacket;
declare type ResearchedCallPacket =
  Packages.mindustry.gen.ResearchedCallPacket;
declare const RotateBlockCallPacket =
  Packages.mindustry.gen.RotateBlockCallPacket;
declare type RotateBlockCallPacket =
  Packages.mindustry.gen.RotateBlockCallPacket;
declare const SectorCaptureCallPacket =
  Packages.mindustry.gen.SectorCaptureCallPacket;
declare type SectorCaptureCallPacket =
  Packages.mindustry.gen.SectorCaptureCallPacket;
declare const SendChatMessageCallPacket =
  Packages.mindustry.gen.SendChatMessageCallPacket;
declare type SendChatMessageCallPacket =
  Packages.mindustry.gen.SendChatMessageCallPacket;
declare const SendMessageCallPacket =
  Packages.mindustry.gen.SendMessageCallPacket;
declare type SendMessageCallPacket =
  Packages.mindustry.gen.SendMessageCallPacket;
declare const SendMessageCallPacket2 =
  Packages.mindustry.gen.SendMessageCallPacket2;
declare type SendMessageCallPacket2 =
  Packages.mindustry.gen.SendMessageCallPacket2;
declare const ServerPacketReliableCallPacket =
  Packages.mindustry.gen.ServerPacketReliableCallPacket;
declare type ServerPacketReliableCallPacket =
  Packages.mindustry.gen.ServerPacketReliableCallPacket;
declare const ServerPacketUnreliableCallPacket =
  Packages.mindustry.gen.ServerPacketUnreliableCallPacket;
declare type ServerPacketUnreliableCallPacket =
  Packages.mindustry.gen.ServerPacketUnreliableCallPacket;
declare const SetCameraPositionCallPacket =
  Packages.mindustry.gen.SetCameraPositionCallPacket;
declare type SetCameraPositionCallPacket =
  Packages.mindustry.gen.SetCameraPositionCallPacket;
declare const SetFloorCallPacket =
  Packages.mindustry.gen.SetFloorCallPacket;
declare type SetFloorCallPacket =
  Packages.mindustry.gen.SetFloorCallPacket;
declare const SetHudTextCallPacket =
  Packages.mindustry.gen.SetHudTextCallPacket;
declare type SetHudTextCallPacket =
  Packages.mindustry.gen.SetHudTextCallPacket;
declare const SetHudTextReliableCallPacket =
  Packages.mindustry.gen.SetHudTextReliableCallPacket;
declare type SetHudTextReliableCallPacket =
  Packages.mindustry.gen.SetHudTextReliableCallPacket;
declare const SetItemCallPacket =
  Packages.mindustry.gen.SetItemCallPacket;
declare type SetItemCallPacket =
  Packages.mindustry.gen.SetItemCallPacket;
declare const SetMapAreaCallPacket =
  Packages.mindustry.gen.SetMapAreaCallPacket;
declare type SetMapAreaCallPacket =
  Packages.mindustry.gen.SetMapAreaCallPacket;
declare const SetObjectivesCallPacket =
  Packages.mindustry.gen.SetObjectivesCallPacket;
declare type SetObjectivesCallPacket =
  Packages.mindustry.gen.SetObjectivesCallPacket;
declare const SetOverlayCallPacket =
  Packages.mindustry.gen.SetOverlayCallPacket;
declare type SetOverlayCallPacket =
  Packages.mindustry.gen.SetOverlayCallPacket;
declare const SetPlayerTeamEditorCallPacket =
  Packages.mindustry.gen.SetPlayerTeamEditorCallPacket;
declare type SetPlayerTeamEditorCallPacket =
  Packages.mindustry.gen.SetPlayerTeamEditorCallPacket;
declare const SetPositionCallPacket =
  Packages.mindustry.gen.SetPositionCallPacket;
declare type SetPositionCallPacket =
  Packages.mindustry.gen.SetPositionCallPacket;
declare const SetRulesCallPacket =
  Packages.mindustry.gen.SetRulesCallPacket;
declare type SetRulesCallPacket =
  Packages.mindustry.gen.SetRulesCallPacket;
declare const SetTeamCallPacket =
  Packages.mindustry.gen.SetTeamCallPacket;
declare type SetTeamCallPacket =
  Packages.mindustry.gen.SetTeamCallPacket;
declare const SetTileCallPacket =
  Packages.mindustry.gen.SetTileCallPacket;
declare type SetTileCallPacket =
  Packages.mindustry.gen.SetTileCallPacket;
declare const SetUnitCommandCallPacket =
  Packages.mindustry.gen.SetUnitCommandCallPacket;
declare type SetUnitCommandCallPacket =
  Packages.mindustry.gen.SetUnitCommandCallPacket;
declare const SoundAtCallPacket =
  Packages.mindustry.gen.SoundAtCallPacket;
declare type SoundAtCallPacket =
  Packages.mindustry.gen.SoundAtCallPacket;
declare const SoundCallPacket =
  Packages.mindustry.gen.SoundCallPacket;
declare type SoundCallPacket =
  Packages.mindustry.gen.SoundCallPacket;
declare const Sounds = Packages.mindustry.gen.Sounds;
declare type Sounds = Packages.mindustry.gen.Sounds;
declare const SpawnEffectCallPacket =
  Packages.mindustry.gen.SpawnEffectCallPacket;
declare type SpawnEffectCallPacket =
  Packages.mindustry.gen.SpawnEffectCallPacket;
declare const StateSnapshotCallPacket =
  Packages.mindustry.gen.StateSnapshotCallPacket;
declare type StateSnapshotCallPacket =
  Packages.mindustry.gen.StateSnapshotCallPacket;
declare const TakeItemsCallPacket =
  Packages.mindustry.gen.TakeItemsCallPacket;
declare type TakeItemsCallPacket =
  Packages.mindustry.gen.TakeItemsCallPacket;
declare const TankUnit = Packages.mindustry.gen.TankUnit;
declare type TankUnit = Packages.mindustry.gen.TankUnit;
declare const Tex = Packages.mindustry.gen.Tex;
declare type Tex = Packages.mindustry.gen.Tex;
declare const TextInputCallPacket =
  Packages.mindustry.gen.TextInputCallPacket;
declare type TextInputCallPacket =
  Packages.mindustry.gen.TextInputCallPacket;
declare const TextInputResultCallPacket =
  Packages.mindustry.gen.TextInputResultCallPacket;
declare type TextInputResultCallPacket =
  Packages.mindustry.gen.TextInputResultCallPacket;
declare const TileConfigCallPacket =
  Packages.mindustry.gen.TileConfigCallPacket;
declare type TileConfigCallPacket =
  Packages.mindustry.gen.TileConfigCallPacket;
declare const TileOp = Packages.mindustry.gen.TileOp;
declare type TileOp = Packages.mindustry.gen.TileOp;
declare const TileTapCallPacket =
  Packages.mindustry.gen.TileTapCallPacket;
declare type TileTapCallPacket =
  Packages.mindustry.gen.TileTapCallPacket;
declare const TimeItem = Packages.mindustry.gen.TimeItem;
declare type TimeItem = Packages.mindustry.gen.TimeItem;
declare const TimedKillc =
  Packages.mindustry.gen.TimedKillc;
declare type TimedKillc = Packages.mindustry.gen.TimedKillc;
declare const TimedKillUnit =
  Packages.mindustry.gen.TimedKillUnit;
declare type TimedKillUnit =
  Packages.mindustry.gen.TimedKillUnit;
declare const TraceInfoCallPacket =
  Packages.mindustry.gen.TraceInfoCallPacket;
declare type TraceInfoCallPacket =
  Packages.mindustry.gen.TraceInfoCallPacket;
declare const TransferInventoryCallPacket =
  Packages.mindustry.gen.TransferInventoryCallPacket;
declare type TransferInventoryCallPacket =
  Packages.mindustry.gen.TransferInventoryCallPacket;
declare const TransferItemEffectCallPacket =
  Packages.mindustry.gen.TransferItemEffectCallPacket;
declare type TransferItemEffectCallPacket =
  Packages.mindustry.gen.TransferItemEffectCallPacket;
declare const TransferItemToCallPacket =
  Packages.mindustry.gen.TransferItemToCallPacket;
declare type TransferItemToCallPacket =
  Packages.mindustry.gen.TransferItemToCallPacket;
declare const TransferItemToUnitCallPacket =
  Packages.mindustry.gen.TransferItemToUnitCallPacket;
declare type TransferItemToUnitCallPacket =
  Packages.mindustry.gen.TransferItemToUnitCallPacket;
declare const UnitBlockSpawnCallPacket =
  Packages.mindustry.gen.UnitBlockSpawnCallPacket;
declare type UnitBlockSpawnCallPacket =
  Packages.mindustry.gen.UnitBlockSpawnCallPacket;
declare const UnitBuildingControlSelectCallPacket =
  Packages.mindustry.gen
    .UnitBuildingControlSelectCallPacket;
declare type UnitBuildingControlSelectCallPacket =
  Packages.mindustry.gen.UnitBuildingControlSelectCallPacket;
declare const UnitCapDeathCallPacket =
  Packages.mindustry.gen.UnitCapDeathCallPacket;
declare type UnitCapDeathCallPacket =
  Packages.mindustry.gen.UnitCapDeathCallPacket;
declare const UnitClearCallPacket =
  Packages.mindustry.gen.UnitClearCallPacket;
declare type UnitClearCallPacket =
  Packages.mindustry.gen.UnitClearCallPacket;
declare const UnitControlCallPacket =
  Packages.mindustry.gen.UnitControlCallPacket;
declare type UnitControlCallPacket =
  Packages.mindustry.gen.UnitControlCallPacket;
declare const UnitDeathCallPacket =
  Packages.mindustry.gen.UnitDeathCallPacket;
declare type UnitDeathCallPacket =
  Packages.mindustry.gen.UnitDeathCallPacket;
declare const UnitDespawnCallPacket =
  Packages.mindustry.gen.UnitDespawnCallPacket;
declare type UnitDespawnCallPacket =
  Packages.mindustry.gen.UnitDespawnCallPacket;
declare const UnitDestroyCallPacket =
  Packages.mindustry.gen.UnitDestroyCallPacket;
declare type UnitDestroyCallPacket =
  Packages.mindustry.gen.UnitDestroyCallPacket;
declare const UnitEntity =
  Packages.mindustry.gen.UnitEntity;
declare type UnitEntity = Packages.mindustry.gen.UnitEntity;
declare const UnitEntityLegacyAlpha =
  Packages.mindustry.gen.UnitEntityLegacyAlpha;
declare type UnitEntityLegacyAlpha =
  Packages.mindustry.gen.UnitEntityLegacyAlpha;
declare const UnitEntityLegacyBeta =
  Packages.mindustry.gen.UnitEntityLegacyBeta;
declare type UnitEntityLegacyBeta =
  Packages.mindustry.gen.UnitEntityLegacyBeta;
declare const UnitEntityLegacyGamma =
  Packages.mindustry.gen.UnitEntityLegacyGamma;
declare type UnitEntityLegacyGamma =
  Packages.mindustry.gen.UnitEntityLegacyGamma;
declare const UnitEntityLegacyMono =
  Packages.mindustry.gen.UnitEntityLegacyMono;
declare type UnitEntityLegacyMono =
  Packages.mindustry.gen.UnitEntityLegacyMono;
declare const UnitEntityLegacyPoly =
  Packages.mindustry.gen.UnitEntityLegacyPoly;
declare type UnitEntityLegacyPoly =
  Packages.mindustry.gen.UnitEntityLegacyPoly;
declare const UnitEnvDeathCallPacket =
  Packages.mindustry.gen.UnitEnvDeathCallPacket;
declare type UnitEnvDeathCallPacket =
  Packages.mindustry.gen.UnitEnvDeathCallPacket;
declare const UnitTetherBlockSpawnedCallPacket =
  Packages.mindustry.gen.UnitTetherBlockSpawnedCallPacket;
declare type UnitTetherBlockSpawnedCallPacket =
  Packages.mindustry.gen.UnitTetherBlockSpawnedCallPacket;
declare const UnitTetherc =
  Packages.mindustry.gen.UnitTetherc;
declare type UnitTetherc =
  Packages.mindustry.gen.UnitTetherc;
declare const WaterMovec =
  Packages.mindustry.gen.WaterMovec;
declare type WaterMovec = Packages.mindustry.gen.WaterMovec;
declare const UnitWaterMove =
  Packages.mindustry.gen.UnitWaterMove;
declare type UnitWaterMove =
  Packages.mindustry.gen.UnitWaterMove;
declare const UpdateGameOverCallPacket =
  Packages.mindustry.gen.UpdateGameOverCallPacket;
declare type UpdateGameOverCallPacket =
  Packages.mindustry.gen.UpdateGameOverCallPacket;
declare const WarningToastCallPacket =
  Packages.mindustry.gen.WarningToastCallPacket;
declare type WarningToastCallPacket =
  Packages.mindustry.gen.WarningToastCallPacket;
declare const WorldDataBeginCallPacket =
  Packages.mindustry.gen.WorldDataBeginCallPacket;
declare type WorldDataBeginCallPacket =
  Packages.mindustry.gen.WorldDataBeginCallPacket;
declare const Drawf = Packages.mindustry.graphics.Drawf;
declare type Drawf = Packages.mindustry.graphics.Drawf;
declare const EnvRenderers =
  Packages.mindustry.graphics.EnvRenderers;
declare type EnvRenderers =
  Packages.mindustry.graphics.EnvRenderers;
declare const InverseKinematics =
  Packages.mindustry.graphics.InverseKinematics;
declare type InverseKinematics =
  Packages.mindustry.graphics.InverseKinematics;
declare const Layer = Packages.mindustry.graphics.Layer;
declare type Layer = Packages.mindustry.graphics.Layer;
declare const Pal = Packages.mindustry.graphics.Pal;
declare type Pal = Packages.mindustry.graphics.Pal;
declare const Shaders = Packages.mindustry.graphics.Shaders;
declare type Shaders = Packages.mindustry.graphics.Shaders;
declare const Voronoi = Packages.mindustry.graphics.Voronoi;
declare type Voronoi = Packages.mindustry.graphics.Voronoi;
declare const PlaceMode =
  Packages.mindustry.input.PlaceMode;
declare type PlaceMode = Packages.mindustry.input.PlaceMode;
declare const DesktopInput =
  Packages.mindustry.input.DesktopInput;
declare type DesktopInput =
  Packages.mindustry.input.DesktopInput;
declare const MobileInput =
  Packages.mindustry.input.MobileInput;
declare type MobileInput =
  Packages.mindustry.input.MobileInput;
declare const DirectionBridge =
  Packages.mindustry.world.blocks.distribution
    .DirectionBridge;
declare type DirectionBridge =
  Packages.mindustry.world.blocks.distribution.DirectionBridge;
declare const ItemBridge =
  Packages.mindustry.world.blocks.distribution.ItemBridge;
declare type ItemBridge =
  Packages.mindustry.world.blocks.distribution.ItemBridge;
declare const Placement =
  Packages.mindustry.input.Placement;
declare type Placement = Packages.mindustry.input.Placement;
declare const JsonIO = Packages.mindustry.io.JsonIO;
declare type JsonIO = Packages.mindustry.io.JsonIO;
declare const SaveFileReader =
  Packages.mindustry.io.SaveFileReader;
declare type SaveFileReader =
  Packages.mindustry.io.SaveFileReader;
declare const SaveVersion =
  Packages.mindustry.io.SaveVersion;
declare type SaveVersion =
  Packages.mindustry.io.SaveVersion;
declare const MapIO = Packages.mindustry.io.MapIO;
declare type MapIO = Packages.mindustry.io.MapIO;
declare const SaveIO = Packages.mindustry.io.SaveIO;
declare type SaveIO = Packages.mindustry.io.SaveIO;
declare const SavePreviewLoader =
  Packages.mindustry.io.SavePreviewLoader;
declare type SavePreviewLoader =
  Packages.mindustry.io.SavePreviewLoader;
declare const TypeIO = Packages.mindustry.io.TypeIO;
declare type TypeIO = Packages.mindustry.io.TypeIO;
declare const LParser = Packages.mindustry.logic.LParser;
declare type LParser = Packages.mindustry.logic.LParser;
declare const LStatements =
  Packages.mindustry.logic.LStatements;
declare type LStatements =
  Packages.mindustry.logic.LStatements;
declare const MapException =
  Packages.mindustry.maps.MapException;
declare type MapException =
  Packages.mindustry.maps.MapException;
declare const MapPreviewLoader =
  Packages.mindustry.maps.MapPreviewLoader;
declare type MapPreviewLoader =
  Packages.mindustry.maps.MapPreviewLoader;
declare const SectorDamage =
  Packages.mindustry.maps.SectorDamage;
declare type SectorDamage =
  Packages.mindustry.maps.SectorDamage;
declare const ClassMap = Packages.mindustry.mod.ClassMap;
declare type ClassMap = Packages.mindustry.mod.ClassMap;
declare const Plugin = Packages.mindustry.mod.Plugin;
declare type Plugin = Packages.mindustry.mod.Plugin;
declare const CopyOnWriteArrayList =
  Packages.java.util.concurrent.CopyOnWriteArrayList;
declare type CopyOnWriteArrayList =
  Packages.java.util.concurrent.CopyOnWriteArrayList;
declare const LZ4Decompressor =
  Packages.net.jpountz.lz4.LZ4Decompressor;
declare type LZ4Decompressor =
  Packages.net.jpountz.lz4.LZ4Decompressor;
declare const LZ4FastDecompressor =
  Packages.net.jpountz.lz4.LZ4FastDecompressor;
declare type LZ4FastDecompressor =
  Packages.net.jpountz.lz4.LZ4FastDecompressor;
declare const LZ4Compressor =
  Packages.net.jpountz.lz4.LZ4Compressor;
declare type LZ4Compressor =
  Packages.net.jpountz.lz4.LZ4Compressor;
declare const ArcNetProvider =
  Packages.mindustry.net.ArcNetProvider;
declare type ArcNetProvider =
  Packages.mindustry.net.ArcNetProvider;
declare const CrashSender =
  Packages.mindustry.net.CrashSender;
declare type CrashSender =
  Packages.mindustry.net.CrashSender;
declare const NetworkIO = Packages.mindustry.net.NetworkIO;
declare type NetworkIO = Packages.mindustry.net.NetworkIO;
declare const Packets = Packages.mindustry.net.Packets;
declare type Packets = Packages.mindustry.net.Packets;
declare const ValidateException =
  Packages.mindustry.net.ValidateException;
declare type ValidateException =
  Packages.mindustry.net.ValidateException;
declare const CellLiquid =
  Packages.mindustry._type.CellLiquid;
declare type CellLiquid =
  Packages.mindustry._type.CellLiquid;
declare const ErrorContent =
  Packages.mindustry._type.ErrorContent;
declare type ErrorContent =
  Packages.mindustry._type.ErrorContent;
declare const Fonts = Packages.mindustry.ui.Fonts;
declare type Fonts = Packages.mindustry.ui.Fonts;
declare const ItemDisplay =
  Packages.mindustry.ui.ItemDisplay;
declare type ItemDisplay =
  Packages.mindustry.ui.ItemDisplay;
declare const Links = Packages.mindustry.ui.Links;
declare type Links = Packages.mindustry.ui.Links;
declare const LiquidDisplay =
  Packages.mindustry.ui.LiquidDisplay;
declare type LiquidDisplay =
  Packages.mindustry.ui.LiquidDisplay;
declare const Menus = Packages.mindustry.ui.Menus;
declare type Menus = Packages.mindustry.ui.Menus;
declare const Minimap = Packages.mindustry.ui.Minimap;
declare type Minimap = Packages.mindustry.ui.Minimap;
declare const Styles = Packages.mindustry.ui.Styles;
declare type Styles = Packages.mindustry.ui.Styles;
declare const WarningBar = Packages.mindustry.ui.WarningBar;
declare type WarningBar = Packages.mindustry.ui.WarningBar;
declare const Build = Packages.mindustry.world.Build;
declare type Build = Packages.mindustry.world.Build;
declare const ColorMapper =
  Packages.mindustry.world.ColorMapper;
declare type ColorMapper =
  Packages.mindustry.world.ColorMapper;
declare const DirectionalItemBuffer =
  Packages.mindustry.world.DirectionalItemBuffer;
declare type DirectionalItemBuffer =
  Packages.mindustry.world.DirectionalItemBuffer;
declare const Edges = Packages.mindustry.world.Edges;
declare type Edges = Packages.mindustry.world.Edges;
declare const ItemBuffer =
  Packages.mindustry.world.ItemBuffer;
declare type ItemBuffer =
  Packages.mindustry.world.ItemBuffer;
declare const AssemblerAI =
  Packages.mindustry.ai._types.AssemblerAI;
declare type AssemblerAI =
  Packages.mindustry.ai._types.AssemblerAI;
declare const BoostAI =
  Packages.mindustry.ai._types.BoostAI;
declare type BoostAI = Packages.mindustry.ai._types.BoostAI;
declare const BuilderAI =
  Packages.mindustry.ai._types.BuilderAI;
declare type BuilderAI =
  Packages.mindustry.ai._types.BuilderAI;
declare const UnitCargoUnloadPoint =
  Packages.mindustry.world.blocks.units
    .UnitCargoUnloadPoint;
declare type UnitCargoUnloadPoint =
  Packages.mindustry.world.blocks.units.UnitCargoUnloadPoint;
declare const CargoAI =
  Packages.mindustry.ai._types.CargoAI;
declare type CargoAI = Packages.mindustry.ai._types.CargoAI;
declare const DefenderAI =
  Packages.mindustry.ai._types.DefenderAI;
declare type DefenderAI =
  Packages.mindustry.ai._types.DefenderAI;
declare const FlyingAI =
  Packages.mindustry.ai._types.FlyingAI;
declare type FlyingAI =
  Packages.mindustry.ai._types.FlyingAI;
declare const FlyingFollowAI =
  Packages.mindustry.ai._types.FlyingFollowAI;
declare type FlyingFollowAI =
  Packages.mindustry.ai._types.FlyingFollowAI;
declare const GroundAI =
  Packages.mindustry.ai._types.GroundAI;
declare type GroundAI =
  Packages.mindustry.ai._types.GroundAI;
declare const HugAI = Packages.mindustry.ai._types.HugAI;
declare type HugAI = Packages.mindustry.ai._types.HugAI;
declare const MinerAI =
  Packages.mindustry.ai._types.MinerAI;
declare type MinerAI = Packages.mindustry.ai._types.MinerAI;
declare const MissileAI =
  Packages.mindustry.ai._types.MissileAI;
declare type MissileAI =
  Packages.mindustry.ai._types.MissileAI;
declare const RepairAI =
  Packages.mindustry.ai._types.RepairAI;
declare type RepairAI =
  Packages.mindustry.ai._types.RepairAI;
declare const SuicideAI =
  Packages.mindustry.ai._types.SuicideAI;
declare type SuicideAI =
  Packages.mindustry.ai._types.SuicideAI;
declare const ArmorPlateAbility =
  Packages.mindustry.entities.abilities.ArmorPlateAbility;
declare type ArmorPlateAbility =
  Packages.mindustry.entities.abilities.ArmorPlateAbility;
declare const EnergyFieldAbility =
  Packages.mindustry.entities.abilities.EnergyFieldAbility;
declare type EnergyFieldAbility =
  Packages.mindustry.entities.abilities.EnergyFieldAbility;
declare const ForceFieldAbility =
  Packages.mindustry.entities.abilities.ForceFieldAbility;
declare type ForceFieldAbility =
  Packages.mindustry.entities.abilities.ForceFieldAbility;
declare const LiquidExplodeAbility =
  Packages.mindustry.entities.abilities
    .LiquidExplodeAbility;
declare type LiquidExplodeAbility =
  Packages.mindustry.entities.abilities.LiquidExplodeAbility;
declare const LiquidRegenAbility =
  Packages.mindustry.entities.abilities.LiquidRegenAbility;
declare type LiquidRegenAbility =
  Packages.mindustry.entities.abilities.LiquidRegenAbility;
declare const MoveEffectAbility =
  Packages.mindustry.entities.abilities.MoveEffectAbility;
declare type MoveEffectAbility =
  Packages.mindustry.entities.abilities.MoveEffectAbility;
declare const MoveLightningAbility =
  Packages.mindustry.entities.abilities
    .MoveLightningAbility;
declare type MoveLightningAbility =
  Packages.mindustry.entities.abilities.MoveLightningAbility;
declare const RegenAbility =
  Packages.mindustry.entities.abilities.RegenAbility;
declare type RegenAbility =
  Packages.mindustry.entities.abilities.RegenAbility;
declare const RepairFieldAbility =
  Packages.mindustry.entities.abilities.RepairFieldAbility;
declare type RepairFieldAbility =
  Packages.mindustry.entities.abilities.RepairFieldAbility;
declare const ShieldArcAbility =
  Packages.mindustry.entities.abilities.ShieldArcAbility;
declare type ShieldArcAbility =
  Packages.mindustry.entities.abilities.ShieldArcAbility;
declare const ShieldRegenFieldAbility =
  Packages.mindustry.entities.abilities
    .ShieldRegenFieldAbility;
declare type ShieldRegenFieldAbility =
  Packages.mindustry.entities.abilities.ShieldRegenFieldAbility;
declare const SpawnDeathAbility =
  Packages.mindustry.entities.abilities.SpawnDeathAbility;
declare type SpawnDeathAbility =
  Packages.mindustry.entities.abilities.SpawnDeathAbility;
declare const StatusFieldAbility =
  Packages.mindustry.entities.abilities.StatusFieldAbility;
declare type StatusFieldAbility =
  Packages.mindustry.entities.abilities.StatusFieldAbility;
declare const SuppressionFieldAbility =
  Packages.mindustry.entities.abilities
    .SuppressionFieldAbility;
declare type SuppressionFieldAbility =
  Packages.mindustry.entities.abilities.SuppressionFieldAbility;
declare const UnitSpawnAbility =
  Packages.mindustry.entities.abilities.UnitSpawnAbility;
declare type UnitSpawnAbility =
  Packages.mindustry.entities.abilities.UnitSpawnAbility;
declare const BasicBulletType =
  Packages.mindustry.entities.bullet.BasicBulletType;
declare type BasicBulletType =
  Packages.mindustry.entities.bullet.BasicBulletType;
declare const ArtilleryBulletType =
  Packages.mindustry.entities.bullet.ArtilleryBulletType;
declare type ArtilleryBulletType =
  Packages.mindustry.entities.bullet.ArtilleryBulletType;
declare const BombBulletType =
  Packages.mindustry.entities.bullet.BombBulletType;
declare type BombBulletType =
  Packages.mindustry.entities.bullet.BombBulletType;
declare const ContinuousBulletType =
  Packages.mindustry.entities.bullet.ContinuousBulletType;
declare type ContinuousBulletType =
  Packages.mindustry.entities.bullet.ContinuousBulletType;
declare const ContinuousFlameBulletType =
  Packages.mindustry.entities.bullet
    .ContinuousFlameBulletType;
declare type ContinuousFlameBulletType =
  Packages.mindustry.entities.bullet.ContinuousFlameBulletType;
declare const ContinuousLaserBulletType =
  Packages.mindustry.entities.bullet
    .ContinuousLaserBulletType;
declare type ContinuousLaserBulletType =
  Packages.mindustry.entities.bullet.ContinuousLaserBulletType;
declare const EmpBulletType =
  Packages.mindustry.entities.bullet.EmpBulletType;
declare type EmpBulletType =
  Packages.mindustry.entities.bullet.EmpBulletType;
declare const ExplosionBulletType =
  Packages.mindustry.entities.bullet.ExplosionBulletType;
declare type ExplosionBulletType =
  Packages.mindustry.entities.bullet.ExplosionBulletType;
declare const FireBulletType =
  Packages.mindustry.entities.bullet.FireBulletType;
declare type FireBulletType =
  Packages.mindustry.entities.bullet.FireBulletType;
declare const FlakBulletType =
  Packages.mindustry.entities.bullet.FlakBulletType;
declare type FlakBulletType =
  Packages.mindustry.entities.bullet.FlakBulletType;
declare const LaserBoltBulletType =
  Packages.mindustry.entities.bullet.LaserBoltBulletType;
declare type LaserBoltBulletType =
  Packages.mindustry.entities.bullet.LaserBoltBulletType;
declare const LaserBulletType =
  Packages.mindustry.entities.bullet.LaserBulletType;
declare type LaserBulletType =
  Packages.mindustry.entities.bullet.LaserBulletType;
declare const LightningBulletType =
  Packages.mindustry.entities.bullet.LightningBulletType;
declare type LightningBulletType =
  Packages.mindustry.entities.bullet.LightningBulletType;
declare const LiquidBulletType =
  Packages.mindustry.entities.bullet.LiquidBulletType;
declare type LiquidBulletType =
  Packages.mindustry.entities.bullet.LiquidBulletType;
declare const MassDriverBolt =
  Packages.mindustry.entities.bullet.MassDriverBolt;
declare type MassDriverBolt =
  Packages.mindustry.entities.bullet.MassDriverBolt;
declare const MissileBulletType =
  Packages.mindustry.entities.bullet.MissileBulletType;
declare type MissileBulletType =
  Packages.mindustry.entities.bullet.MissileBulletType;
declare const PointBulletType =
  Packages.mindustry.entities.bullet.PointBulletType;
declare type PointBulletType =
  Packages.mindustry.entities.bullet.PointBulletType;
declare const PointLaserBulletType =
  Packages.mindustry.entities.bullet.PointLaserBulletType;
declare type PointLaserBulletType =
  Packages.mindustry.entities.bullet.PointLaserBulletType;
declare const RailBulletType =
  Packages.mindustry.entities.bullet.RailBulletType;
declare type RailBulletType =
  Packages.mindustry.entities.bullet.RailBulletType;
declare const SapBulletType =
  Packages.mindustry.entities.bullet.SapBulletType;
declare type SapBulletType =
  Packages.mindustry.entities.bullet.SapBulletType;
declare const ShrapnelBulletType =
  Packages.mindustry.entities.bullet.ShrapnelBulletType;
declare type ShrapnelBulletType =
  Packages.mindustry.entities.bullet.ShrapnelBulletType;
declare const SpaceLiquidBulletType =
  Packages.mindustry.entities.bullet.SpaceLiquidBulletType;
declare type SpaceLiquidBulletType =
  Packages.mindustry.entities.bullet.SpaceLiquidBulletType;
declare const ExplosionEffect =
  Packages.mindustry.entities.effect.ExplosionEffect;
declare type ExplosionEffect =
  Packages.mindustry.entities.effect.ExplosionEffect;
declare const MultiEffect =
  Packages.mindustry.entities.effect.MultiEffect;
declare type MultiEffect =
  Packages.mindustry.entities.effect.MultiEffect;
declare const ParticleEffect =
  Packages.mindustry.entities.effect.ParticleEffect;
declare type ParticleEffect =
  Packages.mindustry.entities.effect.ParticleEffect;
declare const RadialEffect =
  Packages.mindustry.entities.effect.RadialEffect;
declare type RadialEffect =
  Packages.mindustry.entities.effect.RadialEffect;
declare const SeqEffect =
  Packages.mindustry.entities.effect.SeqEffect;
declare type SeqEffect =
  Packages.mindustry.entities.effect.SeqEffect;
declare const WaveEffect =
  Packages.mindustry.entities.effect.WaveEffect;
declare type WaveEffect =
  Packages.mindustry.entities.effect.WaveEffect;
declare const FlarePart =
  Packages.mindustry.entities.part.FlarePart;
declare type FlarePart =
  Packages.mindustry.entities.part.FlarePart;
declare const HaloPart =
  Packages.mindustry.entities.part.HaloPart;
declare type HaloPart =
  Packages.mindustry.entities.part.HaloPart;
declare const HoverPart =
  Packages.mindustry.entities.part.HoverPart;
declare type HoverPart =
  Packages.mindustry.entities.part.HoverPart;
declare const RegionPart =
  Packages.mindustry.entities.part.RegionPart;
declare type RegionPart =
  Packages.mindustry.entities.part.RegionPart;
declare const ShapePart =
  Packages.mindustry.entities.part.ShapePart;
declare type ShapePart =
  Packages.mindustry.entities.part.ShapePart;
declare const ShootAlternate =
  Packages.mindustry.entities.pattern.ShootAlternate;
declare type ShootAlternate =
  Packages.mindustry.entities.pattern.ShootAlternate;
declare const ShootBarrel =
  Packages.mindustry.entities.pattern.ShootBarrel;
declare type ShootBarrel =
  Packages.mindustry.entities.pattern.ShootBarrel;
declare const ShootHelix =
  Packages.mindustry.entities.pattern.ShootHelix;
declare type ShootHelix =
  Packages.mindustry.entities.pattern.ShootHelix;
declare const ShootMulti =
  Packages.mindustry.entities.pattern.ShootMulti;
declare type ShootMulti =
  Packages.mindustry.entities.pattern.ShootMulti;
declare const ShootSine =
  Packages.mindustry.entities.pattern.ShootSine;
declare type ShootSine =
  Packages.mindustry.entities.pattern.ShootSine;
declare const ShootSpread =
  Packages.mindustry.entities.pattern.ShootSpread;
declare type ShootSpread =
  Packages.mindustry.entities.pattern.ShootSpread;
declare const ShootSummon =
  Packages.mindustry.entities.pattern.ShootSummon;
declare type ShootSummon =
  Packages.mindustry.entities.pattern.ShootSummon;
declare const PlanetMesh =
  Packages.mindustry.graphics.g3d.PlanetMesh;
declare type PlanetMesh =
  Packages.mindustry.graphics.g3d.PlanetMesh;
declare const HexMesh =
  Packages.mindustry.graphics.g3d.HexMesh;
declare type HexMesh =
  Packages.mindustry.graphics.g3d.HexMesh;
declare const HexSkyMesh =
  Packages.mindustry.graphics.g3d.HexSkyMesh;
declare type HexSkyMesh =
  Packages.mindustry.graphics.g3d.HexSkyMesh;
declare const MatMesh =
  Packages.mindustry.graphics.g3d.MatMesh;
declare type MatMesh =
  Packages.mindustry.graphics.g3d.MatMesh;
declare const MeshBuilder =
  Packages.mindustry.graphics.g3d.MeshBuilder;
declare type MeshBuilder =
  Packages.mindustry.graphics.g3d.MeshBuilder;
declare const MultiMesh =
  Packages.mindustry.graphics.g3d.MultiMesh;
declare type MultiMesh =
  Packages.mindustry.graphics.g3d.MultiMesh;
declare const NoiseMesh =
  Packages.mindustry.graphics.g3d.NoiseMesh;
declare type NoiseMesh =
  Packages.mindustry.graphics.g3d.NoiseMesh;
declare const ShaderSphereMesh =
  Packages.mindustry.graphics.g3d.ShaderSphereMesh;
declare type ShaderSphereMesh =
  Packages.mindustry.graphics.g3d.ShaderSphereMesh;
declare const SunMesh =
  Packages.mindustry.graphics.g3d.SunMesh;
declare type SunMesh =
  Packages.mindustry.graphics.g3d.SunMesh;
declare const LegacyIO =
  Packages.mindustry.io.versions.LegacyIO;
declare type LegacyIO =
  Packages.mindustry.io.versions.LegacyIO;
declare const LegacyRegionSaveVersion =
  Packages.mindustry.io.versions.LegacyRegionSaveVersion;
declare type LegacyRegionSaveVersion =
  Packages.mindustry.io.versions.LegacyRegionSaveVersion;
declare const LegacySaveVersion =
  Packages.mindustry.io.versions.LegacySaveVersion;
declare type LegacySaveVersion =
  Packages.mindustry.io.versions.LegacySaveVersion;
declare const LegacySaveVersion2 =
  Packages.mindustry.io.versions.LegacySaveVersion2;
declare type LegacySaveVersion2 =
  Packages.mindustry.io.versions.LegacySaveVersion2;
declare const Save1 = Packages.mindustry.io.versions.Save1;
declare type Save1 = Packages.mindustry.io.versions.Save1;
declare const Save2 = Packages.mindustry.io.versions.Save2;
declare type Save2 = Packages.mindustry.io.versions.Save2;
declare const Save3 = Packages.mindustry.io.versions.Save3;
declare type Save3 = Packages.mindustry.io.versions.Save3;
declare const Save4 = Packages.mindustry.io.versions.Save4;
declare type Save4 = Packages.mindustry.io.versions.Save4;
declare const Save5 = Packages.mindustry.io.versions.Save5;
declare type Save5 = Packages.mindustry.io.versions.Save5;
declare const Save6 = Packages.mindustry.io.versions.Save6;
declare type Save6 = Packages.mindustry.io.versions.Save6;
declare const Save7 = Packages.mindustry.io.versions.Save7;
declare type Save7 = Packages.mindustry.io.versions.Save7;
declare const BlendFilter =
  Packages.mindustry.maps.filters.BlendFilter;
declare type BlendFilter =
  Packages.mindustry.maps.filters.BlendFilter;
declare const ClearFilter =
  Packages.mindustry.maps.filters.ClearFilter;
declare type ClearFilter =
  Packages.mindustry.maps.filters.ClearFilter;
declare const CoreSpawnFilter =
  Packages.mindustry.maps.filters.CoreSpawnFilter;
declare type CoreSpawnFilter =
  Packages.mindustry.maps.filters.CoreSpawnFilter;
declare const DistortFilter =
  Packages.mindustry.maps.filters.DistortFilter;
declare type DistortFilter =
  Packages.mindustry.maps.filters.DistortFilter;
declare const EnemySpawnFilter =
  Packages.mindustry.maps.filters.EnemySpawnFilter;
declare type EnemySpawnFilter =
  Packages.mindustry.maps.filters.EnemySpawnFilter;
declare const MedianFilter =
  Packages.mindustry.maps.filters.MedianFilter;
declare type MedianFilter =
  Packages.mindustry.maps.filters.MedianFilter;
declare const MirrorFilter =
  Packages.mindustry.maps.filters.MirrorFilter;
declare type MirrorFilter =
  Packages.mindustry.maps.filters.MirrorFilter;
declare const NoiseFilter =
  Packages.mindustry.maps.filters.NoiseFilter;
declare type NoiseFilter =
  Packages.mindustry.maps.filters.NoiseFilter;
declare const OreFilter =
  Packages.mindustry.maps.filters.OreFilter;
declare type OreFilter =
  Packages.mindustry.maps.filters.OreFilter;
declare const OreMedianFilter =
  Packages.mindustry.maps.filters.OreMedianFilter;
declare type OreMedianFilter =
  Packages.mindustry.maps.filters.OreMedianFilter;
declare const RandomItemFilter =
  Packages.mindustry.maps.filters.RandomItemFilter;
declare type RandomItemFilter =
  Packages.mindustry.maps.filters.RandomItemFilter;
declare const RiverNoiseFilter =
  Packages.mindustry.maps.filters.RiverNoiseFilter;
declare type RiverNoiseFilter =
  Packages.mindustry.maps.filters.RiverNoiseFilter;
declare const ScatterFilter =
  Packages.mindustry.maps.filters.ScatterFilter;
declare type ScatterFilter =
  Packages.mindustry.maps.filters.ScatterFilter;
declare const SpawnPathFilter =
  Packages.mindustry.maps.filters.SpawnPathFilter;
declare type SpawnPathFilter =
  Packages.mindustry.maps.filters.SpawnPathFilter;
declare const TerrainFilter =
  Packages.mindustry.maps.filters.TerrainFilter;
declare type TerrainFilter =
  Packages.mindustry.maps.filters.TerrainFilter;
declare const BaseGenerator =
  Packages.mindustry.maps.generators.BaseGenerator;
declare type BaseGenerator =
  Packages.mindustry.maps.generators.BaseGenerator;
declare const ErekirPlanetGenerator =
  Packages.mindustry.maps.planet.ErekirPlanetGenerator;
declare type ErekirPlanetGenerator =
  Packages.mindustry.maps.planet.ErekirPlanetGenerator;
declare const Room =
  Packages.mindustry.maps.planet.SerpuloPlanetGenerator
    .Room;
declare type Room =
  Packages.mindustry.maps.planet.SerpuloPlanetGenerator.Room;
declare const SerpuloPlanetGenerator =
  Packages.mindustry.maps.planet.SerpuloPlanetGenerator;
declare type SerpuloPlanetGenerator =
  Packages.mindustry.maps.planet.SerpuloPlanetGenerator;
declare const TantrosPlanetGenerator =
  Packages.mindustry.maps.planet.TantrosPlanetGenerator;
declare type TantrosPlanetGenerator =
  Packages.mindustry.maps.planet.TantrosPlanetGenerator;
declare const ItemAmmoType =
  Packages.mindustry._type.ammo.ItemAmmoType;
declare type ItemAmmoType =
  Packages.mindustry._type.ammo.ItemAmmoType;
declare const PowerAmmoType =
  Packages.mindustry._type.ammo.PowerAmmoType;
declare type PowerAmmoType =
  Packages.mindustry._type.ammo.PowerAmmoType;
declare const ErekirUnitType =
  Packages.mindustry._type.unit.ErekirUnitType;
declare type ErekirUnitType =
  Packages.mindustry._type.unit.ErekirUnitType;
declare const MissileUnitType =
  Packages.mindustry._type.unit.MissileUnitType;
declare type MissileUnitType =
  Packages.mindustry._type.unit.MissileUnitType;
declare const NeoplasmUnitType =
  Packages.mindustry._type.unit.NeoplasmUnitType;
declare type NeoplasmUnitType =
  Packages.mindustry._type.unit.NeoplasmUnitType;
declare const TankUnitType =
  Packages.mindustry._type.unit.TankUnitType;
declare type TankUnitType =
  Packages.mindustry._type.unit.TankUnitType;
declare const BuildWeapon =
  Packages.mindustry._type.weapons.BuildWeapon;
declare type BuildWeapon =
  Packages.mindustry._type.weapons.BuildWeapon;
declare const PointDefenseWeapon =
  Packages.mindustry._type.weapons.PointDefenseWeapon;
declare type PointDefenseWeapon =
  Packages.mindustry._type.weapons.PointDefenseWeapon;
declare const RepairBeamWeapon =
  Packages.mindustry._type.weapons.RepairBeamWeapon;
declare type RepairBeamWeapon =
  Packages.mindustry._type.weapons.RepairBeamWeapon;
declare const MagneticStorm =
  Packages.mindustry._type.weather.MagneticStorm;
declare type MagneticStorm =
  Packages.mindustry._type.weather.MagneticStorm;
declare const ParticleWeather =
  Packages.mindustry._type.weather.ParticleWeather;
declare type ParticleWeather =
  Packages.mindustry._type.weather.ParticleWeather;
declare const RainWeather =
  Packages.mindustry._type.weather.RainWeather;
declare type RainWeather =
  Packages.mindustry._type.weather.RainWeather;
declare const SolarFlare =
  Packages.mindustry._type.weather.SolarFlare;
declare type SolarFlare =
  Packages.mindustry._type.weather.SolarFlare;
declare const FileChooser =
  Packages.mindustry.ui.dialogs.FileChooser;
declare type FileChooser =
  Packages.mindustry.ui.dialogs.FileChooser;
declare const PaletteDialog =
  Packages.mindustry.ui.dialogs.PaletteDialog;
declare type PaletteDialog =
  Packages.mindustry.ui.dialogs.PaletteDialog;
declare const FadeInFragment =
  Packages.mindustry.ui.fragments.FadeInFragment;
declare type FadeInFragment =
  Packages.mindustry.ui.fragments.FadeInFragment;
declare const TreeLayout =
  Packages.mindustry.ui.layout.TreeLayout;
declare type TreeLayout =
  Packages.mindustry.ui.layout.TreeLayout;
declare const BranchTreeLayout =
  Packages.mindustry.ui.layout.BranchTreeLayout;
declare type BranchTreeLayout =
  Packages.mindustry.ui.layout.BranchTreeLayout;
declare const RadialTreeLayout =
  Packages.mindustry.ui.layout.RadialTreeLayout;
declare type RadialTreeLayout =
  Packages.mindustry.ui.layout.RadialTreeLayout;
declare const RowTreeLayout =
  Packages.mindustry.ui.layout.RowTreeLayout;
declare type RowTreeLayout =
  Packages.mindustry.ui.layout.RowTreeLayout;
declare const Autotiler =
  Packages.mindustry.world.blocks.Autotiler;
declare type Autotiler =
  Packages.mindustry.world.blocks.Autotiler;
declare const ConstructBlock =
  Packages.mindustry.world.blocks.ConstructBlock;
declare type ConstructBlock =
  Packages.mindustry.world.blocks.ConstructBlock;
declare const ControlBlock =
  Packages.mindustry.world.blocks.ControlBlock;
declare type ControlBlock =
  Packages.mindustry.world.blocks.ControlBlock;
declare const ItemSelection =
  Packages.mindustry.world.blocks.ItemSelection;
declare type ItemSelection =
  Packages.mindustry.world.blocks.ItemSelection;
declare const UnitTetherBlock =
  Packages.mindustry.world.blocks.UnitTetherBlock;
declare type UnitTetherBlock =
  Packages.mindustry.world.blocks.UnitTetherBlock;
declare const ConsumeItemFilter =
  Packages.mindustry.world.consumers.ConsumeItemFilter;
declare type ConsumeItemFilter =
  Packages.mindustry.world.consumers.ConsumeItemFilter;
declare const ConsumeItemCharged =
  Packages.mindustry.world.consumers.ConsumeItemCharged;
declare type ConsumeItemCharged =
  Packages.mindustry.world.consumers.ConsumeItemCharged;
declare const ConsumeItemDynamic =
  Packages.mindustry.world.consumers.ConsumeItemDynamic;
declare type ConsumeItemDynamic =
  Packages.mindustry.world.consumers.ConsumeItemDynamic;
declare const ConsumeItemExplode =
  Packages.mindustry.world.consumers.ConsumeItemExplode;
declare type ConsumeItemExplode =
  Packages.mindustry.world.consumers.ConsumeItemExplode;
declare const ConsumeItemExplosive =
  Packages.mindustry.world.consumers.ConsumeItemExplosive;
declare type ConsumeItemExplosive =
  Packages.mindustry.world.consumers.ConsumeItemExplosive;
declare const ConsumeItemFlammable =
  Packages.mindustry.world.consumers.ConsumeItemFlammable;
declare type ConsumeItemFlammable =
  Packages.mindustry.world.consumers.ConsumeItemFlammable;
declare const ConsumeItemRadioactive =
  Packages.mindustry.world.consumers.ConsumeItemRadioactive;
declare type ConsumeItemRadioactive =
  Packages.mindustry.world.consumers.ConsumeItemRadioactive;
declare const ConsumeLiquidFlammable =
  Packages.mindustry.world.consumers.ConsumeLiquidFlammable;
declare type ConsumeLiquidFlammable =
  Packages.mindustry.world.consumers.ConsumeLiquidFlammable;
declare const ConsumePayloadDynamic =
  Packages.mindustry.world.consumers.ConsumePayloadDynamic;
declare type ConsumePayloadDynamic =
  Packages.mindustry.world.consumers.ConsumePayloadDynamic;
declare const ConsumePayloadFilter =
  Packages.mindustry.world.consumers.ConsumePayloadFilter;
declare type ConsumePayloadFilter =
  Packages.mindustry.world.consumers.ConsumePayloadFilter;
declare const ConsumePayloads =
  Packages.mindustry.world.consumers.ConsumePayloads;
declare type ConsumePayloads =
  Packages.mindustry.world.consumers.ConsumePayloads;
declare const ConsumePowerCondition =
  Packages.mindustry.world.consumers.ConsumePowerCondition;
declare type ConsumePowerCondition =
  Packages.mindustry.world.consumers.ConsumePowerCondition;
declare const ConsumePowerDynamic =
  Packages.mindustry.world.consumers.ConsumePowerDynamic;
declare type ConsumePowerDynamic =
  Packages.mindustry.world.consumers.ConsumePowerDynamic;
declare const GenericCrafter =
  Packages.mindustry.world.blocks.production.GenericCrafter;
declare type GenericCrafter =
  Packages.mindustry.world.blocks.production.GenericCrafter;
declare const DrawBlock =
  Packages.mindustry.world.draw.DrawBlock;
declare type DrawBlock =
  Packages.mindustry.world.draw.DrawBlock;
declare const DrawArcSmelt =
  Packages.mindustry.world.draw.DrawArcSmelt;
declare type DrawArcSmelt =
  Packages.mindustry.world.draw.DrawArcSmelt;
declare const DrawBlurSpin =
  Packages.mindustry.world.draw.DrawBlurSpin;
declare type DrawBlurSpin =
  Packages.mindustry.world.draw.DrawBlurSpin;
declare const DrawBubbles =
  Packages.mindustry.world.draw.DrawBubbles;
declare type DrawBubbles =
  Packages.mindustry.world.draw.DrawBubbles;
declare const DrawCells =
  Packages.mindustry.world.draw.DrawCells;
declare type DrawCells =
  Packages.mindustry.world.draw.DrawCells;
declare const DrawCircles =
  Packages.mindustry.world.draw.DrawCircles;
declare type DrawCircles =
  Packages.mindustry.world.draw.DrawCircles;
declare const DrawCrucibleFlame =
  Packages.mindustry.world.draw.DrawCrucibleFlame;
declare type DrawCrucibleFlame =
  Packages.mindustry.world.draw.DrawCrucibleFlame;
declare const DrawCultivator =
  Packages.mindustry.world.draw.DrawCultivator;
declare type DrawCultivator =
  Packages.mindustry.world.draw.DrawCultivator;
declare const DrawDefault =
  Packages.mindustry.world.draw.DrawDefault;
declare type DrawDefault =
  Packages.mindustry.world.draw.DrawDefault;
declare const DrawFade =
  Packages.mindustry.world.draw.DrawFade;
declare type DrawFade =
  Packages.mindustry.world.draw.DrawFade;
declare const DrawFlame =
  Packages.mindustry.world.draw.DrawFlame;
declare type DrawFlame =
  Packages.mindustry.world.draw.DrawFlame;
declare const DrawFrames =
  Packages.mindustry.world.draw.DrawFrames;
declare type DrawFrames =
  Packages.mindustry.world.draw.DrawFrames;
declare const DrawGlowRegion =
  Packages.mindustry.world.draw.DrawGlowRegion;
declare type DrawGlowRegion =
  Packages.mindustry.world.draw.DrawGlowRegion;
declare const DrawHeatInput =
  Packages.mindustry.world.draw.DrawHeatInput;
declare type DrawHeatInput =
  Packages.mindustry.world.draw.DrawHeatInput;
declare const DrawHeatOutput =
  Packages.mindustry.world.draw.DrawHeatOutput;
declare type DrawHeatOutput =
  Packages.mindustry.world.draw.DrawHeatOutput;
declare const DrawHeatRegion =
  Packages.mindustry.world.draw.DrawHeatRegion;
declare type DrawHeatRegion =
  Packages.mindustry.world.draw.DrawHeatRegion;
declare const DrawLiquidOutputs =
  Packages.mindustry.world.draw.DrawLiquidOutputs;
declare type DrawLiquidOutputs =
  Packages.mindustry.world.draw.DrawLiquidOutputs;
declare const DrawLiquidRegion =
  Packages.mindustry.world.draw.DrawLiquidRegion;
declare type DrawLiquidRegion =
  Packages.mindustry.world.draw.DrawLiquidRegion;
declare const DrawLiquidTile =
  Packages.mindustry.world.draw.DrawLiquidTile;
declare type DrawLiquidTile =
  Packages.mindustry.world.draw.DrawLiquidTile;
declare const DrawMulti =
  Packages.mindustry.world.draw.DrawMulti;
declare type DrawMulti =
  Packages.mindustry.world.draw.DrawMulti;
declare const DrawMultiWeave =
  Packages.mindustry.world.draw.DrawMultiWeave;
declare type DrawMultiWeave =
  Packages.mindustry.world.draw.DrawMultiWeave;
declare const DrawParticles =
  Packages.mindustry.world.draw.DrawParticles;
declare type DrawParticles =
  Packages.mindustry.world.draw.DrawParticles;
declare const DrawPistons =
  Packages.mindustry.world.draw.DrawPistons;
declare type DrawPistons =
  Packages.mindustry.world.draw.DrawPistons;
declare const DrawPlasma =
  Packages.mindustry.world.draw.DrawPlasma;
declare type DrawPlasma =
  Packages.mindustry.world.draw.DrawPlasma;
declare const DrawPower =
  Packages.mindustry.world.draw.DrawPower;
declare type DrawPower =
  Packages.mindustry.world.draw.DrawPower;
declare const DrawPulseShape =
  Packages.mindustry.world.draw.DrawPulseShape;
declare type DrawPulseShape =
  Packages.mindustry.world.draw.DrawPulseShape;
declare const DrawPumpLiquid =
  Packages.mindustry.world.draw.DrawPumpLiquid;
declare type DrawPumpLiquid =
  Packages.mindustry.world.draw.DrawPumpLiquid;
declare const DrawRegion =
  Packages.mindustry.world.draw.DrawRegion;
declare type DrawRegion =
  Packages.mindustry.world.draw.DrawRegion;
declare const DrawShape =
  Packages.mindustry.world.draw.DrawShape;
declare type DrawShape =
  Packages.mindustry.world.draw.DrawShape;
declare const DrawSideRegion =
  Packages.mindustry.world.draw.DrawSideRegion;
declare type DrawSideRegion =
  Packages.mindustry.world.draw.DrawSideRegion;
declare const DrawSoftParticles =
  Packages.mindustry.world.draw.DrawSoftParticles;
declare type DrawSoftParticles =
  Packages.mindustry.world.draw.DrawSoftParticles;
declare const DrawSpikes =
  Packages.mindustry.world.draw.DrawSpikes;
declare type DrawSpikes =
  Packages.mindustry.world.draw.DrawSpikes;
declare const RotBlock =
  Packages.mindustry.world.blocks.RotBlock;
declare type RotBlock =
  Packages.mindustry.world.blocks.RotBlock;
declare const BaseTurret =
  Packages.mindustry.world.blocks.defense.turrets
    .BaseTurret;
declare type BaseTurret =
  Packages.mindustry.world.blocks.defense.turrets.BaseTurret;
declare const ReloadTurret =
  Packages.mindustry.world.blocks.defense.turrets
    .ReloadTurret;
declare type ReloadTurret =
  Packages.mindustry.world.blocks.defense.turrets.ReloadTurret;
declare const Turret =
  Packages.mindustry.world.blocks.defense.turrets.Turret;
declare type Turret =
  Packages.mindustry.world.blocks.defense.turrets.Turret;
declare const DrawTurret =
  Packages.mindustry.world.draw.DrawTurret;
declare type DrawTurret =
  Packages.mindustry.world.draw.DrawTurret;
declare const DrawWarmupRegion =
  Packages.mindustry.world.draw.DrawWarmupRegion;
declare type DrawWarmupRegion =
  Packages.mindustry.world.draw.DrawWarmupRegion;
declare const DrawWeave =
  Packages.mindustry.world.draw.DrawWeave;
declare type DrawWeave =
  Packages.mindustry.world.draw.DrawWeave;
declare const Env = Packages.mindustry.world.meta.Env;
declare type Env = Packages.mindustry.world.meta.Env;
declare const StatValues =
  Packages.mindustry.world.meta.StatValues;
declare type StatValues =
  Packages.mindustry.world.meta.StatValues;
declare const Accelerator =
  Packages.mindustry.world.blocks.campaign.Accelerator;
declare type Accelerator =
  Packages.mindustry.world.blocks.campaign.Accelerator;
declare const LaunchPad =
  Packages.mindustry.world.blocks.campaign.LaunchPad;
declare type LaunchPad =
  Packages.mindustry.world.blocks.campaign.LaunchPad;
declare const Wall =
  Packages.mindustry.world.blocks.defense.Wall;
declare type Wall =
  Packages.mindustry.world.blocks.defense.Wall;
declare const AutoDoor =
  Packages.mindustry.world.blocks.defense.AutoDoor;
declare type AutoDoor =
  Packages.mindustry.world.blocks.defense.AutoDoor;
declare const BaseShield =
  Packages.mindustry.world.blocks.defense.BaseShield;
declare type BaseShield =
  Packages.mindustry.world.blocks.defense.BaseShield;
declare const BuildTurret =
  Packages.mindustry.world.blocks.defense.BuildTurret;
declare type BuildTurret =
  Packages.mindustry.world.blocks.defense.BuildTurret;
declare const DirectionalForceProjector =
  Packages.mindustry.world.blocks.defense
    .DirectionalForceProjector;
declare type DirectionalForceProjector =
  Packages.mindustry.world.blocks.defense.DirectionalForceProjector;
declare const Door =
  Packages.mindustry.world.blocks.defense.Door;
declare type Door =
  Packages.mindustry.world.blocks.defense.Door;
declare const ForceProjector =
  Packages.mindustry.world.blocks.defense.ForceProjector;
declare type ForceProjector =
  Packages.mindustry.world.blocks.defense.ForceProjector;
declare const MendProjector =
  Packages.mindustry.world.blocks.defense.MendProjector;
declare type MendProjector =
  Packages.mindustry.world.blocks.defense.MendProjector;
declare const OverdriveProjector =
  Packages.mindustry.world.blocks.defense
    .OverdriveProjector;
declare type OverdriveProjector =
  Packages.mindustry.world.blocks.defense.OverdriveProjector;
declare const Radar =
  Packages.mindustry.world.blocks.defense.Radar;
declare type Radar =
  Packages.mindustry.world.blocks.defense.Radar;
declare const RegenProjector =
  Packages.mindustry.world.blocks.defense.RegenProjector;
declare type RegenProjector =
  Packages.mindustry.world.blocks.defense.RegenProjector;
declare const ShieldWall =
  Packages.mindustry.world.blocks.defense.ShieldWall;
declare type ShieldWall =
  Packages.mindustry.world.blocks.defense.ShieldWall;
declare const ShockMine =
  Packages.mindustry.world.blocks.defense.ShockMine;
declare type ShockMine =
  Packages.mindustry.world.blocks.defense.ShockMine;
declare const ShockwaveTower =
  Packages.mindustry.world.blocks.defense.ShockwaveTower;
declare type ShockwaveTower =
  Packages.mindustry.world.blocks.defense.ShockwaveTower;
declare const Thruster =
  Packages.mindustry.world.blocks.defense.Thruster;
declare type Thruster =
  Packages.mindustry.world.blocks.defense.Thruster;
declare const ChainedBuilding =
  Packages.mindustry.world.blocks.distribution
    .ChainedBuilding;
declare type ChainedBuilding =
  Packages.mindustry.world.blocks.distribution.ChainedBuilding;
declare const Conveyor =
  Packages.mindustry.world.blocks.distribution.Conveyor;
declare type Conveyor =
  Packages.mindustry.world.blocks.distribution.Conveyor;
declare const ArmoredConveyor =
  Packages.mindustry.world.blocks.distribution
    .ArmoredConveyor;
declare type ArmoredConveyor =
  Packages.mindustry.world.blocks.distribution.ArmoredConveyor;
declare const BufferedItemBridge =
  Packages.mindustry.world.blocks.distribution
    .BufferedItemBridge;
declare type BufferedItemBridge =
  Packages.mindustry.world.blocks.distribution.BufferedItemBridge;
declare const DirectionLiquidBridge =
  Packages.mindustry.world.blocks.distribution
    .DirectionLiquidBridge;
declare type DirectionLiquidBridge =
  Packages.mindustry.world.blocks.distribution.DirectionLiquidBridge;
declare const DirectionalUnloader =
  Packages.mindustry.world.blocks.distribution
    .DirectionalUnloader;
declare type DirectionalUnloader =
  Packages.mindustry.world.blocks.distribution.DirectionalUnloader;
declare const Duct =
  Packages.mindustry.world.blocks.distribution.Duct;
declare type Duct =
  Packages.mindustry.world.blocks.distribution.Duct;
declare const DuctBridge =
  Packages.mindustry.world.blocks.distribution.DuctBridge;
declare type DuctBridge =
  Packages.mindustry.world.blocks.distribution.DuctBridge;
declare const DuctRouter =
  Packages.mindustry.world.blocks.distribution.DuctRouter;
declare type DuctRouter =
  Packages.mindustry.world.blocks.distribution.DuctRouter;
declare const Junction =
  Packages.mindustry.world.blocks.distribution.Junction;
declare type Junction =
  Packages.mindustry.world.blocks.distribution.Junction;
declare const MassDriver =
  Packages.mindustry.world.blocks.distribution.MassDriver;
declare type MassDriver =
  Packages.mindustry.world.blocks.distribution.MassDriver;
declare const OverflowDuct =
  Packages.mindustry.world.blocks.distribution.OverflowDuct;
declare type OverflowDuct =
  Packages.mindustry.world.blocks.distribution.OverflowDuct;
declare const OverflowGate =
  Packages.mindustry.world.blocks.distribution.OverflowGate;
declare type OverflowGate =
  Packages.mindustry.world.blocks.distribution.OverflowGate;
declare const Router =
  Packages.mindustry.world.blocks.distribution.Router;
declare type Router =
  Packages.mindustry.world.blocks.distribution.Router;
declare const Sorter =
  Packages.mindustry.world.blocks.distribution.Sorter;
declare type Sorter =
  Packages.mindustry.world.blocks.distribution.Sorter;
declare const StackConveyor =
  Packages.mindustry.world.blocks.distribution
    .StackConveyor;
declare type StackConveyor =
  Packages.mindustry.world.blocks.distribution.StackConveyor;
declare const StackRouter =
  Packages.mindustry.world.blocks.distribution.StackRouter;
declare type StackRouter =
  Packages.mindustry.world.blocks.distribution.StackRouter;
declare const AirBlock =
  Packages.mindustry.world.blocks.environment.AirBlock;
declare type AirBlock =
  Packages.mindustry.world.blocks.environment.AirBlock;
declare const Cliff =
  Packages.mindustry.world.blocks.environment.Cliff;
declare type Cliff =
  Packages.mindustry.world.blocks.environment.Cliff;
declare const EmptyFloor =
  Packages.mindustry.world.blocks.environment.EmptyFloor;
declare type EmptyFloor =
  Packages.mindustry.world.blocks.environment.EmptyFloor;
declare const Prop =
  Packages.mindustry.world.blocks.environment.Prop;
declare type Prop =
  Packages.mindustry.world.blocks.environment.Prop;
declare const SeaBush =
  Packages.mindustry.world.blocks.environment.SeaBush;
declare type SeaBush =
  Packages.mindustry.world.blocks.environment.SeaBush;
declare const Seaweed =
  Packages.mindustry.world.blocks.environment.Seaweed;
declare type Seaweed =
  Packages.mindustry.world.blocks.environment.Seaweed;
declare const ShallowLiquid =
  Packages.mindustry.world.blocks.environment.ShallowLiquid;
declare type ShallowLiquid =
  Packages.mindustry.world.blocks.environment.ShallowLiquid;
declare const SpawnBlock =
  Packages.mindustry.world.blocks.environment.SpawnBlock;
declare type SpawnBlock =
  Packages.mindustry.world.blocks.environment.SpawnBlock;
declare const StaticWall =
  Packages.mindustry.world.blocks.environment.StaticWall;
declare type StaticWall =
  Packages.mindustry.world.blocks.environment.StaticWall;
declare const StaticTree =
  Packages.mindustry.world.blocks.environment.StaticTree;
declare type StaticTree =
  Packages.mindustry.world.blocks.environment.StaticTree;
declare const SteamVent =
  Packages.mindustry.world.blocks.environment.SteamVent;
declare type SteamVent =
  Packages.mindustry.world.blocks.environment.SteamVent;
declare const TallBlock =
  Packages.mindustry.world.blocks.environment.TallBlock;
declare type TallBlock =
  Packages.mindustry.world.blocks.environment.TallBlock;
declare const TreeBlock =
  Packages.mindustry.world.blocks.environment.TreeBlock;
declare type TreeBlock =
  Packages.mindustry.world.blocks.environment.TreeBlock;
declare const WobbleProp =
  Packages.mindustry.world.blocks.environment.WobbleProp;
declare type WobbleProp =
  Packages.mindustry.world.blocks.environment.WobbleProp;
declare const HeatBlock =
  Packages.mindustry.world.blocks.heat.HeatBlock;
declare type HeatBlock =
  Packages.mindustry.world.blocks.heat.HeatBlock;
declare const HeatConsumer =
  Packages.mindustry.world.blocks.heat.HeatConsumer;
declare type HeatConsumer =
  Packages.mindustry.world.blocks.heat.HeatConsumer;
declare const HeatConductor =
  Packages.mindustry.world.blocks.heat.HeatConductor;
declare type HeatConductor =
  Packages.mindustry.world.blocks.heat.HeatConductor;
declare const HeatProducer =
  Packages.mindustry.world.blocks.heat.HeatProducer;
declare type HeatProducer =
  Packages.mindustry.world.blocks.heat.HeatProducer;
declare const LegacyBlock =
  Packages.mindustry.world.blocks.legacy.LegacyBlock;
declare type LegacyBlock =
  Packages.mindustry.world.blocks.legacy.LegacyBlock;
declare const LegacyCommandCenter =
  Packages.mindustry.world.blocks.legacy
    .LegacyCommandCenter;
declare type LegacyCommandCenter =
  Packages.mindustry.world.blocks.legacy.LegacyCommandCenter;
declare const LegacyMechPad =
  Packages.mindustry.world.blocks.legacy.LegacyMechPad;
declare type LegacyMechPad =
  Packages.mindustry.world.blocks.legacy.LegacyMechPad;
declare const LegacyUnitFactory =
  Packages.mindustry.world.blocks.legacy.LegacyUnitFactory;
declare type LegacyUnitFactory =
  Packages.mindustry.world.blocks.legacy.LegacyUnitFactory;
declare const LiquidBlock =
  Packages.mindustry.world.blocks.liquid.LiquidBlock;
declare type LiquidBlock =
  Packages.mindustry.world.blocks.liquid.LiquidBlock;
declare const Conduit =
  Packages.mindustry.world.blocks.liquid.Conduit;
declare type Conduit =
  Packages.mindustry.world.blocks.liquid.Conduit;
declare const ArmoredConduit =
  Packages.mindustry.world.blocks.liquid.ArmoredConduit;
declare type ArmoredConduit =
  Packages.mindustry.world.blocks.liquid.ArmoredConduit;
declare const LiquidBridge =
  Packages.mindustry.world.blocks.liquid.LiquidBridge;
declare type LiquidBridge =
  Packages.mindustry.world.blocks.liquid.LiquidBridge;
declare const LiquidJunction =
  Packages.mindustry.world.blocks.liquid.LiquidJunction;
declare type LiquidJunction =
  Packages.mindustry.world.blocks.liquid.LiquidJunction;
declare const LiquidRouter =
  Packages.mindustry.world.blocks.liquid.LiquidRouter;
declare type LiquidRouter =
  Packages.mindustry.world.blocks.liquid.LiquidRouter;
declare const CanvasBlock =
  Packages.mindustry.world.blocks.logic.CanvasBlock;
declare type CanvasBlock =
  Packages.mindustry.world.blocks.logic.CanvasBlock;
declare const LogicDisplay =
  Packages.mindustry.world.blocks.logic.LogicDisplay;
declare type LogicDisplay =
  Packages.mindustry.world.blocks.logic.LogicDisplay;
declare const MemoryBlock =
  Packages.mindustry.world.blocks.logic.MemoryBlock;
declare type MemoryBlock =
  Packages.mindustry.world.blocks.logic.MemoryBlock;
declare const MessageBlock =
  Packages.mindustry.world.blocks.logic.MessageBlock;
declare type MessageBlock =
  Packages.mindustry.world.blocks.logic.MessageBlock;
declare const SwitchBlock =
  Packages.mindustry.world.blocks.logic.SwitchBlock;
declare type SwitchBlock =
  Packages.mindustry.world.blocks.logic.SwitchBlock;
declare const PayloadBlock =
  Packages.mindustry.world.blocks.payloads.PayloadBlock;
declare type PayloadBlock =
  Packages.mindustry.world.blocks.payloads.PayloadBlock;
declare const BlockProducer =
  Packages.mindustry.world.blocks.payloads.BlockProducer;
declare type BlockProducer =
  Packages.mindustry.world.blocks.payloads.BlockProducer;
declare const Constructor =
  Packages.mindustry.world.blocks.payloads.Constructor;
declare type Constructor =
  Packages.mindustry.world.blocks.payloads.Constructor;
declare const PayloadConveyor =
  Packages.mindustry.world.blocks.payloads.PayloadConveyor;
declare type PayloadConveyor =
  Packages.mindustry.world.blocks.payloads.PayloadConveyor;
declare const PayloadDeconstructor =
  Packages.mindustry.world.blocks.payloads
    .PayloadDeconstructor;
declare type PayloadDeconstructor =
  Packages.mindustry.world.blocks.payloads.PayloadDeconstructor;
declare const PayloadLoader =
  Packages.mindustry.world.blocks.payloads.PayloadLoader;
declare type PayloadLoader =
  Packages.mindustry.world.blocks.payloads.PayloadLoader;
declare const PayloadMassDriver =
  Packages.mindustry.world.blocks.payloads
    .PayloadMassDriver;
declare type PayloadMassDriver =
  Packages.mindustry.world.blocks.payloads.PayloadMassDriver;
declare const PayloadRouter =
  Packages.mindustry.world.blocks.payloads.PayloadRouter;
declare type PayloadRouter =
  Packages.mindustry.world.blocks.payloads.PayloadRouter;
declare const PayloadSource =
  Packages.mindustry.world.blocks.payloads.PayloadSource;
declare type PayloadSource =
  Packages.mindustry.world.blocks.payloads.PayloadSource;
declare const PayloadUnloader =
  Packages.mindustry.world.blocks.payloads.PayloadUnloader;
declare type PayloadUnloader =
  Packages.mindustry.world.blocks.payloads.PayloadUnloader;
declare const PayloadVoid =
  Packages.mindustry.world.blocks.payloads.PayloadVoid;
declare type PayloadVoid =
  Packages.mindustry.world.blocks.payloads.PayloadVoid;
declare const PowerBlock =
  Packages.mindustry.world.blocks.power.PowerBlock;
declare type PowerBlock =
  Packages.mindustry.world.blocks.power.PowerBlock;
declare const PowerDistributor =
  Packages.mindustry.world.blocks.power.PowerDistributor;
declare type PowerDistributor =
  Packages.mindustry.world.blocks.power.PowerDistributor;
declare const Battery =
  Packages.mindustry.world.blocks.power.Battery;
declare type Battery =
  Packages.mindustry.world.blocks.power.Battery;
declare const BeamNode =
  Packages.mindustry.world.blocks.power.BeamNode;
declare type BeamNode =
  Packages.mindustry.world.blocks.power.BeamNode;
declare const PowerGenerator =
  Packages.mindustry.world.blocks.power.PowerGenerator;
declare type PowerGenerator =
  Packages.mindustry.world.blocks.power.PowerGenerator;
declare const ConsumeGenerator =
  Packages.mindustry.world.blocks.power.ConsumeGenerator;
declare type ConsumeGenerator =
  Packages.mindustry.world.blocks.power.ConsumeGenerator;
declare const HeaterGenerator =
  Packages.mindustry.world.blocks.power.HeaterGenerator;
declare type HeaterGenerator =
  Packages.mindustry.world.blocks.power.HeaterGenerator;
declare const ImpactReactor =
  Packages.mindustry.world.blocks.power.ImpactReactor;
declare type ImpactReactor =
  Packages.mindustry.world.blocks.power.ImpactReactor;
declare const LightBlock =
  Packages.mindustry.world.blocks.power.LightBlock;
declare type LightBlock =
  Packages.mindustry.world.blocks.power.LightBlock;
declare const PowerNode =
  Packages.mindustry.world.blocks.power.PowerNode;
declare type PowerNode =
  Packages.mindustry.world.blocks.power.PowerNode;
declare const LongPowerNode =
  Packages.mindustry.world.blocks.power.LongPowerNode;
declare type LongPowerNode =
  Packages.mindustry.world.blocks.power.LongPowerNode;
declare const NuclearReactor =
  Packages.mindustry.world.blocks.power.NuclearReactor;
declare type NuclearReactor =
  Packages.mindustry.world.blocks.power.NuclearReactor;
declare const PowerDiode =
  Packages.mindustry.world.blocks.power.PowerDiode;
declare type PowerDiode =
  Packages.mindustry.world.blocks.power.PowerDiode;
declare const SolarGenerator =
  Packages.mindustry.world.blocks.power.SolarGenerator;
declare type SolarGenerator =
  Packages.mindustry.world.blocks.power.SolarGenerator;
declare const ThermalGenerator =
  Packages.mindustry.world.blocks.power.ThermalGenerator;
declare type ThermalGenerator =
  Packages.mindustry.world.blocks.power.ThermalGenerator;
declare const VariableReactor =
  Packages.mindustry.world.blocks.power.VariableReactor;
declare type VariableReactor =
  Packages.mindustry.world.blocks.power.VariableReactor;
declare const AttributeCrafter =
  Packages.mindustry.world.blocks.production
    .AttributeCrafter;
declare type AttributeCrafter =
  Packages.mindustry.world.blocks.production.AttributeCrafter;
declare const BeamDrill =
  Packages.mindustry.world.blocks.production.BeamDrill;
declare type BeamDrill =
  Packages.mindustry.world.blocks.production.BeamDrill;
declare const Drill =
  Packages.mindustry.world.blocks.production.Drill;
declare type Drill =
  Packages.mindustry.world.blocks.production.Drill;
declare const BurstDrill =
  Packages.mindustry.world.blocks.production.BurstDrill;
declare type BurstDrill =
  Packages.mindustry.world.blocks.production.BurstDrill;
declare const Pump =
  Packages.mindustry.world.blocks.production.Pump;
declare type Pump =
  Packages.mindustry.world.blocks.production.Pump;
declare const SolidPump =
  Packages.mindustry.world.blocks.production.SolidPump;
declare type SolidPump =
  Packages.mindustry.world.blocks.production.SolidPump;
declare const Fracker =
  Packages.mindustry.world.blocks.production.Fracker;
declare type Fracker =
  Packages.mindustry.world.blocks.production.Fracker;
declare const HeatCrafter =
  Packages.mindustry.world.blocks.production.HeatCrafter;
declare type HeatCrafter =
  Packages.mindustry.world.blocks.production.HeatCrafter;
declare const Incinerator =
  Packages.mindustry.world.blocks.production.Incinerator;
declare type Incinerator =
  Packages.mindustry.world.blocks.production.Incinerator;
declare const ItemIncinerator =
  Packages.mindustry.world.blocks.production
    .ItemIncinerator;
declare type ItemIncinerator =
  Packages.mindustry.world.blocks.production.ItemIncinerator;
declare const Separator =
  Packages.mindustry.world.blocks.production.Separator;
declare type Separator =
  Packages.mindustry.world.blocks.production.Separator;
declare const SingleBlockProducer =
  Packages.mindustry.world.blocks.production
    .SingleBlockProducer;
declare type SingleBlockProducer =
  Packages.mindustry.world.blocks.production.SingleBlockProducer;
declare const WallCrafter =
  Packages.mindustry.world.blocks.production.WallCrafter;
declare type WallCrafter =
  Packages.mindustry.world.blocks.production.WallCrafter;
declare const ItemSource =
  Packages.mindustry.world.blocks.sandbox.ItemSource;
declare type ItemSource =
  Packages.mindustry.world.blocks.sandbox.ItemSource;
declare const ItemVoid =
  Packages.mindustry.world.blocks.sandbox.ItemVoid;
declare type ItemVoid =
  Packages.mindustry.world.blocks.sandbox.ItemVoid;
declare const LiquidSource =
  Packages.mindustry.world.blocks.sandbox.LiquidSource;
declare type LiquidSource =
  Packages.mindustry.world.blocks.sandbox.LiquidSource;
declare const LiquidVoid =
  Packages.mindustry.world.blocks.sandbox.LiquidVoid;
declare type LiquidVoid =
  Packages.mindustry.world.blocks.sandbox.LiquidVoid;
declare const PowerSource =
  Packages.mindustry.world.blocks.sandbox.PowerSource;
declare type PowerSource =
  Packages.mindustry.world.blocks.sandbox.PowerSource;
declare const PowerVoid =
  Packages.mindustry.world.blocks.sandbox.PowerVoid;
declare type PowerVoid =
  Packages.mindustry.world.blocks.sandbox.PowerVoid;
declare const Unloader =
  Packages.mindustry.world.blocks.storage.Unloader;
declare type Unloader =
  Packages.mindustry.world.blocks.storage.Unloader;
declare const DroneCenter =
  Packages.mindustry.world.blocks.units.DroneCenter;
declare type DroneCenter =
  Packages.mindustry.world.blocks.units.DroneCenter;
declare const UnitBlock =
  Packages.mindustry.world.blocks.units.UnitBlock;
declare type UnitBlock =
  Packages.mindustry.world.blocks.units.UnitBlock;
declare const Reconstructor =
  Packages.mindustry.world.blocks.units.Reconstructor;
declare type Reconstructor =
  Packages.mindustry.world.blocks.units.Reconstructor;
declare const RepairTower =
  Packages.mindustry.world.blocks.units.RepairTower;
declare type RepairTower =
  Packages.mindustry.world.blocks.units.RepairTower;
declare const RepairTurret =
  Packages.mindustry.world.blocks.units.RepairTurret;
declare type RepairTurret =
  Packages.mindustry.world.blocks.units.RepairTurret;
declare const UnitAssemblerModule =
  Packages.mindustry.world.blocks.units.UnitAssemblerModule;
declare type UnitAssemblerModule =
  Packages.mindustry.world.blocks.units.UnitAssemblerModule;
declare const UnitAssembler =
  Packages.mindustry.world.blocks.units.UnitAssembler;
declare type UnitAssembler =
  Packages.mindustry.world.blocks.units.UnitAssembler;
declare const UnitCargoLoader =
  Packages.mindustry.world.blocks.units.UnitCargoLoader;
declare type UnitCargoLoader =
  Packages.mindustry.world.blocks.units.UnitCargoLoader;
declare const UnitFactory =
  Packages.mindustry.world.blocks.units.UnitFactory;
declare type UnitFactory =
  Packages.mindustry.world.blocks.units.UnitFactory;
declare const ContinuousTurret =
  Packages.mindustry.world.blocks.defense.turrets
    .ContinuousTurret;
declare type ContinuousTurret =
  Packages.mindustry.world.blocks.defense.turrets.ContinuousTurret;
declare const ContinuousLiquidTurret =
  Packages.mindustry.world.blocks.defense.turrets
    .ContinuousLiquidTurret;
declare type ContinuousLiquidTurret =
  Packages.mindustry.world.blocks.defense.turrets.ContinuousLiquidTurret;
declare const ItemTurret =
  Packages.mindustry.world.blocks.defense.turrets
    .ItemTurret;
declare type ItemTurret =
  Packages.mindustry.world.blocks.defense.turrets.ItemTurret;
declare const PowerTurret =
  Packages.mindustry.world.blocks.defense.turrets
    .PowerTurret;
declare type PowerTurret =
  Packages.mindustry.world.blocks.defense.turrets.PowerTurret;
declare const LaserTurret =
  Packages.mindustry.world.blocks.defense.turrets
    .LaserTurret;
declare type LaserTurret =
  Packages.mindustry.world.blocks.defense.turrets.LaserTurret;
declare const LiquidTurret =
  Packages.mindustry.world.blocks.defense.turrets
    .LiquidTurret;
declare type LiquidTurret =
  Packages.mindustry.world.blocks.defense.turrets.LiquidTurret;
declare const PayloadAmmoTurret =
  Packages.mindustry.world.blocks.defense.turrets
    .PayloadAmmoTurret;
declare type PayloadAmmoTurret =
  Packages.mindustry.world.blocks.defense.turrets.PayloadAmmoTurret;
declare const PointDefenseTurret =
  Packages.mindustry.world.blocks.defense.turrets
    .PointDefenseTurret;
declare type PointDefenseTurret =
  Packages.mindustry.world.blocks.defense.turrets.PointDefenseTurret;
declare const TractorBeamTurret =
  Packages.mindustry.world.blocks.defense.turrets
    .TractorBeamTurret;
declare type TractorBeamTurret =
  Packages.mindustry.world.blocks.defense.turrets.TractorBeamTurret;
declare function log(
  context: string,
  obj: object | string,
): void;
declare function print(text: string): void;
declare function newFloats(cap: number): number[];

declare function run(
  p: () => void,
): Packages.java.lang.Runnable;

declare function boolf<T>(
  p: (a: T) => boolean,
): Packages.arc.func.Boolf<T>;
declare function floatf<T>(
  p: (a: T) => number,
): Packages.arc.func.Floatf<T>;
declare function boolp(
  p: () => boolean,
): Packages.arc.func.Boolp;
declare function floatp(
  p: () => number,
): Packages.arc.func.Floatp;
declare function cons<T>(
  p: (a: T) => void,
): Packages.arc.func.Cons<T>;
declare function prov<T>(
  p: () => T,
): Packages.arc.func.Prov<T>;
declare function cons<P, R>(
  p: (a: P) => R,
): Packages.arc.func.Func<P, R>;
declare function newEffect(
  life: number,
  render: Packages.arc.func.Cons<
    typeof Packages.mindustry.entities.Effect.EffectContainer
  >,
): Packages.mindustry.entities.Effect;
declare type Class<T> = Packages.java.lang.Class<T>;
declare function extend<T1, T2>(
  father: Class<T1>,
  _addon: Partial<T1> & T2,
): T1;
declare const AdminRequestEvent =
  Packages.mindustry.game.EventType.AdminRequestEvent;
declare const PlayerIpUnbanEvent =
  Packages.mindustry.game.EventType.PlayerIpUnbanEvent;
declare const PlayerIpBanEvent =
  Packages.mindustry.game.EventType.PlayerIpBanEvent;
declare const PlayerUnbanEvent =
  Packages.mindustry.game.EventType.PlayerUnbanEvent;
declare const PlayerBanEvent =
  Packages.mindustry.game.EventType.PlayerBanEvent;
declare const PlayerLeave =
  Packages.mindustry.game.EventType.PlayerLeave;
declare const PlayerConnect =
  Packages.mindustry.game.EventType.PlayerConnect;
declare const PlayerJoin =
  Packages.mindustry.game.EventType.PlayerJoin;
declare const PlayerConnectionConfirmed =
  Packages.mindustry.game.EventType
    .PlayerConnectionConfirmed;
declare const ConnectPacketEvent =
  Packages.mindustry.game.EventType.ConnectPacketEvent;
declare const ConnectionEvent =
  Packages.mindustry.game.EventType.ConnectionEvent;
declare const UnitChangeEvent =
  Packages.mindustry.game.EventType.UnitChangeEvent;
declare const UnitUnloadEvent =
  Packages.mindustry.game.EventType.UnitUnloadEvent;
declare const UnitSpawnEvent =
  Packages.mindustry.game.EventType.UnitSpawnEvent;
declare const UnitCreateEvent =
  Packages.mindustry.game.EventType.UnitCreateEvent;
declare const UnitDrownEvent =
  Packages.mindustry.game.EventType.UnitDrownEvent;
declare const UnitDestroyEvent =
  Packages.mindustry.game.EventType.UnitDestroyEvent;
declare const BlockDestroyEvent =
  Packages.mindustry.game.EventType.BlockDestroyEvent;
declare const BuildSelectEvent =
  Packages.mindustry.game.EventType.BuildSelectEvent;
declare const BlockBuildEndEvent =
  Packages.mindustry.game.EventType.BlockBuildEndEvent;
declare const BlockBuildBeginEvent =
  Packages.mindustry.game.EventType.BlockBuildBeginEvent;
declare const ResearchEvent =
  Packages.mindustry.game.EventType.ResearchEvent;
declare const UnlockEvent =
  Packages.mindustry.game.EventType.UnlockEvent;
declare const StateChangeEvent =
  Packages.mindustry.game.EventType.StateChangeEvent;
declare const CoreChangeEvent =
  Packages.mindustry.game.EventType.CoreChangeEvent;
declare const BuildTeamChangeEvent =
  Packages.mindustry.game.EventType.BuildTeamChangeEvent;
declare const TileChangeEvent =
  Packages.mindustry.game.EventType.TileChangeEvent;
declare const TilePreChangeEvent =
  Packages.mindustry.game.EventType.TilePreChangeEvent;
declare const BuildDamageEvent =
  Packages.mindustry.game.EventType.BuildDamageEvent;
declare const GameOverEvent =
  Packages.mindustry.game.EventType.GameOverEvent;
declare const UnitControlEvent =
  Packages.mindustry.game.EventType.UnitControlEvent;
declare const PickupEvent =
  Packages.mindustry.game.EventType.PickupEvent;
declare const TapEvent =
  Packages.mindustry.game.EventType.TapEvent;
declare const ConfigEvent =
  Packages.mindustry.game.EventType.ConfigEvent;
declare const DepositEvent =
  Packages.mindustry.game.EventType.DepositEvent;
declare const WithdrawEvent =
  Packages.mindustry.game.EventType.WithdrawEvent;
declare const SectorCaptureEvent =
  Packages.mindustry.game.EventType.SectorCaptureEvent;
declare const PlayerChatEvent =
  Packages.mindustry.game.EventType.PlayerChatEvent;
declare const MenuOptionChooseEvent =
  Packages.mindustry.game.EventType.MenuOptionChooseEvent;
declare const ClientPreConnectEvent =
  Packages.mindustry.game.EventType.ClientPreConnectEvent;
declare const SchematicCreateEvent =
  Packages.mindustry.game.EventType.SchematicCreateEvent;
declare const SectorLaunchEvent =
  Packages.mindustry.game.EventType.SectorLaunchEvent;
declare const LaunchItemEvent =
  Packages.mindustry.game.EventType.LaunchItemEvent;
declare const SectorInvasionEvent =
  Packages.mindustry.game.EventType.SectorInvasionEvent;
declare const SectorLoseEvent =
  Packages.mindustry.game.EventType.SectorLoseEvent;
declare const WorldLoadEvent =
  Packages.mindustry.game.EventType.WorldLoadEvent;
declare const FileTreeInitEvent =
  Packages.mindustry.game.EventType.FileTreeInitEvent;
declare const MusicRegisterEvent =
  Packages.mindustry.game.EventType.MusicRegisterEvent;
declare const ClientLoadEvent =
  Packages.mindustry.game.EventType.ClientLoadEvent;
declare const ContentInitEvent =
  Packages.mindustry.game.EventType.ContentInitEvent;
declare const BlockInfoEvent =
  Packages.mindustry.game.EventType.BlockInfoEvent;
declare const CoreItemDeliverEvent =
  Packages.mindustry.game.EventType.CoreItemDeliverEvent;
declare const TurretAmmoDeliverEvent =
  Packages.mindustry.game.EventType.TurretAmmoDeliverEvent;
declare const LineConfirmEvent =
  Packages.mindustry.game.EventType.LineConfirmEvent;
declare const TurnEvent =
  Packages.mindustry.game.EventType.TurnEvent;
declare const WaveEvent =
  Packages.mindustry.game.EventType.WaveEvent;
declare const ResetEvent =
  Packages.mindustry.game.EventType.ResetEvent;
declare const PlayEvent =
  Packages.mindustry.game.EventType.PlayEvent;
declare const DisposeEvent =
  Packages.mindustry.game.EventType.DisposeEvent;
declare const ServerLoadEvent =
  Packages.mindustry.game.EventType.ServerLoadEvent;
declare const ClientCreateEvent =
  Packages.mindustry.game.EventType.ClientCreateEvent;
declare const SaveLoadEvent =
  Packages.mindustry.game.EventType.SaveLoadEvent;
declare const SaveWriteEvent =
  Packages.mindustry.game.EventType.SaveWriteEvent;
declare const MapPublishEvent =
  Packages.mindustry.game.EventType.MapPublishEvent;
declare const MapMakeEvent =
  Packages.mindustry.game.EventType.MapMakeEvent;
declare const ResizeEvent =
  Packages.mindustry.game.EventType.ResizeEvent;
declare const LoseEvent =
  Packages.mindustry.game.EventType.LoseEvent;
declare const WinEvent =
  Packages.mindustry.game.EventType.WinEvent;
declare const Trigger =
  Packages.mindustry.game.EventType.Trigger;
declare type AdminRequestEvent =
  Packages.mindustry.game.EventType.AdminRequestEvent;
declare type PlayerIpUnbanEvent =
  Packages.mindustry.game.EventType.PlayerIpUnbanEvent;
declare type PlayerIpBanEvent =
  Packages.mindustry.game.EventType.PlayerIpBanEvent;
declare type PlayerUnbanEvent =
  Packages.mindustry.game.EventType.PlayerUnbanEvent;
declare type PlayerBanEvent =
  Packages.mindustry.game.EventType.PlayerBanEvent;
declare type PlayerLeave =
  Packages.mindustry.game.EventType.PlayerLeave;
declare type PlayerConnect =
  Packages.mindustry.game.EventType.PlayerConnect;
declare type PlayerJoin =
  Packages.mindustry.game.EventType.PlayerJoin;
declare type PlayerConnectionConfirmed =
  Packages.mindustry.game.EventType.PlayerConnectionConfirmed;
declare type ConnectPacketEvent =
  Packages.mindustry.game.EventType.ConnectPacketEvent;
declare type ConnectionEvent =
  Packages.mindustry.game.EventType.ConnectionEvent;
declare type UnitChangeEvent =
  Packages.mindustry.game.EventType.UnitChangeEvent;
declare type UnitUnloadEvent =
  Packages.mindustry.game.EventType.UnitUnloadEvent;
declare type UnitSpawnEvent =
  Packages.mindustry.game.EventType.UnitSpawnEvent;
declare type UnitCreateEvent =
  Packages.mindustry.game.EventType.UnitCreateEvent;
declare type UnitDrownEvent =
  Packages.mindustry.game.EventType.UnitDrownEvent;
declare type UnitDestroyEvent =
  Packages.mindustry.game.EventType.UnitDestroyEvent;
declare type BlockDestroyEvent =
  Packages.mindustry.game.EventType.BlockDestroyEvent;
declare type BuildSelectEvent =
  Packages.mindustry.game.EventType.BuildSelectEvent;
declare type BlockBuildEndEvent =
  Packages.mindustry.game.EventType.BlockBuildEndEvent;
declare type BlockBuildBeginEvent =
  Packages.mindustry.game.EventType.BlockBuildBeginEvent;
declare type ResearchEvent =
  Packages.mindustry.game.EventType.ResearchEvent;
declare type UnlockEvent =
  Packages.mindustry.game.EventType.UnlockEvent;
declare type StateChangeEvent =
  Packages.mindustry.game.EventType.StateChangeEvent;
declare type CoreChangeEvent =
  Packages.mindustry.game.EventType.CoreChangeEvent;
declare type BuildTeamChangeEvent =
  Packages.mindustry.game.EventType.BuildTeamChangeEvent;
declare type TileChangeEvent =
  Packages.mindustry.game.EventType.TileChangeEvent;
declare type TilePreChangeEvent =
  Packages.mindustry.game.EventType.TilePreChangeEvent;
declare type BuildDamageEvent =
  Packages.mindustry.game.EventType.BuildDamageEvent;
declare type GameOverEvent =
  Packages.mindustry.game.EventType.GameOverEvent;
declare type UnitControlEvent =
  Packages.mindustry.game.EventType.UnitControlEvent;
declare type PickupEvent =
  Packages.mindustry.game.EventType.PickupEvent;
declare type TapEvent =
  Packages.mindustry.game.EventType.TapEvent;
declare type ConfigEvent =
  Packages.mindustry.game.EventType.ConfigEvent;
declare type DepositEvent =
  Packages.mindustry.game.EventType.DepositEvent;
declare type WithdrawEvent =
  Packages.mindustry.game.EventType.WithdrawEvent;
declare type SectorCaptureEvent =
  Packages.mindustry.game.EventType.SectorCaptureEvent;
declare type PlayerChatEvent =
  Packages.mindustry.game.EventType.PlayerChatEvent;
declare type MenuOptionChooseEvent =
  Packages.mindustry.game.EventType.MenuOptionChooseEvent;
declare type ClientPreConnectEvent =
  Packages.mindustry.game.EventType.ClientPreConnectEvent;
declare type SchematicCreateEvent =
  Packages.mindustry.game.EventType.SchematicCreateEvent;
declare type SectorLaunchEvent =
  Packages.mindustry.game.EventType.SectorLaunchEvent;
declare type LaunchItemEvent =
  Packages.mindustry.game.EventType.LaunchItemEvent;
declare type SectorInvasionEvent =
  Packages.mindustry.game.EventType.SectorInvasionEvent;
declare type SectorLoseEvent =
  Packages.mindustry.game.EventType.SectorLoseEvent;
declare type WorldLoadEvent =
  Packages.mindustry.game.EventType.WorldLoadEvent;
declare type FileTreeInitEvent =
  Packages.mindustry.game.EventType.FileTreeInitEvent;
declare type MusicRegisterEvent =
  Packages.mindustry.game.EventType.MusicRegisterEvent;
declare type ClientLoadEvent =
  Packages.mindustry.game.EventType.ClientLoadEvent;
declare type ContentInitEvent =
  Packages.mindustry.game.EventType.ContentInitEvent;
declare type BlockInfoEvent =
  Packages.mindustry.game.EventType.BlockInfoEvent;
declare type CoreItemDeliverEvent =
  Packages.mindustry.game.EventType.CoreItemDeliverEvent;
declare type TurretAmmoDeliverEvent =
  Packages.mindustry.game.EventType.TurretAmmoDeliverEvent;
declare type LineConfirmEvent =
  Packages.mindustry.game.EventType.LineConfirmEvent;
declare type TurnEvent =
  Packages.mindustry.game.EventType.TurnEvent;
declare type WaveEvent =
  Packages.mindustry.game.EventType.WaveEvent;
declare type ResetEvent =
  Packages.mindustry.game.EventType.ResetEvent;
declare type PlayEvent =
  Packages.mindustry.game.EventType.PlayEvent;
declare type DisposeEvent =
  Packages.mindustry.game.EventType.DisposeEvent;
declare type ServerLoadEvent =
  Packages.mindustry.game.EventType.ServerLoadEvent;
declare type ClientCreateEvent =
  Packages.mindustry.game.EventType.ClientCreateEvent;
declare type SaveLoadEvent =
  Packages.mindustry.game.EventType.SaveLoadEvent;
declare type SaveWriteEvent =
  Packages.mindustry.game.EventType.SaveWriteEvent;
declare type MapPublishEvent =
  Packages.mindustry.game.EventType.MapPublishEvent;
declare type MapMakeEvent =
  Packages.mindustry.game.EventType.MapMakeEvent;
declare type ResizeEvent =
  Packages.mindustry.game.EventType.ResizeEvent;
declare type LoseEvent =
  Packages.mindustry.game.EventType.LoseEvent;
declare type WinEvent =
  Packages.mindustry.game.EventType.WinEvent;
declare type Trigger =
  Packages.mindustry.game.EventType.Trigger;
